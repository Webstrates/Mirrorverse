<!doctype html>
<html data-protected="all"><head>
    <title>Mirrorverse</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <script type="text/json+bootconfig">{
    "creator": "WPMPackageManager",
    "created": 1650368097912,
    "require": [
        {
            "repositories": {
                "codestrates-repos": "https://raw.githubusercontent.com/Webstrates/Codestrates-v2/master/codestrates.html",
                "webstrate-components-repos": "https://raw.githubusercontent.com/Webstrates/WebstrateComponents/master/components.html",
                "cauldron-repos": "https://raw.githubusercontent.com/Webstrates/Cauldron/master/cauldron.html",
                "wpm_js_libs": "https://raw.githubusercontent.com/Webstrates/WebstrateLibraryRepository/master/libraries.html",
                "varv-repos": "https://raw.githubusercontent.com/Webstrates/Varv/master/varv.html",
                "wpm-repos": "https://raw.githubusercontent.com/Webstrates/WPM/master/build.html"
            },
            "dependencies": [
                {
                    "package": "CauldronURLLauncher",
                    "repository": "cauldron-repos"
                },
                {
                    "package": "CauldronButtonLauncher",
                    "repository": "cauldron-repos"
                },
                {
                    "package": "fragment_js",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_html",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_json",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_wpm-descriptor",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_css",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_scss",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "varv-location",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-inspector",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-codestrates-extensions",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-cauldron-delayloader",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-cauldron",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-localstorage",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-memory",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-domdiff-view",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-dom-triggers",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-dom",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-builtin-triggers",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-builtin-actions",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-engine",
                    "repository": "varv-repos"
                },
                {
                    "package": "mirrorverse-audio-router",
                    "repository": "varv-repos"
                },
                {
                    "package": "WPM",
                    "repository": "wpm-repos"
                }
            ],
            "options": {}
        }
    ],
    "updated": 1692975361169,
    "knownRepositories": []
}</script>
<WPM-PACKAGE data-repository="wpm_js_libs" id="cQuery" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "cQuery - Lightweight jQuery alternative",
    "dependencies": [],
    "assets": [],
    "version": "1.0",
    "changelog": {
        "1.0": "Initial version",
        "1.1": "Fixed liveQuery to work on elements where attributes change, and attribute was part of the live query"
    },
    "documentationLink": "",
    "license": "Apache 2.0"
}

</SCRIPT><SCRIPT type="disabled">
                    await wpm.requireExternal("https://libraries.projects.cavi.au.dk/javascript/cQuery/1.1/caviQuery.min.js");
                    await wpm.requireExternal("https://libraries.projects.cavi.au.dk/javascript/cQuery/1.1/caviQueryPlugins.min.js");
                </SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="CaviDraggableHTML5" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "CaviDraggableHTML5 makes HTML5 dnd api easy to use",
    "dependencies": [],
    "assets": [],
    "version": "1.0",
    "changelog": {
    },
    "license": "Apache 2.0",
    "documentationLink": ""
}

</SCRIPT><SCRIPT type="disabled">
                    await wpm.requireExternal("https://libraries.projects.cavi.au.dk/javascript/CaviDraggableHTML5/1.0/draggable.min.js");
                </SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="CaviTouch" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "CaviTouch is a library to seemlesly handle touch, mouse, pointers and gestures",
    "dependencies": [],
    "assets": [],
    "version": "1.4",
    "changelog": {
        "1.0": "Initial version",
        "1.1": "Added upgrade workaround",
        "1.2": "Fixed bug during upgrade",
        "1.3": "Fixed another bug during upgrade",
        "1.4": "Moved to CDN and minified"
    },
    "documentationLink": "",
    "license": "Apache 2.0"
}

</SCRIPT><SCRIPT type="disabled">
                    await wpm.requireExternal("https://libraries.projects.cavi.au.dk/javascript/CaviTouch/1.4/CaviTouch.min.js");
                </SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="diffHTML" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "A JavaScript diffing algorithm for DOM elements",
    "dependencies": [],
    "assets": [],
    "version": "1.0.0-beta.27",
    "license": "MIT",
    "documentationLink": "https://github.com/tbranyen/diffhtml/"
}

</SCRIPT><SCRIPT type="disabled">
                    await wpm.requireExternal("https://unpkg.com/diffhtml@1.0.0-beta.27/dist/diffhtml.min.js");
                </SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="Observer" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "Webstrate iframe observer, can wait for transclude, and changes to have propagated to server",
    "dependencies": [],
    "assets": [],
    "version": "1.0",
    "license": "Apache 2.0",
    "documentationLink": ""
}

</SCRIPT><SCRIPT type="disabled">
                    await wpm.requireExternal("https://libraries.projects.cavi.au.dk/javascript/Observer/1.0/Observer.min.js");
                </SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="requirejs" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "Require.js",
    "dependencies": [],
    "assets": [],
    "version": "2.3.6",
    "license": "MIT",
    "documentationLink": "https://requirejs.org/docs/api.html"
}

</SCRIPT><SCRIPT type="disabled">
                    await wpm.requireExternal("https://libraries.projects.cavi.au.dk/javascript/require/require.js");
                </SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="material-design-components" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="components-descriptor-script" type="descriptor">
{
    "description": "Material Design UI (full minified CDN version)",
    "dependencies": [],
    "assets": [],
    "license": "MIT",
    "version": "14.0.0"
}

</SCRIPT><SCRIPT type="disabled">
                    await wpm.requireExternal("https://unpkg.com/material-components-web@14.0.0/dist/material-components-web.min.js");
                </SCRIPT><LINK href="https://unpkg.com/material-components-web@7.0.0/dist/material-components-web.min.css" rel="stylesheet" type="text/css"/></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="material-design-icons" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="icons-descriptor-script" type="descriptor">
{
    "description": "Material Design Icons (full minified CDN version)",
    "dependencies": [],
    "assets": [],
    "license": "Apache 2.0",
    "version": "0.1",
    "documentationLink": "https://github.com/google/material-design-icons"
}

</SCRIPT><LINK href="https://fonts.googleapis.com/css?family=Material+Icons|Material+Icons+Outlined" rel="stylesheet" type="text/css"/></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="rxjs" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "RxJS is a library for composing asynchronous and event-based programs by using observable sequences.",
    "dependencies": [
    ],
    "assets": [],
    "version": "6.1.0",
    "changelog": {},
    "license": "Apache 2.0",
    "documentationLink": "https://rxjs-dev.firebaseapp.com/api"
}

</SCRIPT><SCRIPT type="disabled">
                    //Get RXJS library used for Subject and Observable and more...
                    await wpm.requireExternal("https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.1.0/rxjs.umd.js");
                </SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="izitoast" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "Elegant, responsive, flexible and lightweight notification plugin with no dependencies.",
    "dependencies": [],
    "assets": [],
    "version": "1.4.0",
    "license": "Apache 2.0",
    "documentationLink": "https://izitoast.marcelodolza.com/"
}

</SCRIPT><SCRIPT type="disabled">
                    await wpm.requireExternal("https://cdnjs.cloudflare.com/ajax/libs/izitoast/1.4.0/js/iziToast.min.js");
                    await wpm.requireExternal("https://cdnjs.cloudflare.com/ajax/libs/izitoast/1.4.0/css/iziToast.min.css");
                </SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="mathjs" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "Math.js library",
    "dependencies": [],
    "assets": [],
    "version": "9.4.3",
    "license": "Apache 2.0",
    "documentationLink": "https://mathjs.org/docs/index.html"
}

</SCRIPT><SCRIPT type="disabled">
                    await wpm.requireExternal("https://unpkg.com/mathjs@9.4.3/lib/browser/math.js");
                </SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="js-yaml" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "This is an implementation of YAML, a human-friendly data serialization language. Started as PyYAML port, it was completely rewritten from scratch. Now it's very fast, and supports 1.2 spec.",
    "dependencies": [],
    "assets": [],
    "version": "4.1.0",
    "license": "MIT",
    "documentationLink": "https://github.com/nodeca/js-yaml"
}

</SCRIPT><SCRIPT type="disabled">
                    await wpm.requireExternal("https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js");
                </SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="UUIDGenerator" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "An UUID generator",
    "dependencies": [],
    "assets": [],
    "version": "1.0",
    "license": "Apache 2.0",
    "changelog": {
        "1.0": "Initial version"
    }
}

</SCRIPT><SCRIPT id="generator-script" type="disabled">
/**
 *  UUIDGenerator
 *  Provides unqiue IDs
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

window.UUIDGenerator = class UUIDGenerator {
    /**
     * Generates a probably unique id
     * @param {string} prefix a prefix for the id
     * @param {number} length the length of the id
     * @returns {String} the generated id
     */
    static generateUUID(prefix = "", length = 20) {
        function dec2hex(dec) {
            return ('0' + dec.toString(16)).substr(-2);
        }

        let arr = new Uint8Array((length || 40) / 2);
        window.crypto.getRandomValues(arr);
        return prefix + Array.from(arr, dec2hex).join('');
    }
};

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="monaco_editor" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "Monaco Editor",
    "dependencies": [
        "#requirejs"
    ],
    "assets": [],
    "version": "0.33.0",
    "license": "MIT",
    "documentationLink": "https://microsoft.github.io/monaco-editor/api/index.html"
}

</SCRIPT><SCRIPT type="disabled">
                    window.MonacoLibraryPath = "https://libraries.projects.cavi.au.dk/javascript/monaco/0.33/vs";

                    {
                        //Configure monaco in require loader
                        requirejs.config({
                            paths: {
                                vs: MonacoLibraryPath
                            }
                        });

                        window.MonacoEnvironment = {
                            getWorkerUrl: function(workerId, label) {
                              return `data:text/javascript;charset=utf-8,${encodeURIComponent(`
                                self.MonacoEnvironment = {
                                  baseUrl: 'https://libraries.projects.cavi.au.dk/javascript/monaco/0.33/'
                                };
                                importScripts('https://libraries.projects.cavi.au.dk/javascript/monaco/0.33/vs/base/worker/workerMain.js');`
                              )}`;
                            }
                          };
                    }
                </SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="sass_js" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "SCSS compiler for JS",
    "dependencies": [
        "#requirejs"
    ],
    "assets": [],
    "version": "0.11.1",
    "license": "MIT",
    "documentationLink": "https://github.com/medialize/sass.js"
}

</SCRIPT><SCRIPT type="disabled">
                    window.SassJsLibraryPath = "https://libraries.projects.cavi.au.dk/javascript/sass.js/0.11.1";
                    {
                        requirejs.config({
                            paths: {
                                sass: SassJsLibraryPath
                            }
                        });
                    }

                    window.fetchSassWorkerBlob = async ()=> {
                        let response = await fetch("https://libraries.projects.cavi.au.dk/javascript/sass.js/0.11.1/sass.worker.min.js");
                        let worker = await response.text();
                        let blob = new Blob([worker], {type: 'application/javascript'});

                        return blob;
                    }
                </SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="fastdiff" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "Fast Diff",
    "dependencies": [
        "#requirejs"
    ],
    "assets": [],
    "version": "2019",
    "license": "Apache 2.0",
    "documentationLink": "https://github.com/google/diff-match-patch"
}

</SCRIPT><SCRIPT type="disabled">
                    await wpm.requireExternal("https://libraries.projects.cavi.au.dk/javascript/fastdiff/2019/fastdiff.min.js");
                </SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="LiveElement" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "A small javascript library to work with 'Live' elements, as they enter the dom",
    "dependencies": [
        "rxjs"
    ],
    "assets": [],
    "version": "0.1",
    "changelog": {
        "0.1": "Initial version"
    },
    "license": "Apache 2.0",
    "documentationLink": ""
}

</SCRIPT><SCRIPT type="disabled">
                    await wpm.requireExternal("https://libraries.projects.cavi.au.dk/javascript/LiveElement/1.0/LiveElement.min.js");
                </SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="Uploader" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
  "description": "An upload helper",
  "dependencies": [
    "#cQuery"
  ],
  "assets": [],
  "version": "1.0",
  "changelog": {
    "1.0": "Initial version"
  },
  "license": "Apache 2.0",
  "documentationLink": ""
}

</SCRIPT><SCRIPT type="disabled">
                    await wpm.requireExternal("https://cdn.jsdelivr.net/npm/exif-js@2.3.0/exif.min.js");
                    await wpm.requireExternal("https://libraries.projects.cavi.au.dk/javascript/Uploader/1.0/Uploader.min.js");
                </SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="golden-layout" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "Golden Layout",
    "dependencies": [
        "#requirejs",
        "#cQuery"
    ],
    "assets": [],
    "version": "1.0",
    "changelog": {
        "1.0": "Initial version"
    },
    "documentationLink": "https://golden-layout.com/",
    "license": "MIT"
}

</SCRIPT><SCRIPT type="disabled">

                    window.GoldenLayoutPath = "https://libraries.projects.cavi.au.dk/javascript/golden-layout";

                    let goldenLayoutLoadPromise = null;

                    window.loadGoldenLayout = async (bodyElement) => {
                        if(goldenLayoutLoadPromise != null) {
                            console.trace();
                            await goldenLayoutLoadPromise;
                            return;
                        }

                        goldenLayoutLoadPromise = new Promise(async (resolve)=>{

                            console.log("Loading GoldenLayout with body replacement:", bodyElement);

                            //Find top component after html
                            let topLevelParent = bodyElement;
                            while(topLevelParent.parentNode != null && !topLevelParent.parentNode.matches("html")) {
                                topLevelParent = topLevelParent.parentNode;
                            }

                            await wpm.requireExternal("https://code.jquery.com/jquery-3.4.1.slim.min.js");

                            let origJQueryOffset = jQuery.fn.offset;

                            jQuery.fn.offset = function() {
                                let el = this[0];
                                var rect = el.getBoundingClientRect();

                                let bounds = topLevelParent.getBoundingClientRect();

                                return {
                                  top: rect.top - bounds.y  + topLevelParent.scrollTop,
                                  left: rect.left - bounds.x + topLevelParent.scrollLeft
                                };
                            };

                            let origJqueryCss = jQuery.fn.css;

                            jQuery.fn.css = function(...args) {
                                if(this.is("body") || this.is("html")) {
                                    console.log("Skipping css on html and body");
                                    return;
                                }

                                return origJqueryCss.bind(this)(...args);
                            };

                            //Setup override event listener
                            var origAddEventListener = EventTarget.prototype.addEventListener;
                            EventTarget.prototype.addEventListener = function(type, fn, capture) {
                                if(type === "mousedown" && this.matches != null && (this.matches(".lm_tab") || this.matches(".lm_splitter"))) {
                                    origAddEventListener.bind(this)(type, (evt)=>{
                                        let bounds = topLevelParent.getBoundingClientRect();

                                        let evtOverrides = new Map();

                                        evtOverrides.set("pageX", evt.pageX - bounds.x);
                                        evtOverrides.set("pageY", evt.pageY - bounds.y);

                                        let evtProxy = new Proxy(evt, {
                                            get: (obj, prop)=>{
                                                if(evtOverrides.has(prop)) {
                                                    let override = evtOverrides.get(prop);
                                                    return typeof override === "function" ? override.bind(obj) : override;
                                                } else {
                                                    return typeof obj[prop] === "function" ? obj[prop].bind(obj) : obj[prop];
                                                }
                                            }
                                        });

                                        fn(evtProxy);

                                    }, capture);
                                } else {
                                    origAddEventListener.bind(this)(type, fn, capture);
                                }
                            }

                            await wpm.requireExternal(GoldenLayoutPath+"/goldenlayout-base.css");
                            await wpm.requireExternal(GoldenLayoutPath+"/goldenlayout-light-theme.css");

                            let documentOverrides = new Map();

                            documentOverrides.set("body", bodyElement);

                            documentOverrides.set("addEventListener", (eventName, callback, options)=>{
                                if(options != null) {
                                    console.log("OPTIONS!!!", options);
                                }

                                cQuery(document).on(eventName, (evt)=>{
                                    let bounds = topLevelParent.getBoundingClientRect();

                                    let evtOverrides = new Map();

                                    evtOverrides.set("pageX", evt.pageX - bounds.x);
                                    evtOverrides.set("pageY", evt.pageY - bounds.y);

                                    let evtProxy = new Proxy(evt, {
                                        get: (obj, prop)=>{
                                            if(evtOverrides.has(prop)) {
                                                let override = evtOverrides.get(prop);
                                                return typeof override === "function" ? override.bind(obj) : override;
                                            } else {
                                                return typeof obj[prop] === "function" ? obj[prop].bind(obj) : obj[prop];
                                            }
                                        }
                                    });

                                    callback(evtProxy);
                                }, options);
                            });

                            documentOverrides.set("removeEventListener", (eventName, callback, options)=>{
                                cQuery(document).off(eventName);
                            });

                            documentOverrides.set("querySelector", (selector)=>{
                                console.log("querySelector", selector);
                                return document.querySelector(selector);
                            });

                            documentOverrides.set("querySelectorAll", (selector)=>{
                                console.log("querySelectorAll", selector);
                                return document.querySelectorAll(selector);
                            });

                            let documentProxy = new Proxy(document, {
                                get: (obj, prop)=>{
                                    if(documentOverrides.has(prop)) {
                                        let override = documentOverrides.get(prop);
                                        return typeof override === "function" ? override.bind(obj) : override;
                                    } else {
                                        return typeof obj[prop] === "function" ? obj[prop].bind(obj) : obj[prop];
                                    }
                                }
                            });

                            async function internalLoad(document) {

                                let response = await fetch(GoldenLayoutPath+"/goldenlayout.min.js", {credentials: 'same-origin'});
                                let scriptContent = await response.text();

                                let origDefine = window.define;
                                if (window.define != null) {
                                    window.define = null;
                                }

                                eval(scriptContent);

                                //Restore previous define, if this script did not set define
                                if (window.define === null && origDefine != null) {
                                    window.define = origDefine;
                                }
                            }

                            await internalLoad(documentProxy);

                            resolve();
                        });

                        await goldenLayoutLoadPromise;
                    };
                </SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm_js_libs" id="golden-layout_material-design-theme" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "Material Design Theme bindings for Golden Layout",
    "dependencies": [
        "#golden-layout"
    ],
    "assets": [],
    "version": "1.0",
    "changelog": {
        "1.0": "Initial version"
    },
    "license": "Apache 2.0"
}

</SCRIPT><STYLE id="gl-mdc-binding-style">
.lm_goldenlayout .lm_content {
  background: var(--mdc-theme-background); }

.lm_maximised .lm_header {
  background-color: var(--mdc-theme-surface); }

.lm_goldenlayout .lm_header .lm_tab {
  background: var(--mdc-theme-surface);
  border: 0;
  user-select: none; }
  .lm_goldenlayout .lm_header .lm_tab .lm_title {
    color: var(--mdc-theme-on-surface); }
  .lm_goldenlayout .lm_header .lm_tab.lm_active {
    border-bottom: 2px solid var(--mdc-theme-primary);
    box-shadow: none;
    padding-bottom: 4px; }
    .lm_goldenlayout .lm_header .lm_tab.lm_active:before {
      position: absolute;
      top: 0;
      left: 0;
      background: var(--mdc-theme-primary);
      opacity: 0.04;
      content: "";
      width: 100%;
      height: 100%; }
</STYLE></WPM-PACKAGE><WPM-PACKAGE data-repository="wpm-repos" id="WPM" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "Webstrate Package Manager",
    "dependencies": [
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "2.42",
    "forceEmbedding": true
}

</SCRIPT><SCRIPT id="WPMv2-script" type="text/javascript">
/**
 * WPMv2 - Webstrate Package Manager
 *
 * Copyright 2019 Rolf Bagge, Janus Bager Kristensen,
 * CAVI - Center for Advanced Visualisation and Interaction,
 * Aarhus University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

/* global Promise, webstrate, eval */

//Encapsulate WPMv2, so we can decide which methods are public
((window) => {

    const WPM_ALIASES = "WPM.repoAliases";

    let runningRequiresPromiseMap = [];

    let allInstalledCallbacksStack = [];

    const requireQueue = [];

    /**
     * WebstratePackageManager version 2
     *
     * It is used to install WPM packages into webstrates.
     *
     * <pre><code>WPMv2.require([
     *      {package: "somePackageName", repository: "/somewebstraterepo"},
     *      {package: "someOtherPackageName", repository: "/somewebstraterepo"}
     * ]).then(()=>{
     *     //Packages are now installed
     * });
     * </code></pre>
     * @hideconstructor
     */
    class WPMv2 {
        static async bootstrap(packageDom, options, requireToken, triggerOnPackageInstalled = false) {
            let wpmPackage = WPMv2.getWPMPackageFromDOM(packageDom);
            let promises = [];

            /**
             * @class WPMInterface
             * @classdesc
             * Internal WPM interface that is provided for every package that is installed via WPMv2. Is accessed as just wpm, when inside package code.
             * @hideconstructor
             * @memberof WPMv2
             */
            let wpmInterface = {};

            /**
             * Reads metadata from the given package. If no packagename is given, metadata from the current package is read.
             *
             * @example
             * let metadata = wpm.readMetadata();
             *
             * @param {string} [packageName] - The package to read metadata from
             * @returns {json}
             * @memberof WPMv2.WPMInterface
             * @name readMetadata
             * @method
             */
            wpmInterface.readMetadata = (packageName = null) => {
                if (packageName == null) {
                    packageName = packageDom.getAttribute("id");
                }

                return WPMv2.readMetadata(packageName);
            };

            /**
             * Registers a callback to be called when this package is installed.
             *
             * @example
             * wpm.onInstalled(()=>{
             *     //Package is now installed
             * });
             *
             * @param {method} callback
             * @memberof WPMv2.WPMInterface
             * @name onInstalled
             * @method
             */
            wpmInterface.onInstalled = (callback) => {
                packageDom.addEventListener("wpm.packageInstalled", callback, {"once": true});
            };

            /**
             * Registers a callback to be called when all packages are installed. (When installing multiple packages at the same time.)
             *
             * @example
             * wpm.onAllInstalled(()=>{
             *     //All packages are installed
             * });
             *
             * @param {method} callback
             * @memberof WPMv2.WPMInterface
             * @name onAllInstalled
             * @method
             */
            wpmInterface.onAllInstalled = (callback) => {
                //Retrieve from stack
                let allInstalledCallbacks = allInstalledCallbacksStack[allInstalledCallbacksStack.length-1];
                if (allInstalledCallbacks){
                    allInstalledCallbacks.push(callback);
                } else {
                    // STUB: Remove FIXME if ok
                    console.log("FIXME: WPMv2 - No allInstalledCallbacks in allInstalledCallbacksStack, assuming no more packages? Is this ok?");
                    // Immediately call the callback since no more packages are left
                    callback();
                }

            };

            /**
             * Registers a callback to be called when this package is removed.
             *
             * @example
             * wpm.onRemoved(({detail: packageName})=>{
             *     //Package is removed, packageName is provided for ease of access, will be same as the package this callback was registered from.
             * });
             *
             * @param {method} callback
             * @memberof WPMv2.WPMInterface
             * @name onRemoved
             * @method
             */
            wpmInterface.onRemoved = (callback) => {
                packageDom.addEventListener("wpm.packageRemoved", callback, {"once": true});
            };

            /**
             * Registers a callback to be called when any package is removed.
             *
             * @example
             * wpm.onRemovedAny(({detail: packageName})=>{
             *      //Package with name "packageName" has been removed
             * });
             *
             * @param {method} callback
             * @memberof WPMv2.WPMInterface
             * @name onRemovedAny
             * @method
             */
            wpmInterface.onRemovedAny = (callback) => {
                document.addEventListener("wpm.packageRemovedAny", callback);
            };

            wpmInterface.require = async (packageRequests, extraOptions) => {
                let convertedPackages = [];

                if (packageRequests != null) {
                    if (!Array.isArray(packageRequests)) {
                        packageRequests = [packageRequests];
                    }

                    for (let packageRequest of packageRequests) {
                        if (typeof packageRequest === "string") {
                            //Shorthand for requiring dependency, lookup in our descriptor
                            let packageName = packageRequest;
                            let repo = wpmPackage.optionalDependencyMap.get(packageName);

                            convertedPackages.push({
                                package: packageName,
                                repository: repo
                            });
                        } else {
                            convertedPackages.push(packageRequest);
                        }
                    }
                } else {
                    //packages == null, means require all dependencies!
                    wpmPackage.optionalDependencyMap.forEach((repo, packageName) => {
                        convertedPackages.push({
                            package: packageName,
                            repository: repo
                        });
                    });
                }

                const combinedOptions = Object.assign({}, options, extraOptions);

                promises.push(WPMv2.require(convertedPackages, combinedOptions, requireToken));

                return Promise.all(promises);
            };

            async function loadExternalCSS(response) {
                let styleContent = await response.text();

                //Attempt linking stylesheets instead of inlining them
                let style = document.createElement("style");

                let transient = document.createElement("transient");
                transient.appendChild(style);

                //Disable sourcemap

                styleContent = styleContent.replace(/\/\*#\s*sourceMappingURL=\S+\s*\*\//, "");
                //styleContent = styleContent.replace(/\/\/#\s*sourceMappingURL=\S+/, "");

                style.innerHTML = styleContent;

                document.head.append(transient);
            }

            async function loadExternalJS(response) {
                let scriptContent = await response.text();

                //Hack to make requirejs work, and be able to hide it
                const origDefine = window.define;
                if (window.define != null) {
                    window.define = undefined;
                }

                //Disable sourcemap
                //scriptContent = scriptContent.replace(/\/\*#\s*sourceMappingURL=\S+\s*\*\//, "");
                scriptContent = scriptContent.replace(/\/\/# sourceMappingURL=\S+/, "");

                eval.call(null, scriptContent);

                //Restore previous define, if this script did not set define
                if (window.define == null && origDefine != null) {
                    window.define = origDefine;
                }
            }

            /**
             * Fetches and evaluates external javascript, or loads css.
             *
             * The server response header Content-Type will be used to determine if its a JS or CSS.
             *
             * @example
             * await wpm.requireExternal("https://some.site.com/someScript.js");
             * //someScript.js has now been parsed and evaluated
             *
             * @param {string|string[]} urls - The URLs to the wanted JS, CSS
             * @returns {Promise<void>} - Resolves when all scripts/styles are fetched and evaluated/loaded
             * @memberof WPMv2.WPMInterface
             * @name requireExternal
             * @method
             */
            wpmInterface.requireExternal = async (urls) => {
                if(!(urls instanceof Array)) {
                    urls = [urls];
                }

                for(let url of urls) {

                    let promise = new Promise(async (resolve, reject)=>{
                        try {
                            let response = await fetch(url, {credentials: 'same-origin'});

                            let contentType = response.headers.get("Content-Type").trim();
                            let indexOfSemicolon = contentType.indexOf(";");
                            if (indexOfSemicolon !== -1) {
                                contentType = contentType.substring(0, indexOfSemicolon).trim();
                            }

                            switch (contentType) {
                                case "text/css": {
                                    await loadExternalCSS(response);
                                    break;
                                }
                                case "text/javascript":
                                case "application/javascript":
                                case "application/x-javascript": {
                                    await loadExternalJS(response);
                                    break;
                                }
                                default:
                                    console.warn("Unhandled contentType:", contentType, url);
                                    console.warn("Loading unknown as JS for know. please report...")
                                    await loadExternalJS(response);
                            }
                            resolve();
                        } catch(e) {
                            reject("Unable to fetch: "+url);
                        }
                    });

                    //promises.push(promise);

                    await promise;
                }
            };

            let scripts = packageDom.querySelectorAll("script[type='disabled']");

            for (let i = 0; i < scripts.length; i++) {
                let script = scripts[i];

                let scriptContent = "";

                if (script.src != null && script.src.length > 0) {
                    let response = await fetch(script.src, {credentials: 'same-origin'});
                    scriptContent = await response.text();
                } else {
                    scriptContent = script.innerText;
                }

                scriptContent = 'try{'+scriptContent+'} catch (ex){console.error("Bootstrap runtime error in '+packageDom.getAttribute("id").replaceAll("'","")+':", ex);}';

                const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;

                try {
                    let functionArgs = [];
                    functionArgs.push("wpm");

                    let functionArgValues = [];
                    functionArgValues.push(wpmInterface);

                    if(options.context != null) {
                        const contextKeys = Object.keys(options.context);
                        functionArgs.push(...contextKeys);

                        const contextValues = Object.values(options.context);
                        functionArgValues.push(...contextValues);
                    }

                    let wpmEval = new AsyncFunction(...functionArgs, scriptContent);
                    await wpmEval(...functionArgValues);
                } catch (e) {
                    console.error("Bootstrap parse error in " + packageDom.getAttribute("id"), e);
                }
            }

            await Promise.all(promises);

            if (triggerOnPackageInstalled) {
                packageDom.dispatchEvent(new CustomEvent("wpm.packageInstalled"));
            }
        }

        /**
         * Installs all packages at the given repository into the current page
         *
         * @example
         * WPMv2.requireAll("https://some.site.com/myRepo");
         *
         * @param {string} repository - The repository to lookup packages from
         * @param {WPMv2~PackageOptions} options - options to use for overriding packages options, also applies for dependencies
         * @returns {Promise<void>} - Resolved when packages are installed
         */
        static async requireAll(repository, options = {}) {
            let packages = [];

            let wpmPackages = await WPMv2.getPackagesFromRepository(repository);

            wpmPackages.forEach((pkg) => {
                if(options.blacklist != null && options.blacklist instanceof Array && options.blacklist.includes(pkg.name)) {
                    //Skip this package
                    return;
                }

                let pkgOptions = {
                    repository: pkg.repository,
                    package: pkg.name
                };
                packages.push(pkgOptions);
            });

            return WPMv2.require(packages, options);
        }

        /**
         * @typedef {Object} WPMv2~PackageOptions
         * @property {string} [repository] - The repository to lookup the package inside. If left unset, the current page is used.
         * @property {HTMLElement|string} [appendTarget] - The dom node to append to. If a string, will be looked up by document.querySelector(appendTarget). Defaults to a transient div inside document.head
         * @property {('append'|'before'|'after'|'prepend')} [appendMethod] - How to append to the appendTarget. Defaults to 'append'.
         */

        /**
         * @typedef {Object} WPMv2~PackageJson
         * @property {string} package - The name of the package
         * @property {string} [repository] - The repository to lookup the package inside. If left unset, the current page is used.
         * @property {HTMLElement|string} [appendTarget] - The dom node to append to. If a string, will be looked up by document.querySelector(appendTarget). Defaults to a transient div inside document.head
         * @property {('append'|'before'|'after'|'prepend')} [appendMethod] - How to append to the appendTarget. Defaults to 'append'.
         */

        /**
         *
         * @param {WPMv2.WPMPackage[]}packages
         * @returns {Promise<void>}
         */
        static async findCompletePackageTreeSorted(packages = [], defaultOptions, overrideOptions = {}) {
            const numPackages = packages.length;

            if (!Array.isArray(packages)) {
                packages = [packages];
            }

            let alreadySorting = [];
            let convertedPackages = [];

            async function addRepo(repoUrl, options) {
                if(overrideOptions.repository != null) {
                    console.warn("Adding a full repository, does not atm support overriding options for repository...");
                }

                try {
                    let packages = await WPMv2.getPackagesFromRepository(repoUrl);
                    for(let pkg of packages) {
                        if(options != null) {
                            pkg.updateFromOptions(options);
                        }
                        await addPackage(pkg);
                    }
                } catch (ex){
                    console.error("WPMv2 very important error: Could not resolve repository. This will probably cause the site to fail horribly! ", repoUrl, ex);
                }
            }

            async function addPackage(wpmPackage) {
                //Check if package is in local dom
                let localPackageDom = document.querySelector(".packages .package#" + wpmPackage.name + ", wpm-package#" + wpmPackage.name);
                let repoOverride = wpmPackage.repository;
                if(localPackageDom != null) {
                    //Local package exists, override repository with local ? This breaks dependencies that are "same repository", since they now lookup on the local repository.
                    //Not setting local repository, makes the update from dom, happen on the non embedded version, which is also wrong?
                    //wpmPackage.repository = WPMv2.getLocalRepositoryURL();
                    repoOverride = WPMv2.getLocalRepositoryURL();
                }

                let name = WPMv2.getName(wpmPackage);
                if(!alreadySorting.includes(name)){
                    alreadySorting.push(name);
                    try {
                        wpmPackage = await WPMv2.getLatestPackageFromPackage(wpmPackage, repoOverride);
                        let dependencies = await WPMv2.findAllDependencies(wpmPackage, Object.assign({}, overrideOptions));

                        for(let dependency of dependencies) {
                            await addPackage(dependency);
                        }
                        convertedPackages.push(wpmPackage);
                    } catch (ex){
                        console.error("WPMv2 very important error: Could not resolve package. This will probably cause the site to fail horribly! ", wpmPackage, ex);
                    }
                }
            }

            // Resolve all the packages
            await Promise.all(packages.map(async (pkg)=>{
                let wpmPackage = null;
                if (pkg instanceof WPMPackage) {
                    //Already a WPMPackage
                    wpmPackage = pkg;
                    wpmPackage.updateFromOptions(overrideOptions);
                } else if(typeof pkg === "string") {
                    if(pkg.startsWith("http") || (pkg.startsWith("/") && pkg.indexOf(" ") === 0)) {
                        //Full repository, http(s)://myrepourl or /my-relative-url
                        await addRepo(pkg);
                        return;
                    } else {
                        //Single package, name or including repository
                        let split = pkg.split(" ");

                        if(split.length === 1) {
                            //Single local package
                            let options = Object.assign({}, defaultOptions, {
                                "package": split[0]
                            }, overrideOptions);
                            wpmPackage = new WPMPackage(options.package, options.repository);
                            wpmPackage.updateFromOptions(options);
                        } else if(split.length === 2) {
                            //Single package from given repository
                            let options = Object.assign({}, defaultOptions, {
                                "package": split[1].replace("#", ""),
                                "repository": split[0]
                            }, overrideOptions);
                            wpmPackage = new WPMPackage(options.package, options.repository);
                            wpmPackage.updateFromOptions(options);
                        } else {
                            console.warn("Unable to parse package from string:", pkg);
                        }
                    }
                } else {
                    if(pkg.repository != null && pkg.package != null) {
                        //Full package, add
                        let options = Object.assign({}, defaultOptions, pkg, overrideOptions);
                        wpmPackage = new WPMPackage(options.package, options.repository);
                        wpmPackage.updateFromOptions(options);
                    } else if(pkg.repository != null) {
                        //Full repo, add all
                        await addRepo(pkg.repository, pkg);
                        return;
                    }
                }

                if(wpmPackage != null) {
                    await addPackage(wpmPackage);
                } else {
                    console.log("Was null:", pkg);
                }
            }));

            const sortedPackages = [];
            let lastLength = convertedPackages.length;
            while(convertedPackages.length > 0) {
                let packagesWithDependenciesInstalled = convertedPackages.filter((pkg)=>{
                    let ready = true;

                    for(let dep of pkg.dependencyMap) {
                        //If any dependency is not sorted to be installed yet, this is not ready
                        if(!WPMv2.hasPackage(sortedPackages, {"package": dep[0]})) {
                            ready = false;
                            break;
                        }
                    }
                    for(let dep of pkg.optionalDependencyMap) {
                        //If not already sorted to be installed, and among packages to install, this is not ready yet
                        if(!WPMv2.hasPackage(sortedPackages, {"package": dep[0]}) && WPMv2.hasPackage(convertedPackages, {"package": dep[0]})) {
                            ready = false;
                            break;
                        }
                    }

                    return ready;
                });

                packagesWithDependenciesInstalled.forEach((pkg)=>{
                    sortedPackages.push(pkg);
                    convertedPackages.splice(convertedPackages.indexOf(pkg), 1);
                });

                if(convertedPackages.length === lastLength) {
                    console.warn("Not able to add any more packages:", convertedPackages);
                    break;
                }
                lastLength = convertedPackages.length;
            }

            return sortedPackages;
        }

        /**
         * Finds all dependencies of a package
         * @param pkg
         * @returns {Promise<WPMv2.WPMPackage[]>}
         * @private
         */
        static async findAllDependencies(pkg, overrideOptions = {}) {
            let dependencies = [];

            for(let dependencyEntry of pkg.dependencyMap) {
                let dependency = new WPMPackage(dependencyEntry[0], dependencyEntry[1]);
                dependency.updateFromOptions(overrideOptions);
                dependencies.push(dependency);
            }

            return dependencies;
        }

        /**
         * Checks if the given array, contains the given package
         * @private
         */
        static hasPackage(packages, searchPackage) {
            return packages.find((pkg)=>{
                let pkgName = WPMv2.getName(pkg);
                let searchPackageName = WPMv2.getName(searchPackage);

                if(pkgName == null || searchPackageName == null) {
                    console.warn("Unable to compare as one was null");
                    return false;
                }

                return pkgName === searchPackageName;
            }) != null;
        }

        static getName(searchPackage){
            if(searchPackage instanceof WPMPackage) {
                return searchPackage.name;
            } else if(searchPackage.package != null) {
                return searchPackage.package;
            } else {
                console.warn("Unable to infer package name from:", searchPackage);
                return null;
            }
        }

        /**
         * Installs the given packages into the current document
         *
         * Override options set in overrideOptions, override the options given in packages.
         *
         * @example
         * WPMv2.require([{package: "myPackage", repository: "myRepositoryUrl"}]);
         *
         * @param {WPMv2.WPMPackage[]|WPMv2.WPMPackage|WPMv2~PackageJson[]|WPMv2~PackageJson} packages - the packages to install
         * @param {WPMv2~PackageOptions} overrideOptions - options to use for overriding packages options, also applies for dependencies
         * @returns {Promise<void>} - Resolves when the packages are done installing
         */
        static async require(packages = [], overrideOptions = {}, givenRequireToken = null) {
            const defaultOptions = {
                repository: WPMv2.getLocalRepositoryURL(),
                appendMethod: "append",
                appendTarget: null,
                bootstrap: true
            };

            //Make sure we dont override package
            if(overrideOptions.hasOwnProperty("package")) {
                console.warn("Overriding package...", overrideOptions);
                delete overrideOptions.package;
            }

            const completePackageTreeSorted = await WPMv2.findCompletePackageTreeSorted(packages, defaultOptions, overrideOptions);

            if (packages.length === 0) {
                return;
            }

            let requireToken = givenRequireToken;

            let timerId = [...Array(10)].map(_ => (Math.random() * 36 | 0).toString(36)).join``;
            let requireTimerId = "Require time [" +timerId +"]";

            if (givenRequireToken == null) {
                allInstalledCallbacksStack.push([]);
                requireToken = {};
                console.time(requireTimerId);
            }

            // Schedule all the package promises in parallel, but keep track of package inter-dependencies too
            let packagePromiseMap = new Map();

            //Save the currently running require
            runningRequiresPromiseMap.push(packagePromiseMap);

            for (let pkg of completePackageTreeSorted) {
                // At this point, since the tree is sorted, a dependency is either hard and supposed to be in the tree or soft and maybe in the tree (if not, then not installed)
                // If the depedency is hard and not in the tree then a missing package error has already happened and we are going by best-effort anyways, so ignore this case.

                //Check for another require already promising to install this package
                let foundPromise = null;
                for(let promiseMap of runningRequiresPromiseMap) {
                    if(promiseMap.has(pkg.name)) {
                        //Use other require promise, to tell us when package is installed
                        foundPromise = promiseMap.get(pkg.name);
                        break;
                    }
                }

                if(foundPromise != null) {
                    packagePromiseMap.set(pkg.name, foundPromise);
                } else {

                    packagePromiseMap.set(pkg.name, async function multithreadedFetchPackage() {
                        // Lookup all hard and optional dependencies and wait for them before starting ours
                        await Promise.all([...pkg.dependencyMap.keys(), ...pkg.optionalDependencyMap.keys()].map((dependency) => {
                            return packagePromiseMap.get(dependency);
                        }));

                        // Install this package
                        let options = Object.assign({}, defaultOptions, pkg.getPackageOptions(), overrideOptions);

                        //Check if package is in dom
                        let packageDom = document.querySelector(".packages .package#" + pkg.name + ", wpm-package#" + pkg.name);

                        let alreadyInstalled = false;

                        let wpmPackage = null;

                        let needsAppending = false;

                        if (packageDom == null) {
                            //We need to fetch and install package to dom
                            let fetchedPackageDom = await WPMv2.getPackageDOM(pkg.repository, pkg.name);

                            //Rewrite packageDom to a wpm-package
                            packageDom = document.createElement("wpm-package");

                            for (let index = fetchedPackageDom.attributes.length - 1; index > -1; --index) {
                                let attribute = fetchedPackageDom.attributes[index];
                                packageDom.setAttribute(attribute.name, attribute.value);
                            }

                            // Instead of display:none, hide it otherwise due to Chrome bug for SVGs
                            packageDom.style.width = 0;
                            packageDom.style.height = 0;
                            packageDom.style.position = "absolute";
                            packageDom.style.visibility = "hidden";

                            Array.from(fetchedPackageDom.children).forEach((child) => {
                                packageDom.appendChild(child);
                            });

                            WPMv2.stripProtection(packageDom);

                            wpmPackage = WPMv2.getWPMPackageFromDOM(packageDom);

                            needsAppending = true;
                        } else {
                            wpmPackage = WPMv2.getWPMPackageFromDOM(packageDom);
                            alreadyInstalled = true;
                        }

                        //Install into page
                        if (needsAppending) {
                            let appendTarget = options.appendTarget;

                            if (typeof appendTarget === "string") {
                                appendTarget = document.querySelector(appendTarget);
                            }

                            if (appendTarget == null) {
                                appendTarget = document.createElement("div");
                                appendTarget.setAttribute("transient-element", "");
                                appendTarget.setAttribute("transient-wpmid", packageDom.id);
                                document.head.appendChild(appendTarget);
                            }

                            switch (options.appendMethod.toLowerCase()) {
                                case "before":
                                    appendTarget.parentNode.insertBefore(packageDom, appendTarget);
                                    break;

                                case "after":
                                    appendTarget.parentNode.insertBefore(packageDom, appendTarget.nextSibling);
                                    break;
                                case "prepend":
                                    appendTarget.prepend(packageDom);
                                    break;

                                case "append":
                                default:
                                    appendTarget.append(packageDom);
                            }

                            // POST all assets to the target
                            if (wpmPackage.assets.length > 0) {
                                let repoAssetsUrl = WPMv2.lookupRepoAlias(wpmPackage.repository);
                                let repoAssets = await WPMv2.fetchAssets(repoAssetsUrl);

                                let localAssetsUrl = location.pathname + "?assets&latest";
                                let localAssets = await WPMv2.fetchAssets(localAssetsUrl);

                                let formData = new FormData();
                                let assetPromises = [];
                                wpmPackage.assets.forEach(function (asset) {
                                    //If we already have same filehash of this asset, skip
                                    let localAsset = localAssets.get(asset);
                                    let repoAsset = repoAssets.get(asset);

                                    if (localAsset != null && repoAsset != null && localAsset.fileHash === repoAsset.fileHash) {
                                        return;
                                    }

                                    assetPromises.push(new Promise(async function (resolve, reject) {
                                        let blob = await WPMv2.fetchAsset(repoAssetsUrl, asset);

                                        // Fetch it and append to POST
                                        formData.append("file", blob, asset);
                                        resolve();
                                    }));
                                });

                                if (assetPromises.length > 0) {
                                    await Promise.all(assetPromises);

                                    await fetch(location.pathname, {
                                        body: formData,
                                        credentials: 'same-origin',
                                        method: "post"
                                    });
                                }
                            }
                        }

                        //Check if package is live
                        if (packageDom.getAttribute("transient-wpm-live") == null) {
                            if(pkg.bootstrap) {
                                //Make package live
                                await WPMv2.bootstrap(packageDom, overrideOptions, requireToken, !alreadyInstalled);

                                packageDom.setAttribute("transient-wpm-live", "");
                            } else {
                                //Ignore
                            }
                        } else {
                            //Already live
                        }
                    }());
                }
            }

            // Wait for all packages to finish installation
            await Promise.all(Array.from(packagePromiseMap.values()));

            //Splice the finished require away
            runningRequiresPromiseMap.splice(runningRequiresPromiseMap.indexOf(packagePromiseMap), 1);

            //Only the first outer call to require, has givenAllInstalledCallbacks set to null
            if (givenRequireToken === null) {
                let allInstalledCallbacks = allInstalledCallbacksStack.pop();
                console.timeEnd(requireTimerId);

                let allInstalledTimerId = "All Installed [" + timerId + "]";

                console.time(allInstalledTimerId);
                for(let allInstalledCallback of allInstalledCallbacks) {
                    await allInstalledCallback();
                }
                console.timeEnd(allInstalledTimerId);
            }
        }

        /**
         * Get the package data based on the package DOM node
         *
         * @param {Node} packageDOM the package dom node
         * @returns {WPMPackage} the package
         * @ignore
         */
        static getWPMPackageFromDOM(packageDOM) {
            try {
                let name = packageDOM.getAttribute("id");

                let descriptorDom = packageDOM.querySelector("script[type='descriptor'], wpm-descriptor");

                if (descriptorDom !== null) {
                    try {
                        let packageJson = JSON.parse(descriptorDom.textContent);
                        let repository = packageDOM.getAttribute("data-repository");

                        if(repository == null) {
                            repository = WPMv2.getLocalRepositoryURL();
                        }

                        return new WPMPackage(name, repository, packageJson);
                    } catch (e){
                        console.error("Erroneous package descriptor", e, descriptorDom.textContent, packageDOM);
                    }
                } else {
                    console.error("Missing package descriptor: ", packageDOM);
                }
            } catch (e) {
                console.error(e);
            }
        }

        static getLocalRepositoryURL() {
            return location.origin + location.pathname + "?raw";
        }

        /**
         * Retrieve the package dom from a repository
         *
         * @param {String} repository the repository to retrieve from
         * @param {String} packageName the package to retrieve
         * @returns {Node} the package dom node
         * @ignore
         */
        static async getPackageDOM(repository, packageName) {
            let dom = null;

            if(repository == this.getLocalRepositoryURL()) {
                dom = document.querySelector("html");
            } else {
                dom = await WPMv2.fetchDom(repository);
            }

            let packageDOMSource = dom.querySelector(".packages .package#" + packageName + ", wpm-package#" + packageName);
            if (packageDOMSource === null) {
                throw new Error("Invalid package '" + packageName + "' specified, no such package in repository '" + repository + "'");
            }

            let packageDOM = packageDOMSource.cloneNode(true);
            if(!packageDOM.hasAttribute("data-repository")) {
                packageDOM.setAttribute("data-repository", repository);
            }

            return packageDOM;
        }

        /**
         * Get an array of all packages that is currently installed in the dom
         *
         * @example
         * let installedPackages = WPMv2.getCurrentlyInstalledPackages();
         *
         * @returns {WPMv2.WPMPackage[]}
         */
        static getCurrentlyInstalledPackages() {
            let packages = [];

            document.querySelectorAll(".packages .package, wpm-package").forEach(function (v) {
                packages.push(WPMv2.getWPMPackageFromDOM(v));
            });

            return packages;
        }

        /**
         * Retrieve the latest package data from the original repository this package is from
         *
         * @example
         * WPMv2.getCurrentlyInstalledPackages().forEach((pkg)=>{
         *     let package = WPMv2.getLatestPackageFromPackage(pkg);
         *     //package now holds the latest data retrieved from the original repo it was installed from: like version, dependencies, changelog etc.
         * });
         *
         * @param {WPMv2.WPMPackage} p - The package to update package data for
         * @returns {Promise<WPMv2.WPMPackage>}
         */
        static async getLatestPackageFromPackage(p, repoOverride=null) {
            let fetchRepository = p.repository;
            if(repoOverride != null) {
                fetchRepository = repoOverride;
            }
            let packageDOM = await WPMv2.getPackageDOM(fetchRepository, p.name);

            let updatedPackage = WPMv2.getWPMPackageFromDOM(packageDOM);

            updatedPackage.updateFromOptions(p.getPackageOptions());

            return updatedPackage;
        }

        /**
         * Find all packages at a repository
         *
         * @example
         * WPMv2.getPackagesFromRepository("some.site.com/myRepo").then((packages)=>{
         *     console.log("Packages at repo:");
         *     packages.forEach((pkg)=>{
         *         console.log(pkg);
         *     }):
         * });
         *
         * @param {String} repositoryUrl the repository to search
         * @returns {Promise<WPMv2.WPMPackage[]>} the packages found
         */
        static async getPackagesFromRepository(repositoryUrl) {
            let packages = [];

            let dom = await WPMv2.fetchDom(repositoryUrl);

            dom.querySelectorAll(".packages .package, wpm-package").forEach(function (v) {
                if(!v.hasAttribute("data-repository")) {
                    v.setAttribute("data-repository", repositoryUrl);
                }
                packages.push(WPMv2.getWPMPackageFromDOM(v));
            });

            return packages;
        }

        static readMetadata(packageName) {
            let packageDom = document.querySelector(".packages .package#" + packageName + ", wpm-package#" + packageName);

            if(packageDom != null) {
                let metadataDom = packageDom.querySelector("script[type='descriptor'], wpm-descriptor");

                if (metadataDom != null) {
                    return JSON.parse(metadataDom.textContent);
                }
            }
            return null;
        }

        static async fetchAsset(url, asset) {
            if(Array.isArray(url)) {
                for(let u of url) {
                    try {
                        let fetchedAsset = await WPMv2.fetchAsset(u, asset);
                        if(fetchedAsset != null) {
                            return fetchedAsset;
                        }
                    } catch(e) {
                        //Ignore
                    }
                }
            }

            let assetUrl = url.substring(0, url.indexOf("?"));
            if (!assetUrl.endsWith("/")) {
                assetUrl += "/";
            }

            assetUrl += asset;

            let response = await fetch(assetUrl, {credentials: 'same-origin'});
            let blob = await response.blob();

            return blob;
        }

        static async fetchAssets(url) {
            if(Array.isArray(url)) {
                for(let u of url) {
                    try {
                        let assets = await WPMv2.fetchAssets(u);
                        if (assets != null) {
                            return assets;
                        }
                    } catch(e) {
                        //Ignore ?
                    }
                }
            }

            if(!url.endsWith("?assets&latest")) {
                url = url.substring(0, url.indexOf("?")) + "?assets&latest";
            }

            if (WPMv2.assetsCache[url] != null) {
                if (Date.now() - WPMv2.assetsCache[url].timestamp < WPMv2.cacheTimeout) {
                    return WPMv2.assetsCache[url].assets;
                }
            }

            let response = await fetch(url, {credentials: 'same-origin'});

            let assetsJson = await response.json();

            let assetResult = new Map();

            assetsJson.forEach((asset)=>{
                let current = assetResult.get(asset.fileName);

                if(current == null || current.v < asset.v) {
                    assetResult.set(asset.fileName, asset);
                }
            });

            WPMv2.assetsCache[url] = {
                assets: assetResult,
                timestamp: Date.now()
            };

            return assetResult;
        }

        static lookupRepoAlias(alias) {
            let localStorageAliases = {};
            let sessionStorageAliases = {};
            try {
                localStorageAliases = JSON.parse(localStorage.getItem(WPM_ALIASES));
            } catch (ex){
                console.warn("Unparseable localStorage.repositoryAliases", ex);
            }
            try {
                sessionStorageAliases = JSON.parse(sessionStorage.getItem(WPM_ALIASES));
            } catch (ex){
                console.warn("Unparseable sessionStorage.repositoryAliases", ex);
            }

            if(localStorageAliases?.hasOwnProperty(alias)) {
                let result = localStorageAliases[alias];
                return result;
            } else if(sessionStorageAliases?.hasOwnProperty(alias)) {
                let result = sessionStorageAliases[alias];
                return result;
            } else {
                //Check if alias might be an url already?
                if(alias.startsWith("http") || alias.startsWith("/")) {
                    //Probabely an url
                    return alias;
                }
            }

            return ["/"+alias+"/?raw", "/"+alias+"/index.html"];
        }

        static async fetchDom(url) {
            //Lookup repos aliases
            url = WPMv2.lookupRepoAlias(url);

            if(Array.isArray(url)) {
                //Call again for each url in array
                for(let u of url) {
                    try {
                        let fetchedDom = await this.fetchDom(u);
                        if(fetchedDom != null) {
                            return fetchedDom;
                        }
                    } catch(e) {
                        //Ignore?
                        console.warn(e);
                    }
                }
            } else {
                if(url.endsWith("?raw") && !url.endsWith("/?raw")) {
                    url = url.substring(0, url.lastIndexOf("?raw")) + "/?raw";
                }

                // Check the cache for ongoing fetches for this URL
                let cachedDom = WPMv2.domCache.get(url);
                if (cachedDom != null) {
                    cachedDom = await cachedDom;
                    if (Date.now() - cachedDom.timestamp < WPMv2.cacheTimeout) {
                        return cachedDom.dom;
                    }
                }

                // No ongoing fetches, start one
                let fetcherPromise = (async function fetchDOMPromise(){
                    let response = await fetch(url, {credentials: 'same-origin'});
                    if(response != null) {
                        let documentText = await response.text();

                        let parsedDom = WPMv2.parser.parseFromString(documentText, "text/html");
                        if (parsedDom.readyState === "loading") {
                            await new Promise((resolve, reject) => {
                                parsedDom.addEventListener("DOMContentLoaded", () => {
                                    resolve();
                                });
                            });
                        }

                        return {
                            dom: parsedDom,
                            timestamp: Date.now()
                        };
                    }
                })();
                WPMv2.domCache.set(url, fetcherPromise);

                return (await fetcherPromise).dom;
            }

            console.error("Unable to fetchDOM from: ", url);
            return null;
        }

        /**
         * Strips all Webstrate protection from the given dom element and its children.
         *
         * @example
         * WPMv2.stripProtection(document.querySelector("#myElement"));
         *
         * @param {HTMLElement} html - The element to strip protection from
         */
        static stripProtection(html) {
            function stripAttributeProtection(elm) {
                if (!elm.__approvedAttributes) {
                    try {
                        elm.__approvedAttributes = new Set();
                    } catch (e) {
                    }
                }

                if (elm.attributes != null) {
                    for (let i = 0, atts = elm.attributes, n = atts.length; i < n; i++) {
                        elm.__approvedAttributes.add(atts[i].nodeName);
                    }
                }
            }

            if (html instanceof Array) {
                html.forEach((entry) => {
                    if (entry != null) {
                        WPMv2.stripProtection(entry);
                    }
                });
                return;
            }

            if (!html.__approved) {
                try {
                    html.__approved = true;
                } catch (e) {
                }
            }

            if (html.removeAttribute != null) {
                html.removeAttribute("unapproved");
            }

            stripAttributeProtection(html);

            if (html.childNodes != null) {
                Array.from(html.childNodes).forEach((child) => {
                    WPMv2.stripProtection(child);
                });
            } else if (html.children != null) {
                Array.from(html.children).forEach((child) => {
                    WPMv2.stripProtection(child);
                });
            }

            if (html.content != null) {
                WPMv2.stripProtection(html.content);
            }
        }

        /**
         * Updates the version of WPMv2 in the current page, with the version in the given url
         *
         * @example
         * await WPMv2.updateWPM("https://some.site.com/containsLatestWPMv2");
         * //WPMv2 is now updated
         *
         * @param {string} url - URL to the webstrate to update WPMv2 from
         * @returns {Promise<void>} - Resolves when WPMv2 is updated
         */
        static async updateWPM(url) {
            console.group("Updating WPM...");
            if(url == null) {
                console.log("No repository given for update, defaulting to \"/wpm/?raw\"");
                url = "/wpm/?raw";
            }

            console.log("Version before update:", window.WPMv2.version);

            let dom = await WPMv2.fetchDom(url);

            let newWpm = dom.querySelector("#WPMv2-script");

            let ourWpm = document.querySelector("#WPMv2-script");

            ourWpm.textContent = newWpm.textContent;

            if(ourWpm.hasAttribute("src")) {
                ourWpm.removeAttribute("src");
                console.warn("Removed src attribute on WPMScript, now inlined instead!");
            }
            eval.call(null, ourWpm.textContent);
            console.log("Version after update:", window.WPMv2.version);
            console.groupEnd();
        }

        /**
         * Installs WPMv2 into the given webstrate. Can be given as an iframe that already points to a transcluded webstrate, or the url to a webstrate.
         *
         * @example
         * await WPMv2.installWPMInto("https://some.site.com/myWebstrate");
         * //WPMv2 is now installed
         *
         * @param {HTMLIFrameElement|string} iframeOrUrl - The iframe or url that WPMv2 should be installed into
         * @returns {Promise<void>} - Resolves when WPMv2 is done installing.
         */
        static async installWPMInto(iframeOrUrl) {
            let iframe = null;
            let transient = null;

            if (typeof iframeOrUrl === "string") {
                iframe = document.createElement("iframe");
                iframe.src = iframeOrUrl;
                let promise = new Promise((resolve, reject) => {
                    iframe.webstrate.on("transcluded", function once() {
                        iframe.webstrate.off("transcluded", once);
                        resolve();
                    });
                });

                transient = document.createElement("transient");
                transient.append(iframe);
                document.body.append(transient);

                await promise;
            } else {
                //Attempt to unpack cQuery/jQuery objects
                if (iframeOrUrl[0] != null) {
                    iframeOrUrl = iframeOrUrl[0];
                }

                if (iframeOrUrl instanceof HTMLIFrameElement) {
                    iframe = iframeOrUrl;
                } else {
                    console.log("Unknown iframe/url: ", iframeOrUrl);
                    return;
                }
            }

            let targetHead = iframe.contentDocument.head;

            //Remove old WPMv2 if present
            let oldWpm = iframe.contentDocument.querySelector("#WPMv2-script");
            if (oldWpm != null) {
                oldWpm.parentNode.removeChild(oldWpm);
            }

            let clonedScript = document.querySelector("#WPMv2-script").cloneNode(true);

            if (clonedScript.src != null && clonedScript.src.length > 0) {
                let response = await fetch(clonedScript.src, {credentials: 'same-origin'});
                let scriptContent = await response.text();

                clonedScript.removeAttribute("src");
                clonedScript.textContent = scriptContent;
            }

            WPMv2.stripProtection(clonedScript);
            targetHead.insertBefore(clonedScript, targetHead.firstChild);

            iframe.contentWindow.eval.call(null, clonedScript.textContent);

            await iframe.contentWindow.webstrate.dataSaved();

            if (transient != null) {
                document.body.removeChild(transient);
            }
        }

        static notifyRemove(packageName, packageDom) {
            let event = new CustomEvent("wpm.packageRemoved", {detail: packageName});
            packageDom.dispatchEvent(event);

            let eventAny = new CustomEvent("wpm.packageRemovedAny", {detail: packageName});
            document.dispatchEvent(eventAny);
        }

        static getRegisteredRepositories(useLocalStorage) {
            let currentAliases = null;

            try {
                if(useLocalStorage) {
                    currentAliases = JSON.parse(localStorage.getItem(WPM_ALIASES));
                } else {
                    currentAliases = JSON.parse(sessionStorage.getItem(WPM_ALIASES));
                }
            } catch (ex){}
            if (currentAliases == null || typeof currentAliases !== "object"){
                currentAliases = {};
            }

            return currentAliases;
        }

        /**
         * Registers a repository alias
         * @param alias The alias to register
         * @param repository The repository to register the alias to
         * @param useLocalStorage If true, the registered alias is registered in localStorage, if not, in sessionStorage
         */
        static registerRepository(alias, repository, useLocalStorage = false) {
            let currentAliases = null;

            try {
                if(useLocalStorage) {
                    currentAliases = JSON.parse(localStorage.getItem(WPM_ALIASES));
                } else {
                    currentAliases = JSON.parse(sessionStorage.getItem(WPM_ALIASES));
                }
            } catch (ex){}
            if (currentAliases == null || typeof currentAliases !== "object"){
                currentAliases = {};
            }

            currentAliases[alias] = repository;

            if(useLocalStorage) {
                localStorage.setItem(WPM_ALIASES, JSON.stringify(currentAliases));
            } else {
                sessionStorage.setItem(WPM_ALIASES, JSON.stringify(currentAliases));
            }
        }

        /**
         * Unregisters a repository alias
         * @param alias The alias to unregister
         * @param useLocalStorage If true, the alias is removed from localStorage, if not, from sessionStorage
         */
        static unregisterRepository(alias, useLocalStorage = false) {
            let currentAliases = null;

            try {
                if(useLocalStorage) {
                    currentAliases = JSON.parse(localStorage.getItem(WPM_ALIASES));
                } else {
                    currentAliases = JSON.parse(sessionStorage.getItem(WPM_ALIASES));
                }
            } catch (ex){
                console.error(ex);
            }
            if (currentAliases == null || typeof currentAliases !== "object"){
                console.log(currentAliases);
                currentAliases = {};
            }

            delete currentAliases[alias];

            if(useLocalStorage) {
                localStorage.setItem(WPM_ALIASES, JSON.stringify(currentAliases));
            } else {
                sessionStorage.setItem(WPM_ALIASES, JSON.stringify(currentAliases));
            }
        }

        /**
         * Clears all registered aliases from storage
         * @param useLocalStorage If true, clears from localStorage, if not, from sessionStorage
         */
        static clearRegisteredRepositories(useLocalStorage = false) {
            if(useLocalStorage) {
                localStorage.setItem(WPM_ALIASES, "{}");
            } else {
                sessionStorage.setItem(WPM_ALIASES, "{}");
            }
        }
    }

    WPMv2.domCache = new Map();
    WPMv2.assetsCache = {};
    WPMv2.parser = new DOMParser();
    WPMv2.cacheTimeout = 5000;

    /**
     * A WPM package
     * @memberof WPMv2
     */
    class WPMPackage {
        /**
         * Create a new WPMPackage
         * @param {string} name - The package name
         * @param {string} repository - The repository that the package should be fetched from
         * @param {json} [descriptorJson] - Package Descriptor
         */
        constructor(name, repository, descriptorJson = {}) {
            /**
             * The name of the package
             * @type {string}
             */
            this.name = name;
            /**
             * The repository the package is fetched from
             * @type {string}
             */
            this.repository = repository;

            /**
             * The version of the package
             * @type {number}
             */
            this.version = -1;
            /**
             * Package dependencies that will be installed when the package is installed
             * @type {string[]}
             */
            this.dependencies = [];
            /**
             * Optional Package dependencies
             * @type {string[]}
             */
            this.optionalDependencies = [];
            /**
             * Assets that the package uses, will be copied over to the webstrate where the package is installed
             * @type {Array.<string>}
             */
            this.assets = [];
            /**
             * A description of the package
             * @type {string}
             */
            this.description = "";
            /**
             * A human friendly name for the package
             * @type {string}
             */
            this.friendlyName = "";
            /**
             * Changelog, holding any changelog information for the package
             * @type {object}
             */
            this.changelog = {};
            /**
             * Link to documentation of the package if any exists
             * @type {string}
             */
            this.documentationLink = "";

            this.dependencyMap = new Map();
            this.optionalDependencyMap = new Map();

            this.appendMethod = "append";
            this.appendTarget = null;

            this.bootstrap = true;

            this.updateFromJson(descriptorJson);
        }

        updateFromOptions(options) {
            ["appendMethod", "appendTarget", "repository", "bootstrap"].forEach((optionProperty)=>{
                if(options.hasOwnProperty(optionProperty)) {
                    this[optionProperty] = options[optionProperty];
                }
            })
        }

        getPackageOptions() {
            let options = {};

            ["appendMethod", "appendTarget", "repository", "bootstrap"].forEach((optionProperty)=>{
                options[optionProperty] = this[optionProperty];
            });

            return options;
        }

        updateFromJson(packageJson) {
            let self = this;

            this.descriptor = packageJson;

            ["version", "friendlyName", "dependencies", "optionalDependencies", "description", "changelog", "documentationLink", "license"].forEach((packageProperty)=>{
                if (packageJson.hasOwnProperty(packageProperty)){
                    this[packageProperty] = packageJson[packageProperty];
                }
            });

            if (packageJson.hasOwnProperty("assets")) {
                packageJson.assets.forEach((asset) => {
                    if (asset.src != null) {
                        self.assets.push(asset.src);
                    } else {
                        self.assets.push(asset);
                    }
                });
            }

            this.dependencies.forEach((dep) => {
                let split = dep.split(" ");

                let repo = null;
                let packageName = null;

                if (split.length === 1) {
                    packageName = split[0].replace("#", "");
                    repo = this.repository;
                } else {
                    packageName = split[1].replace("#", "");
                    repo = split[0];
                }

                self.dependencyMap.set(packageName, repo);
            });

            this.optionalDependencies.forEach((dep) => {
                let split = dep.split(" ");

                let repo = null;
                let packageName = null;

                if (split.length === 1) {
                    packageName = split[0].replace("#", "");
                    repo = this.repository;
                } else {
                    packageName = split[1].replace("#", "");
                    repo = split[0];
                }

                self.optionalDependencyMap.set(packageName, repo);
            });
        }

        toString() {
            return this.name + "[" + this.version + "]";
        }
    }

    let removedObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            mutation.removedNodes.forEach((node) => {
                if (node.matches != null && node.matches(".packages .package, wpm-package")) {
                    WPMv2.notifyRemove(node.id, node);
                } else if (node.querySelectorAll != null) {
                    node.querySelectorAll(".packages .package, wpm-package").forEach((child) => {
                        WPMv2.notifyRemove(child.id, child);
                    });
                }
            });
        });
    });

    removedObserver.observe(document, {
        childList: true,
        attributes: false,
        subtree: true
    });

    //Setup attribute "transient-element" that marks a DOM element as transient
    if(typeof webstrate !== "undefined") {
        let oldIsTransientElement = webstrate.config.isTransientElement;
        webstrate.config.isTransientElement = (node) => {
            if (node.hasAttribute("transient-element")) {
                return true;
            }

            return oldIsTransientElement(node);
        };
    }

    //WPMv2 Interface to the world!
    window.WPMv2 = {
        require: WPMv2.require,
        requireAll: WPMv2.requireAll,
        installWPMInto: WPMv2.installWPMInto,
        stripProtection: WPMv2.stripProtection,
        updateWPM: WPMv2.updateWPM,
        getPackagesFromRepository: WPMv2.getPackagesFromRepository,
        getCurrentlyInstalledPackages: WPMv2.getCurrentlyInstalledPackages,
        getLatestPackageFromPackage: WPMv2.getLatestPackageFromPackage,
        registerRepository: WPMv2.registerRepository,
        unregisterRepository: WPMv2.unregisterRepository,
        clearRegisteredRepositories: WPMv2.clearRegisteredRepositories,
        getRegisteredRepositories: WPMv2.getRegisteredRepositories,
        getLocalRepositoryURL: WPMv2.getLocalRepositoryURL,
        version: 2.42,
        revision: "$Id: WPMv2.js 1023 2023-03-14 10:02:57Z au182811@uni.au.dk $",
        test: WPMv2
    };

    window.WPM = window.WPMv2;
    window.WPMPackage = WPMPackage;
})(window);

// Provide bootloader functionality
class WPMBoot {
    static loadedCallbacks = [];
    static isLoaded = false;

    static async wpmv2_bootloader(){
        document.querySelector("html").setAttribute("transient-wpm2-bootloader", "loading");

        let bootConfigElement = document.querySelector("head script[type='text/json+bootconfig']");
        if (!bootConfigElement){
            return;
        }

        let bootConfig = null;
        try {
            bootConfig = JSON.parse(bootConfigElement.textContent);
        } catch (ex){
            console.error("WPM bootloader cannot parse boot config", bootConfigElement.textContent, ex);
            return;
        }

        if (!bootConfig.require){
            console.warn("WPM bootloader did not find required 'require' section in boot config, ignoring");
            return;
        }

        if (!Array.isArray(bootConfig.require)){
            console.warn("WPM bootloader 'require' section in boot config is not an array, ignoring");
            return;
        }

        // Load all required packages with WPM
        for (let requireStep of bootConfig.require){
            if (!(requireStep.dependencies && Array.isArray(requireStep.dependencies))){
                console.warn("WPM bootloader skipping incorrect requirestep, dependency list is missing", requireStep);
                continue;
            }
            if (requireStep.repositories){
                if (typeof requireStep.repositories !== "object"){
                    console.warn("WPM bootloader skipping registration of repositories because requireStep.repositories isn't an object map of name->url", requireStep);
                } else {
                    for (const [key, value] of Object.entries(requireStep.repositories)) {
                        WPMv2.registerRepository(key, value);
                    }
                }
            }

            if (requireStep.options){
                await WPMv2.require(requireStep.dependencies, requireStep.options);
            } else {
                await WPMv2.require(requireStep.dependencies);
            }
        }

        // Fire loaded events
        document.querySelector("html").setAttribute("transient-wpm2-bootloader", "initializing");
        while (WPMBoot.loadedCallbacks.length>0){
            let callback = WPMBoot.loadedCallbacks.pop();
            try {
                await callback();
            } catch (ex){
                console.error("WPMv2 Bootloader exception in WPMBoot.onLoaded(...) callback", ex, callback);
            }
        }
        document.querySelector("html").setAttribute("transient-wpm2-bootloader", "loaded");
    }

    static async onLoaded(callback){
        if (WPMBoot.isLoaded){
            await callback();
        } else {
            WPMBoot.loadedCallbacks.push(callback);
        }
    }
}
window.WPMBoot = WPMBoot;

document.querySelector("html").setAttribute("transient-wpm2-bootloader", "waiting");
if(typeof webstrate  !== "undefined") {
    // Webstrate mode
    webstrate.on("loaded", async function wpmv2_bootloader_loader() {
        await WPMBoot.wpmv2_bootloader();
    });
} else {
    // Standalone mode
    document.addEventListener("DOMContentLoaded", async function(event) {
        await WPMBoot.wpmv2_bootloader();
    });
}

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="webstrate-components-repos" id="wsc-icon-registry" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Icon registry",
    "description": "Icon providers can register icons for everyone and everything",
    "dependencies": [],
    "assets": [
    ],
    "version": "0.1",
    "license": "Apache 2.0 + CC-BY",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="IconRegistry-script" type="disabled">
/**
 *  IconRegistry
 *  Register icons and use them on the page
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

window.IconRegistry = class IconRegistry {
    static registerProvider(iconProvider){
        IconRegistry.iconProviders.push(iconProvider);

        // TODO: update all icons
    }

    static createIcon(iconIdentifier){
        let icon = null;
        let searchPath = null;

        if (Array.isArray(iconIdentifier)){
            searchPath = iconIdentifier;
        } else {
            searchPath = [iconIdentifier];
        }

        // Query each icon or fallback in order
        search: for (const attempt of searchPath){
            for (const provider of IconRegistry.iconProviders){
                if (provider.provides(attempt)){
                    icon = provider.createIcon(attempt);
                    break search;
                }
            }
        }


        // Ultimate fallback is invisible
        if (icon===null){
            icon = document.createElement("span");
        }
        icon.classList.add("wsc-registry-icon");
        icon.wscIconIdentifier = iconIdentifier;

        return icon;
    }
};
window.IconRegistry.iconProviders = [];

</SCRIPT><STYLE id="icons-style">
.wsc-registry-icon {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

/* Fix Chrome SVG render bug for gradients/filters etc */
head {
    display: block;
    position: absolute;
    z-index: -10;
    opacity: 0;
    pointer-events: none;
}
</STYLE></WPM-PACKAGE><WPM-PACKAGE data-repository="webstrate-components-repos" id="WebstrateComponents_Tools" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "WebstrateComponents Tools",
    "description": "Various tools that are nice to reuse",
    "dependencies": [],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="Tools-script" type="disabled">
/**
 * WebstrateComponents Tools
 *
 * Ease-of-use tools to help manage WPM package info and templates
 *
 * Copyright 2019, 2020, 2021 Rolf Bagge, Janus Bager Kristensen,
 * CAVI - Center for Advanced Visualisation and Interaction,
 * Aarhus University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

/**
 * @namespace WebstrateComponents
 */
window.WebstrateComponents = {};

/**
 * A collection of tools
 * @type {WebstrateComponents.Tools}
 * @hideconstructor
 */
WebstrateComponents.Tools = class Tools {
    /**
     * Tries to extract the entry with the given key from the given config. If key does not exist, returns defaultValue instead.
     * @param {Object} config - The configuration to extract the entry from
     * @param {String} key - The key of the entry to extract
     * @param {*} [defaultValue=null] - The default value to return if the key does not exist.
     */
    static fromConfig(config, key, defaultValue = null) {
        if(config != null && config[key] != null) {
            return config[key];
        }

        return defaultValue;
    }

    /**
     * Loads a template from the document and returns it
     * @param {String} id - The identifier of the template to load
     * @returns {Element} - The loaded template
     */
    static loadTemplate(id) {
        if(!id.startsWith("#")) {
            id = "#" + id;
        }

        let fragment = document.importNode(document.querySelector(id).content, true);

        if(fragment.children.length > 1) {
            console.warn("Template had more than 1 direct child:", id, fragment);
        }

        return fragment.children[0];
    }

    /**
     * Tests if the given testElement is inside the given elm
     * @param {Element} elm
     * @param {Element} testElement
     */
    static isInsideElement(elm, testElement) {
        let parent = testElement;

        while(parent != null) {
            if(parent === elm) {
                return true;
            }

            parent = parent.parentNode;
        }

        return false;
    }
};

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="webstrate-components-repos" id="ButtonSystem" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Buttons",
    "description": "Buttons for all",
    "dependencies": [],
    "assets": [
    ],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="buttons-script" type="disabled">
/**
 *  Button System
 *  Provides easily usable buttons
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/**
 * @namespace ButtonSystem
 */
window.ButtonSystem = {};

/**
 * @typedef {Object} ButtonSystem~ButtonConfig
 * @property {ButtonSystem.ButtonBuilder} [builder] - The builder to use when creating the button, if not specified, the DefaultBuilder will be used.
 * @property {'text'|'outlined'|'raised'|'unelevated'} [style='text'] - The style of the button
 * @property {Element} [icon] - An icon to add to the button
 * @property {boolean} [iconTrailing=true] - Wether the icon should be trailing the button text
 * @property {Function} [onAction] - The callback to run when the button has its action triggered
 */

/**
 * ButtonFactory can create buttons
 */
ButtonSystem.ButtonFactory = class ButtonFactory {
    /**
     * Create a new button
     *
     * @example
     * ButtonFactory.createButton("MyButton", {
     *     style: "outlined",
     *     onAction: ()=>{
     *         //Someone pressed my button
     *     }
     * });
     *
     * @param {String} text - The text of the button
     * @param {ButtonSystem~ButtonConfig} options
     * @returns {ButtonSystem.Button}
     */
    static createButton(text, options) {
        if(options.builder == null) {
            if(ButtonFactory.defaultBuilder == null) {
                throw "Attempt to create Button with defaultBuilder but no default builder is set!";
            }

            options.builder = ButtonFactory.defaultBuilder;
        }

        if(options.style == null) {
            options.style = "text";
        }

        return new ButtonSystem.Button(text, options);
    }

    /**
     * Sets the defailt button builder
     * @param {ButtonBuilder} builder
     */
    static setDefaultBuilder(builder) {
        ButtonFactory.defaultBuilder = builder;
    }
}

ButtonSystem.ButtonFactory.defaultBuilder = null;

ButtonSystem.ButtonBuilder = class ButtonBuilder {
    /**
     * Build the DOM for the given button
     * @param button
     */
    static buildButton(button) {
        //Override in subclass
    }
}

/**
 * Button represents a Button
 * @type {ButtonSystem.Button}
 */
ButtonSystem.Button = class Button {
    /**
     * @param {String} text - The text of the button
     * @param {ButtonSystem~ButtonConfig} options
     */
    constructor(text, options) {
        let self = this;

        this.text = text;
        this.options = options;

        /** @member {Element} - The DOM element of this button */
        this.html = this.options.builder.buildButton(this);

        this.html.addEventListener("click", ()=>{
            if(self.options.onAction != null) {
                self.options.onAction();
            }
        });
    }
}

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="webstrate-components-repos" id="FragmentLogoIcons" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Fragment Logo Icon Set",
    "description": "Provides Icons for Fragments based on their logos",
    "dependencies": [
        "#wsc-icon-registry"
    ],
    "assets": [
    ],
    "version": "0.1",
    "license": "Apache 2.0 + Various",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="FragmentLogoIconProvider-script" type="disabled">
/**
 *  FragmentLogoIconProvider
 *  A provider for Codestrate fragment type icons
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

window.FragmentLogoIconProvider = class FragmentLogoIconProvider {
    provides(iconIdentifier){
        return iconIdentifier.startsWith("code-fragment:");
    }

    /**
     * Create an icon
     */
    createIcon(iconIdentifier) {
        let mimeType = iconIdentifier.slice(14);
        /*
          "wpm/descriptor": (
            base: #000080,
            text: #A0A0FF,
            name: 'WPM Package Descriptor',
            type: 'wpm'
          ),
        */
        let supportedTypes = [
            "text/html",
            "text/javascript",
            "text/css",
            "text/x-typescript",
            "text/markdown",
            "text/x-latex",
            "image/svg+xml",
            "application/json",
            "text/p5js",
            "text/ruby",
            "application/x-lua",
            "text/x-scss",
            "text/python"
        ];
        if (supportedTypes.includes(mimeType)){
            let icon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            let link = document.createElementNS('http://www.w3.org/2000/svg', 'use');
            link.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#'+mimeType.replace(/(\/|\+)/g, "-"));
            icon.appendChild(link);
            return icon;
        }

        if (mimeType==="wpm/descriptor"){
            return IconRegistry.createIcon("mdc:list_alt");
        } else if (mimeType==="text/mirrorverse-audio-router"){
            return IconRegistry.createIcon("mdc:route");
        } else if (mimeType==="text/varv"){
            return IconRegistry.createIcon("webstrates:varv");
        }

        return null;
    }
}


/**
 * Icons for fragments
 * @type {FragmentIcons.IconProvider}
 * @hideconstructor
 */
IconRegistry.registerProvider(new FragmentLogoIconProvider());

</SCRIPT><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 595.3 841.9">
    <symbol id="text-html" viewBox="0 0 512 512">
        <!-- License: Creative Commons Attribution 3.0: W3C -->
        <path d="M108.4 0h23v22.8h21.2V0h23v69h-23V46h-21v23h-23.2M206 23h-20.3V0h63.7v23H229v46h-23M259.5 0h24.1l14.8 24.3L313.2 0h24.1v69h-23V34.8l-16.1 24.8l-16.1-24.8v34.2h-22.6M348.7 0h23v46.2h32.6V69h-55.6"></path>
        <path fill="#e44d26" d="M107.6 471l-33-370.4h362.8l-33 370.2L255.7 512"></path>
        <path fill="#f16529" d="M256 480.5V131H404.3L376 447"></path>
        <path fill="#ebebeb" d="M142 176.3h114v45.4h-64.2l4.2 46.5h60v45.3H154.4M156.4 336.3H202l3.2 36.3 50.8 13.6v47.4l-93.2-26"></path>
        <path fill="#fff" d="M369.6 176.3H255.8v45.4h109.6M361.3 268.2H255.8v45.4h56l-5.3 59-50.7 13.6v47.2l93-25.8"></path>
    </symbol>
    <symbol id="text-css" viewBox="0 0 362.73 512">
        <!-- License: Creative Commons Attribution 3.0: Rudloff -->
        <g transform="translate(-193.63 -276.36)">
            <g transform="translate(119 276.36)">
                <polygon points="437.37 100.62 404.32 470.82 255.78 512 107.64 470.88 74.633 100.62" fill="#264de4"></polygon>
                <polygon points="376.03 447.25 404.27 130.89 256 130.89 256 480.52" fill="#2965f1"></polygon>
                <g fill="#ebebeb">
                    <polygon points="150.31 268.22 154.38 313.63 256 313.63 256 268.22"></polygon>
                    <polygon points="256 176.3 255.84 176.3 142.13 176.3 146.26 221.72 256 221.72"></polygon>
                    <polygon points="256 433.4 256 386.15 255.8 386.21 205.23 372.55 201.99 336.33 177.42 336.33 156.41 336.33 162.77 407.63 255.79 433.46"></polygon>
                </g>
                <path d="m160 0h55v23h-32v23h32v23h-55z"></path>
                <path d="m226 0h55v20h-32v4h32v46h-55v-21h32v-4h-32z"></path>
                <path d="m292 0h55v20h-32v4h32v46h-55v-21h32v-4h-32z"></path>
                <polygon points="311.76 313.63 306.49 372.52 255.84 386.19 255.84 433.44 348.94 407.63 349.62 399.96 360.29 280.41 361.4 268.22 369.6 176.3 255.84 176.3 255.84 221.72 319.83 221.72 315.7 268.22 255.84 268.22 255.84 313.63" fill="#fff"></polygon>
            </g>
        </g>
    </symbol>
    <symbol id="text-javascript" viewBox="0 0 630 630">
        <!-- License: MIT: Copyright (c) 2011 Christopher Williams -->
        <rect width="630" height="630" fill="#f7df1e"></rect>
        <path d="m423.2 492.19c12.69 20.72 29.2 35.95 58.4 35.95 24.53 0 40.2-12.26 40.2-29.2 0-20.3-16.1-27.49-43.1-39.3l-14.8-6.35c-42.72-18.2-71.1-41-71.1-89.2 0-44.4 33.83-78.2 86.7-78.2 37.64 0 64.7 13.1 84.2 47.4l-46.1 29.6c-10.15-18.2-21.1-25.37-38.1-25.37-17.34 0-28.33 11-28.33 25.37 0 17.76 11 24.95 36.4 35.95l14.8 6.34c50.3 21.57 78.7 43.56 78.7 93 0 53.3-41.87 82.5-98.1 82.5-54.98 0-90.5-26.2-107.88-60.54zm-209.13 5.13c9.3 16.5 17.76 30.45 38.1 30.45 19.45 0 31.72-7.61 31.72-37.2v-201.3h59.2v202.1c0 61.3-35.94 89.2-88.4 89.2-47.4 0-74.85-24.53-88.81-54.075z"></path>
    </symbol>
    <symbol id="text-x-latex" viewBox="0 0 1200 500">
        <path d="M285.7 238h-11.25c-4.5 45.9-10.8 101.7-90 101.7H148c-21.15 0-22.05-3.15-22.05-18V82.75c0-15.3 0-21.6 42.3-21.6h14.85v-13.5C166.9 49 126.4 49 107.95 49 90.4 49 55.3 49 40 47.65v13.5h10.35C85 61.15 85.9 66.1 85.9 82.3v236.25c0 16.2-.9 21.15-35.55 21.15H40v13.95h233.55L285.7 238z"></path>
        <path d="M278.05 47.2c-1.8-5.4-2.7-7.2-8.55-7.2-5.85 0-7.2 1.8-9 7.2l-72.45 183.6c-3.15 7.65-8.55 21.6-36.45 21.6v11.25h69.75V252.4c-13.95 0-22.5-6.3-22.5-15.3 0-2.25.45-3.15 1.35-6.3l15.3-38.7h89.1l18 45.9c.9 1.8 1.8 4.05 1.8 5.4 0 9-17.1 9-25.65 9v11.25h88.65V252.4h-6.3c-21.15 0-23.4-3.15-26.55-12.15L278.05 47.2zm-18 31.95l40.05 101.7H220l40.05-101.7z"></path>
        <path d="M638.5 50.35H364.45l-8.1 100.8h10.8c6.3-72.45 13.05-87.3 81-87.3 8.1 0 19.8 0 24.3.9 9.45 1.8 9.45 6.75 9.45 17.1V318.1c0 15.3 0 21.6-47.25 21.6h-18v13.95c18.45-1.35 63.9-1.35 84.6-1.35 20.7 0 67.05 0 85.5 1.35V339.7h-18c-47.25 0-47.25-6.3-47.25-21.6V81.85c0-9 0-15.3 8.1-17.1 4.95-.9 17.1-.9 25.65-.9 67.5 0 74.25 14.85 80.55 87.3h11.25l-8.55-100.8z"></path>
        <path d="M879.7 339.25h-11.25c-11.25 68.85-21.6 101.7-98.55 101.7h-59.4c-21.15 0-22.05-3.15-22.05-18v-119.7h40.05c43.65 0 48.6 14.4 48.6 52.65h11.25V237.1H777.1c0 38.25-4.95 52.2-48.6 52.2h-40.05V181.75c0-14.85.9-18 22.05-18h57.6c68.85 0 80.55 24.75 87.75 87.3h11.25l-12.6-100.8h-252v13.5h10.35c34.65 0 35.55 4.95 35.55 21.15v234.9c0 16.2-.9 21.15-35.55 21.15H602.5v13.95h258.3l18.9-115.65z"></path>
        <path d="M1015.15 180.4l61.65-90c9.45-14.4 24.75-28.8 64.8-29.25v-13.5h-107.1v13.5c18 .45 27.9 10.35 27.9 20.7 0 4.5-.9 5.4-4.05 10.35l-51.3 75.6-57.6-86.4c-.9-1.35-3.15-4.95-3.15-6.75 0-5.4 9.9-13.05 28.8-13.5v-13.5C959.8 49 926.95 49 909.85 49c-13.95 0-41.85-.45-58.5-1.35v13.5h8.55c24.75 0 33.3 3.15 41.85 15.75l82.35 124.65L910.75 310c-6.3 9-19.8 29.7-64.8 29.7v13.95h107.1V339.7c-20.7-.45-28.35-12.6-28.35-20.7 0-4.05 1.35-5.85 4.5-10.8l63.45-94.05 71.1 107.1c.9 1.8 2.25 3.6 2.25 4.95 0 5.4-9.9 13.05-29.25 13.5v13.95c15.75-1.35 48.6-1.35 65.25-1.35 18.9 0 39.6.45 58.5 1.35V339.7h-8.55c-23.4 0-32.85-2.25-42.3-16.2l-94.5-143.1z"></path>
    </symbol>
    <symbol id="text-x-typescript" viewBox="0 0 400 400">
        <path fill="#007acc" d="M0 200V0h400v400H0"></path>
        <path d="M87.7 200.7V217h52v148h36.9V217h52v-16c0-9 0-16.3-.4-16.5 0-.3-31.7-.4-70.2-.4l-70 .3v16.4l-.3-.1zM321.4 184c10.2 2.4 18 7 25 14.3 3.7 4 9.2 11 9.6 12.8 0 .6-17.3 12.3-27.8 18.8-.4.3-2-1.4-3.6-4-5.2-7.4-10.5-10.6-18.8-11.2-12-.8-20 5.5-20 16 0 3.2.6 5 1.8 7.6 2.7 5.5 7.7 8.8 23.2 15.6 28.6 12.3 41 20.4 48.5 32 8.5 13 10.4 33.4 4.7 48.7-6.4 16.7-22 28-44.3 31.7-7 1.2-23 1-30.5-.3-16-3-31.3-11-40.7-21.3-3.7-4-10.8-14.7-10.4-15.4l3.8-2.4 15-8.7 11.3-6.6 2.6 3.5c3.3 5.2 10.7 12.2 15 14.6 13 6.7 30.4 5.8 39-2 3.7-3.4 5.3-7 5.3-12 0-4.6-.7-6.7-3-10.2-3.2-4.4-9.6-8-27.6-16-20.7-8.8-29.5-14.4-37.7-23-4.7-5.2-9-13.3-11-20-1.5-5.8-2-20-.6-25.7 4.3-20 19.4-34 41-38 7-1.4 23.5-.8 30.4 1l-.2.2z"></path>
    </symbol>
    <symbol id="text-markdown" viewBox="0 0 208 128">
        <!-- License: Creative Commons CC0 1.0 Universal Public Domain Dedication -->
        <rect width="198" height="118" x="5" y="5" ry="10" stroke="currentColor" stroke-width="10" fill="none"></rect>
        <path d="M30 98V30h20l20 25 20-25h20v68H90V59L70 84 50 59v39zm125 0l-30-33h20V30h20v35h20z"></path>
    </symbol>

    <symbol id="text-x-scss" viewBox="0 0 548 548">
        <!-- License: Creative Commons CC0 1.0 Universal Public Domain Dedication, (c) Jonas Oxenbøll Petersen -->
        <g fill="#D465A7">
            <path d="M199 370c-31 0-55 15-51 35 5 21 41 36 84 36 17 0 34-1 48-4 6-35-23-67-81-67zm125-206c-8 12-14 26-15 42-2 20 7 34 19 34 9 0 15-9 17-20s4-35-21-56z"></path>
            <path d="M274 0a274 274 0 1 0 0 548 274 274 0 0 0 0-548zm143 109c-3 11-12 17-21 17-16 0-32 6-47 16a82 82 0 0 1 22 78c-4 24-24 46-47 46-25 0-45-23-43-60 1-17 7-37 16-52l-24-3c-71 0-101 45-97 82 4 38 36 52 86 70 49 17 106 37 92 91-6 23-27 42-60 51a69 69 0 0 1-47 38c-5 0-8-2-8-5 0-2 1-4 5-5 11-3 23-11 30-23a308 308 0 0 1-42 3c-50 0-96-18-103-48-7-28 22-52 68-52 63 0 105 36 101 78 19-7 33-21 36-37 8-37-26-53-80-71-47-15-96-31-105-90-8-54 32-118 126-118 18 0 33 4 46 8 23-21 52-35 84-35 9 0 15 9 12 21z"></path>
        </g>
    </symbol>
    <symbol id="text-p5js" viewBox="0 0 202 202">
        <!-- License: Creative Commons CC0 1.0 Universal Public Domain Dedication, (c) Jonas Oxenbøll Petersen -->
        <g fill="#E83B71">
            <path d="M0 0v202h202V0H0zm66 157c-9 5-26 6-35-6v38H16V98h14v9l1-1c16-17 42-11 49 11 4 16-1 33-14 40zm62 2c-14 5-31 2-39-10l-2-2 11-10c3 7 8 11 16 12 12 0 20-9 18-21-2-9-8-14-17-15l-12 1-12 4 1-48h51v13h-36l-1 18c7 1 14 0 20 2 13 3 20 12 21 25 1 14-6 26-19 31zm56-66-5 4-6-8-6 7-5-4 6-7-9-3 2-7 9 3v-9h6v9l9-2 2 6-8 3 5 8z"></path>
            <path d="M45 109c-10 2-17 13-14 24 2 10 10 16 20 15 9-1 15-9 15-20 0-12-9-21-21-19z"></path>
        </g>
    </symbol>
    <symbol id="image-svg-xml" viewBox="0 0 966 966">
        <!-- License: Creative Commons CC0 1.0 Universal Public Domain Dedication, (c) Jonas Oxenbøll Petersen -->
        <path fill="#000100" d="M825 0H141C63 0 0 63 0 141v684c0 78 63 141 141 141h684c78 0 141-63 141-141V141C966 63 903 0 825 0z"></path>
        <path fill="#FAAE3C" d="M659 217a34 34 0 0 0-48 0h-70l49-49a34 34 0 1 0-34-34l-49 49v-69a34 34 0 1 0-48 0v69l-49-49a34 34 0 1 0-34 34l49 49h-70a34 34 0 1 0 0 49h70l-49 49a34 34 0 1 0 34 34l49-49v69a34 34 0 1 0 48 0v-69l49 49a34 34 0 1 0 34-34l-49-49h70a34 34 0 1 0 48-49z"></path>
        <path fill="#FFF" d="M144 687a125 125 0 0 1 89-213c69 0 125 56 125 125h-74a52 52 0 1 0-88 36c9 10 17 13 37 16 34 3 65 14 88 36a125 125 0 0 1-88 214c-69 0-126-56-126-125h74a52 52 0 1 0 88-37c-9-9-23-12-36-15-34-5-66-14-89-37zm464-213-88 427h-74l-88-427h73l52 250 52-250h73zm125 177h126v125a125 125 0 0 1-251 0V599a125 125 0 0 1 251 0h-74a52 52 0 0 0-103 0v177a52 52 0 0 0 103 0v-52h-52v-73z"></path>
    </symbol>
    <symbol id="text-ruby" viewBox="0 0 384.9 369">
        <!-- License: Creative Commons CC0 1.0 Universal Public Domain Dedication, (c) Jonas Oxenbøll Petersen -->
        <path fill="#D5181D" d="M274 223 106 331l254 35-86-143zM384 63l-23 34-77 116c-1 3-3 4-1 8l74 123 13 19 15-299-1-1zM44 191c1 2 4 2 6 2l71-36c8-5 13-12 20-18l65-60 4-4 23-46-28-10c-1-1-3 0-4 1l-63 36c-10 6-18 15-27 24a3253 3253 0 0 0-53 52l-30 43 16 16zm88-19L96 323l168-108-132-43zm94-84 49 118 94-142-143 24zm-92 74 130 42-49-117-81 75zm-88 59L1 329l86-2-41-106zm42 81 1-1 32-131-69 36 36 96zM352 57l-42-11-59-16c-3-1-5-1-6 2l-21 43-1 2 129-19v-1zm-80-33 112 31-18-53-94 21v1zm34 344-93-13-115-15c-14-2-28-1-43 0a2033 2033 0 0 0-38 2l288 27 1-1zM3 296l37-86c1-3 1-5-2-7l-15-17L0 300h1l2-3zM247 17l63-15 4-1V0l-91 12c9 4 15 7 24 5z"></path>
    </symbol>

    <symbol id="application-x-lua" viewBox="0 0 946.5 946.5">
        <!-- License:
            Copyright © 1998 Lua.org. Graphic design by Alexandre Nakonechnyj.

            Permission is hereby granted, without written agreement and without license or royalty fees, to use, copy, and distribute this logo for any purpose, including commercial applications, subject to the following conditions:

            The origin of this logo must not be misrepresented; you must not claim that you drew the original logo.
            The only modification you can make is to adapt the orbiting text to your product name.
            The logo can be used in any scale as long as the relative proportions of its elements are maintained.
        -->
        <path fill="navy" d="M835 473a362 362 0 1 0-724 1 362 362 0 0 0 724-1"></path>
        <path fill="#fff" d="M729 323a106 106 0 1 0-212 0 106 106 0 0 0 212 0"></path>
        <path fill="navy" d="M941 111a106 106 0 1 0-212 0 106 106 0 0 0 212 0"></path>
        <path fill="#fff" d="M258 628h117v26H228V417h30zm257 26v-24c-16 23-32 32-57 32-33 0-54-18-54-47V484h27v120c0 21 14 34 35 34 28 0 47-23 47-58v-96h27v170zm223 5-18 3c-18 0-27-8-28-25a81 81 0 0 1-58 25c-35 0-56-20-56-51 0-22 10-37 30-45 10-5 16-6 54-11 22-2 29-7 29-19v-7c0-16-14-25-39-25s-37 9-40 30h-27c1-17 4-27 12-35 11-13 32-20 56-20 42 0 65 16 65 46v101c0 8 5 13 14 13l6-1zm-47-89c-10 4-15 5-44 9s-41 14-41 32c0 17 12 27 33 27 16 0 30-5 41-15 8-8 11-13 11-23z"></path>
        <path fill="none" stroke="gray" stroke-dasharray="40.8" stroke-miterlimit="10" stroke-width="10.9" d="M890 261A468 468 0 1 1 709 69"></path>
    </symbol>

    <defs>
        <linearGradient id="application-json-linearGradient8385">
            <stop offset="0"></stop>
            <stop stop-color="#fff" offset="1"></stop>
        </linearGradient>
        <linearGradient id="application-json-linearGradient3002" x1="-553.27" x2="-666.12" y1="525.91" y2="413.05" gradientTransform="matrix(.99884 0 0 .9987 689.01 -388.84)" gradientUnits="userSpaceOnUse" xlink:href="#application-json-linearGradient8385"></linearGradient>
        <linearGradient id="application-json-linearGradient3005" x1="-666.12" x2="-553.27" y1="413.04" y2="525.91" gradientTransform="matrix(.99884 0 0 .9987 689.01 -388.84)" gradientUnits="userSpaceOnUse" xlink:href="#application-json-linearGradient8385"></linearGradient>
    </defs>
    <symbol id="application-json" viewBox="0 0 160 160">
        <!-- License:
            Douglas Crockford
            This logo image consists only of simple geometric shapes or text. It does not meet the threshold of originality needed for copyright protection, and is therefore in the public domain. Although it is free of copyright restrictions, this image may still be subject to other restrictions - Wikimedia Commons
        -->
        <path d="m79.865 119.1c35.398 48.255 70.04-13.469 69.989-50.587-0.0602-43.886-44.541-68.414-70.018-68.414-40.892 0-79.836 33.796-79.836 80.036 0 51.396 44.64 79.865 79.836 79.865-7.9645-1.1468-34.506-6.834-34.863-67.967-0.23987-41.347 13.488-57.866 34.805-50.599 0.47743 0.17707 23.514 9.2645 23.514 38.951 0 29.56-23.427 38.715-23.427 38.715z" color="#000000" fill="url(#application-json-linearGradient3005)" fill-rule="evenodd"></path>
        <path d="m79.823 41.401c-23.39-8.0619-52.043 11.216-52.043 49.829 0 63.048 46.721 68.77 52.384 68.77 40.892 0 79.836-33.796 79.836-80.036 0-51.396-44.64-79.865-79.836-79.865 9.7481-1.35 52.541 10.55 52.541 69.037 0 38.141-31.953 58.905-52.735 50.033-0.47743-0.17707-23.514-9.2645-23.514-38.951 0-29.56 23.367-38.818 23.367-38.818z" color="#000000" fill="url(#application-json-linearGradient3002)" fill-rule="evenodd"></path>
    </symbol>

    <defs>
        <linearGradient id="text-python-b" x1="89.1" x2="147.8" y1="111.9" y2="168.1" gradientUnits="userSpaceOnUse">
            <stop offset="0" stop-color="#ffe052"></stop>
            <stop offset="1" stop-color="#ffc331"></stop>
        </linearGradient>
        <linearGradient id="text-python-a" x1="55.5" x2="110.2" y1="77.1" y2="131.8" gradientUnits="userSpaceOnUse">
            <stop offset="0" stop-color="#387eb8"></stop>
            <stop offset="1" stop-color="#366994"></stop>
        </linearGradient>
    </defs>
    <symbol id="text-python" viewBox="0 0 110.4 109.8">
        <!-- License:
            https://www.python.org/psf/trademarks/
            Use of Python Two-Snakes trademarked logo (version 1.5.0):

            [...] stating accurately that software is written in the Python programming language,
        that it is compatible with the Python programming language, or that it contains the Python
        programming language, is always allowed. In those cases, you may use the word "Python"
        or the unaltered logos to indicate this, without our prior approval. This is true
        both for non-commercial and commercial uses.

        This clause overrides other clauses of this policy

            [...]-->

        <g color="#000">
            <path fill="url(#text-python-a)" d="M100 67c-28 0-27 13-27 13l1 12h26v4H63s-18-2-18 26c0 29 16 28 16 28h9v-14s-1-15 15-15h27s15 0 15-15V82s2-15-27-15zm-15 9a5 5 0 1 1 0 10 5 5 0 0 1 0-10z" transform="translate(-45 -67)"></path>
            <path fill="url(#text-python-b)" d="M101 177c28 0 26-12 26-12v-12h-27v-4h37s18 2 18-26c0-29-15-28-15-28h-10v13s1 16-15 16H88s-14 0-14 14v25s-3 14 27 14zm14-8a5 5 0 1 1 0-10 5 5 0 0 1 0 10z" transform="translate(-45 -67)"></path>
        </g>
</symbol></svg></WPM-PACKAGE><WPM-PACKAGE data-repository="webstrate-components-repos" id="WebstrateIcons" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Webstrates Default Icon Set",
    "description": "Provides Icons for Webstrate features",
    "dependencies": [
        "#wsc-icon-registry"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0 + CC-BY",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="WSIconProvider-script" type="disabled">
/**
 *  WSIconProvider
 *  A provider for webstrates icons
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

window.WSIconProvider = class WSIconProvider {
    constructor(){
        this.supportedTypes = [
            "webstrates:logo",
            "webstrates:wpm-package-open",
            "webstrates:wpm-package-closed",
            "webstrates:cauldron",
            "webstrates:codestrates",
            "webstrates:components",
            "webstrates:varv"
        ];
    }

    provides(iconIdentifier){
        return this.supportedTypes.includes(iconIdentifier);
    }

    createIcon(iconIdentifier) {
            let icon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            let link = document.createElementNS('http://www.w3.org/2000/svg', 'use');
            link.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#'+iconIdentifier.replace(/webstrates:/g, '')+"-icon");
            icon.appendChild(link);
            return icon;
    }
};

IconRegistry.registerProvider(new WSIconProvider());

</SCRIPT><svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 595.3 841.9" enable-background="new 0 0 595.3 841.9" xml:space="preserve">
    <symbol id="logo-icon" viewBox="0 0 265.000000 265.000000" preserveAspectRatio="xMidYMid meet">
        <!-- License:
            Copyright (c) 2020, 2021 Jonas Oxenbøll Petersen, CAVI - Center for Advanced Visualization and Interaction, Aarhus University
            Distributed under Creative Commons Attribution 4.0 (CC-BY-4.0)
        -->
    <g transform="translate(0.000000,265.000000) scale(0.100000,-0.100000)" fill="currentColor" stroke="none">
    <path d="M407 2300 c-119 -42 -177 -101 -177 -180 0 -45 0 -46 120 -153 41
    -38 42 -40 36 -87 -10 -75 -69 -251 -186 -555 -173 -449 -173 -450 -178 -593
    -5 -145 8 -190 70 -258 53 -57 108 -77 196 -72 126 7 265 94 471 293 63 60
    147 150 187 198 l74 88 0 -83 c1 -157 49 -304 129 -390 129 -140 376 -156 607
    -40 336 170 658 570 798 992 58 174 68 246 64 442 -3 165 -4 176 -31 233 -62
    132 -123 176 -252 183 -130 7 -231 -31 -282 -107 -29 -43 -31 -108 -4 -142 57
    -73 87 -169 101 -318 16 -172 -18 -337 -110 -528 -94 -197 -228 -355 -354
    -414 -152 -72 -228 -10 -228 186 0 179 53 341 234 719 95 196 111 237 115 290
    4 52 2 66 -19 95 -12 19 -40 43 -60 53 -48 25 -166 34 -240 19 -100 -21 -111
    -34 -233 -269 -137 -264 -256 -458 -399 -649 -104 -139 -338 -395 -350 -382
    -8 8 69 222 182 505 218 547 249 723 145 843 -18 22 -59 52 -91 67 -49 24 -72
    28 -167 31 -92 3 -120 0 -168 -17z m317 -60 c27 -14 63 -42 80 -64 31 -37 31
    -40 30 -144 -1 -136 -23 -208 -186 -622 -140 -354 -201 -530 -196 -568 2 -22
    9 -28 35 -30 27 -3 43 8 128 90 250 239 482 577 732 1068 70 138 87 151 204
    158 96 6 162 -11 190 -47 39 -49 25 -102 -98 -357 -182 -377 -228 -523 -228
    -724 0 -115 2 -130 26 -175 14 -28 41 -61 60 -73 29 -21 43 -23 95 -19 232 18
    509 376 588 761 22 103 20 269 -3 381 -17 84 -67 205 -91 220 -5 3 -10 21 -10
    40 0 45 37 87 101 115 44 18 66 21 140 18 78 -3 92 -6 131 -33 53 -38 103
    -126 117 -211 89 -510 -334 -1265 -852 -1520 -110 -53 -176 -67 -291 -62 -145
    8 -239 64 -295 177 -43 86 -52 120 -64 268 l-12 138 -30 3 c-27 2 -38 -7 -99
    -83 -86 -105 -288 -304 -381 -374 -192 -145 -329 -163 -422 -57 -80 90 -83
    228 -9 441 24 72 81 225 126 340 101 258 165 446 185 542 21 102 10 129 -81
    203 -53 42 -64 56 -64 81 0 42 15 65 59 93 71 45 118 56 231 53 90 -2 113 -6
    154 -27z"></path>
    </g>
    </symbol>
    <symbol id="wpm-package-open-icon" viewBox="0 0 195 195" enable-background="new 0 0 195 195" xml:space="preserve">
        <!-- License:
            Copyright (c) 2020, 2021 Jonas Oxenbøll Petersen, CAVI - Center for Advanced Visualization and Interaction, Aarhus University
            Distributed under Creative Commons Attribution 4.0 (CC-BY-4.0)
        -->

            <g>
                <polygon fill="#8C6239" points="35.9,45.1 83.6,72.2 86.5,163.7 42,121.1 	"></polygon>
                <polygon fill="#C69C6D" points="163.2,51.3 155.1,132.7 86.5,163.7 83.6,72.2 	"></polygon>
                <g id="izg6T3.tif_6_">
                        <g>
                                <path fill="#298158" d="M129.2,125.9c-1.2,0.2-2.5,0.6-3.7,0.6c-2.5,0.1-4-1.4-5-3.6c-0.7-1.6-1.1-3.5-1.7-5.5
                                        c-0.8,1.8-1.6,3.5-2.4,5.2c-2.3,4.8-4.8,9.4-8.1,13.6c-3.5,4.2-7.4,5.2-9.6,2.2c-1-1.4-1.7-3.5-1.7-5.6c0.2-5.4,1-11,1.5-16.8
                                        c0.4-4.2,0.6-8.6,0.8-13c0.1-1.7-0.7-2.5-2.1-2.8c-0.3-0.1-0.6-0.2-1-0.3c-3.3-0.8-3.8-2.7-1.7-6.4c2.9-5,11.6-8.8,14.8-5.1
                                        c1.8,2,2,4.9,1.7,7.6c-0.7,7.4-1.8,14.6-2.6,21.5c-0.4,2.9-0.6,5.7-1,8.5c0.2,0,0.4,0,0.5,0c0.9-1.7,1.9-3.3,2.7-5.1
                                        c4.6-9.8,7.8-20.1,10.2-31.2c0.3-1.2,0.4-2.6,0.9-3.7c0.6-1.3,1.3-3,2.2-3.7c1.8-1.3,3.9-2.6,5.8-2.9c2.6-0.5,3.6,1.7,2.8,5
                                        c-1,4.5-2.2,9-3.1,13.3c-1.2,5.5-2.2,10.9-1.2,15.5c0.2,0.8,0.6,1.5,1,2c0.7,1,1.7,0.8,2.9-0.3c2.6-2.3,4.2-5.3,5.6-8.5
                                        c2.7-6.6,4.2-13.3,3.5-19.9c-0.3-3.3-1-6.5-3-8.8c-1.5-1.7-0.3-5.7,2.4-7.9c4.9-4.1,8-3.2,9.7,2.4c1.3,5.6,0.4,10.2,0.4,10.7
                                        c-0.7,6.9-2.5,13.5-5.2,20c-2.5,6-5.3,11.6-9.4,16.4c-1.6,1.9-3.4,3.5-5.2,5.3C130.6,125.1,129.9,125.5,129.2,125.9z M150.5,76.9
                                        c-0.2-1-0.4-2.7-0.9-4.4c-1.2-4.6-5.2-5.1-8.8-1.1c-1.9,2.2-2.3,4.3-1,5.9c1.7,2.1,2.3,4.9,2.7,7.9c0.6,4.5,0.1,9.1-1.1,13.8
                                        c-1.4,5.5-3.3,10.8-7,15.2c-2.5,3-4.7,3.7-6.1,0.9c-0.5-1-0.8-2.2-0.9-3.5c-0.2-4.3,0.4-9,1.5-13.7c0.9-4.4,2.1-8.8,3.2-13.4
                                        c0.6-2.7,0-4.2-2-4c-1.5,0.2-3.1,1.1-4.6,2c-1.4,0.9-2.1,2.6-2.5,4.4c-1.6,6.2-3.1,12.3-5,18.2c-1.5,4.7-3.3,9.3-5.1,13.8
                                        c-1.1,2.6-2.5,5.1-3.9,7.5c-0.3,0.5-1,0.8-1.5,1.2c-0.1-0.5-0.5-0.9-0.4-1.5c0.8-6.7,1.7-13.7,2.4-20.9c0.4-4.2,0.6-8.5,0.7-12.8
                                        c0-2.1-1-3.7-2.9-4.1c-3.5-0.8-6.8,0.9-9.9,3.7c-1.3,1.2-2.5,2.7-2.3,4.6c0.1,1.9,1.9,2,3.2,2.3c1.9,0.4,2.7,1.7,2.7,3.8
                                        c0,1.8,0,3.6-0.2,5.3c-0.6,6.1-1.3,12-2,17.7c-0.4,3.9-0.8,7.7,0.5,10.9c1,2.5,4.6,3.2,7.2,0.6c3.8-3.8,6-8.4,8.5-13
                                        c1.2-2.3,2.1-4.7,3.2-7.1c0.2-0.5,0.8-1.1,1.2-1.2c0.3-0.1,0.7,0.5,0.8,0.9c0.4,1.3,0.6,2.7,1,4c1.9,5.9,6,6,11.3,1.8
                                        c3.4-2.6,5.9-6.4,8.2-10.4c2.8-4.8,5-9.9,6.8-15.3C149.3,90.8,150.5,84.3,150.5,76.9z"></path>
                                <path fill="#31A36E" d="M150.5,76.9c0.1,7.4-1.2,13.8-3.2,20.2c-1.7,5.4-4,10.5-6.8,15.3c-2.3,4-4.9,7.8-8.2,10.4
                                        c-5.3,4.1-9.4,4-11.3-1.8c-0.4-1.3-0.6-2.7-1-4c-0.1-0.4-0.5-0.9-0.8-0.9c-0.4,0.1-0.9,0.7-1.2,1.2c-1.1,2.4-2,4.8-3.2,7.1
                                        c-2.5,4.6-4.7,9.2-8.5,13c-2.6,2.6-6.2,1.9-7.2-0.6c-1.2-3.2-0.9-7-0.5-10.9c0.6-5.7,1.3-11.6,2-17.7c0.2-1.8,0.2-3.6,0.2-5.3
                                        c0-2-0.8-3.4-2.7-3.8c-1.3-0.3-3-0.3-3.2-2.3c-0.1-1.8,1-3.4,2.3-4.6c3.1-2.8,6.4-4.5,9.9-3.7c1.9,0.4,3,2,2.9,4.1
                                        c0,4.3-0.3,8.6-0.7,12.8c-0.7,7.2-1.7,14.2-2.4,20.9c-0.1,0.5,0.3,1,0.4,1.5c0.5-0.4,1.2-0.7,1.5-1.2c1.4-2.5,2.9-4.9,3.9-7.5
                                        c1.9-4.5,3.7-9.1,5.1-13.8c1.8-5.9,3.3-11.9,5-18.2c0.5-1.8,1.1-3.6,2.5-4.4c1.5-0.9,3.1-1.9,4.6-2c2.1-0.3,2.7,1.3,2,4
                                        c-1.1,4.6-2.2,9-3.2,13.4c-1,4.8-1.7,9.4-1.5,13.7c0.1,1.3,0.4,2.5,0.9,3.5c1.5,2.8,3.6,2.1,6.1-0.9c3.8-4.4,5.6-9.7,7-15.2
                                        c1.2-4.7,1.7-9.3,1.1-13.8c-0.4-3-1-5.8-2.7-7.9c-1.3-1.6-0.9-3.8,1-5.9c3.6-4,7.6-3.5,8.8,1.1C150,74.2,150.3,76,150.5,76.9z"></path>
                        </g>
                </g>
                <polygon fill="#754C24" points="105.9,31.3 107.3,66 83.6,72.2 35.9,45.1 	"></polygon>
                <polygon fill="#603813" points="163.2,51.3 107.3,66 105.9,31.3 	"></polygon>
                <polygon fill="#A67C52" points="35.9,45.1 83.6,72.2 42.3,103.8 0.9,67.4 	"></polygon>
                <polygon fill="#A67C52" points="105.9,31.3 35.9,45.1 17.2,25.2 86.5,16.5 	"></polygon>
                <polygon fill="#A67C52" points="163.2,51.3 105.9,31.3 130.3,8.9 190.1,21.8 	"></polygon>
                <polygon fill="#A67C52" points="83.6,72.2 163.2,51.3 193.2,81.2 111.8,112.5 	"></polygon>
            </g>
    </symbol>
    <symbol id="wpm-package-closed-icon" viewBox="0 0 195 195" enable-background="new 0 0 195 195" xml:space="preserve">
        <!-- License:
            Copyright (c) 2020, 2021 Jonas Oxenbøll Petersen, CAVI - Center for Advanced Visualization and Interaction, Aarhus University
            Distributed under Creative Commons Attribution 4.0 (CC-BY-4.0)
        -->
        <g>
                <polygon fill="#8C6239" points="35.8,45.1 83.5,72.2 86.5,163.7 41.9,121.1 	"></polygon>
                <polygon fill="#C69C6D" points="163.2,51.3 155,132.7 86.5,163.7 83.5,72.2 	"></polygon>
                <polygon fill="#A67C52" points="104.9,31.3 163.2,51.3 83.5,72.2 35.8,45.1 	"></polygon>
                <g id="izg6T3.tif_3_">
                        <g>
                                <path fill="#298158" d="M129.1,125.9c-1.2,0.2-2.5,0.6-3.7,0.6c-2.5,0.1-4-1.4-5-3.6c-0.7-1.6-1.1-3.5-1.7-5.5
                                        c-0.8,1.8-1.6,3.5-2.4,5.2c-2.3,4.8-4.8,9.4-8.1,13.6c-3.5,4.2-7.4,5.2-9.6,2.2c-1-1.4-1.7-3.5-1.7-5.6c0.2-5.4,1-11,1.5-16.8
                                        c0.4-4.2,0.6-8.6,0.8-13c0.1-1.7-0.7-2.5-2.1-2.8c-0.3-0.1-0.6-0.2-1-0.3c-3.3-0.8-3.8-2.7-1.7-6.4c2.9-5,11.6-8.8,14.8-5.1
                                        c1.8,2,2,4.9,1.7,7.6c-0.7,7.4-1.8,14.6-2.6,21.5c-0.4,2.9-0.6,5.7-1,8.5c0.2,0,0.4,0,0.5,0c0.9-1.7,1.9-3.3,2.7-5.1
                                        c4.6-9.8,7.8-20.1,10.2-31.2c0.3-1.2,0.4-2.6,0.9-3.7c0.6-1.3,1.3-3,2.2-3.7c1.8-1.3,3.9-2.6,5.8-2.9c2.6-0.5,3.6,1.7,2.8,5
                                        c-1,4.5-2.2,9-3.1,13.3c-1.2,5.5-2.2,10.9-1.2,15.5c0.2,0.8,0.6,1.5,1,2c0.7,1,1.7,0.8,2.9-0.3c2.6-2.3,4.2-5.3,5.6-8.5
                                        c2.7-6.6,4.2-13.3,3.5-19.9c-0.3-3.3-1-6.5-3-8.8c-1.5-1.7-0.3-5.7,2.4-7.9c4.9-4.1,8-3.2,9.7,2.4c1.3,5.6,0.4,10.2,0.4,10.7
                                        c-0.7,6.9-2.5,13.5-5.2,20c-2.5,6-5.3,11.6-9.4,16.4c-1.6,1.9-3.4,3.5-5.2,5.3C130.5,125.1,129.8,125.5,129.1,125.9z M150.4,76.9
                                        c-0.2-1-0.4-2.7-0.9-4.4c-1.2-4.6-5.2-5.1-8.8-1.1c-1.9,2.2-2.3,4.3-1,5.9c1.7,2.1,2.3,4.9,2.7,7.9c0.6,4.5,0.1,9.1-1.1,13.8
                                        c-1.4,5.5-3.3,10.8-7,15.2c-2.5,3-4.7,3.7-6.1,0.9c-0.5-1-0.8-2.2-0.9-3.5c-0.2-4.3,0.4-9,1.5-13.7c0.9-4.4,2.1-8.8,3.2-13.4
                                        c0.6-2.7,0-4.2-2-4c-1.5,0.2-3.1,1.1-4.6,2c-1.4,0.9-2.1,2.6-2.5,4.4c-1.6,6.2-3.1,12.3-5,18.2c-1.5,4.7-3.3,9.3-5.1,13.8
                                        c-1.1,2.6-2.5,5.1-3.9,7.5c-0.3,0.5-1,0.8-1.5,1.2c-0.1-0.5-0.5-0.9-0.4-1.5c0.8-6.7,1.7-13.7,2.4-20.9c0.4-4.2,0.6-8.5,0.7-12.8
                                        c0-2.1-1-3.7-2.9-4.1c-3.5-0.8-6.8,0.9-9.9,3.7c-1.3,1.2-2.5,2.7-2.3,4.6c0.1,1.9,1.9,2,3.2,2.3c1.9,0.4,2.7,1.7,2.7,3.8
                                        c0,1.8,0,3.6-0.2,5.3c-0.6,6.1-1.3,12-2,17.7c-0.4,3.9-0.8,7.7,0.5,10.9c1,2.5,4.6,3.2,7.2,0.6c3.8-3.8,6-8.4,8.5-13
                                        c1.2-2.3,2.1-4.7,3.2-7.1c0.2-0.5,0.8-1.1,1.2-1.2c0.3-0.1,0.7,0.5,0.8,0.9c0.4,1.3,0.6,2.7,1,4c1.9,5.9,6,6,11.3,1.8
                                        c3.4-2.6,5.9-6.4,8.2-10.4c2.8-4.8,5-9.9,6.8-15.3C149.2,90.8,150.4,84.3,150.4,76.9z"></path>
                                <path fill="#31A36E" d="M150.4,76.9c0.1,7.4-1.2,13.8-3.2,20.2c-1.7,5.4-4,10.5-6.8,15.3c-2.3,4-4.9,7.8-8.2,10.4
                                        c-5.3,4.1-9.4,4-11.3-1.8c-0.4-1.3-0.6-2.7-1-4c-0.1-0.4-0.5-0.9-0.8-0.9c-0.4,0.1-0.9,0.7-1.2,1.2c-1.1,2.4-2,4.8-3.2,7.1
                                        c-2.5,4.6-4.7,9.2-8.5,13c-2.6,2.6-6.2,1.9-7.2-0.6c-1.2-3.2-0.9-7-0.5-10.9c0.6-5.7,1.3-11.6,2-17.7c0.2-1.8,0.2-3.6,0.2-5.3
                                        c0-2-0.8-3.4-2.7-3.8c-1.3-0.3-3-0.3-3.2-2.3c-0.1-1.8,1-3.4,2.3-4.6c3.1-2.8,6.4-4.5,9.9-3.7c1.9,0.4,3,2,2.9,4.1
                                        c0,4.3-0.3,8.6-0.7,12.8c-0.7,7.2-1.7,14.2-2.4,20.9c-0.1,0.5,0.3,1,0.4,1.5c0.5-0.4,1.2-0.7,1.5-1.2c1.4-2.5,2.9-4.9,3.9-7.5
                                        c1.9-4.5,3.7-9.1,5.1-13.8c1.8-5.9,3.3-11.9,5-18.2c0.5-1.8,1.1-3.6,2.5-4.4c1.5-0.9,3.1-1.9,4.6-2c2.1-0.3,2.7,1.3,2,4
                                        c-1.1,4.6-2.2,9-3.2,13.4c-1,4.8-1.7,9.4-1.5,13.7c0.1,1.3,0.4,2.5,0.9,3.5c1.5,2.8,3.6,2.1,6.1-0.9c3.8-4.4,5.6-9.7,7-15.2
                                        c1.2-4.7,1.7-9.3,1.1-13.8c-0.4-3-1-5.8-2.7-7.9c-1.3-1.6-0.9-3.8,1-5.9c3.6-4,7.6-3.5,8.8,1.1C149.9,74.2,150.2,76,150.4,76.9z"></path>
                        </g>
                </g>
        </g>
    </symbol>
    <symbol id="cauldron-icon" viewBox="0 0 121.1 121.1" enable-background="new 0 0 121.1 121.1" xml:space="preserve">
        <!-- License:
            Copyright (c) 2020, 2021 Jonas Oxenbøll Petersen, CAVI - Center for Advanced Visualization and Interaction, Aarhus University
            Distributed under Creative Commons Attribution 4.0 (CC-BY-4.0)
        -->
        <path fill="none" stroke="currentColor" stroke-width="12" stroke-miterlimit="10" d="M102.4,36.5v60.9c0,9.7-9.1,17.6-20.3,17.6H39.8
                c-11.2,0-20.3-7.9-20.3-17.6V36.5"></path>
        <path d="M83.6,29.9c-2.2,4.4-5.1,7.5-8.6,10.1c-3,2.2-6.2,4-9.8,5.1c-2.9,1-6,1.6-9,0.9c-4.7-1.2-6.9-4.2-5.4-9.2
                c0.3-1,0.8-2.1,1.1-3.1c0.1-0.3,0.1-0.9-0.1-1c-0.2-0.2-0.8-0.2-1.1-0.1c-1.5,0.7-3,1.6-4.6,2.1c-3.2,1.1-6.4,2.4-9.9,2.2
                c-2.4-0.2-3.8-3-3-5.1c0.9-2.6,2.8-4.5,4.7-6.4c2.7-2.7,5.4-5.3,8.1-8c0.8-0.8,1.5-1.6,2.1-2.5c0.8-1,0.9-2,0.2-3.2
                c-0.5-0.8-1.2-1.7-0.6-2.6c0.6-0.9,1.7-1,2.7-0.9c2.4,0.2,4.5,1.1,5.8,3.2c0.7,1.2,0.7,2.4,0,3.4c-1.6,2.1-3.2,4.1-5,6
                c-3.2,3.4-6.5,6.6-9.7,9.9c-0.3,0.3-0.3,0.7-0.5,1.1c0.4,0.1,0.9,0.4,1.2,0.3c1.7-0.5,3.5-1,5.1-1.8c2.8-1.4,5.5-2.9,8.1-4.6
                c3.1-2.1,6.1-4.4,9.1-6.7c0.9-0.7,1.8-1.2,2.8-0.8c1.1,0.4,2.3,0.8,3.1,1.5c1.2,1,1.1,2.2-0.2,3.2c-2.1,1.8-4.3,3.5-6.4,5.4
                c-2.3,2.1-4.4,4.4-6,7.1c-0.5,0.8-0.8,1.8-0.9,2.8c-0.3,2.8,1.2,3.9,3.8,3.7c3.9-0.2,7-2.3,9.9-4.7c2.4-2,4.2-4.5,5.3-7.5
                c0.7-1.9,1.3-3.9,0.9-6c-0.3-1.6,0.6-2.5,2.4-2.6c3.3-0.1,5.5,2.5,5,5.8C84.1,28.1,83.8,29.2,83.6,29.9z"></path>
        <path d="M53.1,64.3c0.4,1.5,0.3,2.9,0.1,4.2c-0.3,1.2-0.7,2.3-1.3,3.3c-0.5,0.9-1.1,1.7-2,2.1c-1.4,0.7-2.6,0.4-3.3-1.1
                c-0.1-0.3-0.2-0.7-0.4-1c0-0.1-0.2-0.2-0.2-0.2c-0.1,0-0.2,0.1-0.3,0.2c-0.2,0.5-0.4,1-0.7,1.5c-0.5,0.9-1,1.9-1.9,2.6
                c-0.6,0.5-1.5,0.1-1.8-0.6c-0.3-0.8-0.3-1.7-0.2-2.5c0.1-1.2,0.2-2.4,0.3-3.7c0-0.3,0-0.7,0-1.1c0-0.4-0.2-0.7-0.6-0.8
                c-0.3-0.1-0.6-0.1-0.7-0.5c0-0.3,0.2-0.6,0.5-0.8c0.6-0.4,1.3-0.7,2.1-0.4c0.4,0.1,0.7,0.4,0.7,0.8c0.1,0.8,0.1,1.7,0,2.5
                c-0.1,1.5-0.2,3-0.2,4.4c0,0.1,0.1,0.2,0.1,0.4c0.1-0.1,0.3-0.1,0.4-0.2c0.3-0.5,0.6-1,0.8-1.5c0.4-0.9,0.7-1.9,1-2.8
                c0.3-1.2,0.5-2.3,0.8-3.5c0.1-0.3,0.2-0.7,0.5-0.8c0.3-0.1,0.7-0.3,1.1-0.3c0.5,0,0.7,0.3,0.6,0.8c-0.1,0.9-0.3,1.8-0.4,2.6
                c-0.1,1-0.1,2,0,3c0.1,0.3,0.2,0.6,0.4,0.9c0.5,0.7,1.1,0.7,1.7,0.1c0.9-0.9,1.2-2,1.4-3.2c0.1-1,0.1-2-0.3-2.9
                c-0.2-0.6-0.5-1.2-1-1.6c-0.4-0.3-0.4-0.7,0-1.1c0.8-0.7,1.9-0.6,2.4,0.3C52.9,63.8,53,64.1,53.1,64.3z"></path>
        <path d="M46.9,88.1c0.1,1.6-0.1,2.9-0.6,4.2c-0.4,1.1-1,2.1-1.8,3.1c-0.6,0.8-1.4,1.5-2.3,1.8c-1.5,0.5-2.6,0-3.1-1.6
                c-0.1-0.3-0.1-0.7-0.2-1c0-0.1-0.1-0.3-0.2-0.3c-0.1,0-0.2,0.1-0.3,0.2c-0.3,0.4-0.5,0.9-0.9,1.4c-0.7,0.9-1.3,1.7-2.3,2.3
                c-0.7,0.4-1.5-0.2-1.7-0.9c-0.2-0.9,0-1.7,0.2-2.5c0.3-1.2,0.6-2.4,0.8-3.6c0.1-0.3,0.1-0.7,0.1-1c0-0.4-0.1-0.7-0.5-0.9
                c-0.3-0.1-0.6-0.2-0.6-0.6c0-0.3,0.3-0.6,0.6-0.7c0.7-0.3,1.4-0.5,2.1-0.1c0.4,0.2,0.6,0.5,0.6,0.9c-0.1,0.8-0.2,1.7-0.3,2.5
                c-0.3,1.5-0.6,2.9-0.9,4.3c0,0.1,0,0.3,0.1,0.4c0.1,0,0.3,0,0.4-0.1c0.4-0.4,0.8-0.9,1.1-1.4c0.5-0.8,1-1.7,1.4-2.6
                c0.5-1.1,0.9-2.2,1.3-3.4c0.1-0.3,0.3-0.6,0.6-0.7c0.4-0.1,0.7-0.2,1.1-0.1c0.5,0.1,0.7,0.4,0.5,0.9c-0.3,0.9-0.6,1.7-0.8,2.6
                C41,92,40.8,93,40.9,94c0,0.3,0.1,0.6,0.2,0.9c0.4,0.8,1,0.8,1.7,0.4c1-0.7,1.5-1.8,1.9-3c0.3-1,0.4-1.9,0.2-2.9
                c-0.1-0.6-0.3-1.3-0.8-1.8c-0.4-0.4-0.3-0.8,0.2-1.1c0.9-0.6,1.9-0.3,2.3,0.7C46.7,87.6,46.8,87.9,46.9,88.1z"></path>
        <path d="M67.2,84.2c-0.2,1.6-0.7,2.8-1.4,4c-0.6,1-1.4,1.9-2.4,2.6c-0.8,0.6-1.6,1.2-2.6,1.3c-1.6,0.2-2.6-0.5-2.7-2.2
                c0-0.4,0-0.7,0-1.1c0-0.1-0.1-0.3-0.1-0.3c-0.1,0-0.3,0-0.3,0.1c-0.4,0.4-0.7,0.8-1.1,1.2c-0.8,0.7-1.6,1.4-2.7,1.8
                c-0.7,0.2-1.5-0.5-1.5-1.2c0-0.9,0.3-1.7,0.7-2.4c0.5-1.1,1-2.2,1.5-3.3c0.1-0.3,0.3-0.7,0.4-1c0.1-0.4,0-0.7-0.3-1
                c-0.2-0.2-0.6-0.4-0.5-0.7c0.1-0.3,0.4-0.5,0.7-0.6c0.7-0.2,1.5-0.2,2.1,0.3c0.4,0.3,0.5,0.6,0.4,1c-0.2,0.8-0.5,1.6-0.8,2.4
                c-0.6,1.4-1.2,2.7-1.8,4.1c0,0.1,0,0.3,0,0.4c0.1,0,0.3,0,0.4-0.1c0.5-0.4,0.9-0.7,1.3-1.1c0.7-0.7,1.3-1.5,1.9-2.3c0.7-1,1.3-2,2-3
                c0.2-0.3,0.4-0.6,0.7-0.6c0.4,0,0.8,0,1.1,0.1c0.5,0.2,0.6,0.5,0.3,1c-0.4,0.8-0.9,1.5-1.3,2.3c-0.5,0.9-0.8,1.8-1,2.8
                c0,0.3,0,0.6,0,0.9c0.2,0.9,0.8,1,1.6,0.7c1.2-0.5,1.8-1.5,2.4-2.5c0.5-0.9,0.8-1.8,0.8-2.8c0-0.7-0.1-1.3-0.4-1.9
                c-0.3-0.5-0.1-0.8,0.4-1c1-0.4,2,0.1,2.1,1.2C67.2,83.6,67.2,84,67.2,84.2z"></path>
        <path d="M84.3,82.9c0.8,1.3,1.2,2.6,1.4,4c0.1,1.2,0.1,2.4-0.2,3.5c-0.2,1-0.5,1.9-1.3,2.6c-1.1,1.1-2.3,1.2-3.4,0
                c-0.2-0.3-0.4-0.6-0.7-0.8c-0.1-0.1-0.2-0.2-0.3-0.2c-0.1,0-0.2,0.2-0.2,0.3c-0.1,0.5-0.1,1.1-0.2,1.6c-0.2,1.1-0.4,2.2-1,3.1
                c-0.4,0.6-1.4,0.5-1.9,0c-0.6-0.7-0.8-1.5-1-2.3c-0.3-1.2-0.6-2.4-0.9-3.6c-0.1-0.3-0.2-0.7-0.3-1c-0.1-0.4-0.4-0.6-0.8-0.6
                c-0.3,0-0.7,0.1-0.8-0.3c-0.1-0.3,0-0.6,0.2-0.9c0.5-0.6,1-1,1.8-1.1c0.4,0,0.8,0.2,0.9,0.6c0.3,0.8,0.6,1.6,0.8,2.4
                c0.4,1.4,0.8,2.9,1.1,4.3c0,0.1,0.2,0.2,0.2,0.3c0.1-0.1,0.3-0.2,0.3-0.3c0.1-0.6,0.3-1.1,0.3-1.7c0.1-1,0.1-2,0.1-3
                c-0.1-1.2-0.2-2.4-0.3-3.6c0-0.3,0-0.7,0.2-0.9c0.3-0.2,0.6-0.5,0.9-0.6c0.5-0.2,0.8,0.1,0.9,0.6c0.1,0.9,0.3,1.8,0.4,2.6
                c0.2,1,0.5,1.9,1,2.8c0.1,0.3,0.4,0.5,0.6,0.7c0.7,0.5,1.3,0.3,1.7-0.4c0.6-1.1,0.5-2.3,0.3-3.5c-0.2-1-0.5-1.9-1.2-2.7
                c-0.4-0.5-0.8-1-1.5-1.2c-0.5-0.2-0.6-0.6-0.3-1.1c0.5-0.9,1.6-1.1,2.4-0.4C83.9,82.5,84.2,82.7,84.3,82.9z"></path>
        <path d="M80.8,69.5c-0.4,1.5-1.2,2.7-2.1,3.7c-0.8,0.9-1.7,1.6-2.8,2.2c-0.9,0.5-1.8,0.9-2.8,0.8c-1.6-0.1-2.4-0.9-2.3-2.6
                c0-0.3,0.1-0.7,0.2-1c0-0.1,0-0.3-0.1-0.3c-0.1,0-0.3,0-0.3,0c-0.4,0.3-0.9,0.7-1.3,0.9c-0.9,0.5-1.9,1.1-3,1.3
                c-0.8,0.1-1.4-0.7-1.3-1.4c0.1-0.9,0.6-1.6,1.1-2.3c0.7-1,1.4-2,2.1-3c0.2-0.3,0.4-0.6,0.5-0.9c0.2-0.4,0.2-0.7-0.1-1
                c-0.2-0.2-0.5-0.4-0.3-0.8c0.1-0.3,0.5-0.4,0.8-0.4c0.8-0.1,1.5,0.1,2,0.7c0.3,0.3,0.4,0.7,0.2,1.1c-0.4,0.7-0.8,1.5-1.2,2.2
                c-0.8,1.2-1.6,2.5-2.5,3.7c-0.1,0.1-0.1,0.2-0.1,0.4c0.1,0,0.3,0.1,0.4,0c0.5-0.3,1-0.5,1.5-0.9c0.8-0.6,1.6-1.2,2.3-1.9
                c0.9-0.8,1.7-1.8,2.5-2.6c0.2-0.3,0.5-0.5,0.8-0.4c0.4,0,0.8,0.1,1.1,0.3c0.4,0.3,0.5,0.6,0.1,1c-0.6,0.7-1.1,1.4-1.7,2.1
                c-0.6,0.8-1.1,1.6-1.5,2.6c-0.1,0.3-0.1,0.6-0.1,0.9c0.1,0.9,0.6,1.1,1.4,0.9c1.2-0.3,2.1-1.1,2.8-2.1c0.6-0.8,1.1-1.7,1.2-2.7
                c0.1-0.6,0.2-1.3-0.1-1.9c-0.2-0.5,0-0.8,0.6-0.9c1-0.2,1.9,0.5,1.9,1.5C80.8,68.9,80.8,69.3,80.8,69.5z"></path>
        <path fill="none" stroke="currentColor" stroke-width="2" stroke-miterlimit="10" d="M24,55.9c0,0,9.5-4,16-4s12.7,4,20.9,4
                S75.5,52,82.1,52s16,3.9,16,3.9"></path>
        <path fill="none" stroke="currentColor" stroke-width="2" stroke-miterlimit="10" d="M32.2,25.1C24,15.3,12.7,14.7,12.7,14.7"></path>
        <path fill="none" stroke="currentColor" stroke-width="2" stroke-miterlimit="10" d="M36.2,19.1C24.5,7.8,12.7,7.8,12.7,7.8"></path>
        <path fill="none" stroke="currentColor" stroke-width="2" stroke-miterlimit="10" d="M40.2,13.1C28.8,1,12.7,1,12.7,1"></path>
    </symbol>
    <symbol id="varv-icon" viewBox="0 0 567 567">
        <!-- License:
            Copyright (c) 2022 Jonas Oxenbøll Petersen, CAVI - Center for Advanced Visualization and Interaction, Aarhus University
            Distributed under Creative Commons Attribution 4.0 (CC-BY-4.0)
        -->
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="50" d="M39 56h503M6 147h503M95 238h472M26 329h416M1 420h503M39 511h485"></path>
    </symbol>
    <symbol id="codestrates-icon" viewBox="0 0 567 567">
        <!-- License:
            Copyright (c) 2022 Jonas Oxenbøll Petersen, CAVI - Center for Advanced Visualization and Interaction, Aarhus University
            Distributed under Creative Commons Attribution 4.0 (CC-BY-4.0)
        -->
        <ellipse cx="283.5" cy="250.8" fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="20" rx="270.1" ry="86.3"></ellipse><ellipse cx="283.5" cy="316.2" fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="20" rx="270.1" ry="86.3"></ellipse><path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="20" d="M13 251v65M554 251v65"></path><path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="9" d="m262 308-25-25 25-25M305 258l26 25-26 25M291 249l-15 69"></path>
    </symbol>
    <symbol id="components-icon" viewBox="0 0 567 567">
        <!-- License:
            Copyright (c) 2022 Jonas Oxenbøll Petersen, CAVI - Center for Advanced Visualization and Interaction, Aarhus University
            Distributed under Creative Commons Attribution 4.0 (CC-BY-4.0)
        -->
        <path fill="currentColor" d="M335 410c-1 13-4 23-9 33-5 8-11 16-18 23-6 5-12 10-20 11-13 3-21-2-23-16l-1-8-1-3-3 1-8 10c-6 6-13 13-21 16-6 2-12-3-13-9 0-7 2-13 4-20l11-27 2-9c1-3 0-5-3-7-2-2-4-3-4-6 1-3 3-4 6-5 5-2 11-2 17 2 3 2 4 5 3 8l-5 19-12 34v3l3-1 10-9 14-20 14-25c2-3 3-5 6-5h9c4 1 5 4 3 8l-9 19c-3 8-6 15-7 23l1 8c2 7 7 8 13 5 9-5 14-13 18-22 4-8 5-15 5-23-1-6-1-11-4-16-3-3-2-6 3-8 7-4 15 0 17 8l2 8z"></path><path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="20" d="M13 364h541v144H13zM80 326h100v38H80zM385 326h100v38H385z"></path><path fill="currentColor" d="M335 144c-1 13-4 24-9 33s-11 16-18 23c-6 5-12 10-20 12-13 2-21-3-23-16l-1-9-1-2c-1-1-2 0-3 1l-8 9c-6 7-13 13-21 16-6 3-12-3-13-8 0-8 2-14 4-21l11-27 2-8c1-3 0-6-3-8-2-1-4-3-4-6 1-2 3-4 6-5 5-2 11-2 17 2 3 2 4 5 3 8l-5 20-12 33v3h3l10-10 14-19 14-26c2-2 3-5 6-5h9c4 1 5 4 3 8l-9 20c-3 7-6 15-7 23l1 7c2 7 7 8 13 5 9-5 14-13 18-22 4-7 5-15 5-23-1-6-1-11-4-15s-2-7 3-9c7-4 15 0 17 8l2 8z"></path><path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="20" d="M13 98h541v144H13zM80 60h100v38H80zM385 60h100v38H385z"></path>
    </symbol>
</svg></WPM-PACKAGE><WPM-PACKAGE data-repository="webstrate-components-repos" id="MaterialDesignOutlinedIcons" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Icons based on the outlined Material Design icon set",
    "description": "Various icons from Material Design",
    "dependencies": [
        "#wsc-icon-registry",
        "wpm_js_libs #material-design-icons"
    ],
    "assets": [],
    "version": "0.1",
    "changelog": {
        "0.1": "Initial version"
    },
    "license": "Apache 2.0"
}

</SCRIPT><SCRIPT id="material-design-outlined-icon-provider-script" type="disabled">
/**
 *  MaterialDesignOutlinedIconProvider
 *  A provider for registering material icons
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

window.MaterialDesignOutlinedIconProvider = class MaterialDesignOutlinedIconProvider {
    provides(iconIdentifier){
        return iconIdentifier.startsWith("mdc:");
    }

    /**
     * Create a MaterialDesign icon
     * @param {String} iconIdentifier - The id of the icon
     * @returns {HTMLSpanElement} - The created icon
     */
    createIcon(iconIdentifier) {
        let iconName = iconIdentifier.slice(4);

        let icon = document.createElement("span");
        icon.classList.add("material-icons-outlined");
        icon.textContent = iconName;
        return icon;
    }
};

IconRegistry.registerProvider(new MaterialDesignOutlinedIconProvider());

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="webstrate-components-repos" id="MenuSystem" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "MenuSystem",
    "description": "A system to dynamically register into a menu structure and present it visually",
    "dependencies": [
        "WebstrateComponents_Tools"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="MenuSystem-script" type="disabled">
/**
 *  MenuSystem
 *  A system to dynamically register into a menu structure and present it visually
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/**
 * @namespace MenuSystem
 */
window.MenuSystem = {};

/**
 * @typedef {Object} MenuSystem~Point
 * @property {Number} x
 * @property {Number} y
 */

/**
 * @typedef {Object} MenuSystem.Menu~menuConfig
 * @property {MenuSystem.MenuBuilder} [builder=null] - The MenuBuilder to use when instanciating the Menu, if null the DefaultBuilder will be used instead.
 * @property {*} [context=null] - The context of this Menu
 * @property {Boolean} [keepOpen=false] - Should the Menu stay open when clicked
 * @property {Boolean} [groupDividers=false] - Should group dividers be visible
 * @property {function} [onOpen] - Called when the Menu is opened
 * @property {function} [onClose] - Called when the Menu is closed
 */

/**
 * @typedef {Object} MenuSystem.MenuItem~menuItemConfig
 * @property {String} [label] - The label of this MenuItem
 * @property {*} [icon] - The icon of this MenuItem
 * @property {Number} [order=99999] - The order of this MenuItem
 * @property {function} [onAction] - The callback to call when this MenuItem has its action triggered
 * @property {function} [onOpen] - Called when the Menu this MenuItem belongs to is about to open. If false is returned, this MenuItem will not be shown.
 * @property {MenuSystem.Menu} [submenu=null] - A submenu to open when clicking this MenuItem
 * @property {boolean} [submenuOnHover=true] - Determines if this MenuItem's submenu should open on hover
 * @property {String} [group] - The group this MenuItem should belong too
 * @property {Number} [groupOrder=99999] - If this MenuItem is part of a group, this is the order the group should have. (The lowest order of all members is choosen)
 */

/**
 * MenuManager is used to interact with menus in MenuSystem
 * @hideconstructor
 * @memberof MenuSystem
 */
MenuSystem.MenuManager = class MenuManager {
    /**
     * Registers a new MenuItem for the given named menu. MenuItem's can be registered both before and after the menu is created.
     * @param {String} menuName - The name of the menu to register this MenuItem for
     * @param {MenuSystem.MenuItem~menuItemConfig} menuItemConfig - The configuration for this MenuItem
     *
     * @returns {Object} - Delete object, with a single method delete(), that removes this menuItemConfig and all menuitems associated with it
     *
     * @example
     * MenuSystem.MenuManager.registerMenuItem("MyMenu", {
     *     label: "MyMenuItem",
     *     order: 10.
     *     onAction: ()=>{console.log("MyMenuItem clicked!");}
     *     onOpen: ()=>{return true;}
     * });
     */
    static registerMenuItem(menuName, menuItemConfig) {
        menuItemConfig._allMenuItems = new Set();

        //Register this MenuItem in the set
        let menuItemSet = MenuSystem.MenuManager.menuItemMap.get(menuName);
        if(menuItemSet == null) {
            menuItemSet = new Set();
            MenuSystem.MenuManager.menuItemMap.set(menuName, menuItemSet);
        }
        menuItemSet.add(menuItemConfig);

        //Add MenuItem to all menus already created
        let menuArray = MenuSystem.MenuManager.menuMap.get(menuName);
        if(menuArray != null) {
            menuArray.forEach((menu)=>{
                menuItemConfig._allMenuItems.add(menu.addItem(menuItemConfig));
            });
        }

        return {
            delete: ()=>{
                menuItemSet.delete(menuItemConfig);

                menuItemConfig._allMenuItems.forEach((menuItem)=>{
                    menuItem.menu.removeItem(menuItem);
                });
            }
        }
    }

    /**
     * Create a new menu
     * @param {String} menuName - The name of the Menu
     * @param {MenuSystem.Menu~menuConfig} [menuConfig] - The configuration of the Menu
     * @return {MenuSystem.Menu} - The created menu
     *
     * @example
     * MenuSystem.MenuManager.createMenu("MyMenu", {
     *     context: myContext,
     *     builder: MenuSystem.MyLovelyMenuBuilder
     *     keepOpen: false,
     *     onOpen: ()=>{console.log("MyMenu was opened!")},
     *     onClose: ()=>{console.log("MyMenu was closed!")},
     * });
     */
    static createMenu(menuName, menuConfig = {}) {

        if(menuConfig.builder == null) {
            if(MenuSystem.MenuManager.defaultBuilder == null) {
                throw "Attempt to create Menu with defaultBuilder but no default builder is set!";
            }

            menuConfig.builder = MenuSystem.MenuManager.defaultBuilder;
        }

        //Build Menu
        let menu = new MenuSystem.Menu(menuConfig);

        //Add it to our map of named menus
        let menuArray = MenuSystem.MenuManager.menuMap.get(menuName);
        if(menuArray == null) {
            menuArray = [];
            MenuSystem.MenuManager.menuMap.set(menuName, menuArray);
        }
        menuArray.push(menu);

        //Add all registered menuItems
        let menuItemSet = MenuSystem.MenuManager.menuItemMap.get(menuName);
        if(menuItemSet != null) {
            menuItemSet.forEach((itemConfig)=>{
                itemConfig._allMenuItems.add(menu.addItem(itemConfig));
            });
        }

        return menu;
    }

    static setDefaultBuilder(builder) {
        MenuSystem.MenuManager.defaultBuilder = builder;
    }
};
MenuSystem.MenuManager.menuItemMap = new Map();
MenuSystem.MenuManager.menuItemDeleterMap = new Map();
MenuSystem.MenuManager.menuMap = new Map();
MenuSystem.MenuManager.defaultBuilder = null;

/**
 * MenuBuilder is used to build concrete instances of Menu's
 */
MenuSystem.MenuBuilder = class MenuBuilder {
    /**
     * Construct the HTML code for the given Menu
     * @param {MenuSystem.Menu} menu
     */
    static buildMenuHtml(menu) {
        //Override in subclass
        throw "Remember to override buildMenuHtml()";
    }

    /**
     * Construct the HTML code for the given MenuItem
     * @param {MenuSystem.MenuItem} menuItem
     */
    static buildMenuItemHtml(menuItem) {
        //Override in subclass
        throw "Remember to override buildMenuItemHtml()";
    }

    /**
     * Clear all MenuItem's from the given Menu
     * @param {MenuSystem.Menu} menu
     */
    static clearMenuItems(menu) {
        //Override in subclass
        throw "Remember to override clearMenuItems()";
    }

    /**
     * Attach the given MenuItem's to the given Menu
     * @param {MenuSystem.Menu} menu
     * @param {MenuSystem.MenuItem[][]} groups - Array of MenuItem arrays, where each outer array is a grouping of MenuItems
     */
    static attachMenuItems(menu, menuItems) {
        //Override in subclass
        throw "Remember to override attachMenuItems()";
    }

    /**
     * Opens the given Menu
     *
     * The source parameter tells where the open event originated from, which can be a Element, or a 2D point
     * @param {MenuSystem.Menu} menu - The Menu to open
     * @param {Element|MenuSystem~Point} source - The source of the open event
     */
    static open(menu, source) {
        //Override in subclass
        throw "Remember to override open()";
    }

    /**
     * Closes the given Menu
     * @param {MenuSystem.Menu} menu
     */
    static close(menu) {
        //Override in subclass
        throw "Remember to override close()";
    }

    /**
     * Destroy the given Menu
     * @param {MenuSystem.Menu} menu
     */
    static destroyMenu(menu) {
        //Override in subclass
        throw "Remember to override destroyMenu()";
    }

    /**
     * Destroy the given MenuItem
     * @param {MenuSystem.MenuItem} menuItem
     */
    static destroyMenuItem(menuItem) {
        //Override in subclass
        throw "Remember to override destroyMenuItem()";
    }

    /**
     * Create an icon that represents a submenu
     */
    static createSubmenuIcon() {
        //Override in subclass
        throw "Remember to override createSubmenuIcon()";
    }
};

/**
 * Represents a Menu in the MenuSystem
 */
MenuSystem.Menu = class Menu {
    /**
     * Construct a new Menu
     * @param {MenuSystem.Menu~menuConfig} [options] - The options to use for this menu
     */
    constructor(options) {
        this.options = options;

        this.context = WebstrateComponents.Tools.fromConfig(options, "context", null);
        this.builder = WebstrateComponents.Tools.fromConfig(options, "builder", null);

        this.keepOpen = WebstrateComponents.Tools.fromConfig(options, "keepOpen", false);

        this.groupDividers = WebstrateComponents.Tools.fromConfig(options, "groupDividers", false);

        this.growDirection = WebstrateComponents.Tools.fromConfig(options, "growDirection", MenuSystem.Menu.GrowDirection.RIGHT);
        this.layoutDirection = WebstrateComponents.Tools.fromConfig(options, "layoutDirection", MenuSystem.Menu.LayoutDirection.VERTICAL);
        this.layoutWrapping = WebstrateComponents.Tools.fromConfig(options, "layoutWrapping", true);
        this.layoutCompact = WebstrateComponents.Tools.fromConfig(options, "layoutCompact", false);
        this.defaultFocus = WebstrateComponents.Tools.fromConfig(options, "defaultFocus", true);

        this.onOpen = new Set();
        let openCallback = WebstrateComponents.Tools.fromConfig(options, "onOpen");
        if(openCallback != null) {
            this.onOpen.add(openCallback);
        }

        this.onClose = new Set();
        let closeCallback = WebstrateComponents.Tools.fromConfig(options, "onClose");
        if(closeCallback != null) {
            this.onClose.add(closeCallback);
        }

        this.menuItems = [];

        this.isOpen = false;
        this.currentSubmenu = null;

        /** @member {Element} - The DOM Element of this Menu */
        this.html = this.builder.buildMenuHtml(this);
        this.html.menu = this;
        this.html.classList.add("menusystem-menu");

        let self = this;

        this.html.addEventListener("contextmenu", (evt)=>{
            evt.preventDefault();
        });

        this.bodyClickHandler = function(evt) {
            self.handleBodyClick(evt);
        }

        if(this.keepOpen) {
            this.open();
        }
    }

    /**
     * Register a callback to be called when this Menu opens
     * @param {Function} callback
     */
    registerOnOpenCallback(callback) {
        this.onOpen.add(callback);
    }

    /**
     * Deregister a callback to be called when this Menu opens
     * @param {Function} callback
     */
    deregisterOnOpenCallback(callback) {
        this.onOpen.delete(callback);
    }

    /**
     * Register a callback to be called when this Menu closes
     * @param {Function} callback
     */
    registerOnCloseCallback(callback) {
        this.onClose.add(callback);
    }

    /**
     * Deregister a callback to be called when this Menu closes
     * @param {Function} callback
     */
    deregisterOnCloseCallback(callback) {
        this.onClose.delete(callback);
    }

    /**
     * Add a MenuItem to this Menu
     * @param {MenuSystem.MenuItem~menuItemConfig} itemConfig
     * @return {MenuSystem.MenuItem} - The added item
     */
    addItem(itemConfig) {
        let menuItem = new MenuSystem.MenuItem(this.builder, this, itemConfig);
        this.menuItems.push(menuItem);

        this.checkUpdate();

        return menuItem;
    }

    /**
     * Remove a MenuItem from this Menu
     * @param {MenuSystem.MenuItem} menuItem - The menu item to remove
     */
    removeItem(menuItem) {
        this.menuItems.splice(this.menuItems.indexOf(menuItem), 1);

        this.checkUpdate();
    }

    /**
     * Opens this Menu
     * @param {Element|MenuSystem~Point} [source] - Some notion of the source that openend the Menu, could be a Element or a Point
     */
    open(source = null) {
        let self = this;

        if(this.closeTimeoutId != null) {
            clearTimeout(this.closeTimeoutId);
            this.closeTimeoutId = null;
        }

        let numItems = this.update();

        if(numItems === 0 && !this.keepOpen) {
            return;
        }

        this.builder.open(this, source);

        this.isOpen = true;

        setTimeout(()=>{
            window.addEventListener("mouseup", self.bodyClickHandler, {
                capture: true
            });
        }, 0);

        this.triggerOnOpen();
    }

    checkUpdate() {
        if(this.isOpen) {
            let numItems = this.update();

            if(numItems === 0 && !this.keepOpen) {
                this.close();
            }
        }
    }

    /**
     * Updates the MenuItems in this menu.
     * @returns {number} - The number of items in the menu
     */
    update() {
        let self = this;

        this.builder.clearMenuItems(this);

        let groupMap = new Map();

        //Filter menu items
        let filteredMenuItems = this.menuItems.filter((item)=>{
            try {
                return item.onOpen(self, item);
            } catch (ex){
                console.warn("MenuSystem: Menu entry caused an exception while evaluating visibility, dropping: ", item, ex);
                return false;
            }
        });

        //Group items
        filteredMenuItems.forEach((item)=>{
            let group = groupMap.get(item.group);
            if(group == null) {
                group = [];
                groupMap.set(item.group, group);
            }

            group.push(item);
        });

        let groupArrays = Array.from(groupMap.values());

        //Sort Groups
        groupArrays.sort((g1, g2)=>{
            let g1MinGroupOrder = 99999999999;
            let g2MinGroupOrder = 99999999999;

            g1.forEach((item)=>{
                g1MinGroupOrder = Math.min(g1MinGroupOrder, item.groupOrder);
            });
            g2.forEach((item)=>{
                g2MinGroupOrder = Math.min(g2MinGroupOrder, item.groupOrder);
            });

            return g1MinGroupOrder - g2MinGroupOrder;
        });

        //Sort items in each group
        groupArrays.forEach((group)=>{
            group.sort((i1, i2) => {
                return i1.order - i2.order;
            });
        });

        this.builder.attachMenuItems(this, groupArrays);

        return filteredMenuItems.length;
    }

    /**
     * Close this Menu
     */
    close() {
        if(!this.isOpen) {
            return;
        }

        this.builder.close(this);

        this.isOpen = false;

        window.removeEventListener("mouseup", this.bodyClickHandler, {
            capture: true
        });

        this.triggerOnClose();
    }

    /**
     * Destroy this menu
     */
    destroy() {
        this.menuItems.forEach((item)=>{
            item.destroy();
        });

        this.builder.destroyMenu(this);
    }

    /**
     * Trigger the onOpen callback attached to this Menu
     * @private
     */
    triggerOnOpen() {
        let self = this;
        this.onOpen.forEach((callback)=>{
            if(typeof callback === "function") {
                try {
                    callback(self);
                } catch(e) {
                    console.error("Error inside onOpen:", e);
                }
            }
        });
    }

    /**
     * Trigger the onClose callback attached to this Menu
     * @private
     */
    triggerOnClose() {
        let self = this;
        this.onClose.forEach((callback)=>{
            if(typeof callback === "function") {
                try {
                    callback(self);
                } catch(e) {
                    console.error("Error inside onClose:", e);
                }
            }
        });
    }

    /**
     * Closes all submenus except on the given MenuItem
     * @param {MenuSystem.MenuItem} menuItem
     */
    closeAllOtherSubmenus(menuItem) {
        this.menuItems.forEach((item)=>{
            if(item != menuItem && item.submenu != null && item.submenu.isOpen) {
                item.toggleSubmenu();
            }
        });
    }

    /**
     * Signals to this Menu that the given MenuItem has been triggered
     * @private
     * @param {MenuSystem.MenuItem} menuItem
     */
    handleItemAction(menuItem) {
        menuItem.triggerOnAction();

        if(!this.keepOpen && menuItem.submenu == null) {
            this.close();
        }
    }

    /**
     * Handles clicks to the document, to check if we should close if clicked outside
     * @private
     * @param {MouseEvent} evt
     */
    handleBodyClick(evt) {
        let self = this;

        if(!WebstrateComponents.Tools.isInsideElement(this.html, evt.target)) {
            this.closeTimeoutId = setTimeout(()=>{
                this.closeTimeoutId = null;

                let shouldClose = !self.keepOpen && self.currentSubmenu == null;

                if(shouldClose) {
                    self.close();
                }
            }, 0);
        }
    }
};

MenuSystem.Menu.GrowDirection = {
    RIGHT: "right",
    DOWN: "down"
};
MenuSystem.Menu.LayoutDirection = {
    HORIZONTAL: "horizontal",
    VERTICAL: "vertical"
};

/**
 * Represents a MenuItem in the MenuSystem
 */
MenuSystem.MenuItem = class MenuItem {
    /**
     * Construct a new MenuItem
     * @param {MenuSystem.MenuBuilder} builder
     * @param {MenuSystem.Menu} menu
     * @param {MenuSystem.MenuItem~menuItemConfig} config
     */
    constructor(builder, menu, config) {
        let self = this;

        this.builder = builder;
        this.config = config;
        this.menu = menu;

        this.order = WebstrateComponents.Tools.fromConfig(config, "order", 99999);
        this.icon = WebstrateComponents.Tools.fromConfig(config, "icon", null);
        this.metaIcon = WebstrateComponents.Tools.fromConfig(config, "metaIcon", null);
        this.label = WebstrateComponents.Tools.fromConfig(config, "label", null);
        this.tooltip = WebstrateComponents.Tools.fromConfig(config, "tooltip", null);
        this.onAction = WebstrateComponents.Tools.fromConfig(config, "onAction", ()=>{});
        this.onOpen = WebstrateComponents.Tools.fromConfig(config, "onOpen", ()=>{return true;});
        this.submenuOnHover = WebstrateComponents.Tools.fromConfig(config, "submenuOnHover", true);
        this.group = WebstrateComponents.Tools.fromConfig(config, "group", null);
        this.groupOrder = WebstrateComponents.Tools.fromConfig(config, "groupOrder", 99999);
        this.class = WebstrateComponents.Tools.fromConfig(config, "class", null);
        this.checked = WebstrateComponents.Tools.fromConfig(config, "checked", null);

        this.submenu = WebstrateComponents.Tools.fromConfig(config, "submenu", null);

        if(this.submenu != null && this.metaIcon == null) {
            this.metaIcon = this.builder.createSubmenuIcon();
        }

        /** @member {Element} - The DOM Element of this MenuItem */
        this.html = builder.buildMenuItemHtml(this);

        if(this.class != null) {
            this.html.classList.add(this.class.split(" "));
        }

        this.submenuCloseHandler = () => {
            if(self.menu.currentSubmenu === self.submenu) {
                if(!self.menu.keepOpen) {
                    self.menu.close();
                }
                self.menu.currentSubmenu = null;
            }
        }

        this.menuCloseHandler = () => {
            if(self.menu.currentSubmenu === self.submenu) {
                self.menu.currentSubmenu = null;
                self.submenu.close();
            }
        }

        this.setupSubmenuHover();
    }

    get active() {
        return this.html.classList.contains("MenuSystem_MenuItem_Active");
    }

    set active(active) {
        this.builder.setItemActive(this, active);
    }

    /**
     * Trigger the onAction callback of this MenuItem
     * @private
     */
    triggerOnAction() {
        let self = this;

        if(typeof this.onAction === "function") {
            this.onAction(this);
        }

        if(this.submenu != null) {
            this.toggleSubmenu();
        }
    }

    /**
     * Toggles the submenu of this MenuItem, undefined behaviour if this MenuItem is not currently showing in a menu
     * @private
     */
    toggleSubmenu() {
        if(this.submenu == null) {
            throw "Tried to toggle submenu on a menuitem that has no submenu!";
        }

        //Find top component after html
        let parent = this.html;
        while(parent.parentNode != null && !parent.parentNode.matches("html")) {
            parent = parent.parentNode;
        }

        parent.appendChild(this.submenu.html);

        if(this.submenu.isOpen) {
            this.menu.deregisterOnCloseCallback(this.menuCloseHandler);
            this.submenu.deregisterOnCloseCallback(this.submenuCloseHandler);
            this.submenu.close();
            this.submenu.superMenu = null;
            this.menu.currentSubmenu = null;
        } else {
            this.submenu.open(this.html);
            this.submenu.superMenu = this.menu;
            this.menu.currentSubmenu = this.submenu;
            this.submenu.registerOnCloseCallback(this.submenuCloseHandler);
            this.menu.registerOnCloseCallback(this.menuCloseHandler);
        }
    }

    /**
     * Destroys this MenuItem
     */
    destroy() {
        this.builder.destroyMenuItem(this);
    }

    /**
     * @private
     */
    setupSubmenuHover() {
        let self = this;

        let submenuHoverTimerId = null;

        this.html.addEventListener("mouseenter", (evt)=>{
            //Close all other submenus from our Menu
            self.menu.closeAllOtherSubmenus(self);

            if(this.submenuOnHover && this.submenu != null && !this.submenu.isOpen) {
                self.toggleSubmenu();
            }
        });

        this.html.addEventListener("mouseleave", (evt)=>{
            let newTarget = document.elementFromPoint(evt.pageX, evt.pageY);

            let menuItemRect = self.html.getBoundingClientRect();
            let submenuRect = null;

            if(this.submenu?.html != null) {
                submenuRect = self.submenu.html.getBoundingClientRect();

                let boxBetween = {
                    xMin: menuItemRect.x+menuItemRect.width - 5,
                    xMax: submenuRect.x + 5,
                    yMin: Math.min(submenuRect.y-5, menuItemRect.y - 5),
                    yMax: Math.max(submenuRect.y+submenuRect.height + 5, menuItemRect.y+menuItemRect.height + 5)
                }

                if(evt.pageX > boxBetween.xMin && evt.pageX < boxBetween.xMax && evt.pageY < boxBetween.yMax && evt.pageY > boxBetween.yMin) {
                    return;
                }
            }

            if(self.submenuOnHover && self.submenu != null && self.submenu.isOpen && !WebstrateComponents.Tools.isInsideElement(self.submenu.html, newTarget)) {
                self.toggleSubmenu();
            }
        });
    }
};

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="webstrate-components-repos" id="HeadEditorComponent" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Head Editor Component",
    "description": "Easily modify the properties in the head of the page",
    "dependencies": [
        "#WebstrateComponents_Tools"
    ],
    "optionalDependencies": [
        "wpm_js_libs #material-design-components",
        "wpm_js_libs #material-design-icons"
    ],
    "assets": [],
    "version": "1.0",
    "license": "Apache 2.0",
    "changelog": {
        "1.0": "Initial version"
    }
}

</SCRIPT><TEMPLATE id="headEditorBase">
    <DIV class="head-editor-base">

        <DIV class="inline-text-field-container">
            <DIV class="mdc-text-field mdc-text-field--filled mdc-text-field--with-leading-icon" data-mdc-auto-init="MDCTextField">
                <I aria-hidden="true" class="material-icons mdc-text-field__icon mdc-text-field__icon--leading">title</I>
                <INPUT class="mdc-text-field__input" id="title-input" type="text" aria-labelledby="title-label"/>
                <DIV class="mdc-line-ripple"></DIV>
                <LABEL class="mdc-floating-label" id="title-label">Title</LABEL>
            </DIV>
            <DIV class="mdc-text-field-helper-line">
                <DIV class="mdc-text-field-helper-text">Shown in browser tabs and history</DIV>
            </DIV>
        </DIV>

        <DIV class="inline-text-field-container">
            <DIV class="mdc-text-field mdc-text-field--filled mdc-text-field--with-leading-icon" data-mdc-auto-init="MDCTextField">
                <I aria-hidden="true" class="material-icons mdc-text-field__icon mdc-text-field__icon--leading">person</I>
                <INPUT class="mdc-text-field__input" type="text" aria-labelledby="author-label" id="author-input"/>
                <SPAN class="mdc-line-ripple"></SPAN>
                <LABEL class="mdc-floating-label" id="author-label">Author</LABEL>
            </DIV>
            <DIV class="mdc-text-field-helper-line">
                <DIV class="mdc-text-field-helper-text">The name of your or your team</DIV>
            </DIV>
        </DIV>

        <DIV class="inline-text-field-container">
            <DIV class="mdc-text-field mdc-text-field--filled mdc-text-field--with-leading-icon" data-mdc-auto-init="MDCTextField">
                <I aria-hidden="true" class="material-icons mdc-text-field__icon mdc-text-field__icon--leading">tag</I>
                <INPUT class="mdc-text-field__input" type="text" aria-labelledby="keywords-label" id="keywords-input"/>
                <SPAN class="mdc-line-ripple"></SPAN>
                <LABEL class="mdc-floating-label" id="keywords-label">Keywords</LABEL>
            </DIV>
            <DIV class="mdc-text-field-helper-line">
                <DIV class="mdc-text-field-helper-text">Comma separated list of keywords</DIV>
            </DIV>
        </DIV>


        <DIV class="inline-text-field-container">
            <DIV class="mdc-text-field mdc-text-field--filled mdc-text-field--with-leading-icon" data-mdc-auto-init="MDCTextField">
                <I aria-hidden="true" class="material-icons mdc-text-field__icon mdc-text-field__icon--leading">edit_note</I>
                <INPUT class="mdc-text-field__input" type="text" aria-labelledby="description-label" id="description-input"/>
                <SPAN class="mdc-line-ripple"></SPAN>
                <LABEL class="mdc-floating-label" id="description-label">Description</LABEL>
            </DIV>
            <DIV class="mdc-text-field-helper-line">
                <DIV class="mdc-text-field-helper-text">Short textual description</DIV>
            </DIV>
        </DIV>
    </DIV>
</TEMPLATE><SCRIPT id="head-editor-component-script" type="disabled">
/**
 *  Package Browser
 *  Visual browser for installing WPM packages into a Webstrate
 *
 *  Copyright 2022 Rolf Bagge & Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 **/

window.HeadEditorComponent = class HeadEditorComponent {
    constructor(autoOpen = true) {
        let self = this;
        self.html = WebstrateComponents.Tools.loadTemplate("#headEditorBase");

        // WPMv2 then
        self.setupBasicProperties();
        //

        if (autoOpen)
            this.openInBody();
    }

    setupBasicProperties() {
        let self = this;

        // Title
        self.html.querySelector("#title-input").value = document.title;
        self.html.querySelector("#title-input").addEventListener("input", () => {
            let newTitle = self.html.querySelector("#title-input").value.trim();
            document.title = newTitle;
            let titleElement = document.head.querySelector("title");
            if (newTitle.length === 0) {
                if (titleElement){
                    titleElement.remove();
                }
            } else {
                if (titleElement){
                    WPMv2.stripProtection(titleElement);
                }
            }
        });

        ["author","keywords","description"].forEach((metaField)=>{
            try {
                self.html.querySelector("#"+metaField+"-input").value = document.querySelector("head meta[name='"+metaField+"']").getAttribute("content");
            } catch (ex){
                // Ignore missing fields
            }

            self.html.querySelector("#"+metaField+"-input").addEventListener("input", () => {
                let newValue = self.html.querySelector("#"+metaField+"-input").value.trim();

                let metaElement = document.head.querySelector('meta[name="'+metaField+'"]');
                if (newValue.length === 0){
                    if (metaElement){
                        metaElement.remove();
                    }
                } else {
                    if (!metaElement){
                        metaElement = document.createElement("meta");
                        metaElement.setAttribute("name", metaField);
                        WPMv2.stripProtection(metaElement);
                        document.head.appendChild(metaElement);
                    }
                    metaElement.setAttribute("content", newValue);
                }
            });
        });
    }

    openInBody() {
        let parent = document.createElement("transient");
        parent.appendChild(this.html);
        document.body.appendChild(parent);
    }
};


// tags:
//  title
//  script:not(unapproved)
//  link rel href
//  base href, target
// meta:
//  viewport, keywords, description, author

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="webstrate-components-repos" id="RevisionBrowser" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Revision Browser",
    "description": "Browse, tag and restore revisions of your webstrate with a visual UI",
    "dependencies": [
        "wpm_js_libs #material-design-components",
        "wpm_js_libs #material-design-icons",
        "WebstrateComponents_Tools"
    ],
    "assets": [],
    "version": "1.0",
    "license": "Apache 2.0",
    "changelog": {
        "1.0": "Initial version"
    }
}

</SCRIPT><STYLE id="mdc-revision-browser-style">
/**
 *  Revision Browser Styles
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
@keyframes revision-browser-card-appears {
  from {
    opacity: 0; }
  to {
    opacity: 1; } }

.revision-browser-base {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(12em, auto));
  background: var(--mdc-theme-background, white); }
  .revision-browser-base .tag-button {
    margin-left: auto; }
  .revision-browser-base .revision-input-spinner {
    width: 100%; }
  .revision-browser-base .revision-browser-scrollable {
    overflow-y: auto;
    max-width: 24em; }
  .revision-browser-base .revision_framecontainer {
    flex: 1 1 auto;
    width: 100vw;
    max-width: 100%;
    min-height: 10%;
    max-height: 100%;
    display: flex;
    justify-content: stretch;
    background: white; }
  .revision-browser-base .revision-framescaler {
    flex: 1 1 auto;
    overflow: hidden;
    margin-left: 1em;
    margin-right: 1em; }
  .revision-browser-base .revision_framecontainer iframe {
    border: 0;
    animation: 0.5s revision-browser-card-appears ease-out;
    animation-delay: 0.1s;
    transform-origin: 0 0;
    transform: scale(0.5);
    width: 200%;
    height: 200%; }
  .revision-browser-base .mdc-card {
    border-radius: 0;
    flex: 1 1 auto; }
  .revision-browser-base .revision-card__primary, .revision-browser-base .mdc-card__actions {
    padding: 0em 1.5em; }
  .revision-browser-base .revision-browser-base .mdc-card__actions {
    justify-content: flex-end; }
</STYLE><SCRIPT id="webstrate-revision-browser-script" type="disabled">
/**
 *  Revision Browser
 *  Manage revisions of a Webstrate in a visual editor
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

window.RevisionBrowser = class RevisionBrowser {
    constructor() {
        let self = this;

        this.selfItemTemplate = WebstrateComponents.Tools.loadTemplate("#revisionBrowserSelfItem");
        this.listItemTemplate = WebstrateComponents.Tools.loadTemplate("#revisionBrowserListItem");
        this.cardTemplate = WebstrateComponents.Tools.loadTemplate("#revisionBrowserPresentationCard");
        this.tagTemplate = WebstrateComponents.Tools.loadTemplate("#revisionBrowserTaggingCard");

        this.html = WebstrateComponents.Tools.loadTemplate("#revision-browser-base");

        this.populateList();

        webstrate.on("tag", ()=>{
            self.populateList();
        });

        let revisionSelector = cQuery(this.html).find(".revisionSelector");
        revisionSelector[0].value = webstrate.version;

        revisionSelector.on("input", ()=>{
            if(parseInt(revisionSelector[0].value) > webstrate.version) {
                revisionSelector[0].value = webstrate.version;
            }
            self.loadRevision(revisionSelector[0].value);
            self.unselect();
            self.selectTagFromRevision(revisionSelector[0].value);

        });
    }

    loadTagUI() {
        let self = this;
        let target = cQuery(this.html).find(".revision_framecontainer");
        target.empty();
        let card = this.tagTemplate.cloneNode(true);
        let tagButton = cQuery(card).find(".tagButton");
        tagButton.on("click", ()=>{
            let label = window.prompt("Enter wanted tag label:");

            if(label != null && label.trim() !== "") {
                webstrate.on("tag", function once(version, label) {
                    console.log("Saved tag:", version, label);
                    webstrate.off("tag", once);
                });

                webstrate.tag(label);
            }
        });

        mdc.autoInit(card);
        target.append(card);
    }

    loadRevision(revision, tagLabel = null) {
        let self = this;

        let tags = webstrate.tags();
        let tagList = Object.keys(tags).sort((v1, v2)=>{
            return parseInt(v2) - parseInt(v1);
        });

        let target = cQuery(this.html).find(".revision_framecontainer");

        let card = this.cardTemplate.cloneNode(true);
        let frameTarget = cQuery(card).one("iframe");
        let authorTarget = cQuery(card).one(".revision-author");
        let deleteButton = cQuery(card).find(".deleteButton");
        let restoreButton = cQuery(card).find(".restoreButton");

        target.empty();
        if (!revision) return;

        frameTarget.src = revision;
        cQuery(card).one(".revision-name").innerText = tags[revision];
        mdc.autoInit(card);
        target.append(card);

        webstrate.getOps(parseInt(revision)-1,parseInt(revision), (err, ops) => {
            let username = "System";
            if (ops != null && ops.length > 0){
                if (ops[0].session){
                    username = ops[0].session.userId;
                } else {
                    username = ops[0].src;
                }
            }
            if (username == "anonymous:") username = "Anonymous";
            authorTarget.innerText = "by "+username;
        });

        restoreButton.on("click", ()=>{
            webstrate.restore(parseInt(revision), (err, newVersion) =>{
                if(err) {
                    console.error(err);
                } else {
                    console.log("Successfully restored");
                    EventSystem.triggerEvent("RevisionBrowser.OnRestore", self);
                }
            });
        });

        if(tagLabel != null) {
            deleteButton.on("click", ()=>{

                console.log("Deleting: ", tagLabel);

                webstrate.untag(tagLabel);

                target.empty();

                self.populateList();
            });
        } else {
            deleteButton.remove();
        }
    }

    unselect(){
        cQuery(this.html).find(".mdc-list-item--selected").removeClass("mdc-list-item--selected");
        cQuery(this.html).find(".mdc-list")[0].MDCList.foundation.selectedIndex_ = -1;
    }

    selectTagFromRevision(revision) {
        let listItem = cQuery(this.html).find(".mdc-list-item[data-revision='"+revision+"']");

        if(listItem != null) {
            let foundIndex = -1;

            cQuery(this.html).find(".mdc-list")[0].MDCList.listElements.forEach((listElement, index)=>{
                if(listItem[0] === listElement) {
                    foundIndex = index;
                }
            });

            cQuery(this.html).find(".mdc-list")[0].MDCList.selectedIndex = foundIndex;
        }
    }

    populateList() {
        let self = this;

        // Populate list
        let tags = webstrate.tags();
        let tagList = Object.keys(tags).sort((v1, v2)=>{
            return parseInt(v2) - parseInt(v1);
        });
        let browserList = cQuery(this.html).one(".mdc-list");

        //Clear old entries
        cQuery(browserList).find(".mdc-list-item").remove();

        let currentItem = this.selfItemTemplate.cloneNode(true);
        cQuery(currentItem).one(".revision-subtext").innerText = "Revision "+webstrate.version;
        currentItem.setAttribute("data-revision", webstrate.version);
        browserList.append(currentItem);

        tagList.forEach((revision)=>{
            let listItem = this.listItemTemplate.cloneNode(true);
            cQuery(listItem).one(".revision-name").innerText = tags[revision];
            cQuery(listItem).one(".revision-subtext").innerText = "Revision "+revision;
            browserList.append(listItem);
            listItem.setAttribute("data-revision", revision);
        });

        // Auto-init all the components
        mdc.autoInit(this.html);

        // Configure list and preview
        let list = browserList.MDCList;
        list.singleSelection = true;

        list.listen("MDCList:action", (evt)=>{
            if (evt.detail.index>0){
                let revision = tagList[evt.detail.index-1];
                let tagLabel = tags[revision];

                self.loadRevision(revision, tagLabel);
                cQuery(self.html).find(".revisionSelector")[0].value=revision;
            } else {
                self.loadTagUI();
            }
        });

        list.selectedIndex = 0;
        this.loadTagUI();
    }
};

</SCRIPT><TEMPLATE id="revision-browser-base">
    <DIV class="revision-browser-base">

        <DIV class="revision-browser-scrollable">
            <DIV>
                <LABEL class="mdc-text-field mdc-text-field--filled revision-input-spinner" data-mdc-auto-init="MDCTextField">
                    <SPAN class="mdc-text-field__ripple"></SPAN>
                    <INPUT type="number" min="1" class="mdc-text-field__input revisionSelector" value="0"/>
                    <SPAN class="mdc-floating-label">Browse revision</SPAN>
                    <SPAN class="mdc-line-ripple"></SPAN>
                </LABEL>
            </DIV>
            <UL class="mdc-list mdc-list--two-line" data-mdc-auto-init="MDCList">
            </UL>
        </DIV>
        <DIV class="mdc-card revision_framecontainer">
        </DIV>
    </DIV>
</TEMPLATE><TEMPLATE id="revisionBrowserSelfItem">
    <LI class="mdc-list-item" data-mdc-auto-init="MDCRipple" tabindex="0">
        <SPAN class="mdc-list-item__ripple"></SPAN>
        <SPAN class="mdc-list-item__text">
            <SPAN class="mdc-list-item__primary-text revision-name">&lt;Current Revision>
            </SPAN>
            <SPAN class="mdc-list-item__secondary-text revision-subtext">Secondary text</SPAN>
        </SPAN>
    </LI>
</TEMPLATE><TEMPLATE id="revisionBrowserListItem">
    <LI class="mdc-list-item" data-mdc-auto-init="MDCRipple" tabindex="0">
        <SPAN class="mdc-list-item__ripple"></SPAN>
        <SPAN class="mdc-list-item__text">
            <SPAN class="mdc-list-item__primary-text revision-name">Two-line item
            </SPAN>
            <SPAN class="mdc-list-item__secondary-text revision-subtext">Secondary text</SPAN>
        </SPAN>
    </LI>
</TEMPLATE><TEMPLATE id="revisionBrowserPresentationCard">
    <DIV class="mdc-card">
        <DIV class="revision-card__primary">
            <H2 class="mdc-typography mdc-typography--headline6 revision-name">The Title</H2>
            <H3 class="mdc-typography mdc-typography--subtitle2 revision-author">by</H3>
        </DIV>
        <DIV class="revision-framescaler mdc-elevation--z3">
            <IFRAME class="mdc-card__media"></IFRAME>
        </DIV>
        <DIV class="mdc-card__actions">
            <DIV class="mdc-card__action-buttons">
                <BUTTON class="mdc-button mdc-card__action mdc-card__action--button deleteButton" data-mdc-auto-init="MDCRipple">Delete<SPAN class="mdc-button__ripple"></SPAN></BUTTON>
                <BUTTON class="mdc-button mdc-button--raised mdc-card__action mdc-card__action--button restoreButton" data-mdc-auto-init="MDCRipple">Restore<SPAN class="mdc-button__ripple"></SPAN></BUTTON>
            </DIV>
        </DIV>
    </DIV>
</TEMPLATE><TEMPLATE id="revisionBrowserTaggingCard">
    <DIV class="mdc-card">
        <DIV class="revision-card__primary">
            <H2 class="mdc-typography mdc-typography--headline6 revision-name">Tags and Revisions</H2>
            <H3 class="mdc-typography mdc-typography--subtitle2 revision-author">Store a tagged revision of the current webstrate - restore it from the list later</H3>
        </DIV>
        <DIV class="mdc-card__actions">
            <DIV class="mdc-card__action-buttons">
                <BUTTON class="mdc-button mdc-button--raised mdc-card__action mdc-card__action--button tagButton" data-mdc-auto-init="MDCRipple">Tag this<SPAN class="mdc-button__ripple"></SPAN></BUTTON>
            </DIV>
        </DIV>
    </DIV>
</TEMPLATE></WPM-PACKAGE><WPM-PACKAGE data-repository="webstrate-components-repos" id="PermissionManager" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Permission Manager",
    "description": "Manage permissions on a webstrate",
    "dependencies": [
        "wpm_js_libs #material-design-components",
        "wpm_js_libs #material-design-icons",
        "WebstrateComponents_Tools"
    ],
    "assets": [],
    "version": "1.0",
    "license": "Apache 2.0",
    "changelog": {
        "1.0": "Initial version"
    }
}

</SCRIPT><STYLE id="main-style">
/**
 *  Permission Manager Styles
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
.webstrate-components-permission-ui .wcp-permission-column {
  white-space: normal;
  width: 1em;
  text-align: center; }

.webstrate-components-permission-ui .wcp-user-column {
  width: 15em; }

.webstrate-components-permission-ui .mdc-data-table__cell:last-child {
  text-align: right; }
</STYLE><SCRIPT id="webstrate-permission-manager-script" type="disabled">
/**
 *  Permission Manager
 *  Low-level interface to control permissions on a Webstrate
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/**
 * Handles managing permissions
 */
class PermissionManager {
    constructor() {
        this.permissions = [];

        this.loadPermissions();

        this.observer = new MutationObserver((mutations)=>{
            this.loadPermissions();
        });

        this.startObserver();
    }

    async executeObserverless(executor) {
        let mutations = this.observer.takeRecords();
        if(mutations.length > 0) {
            this.loadPermissions();
        }
        this.observer.disconnect();

        await executor();

        this.startObserver();
    }

    startObserver() {
        this.observer.observe(document.querySelector("html"), {
            attributes: true,
            attributeFilter: ["data-auth"]
        });
    }

    loadPermissions() {
        let self = this;

        let permissionJson = JSON.parse(document.querySelector("html").getAttribute("data-auth"));

        self.permissions = [];

        if(permissionJson != null) {
            permissionJson.forEach((perm)=>{
                if(perm.webstrateId != null) {
                    //Inherit permissions
                    console.warn("This webstrate is inheriting permissions (Unsupported) from: ", perm.webstrateId);
                } else {
                    self.permissions.push(new Permission(perm.username, perm.provider, perm.permissions));
                }
            });
        }

        this.checkAnonymousUser();

        EventSystem.triggerEvent("PermissionManager.Permissions.Changed", {
            permissions: this.permissions
        });
    }

    checkAnonymousUser() {
        //Remove anonymous if last user
        if(this.permissions.length === 1 && this.permissions[0].username === "anonymous" && this.permissions[0].provider === "") {
            this.permissions.pop();
        }

        //Only add anonymous if another user is present
        if(this.permissions.length > 0 && this.permissions.find((perm)=>{
            return perm.username === "anonymous" && perm.provider === "";
        }) == null) {
            //no anonymous permission, adding with no rights
            this.permissions.push(new Permission("anonymous", "", ""));
        }
    }

    setPermission(permission) {
        console.log("Setting permission: ", permission);

        let oldPermission = this.permissions.find((perm)=>{
            return permission.username === perm.username && permission.provider === perm.provider;
        });

        if(oldPermission != null) {
            oldPermission.permissions = permission.permissions;
        } else {
            this.permissions.push(permission);
        }

        this.checkAnonymousUser();

        EventSystem.triggerEvent("PermissionManager.Permissions.Changed", {
            permissions: this.permissions
        });
    }

    removePermission(permission) {
        this.permissions = this.permissions.filter((perm)=>{
            return permission.username !== perm.username || permission.provider !== perm.provider;
        });

        this.checkAnonymousUser();

        EventSystem.triggerEvent("PermissionManager.Permissions.Changed", {
            permissions: this.permissions
        });
    }

    save() {
        if(this.permissions.length === 0 || (this.permissions.length === 1 && this.permissions[0].username === "anonymous")) {
            //Empty permissions, remove auth property, everyone can do anything!
            if(confirm("After saving everyone has full access to this webstrate.\nContinue?")) {
                document.querySelector("html").removeAttribute("data-auth");
                return true;
            } else {
                return false;
            }
        } else {
            //Checks for the current user not locking himself out
            let ourPermissions = this.permissions.find((perm)=>{
                return perm.username === webstrate.user.username && perm.provider === webstrate.user.provider;
            });

            let anonPermissions = this.permissions.find((perm)=>{
                return perm.username === "anonymous" && perm.provider === "";
            });

            let anyAdmin = this.permissions.find((perm)=>{
                return perm.hasPermission("a");
            }) != null;

            if(ourPermissions == null) {
                //If our user does not exist, we are anon
                ourPermissions = anonPermissions;
            }

            let canRead = ourPermissions!=null?ourPermissions.hasPermission("r"):false;
            let canWrite = ourPermissions!=null?ourPermissions.hasPermission("w"):false;
            let canAdmin = ourPermissions!=null?((anyAdmin)?ourPermissions.hasPermission("a"):canWrite):false;

            let permissionsJson = JSON.stringify(this.permissions.map((perm)=>{
                return perm.toJson();
            }));

            if(!canAdmin) {
                if(confirm("After saving permissions, you will no longer be able to change permissions.\nContinue?")) {
                    document.querySelector("html").setAttribute("data-auth", permissionsJson, {approved: true});
                    return true;
                } else {
                    return false;
                }
            } else {
                document.querySelector("html").setAttribute("data-auth", permissionsJson, {approved: true});
                return true;
            }
        }
    }
}

window.WebstrateComponents.PermissionManager = PermissionManager;

class Permission {
    constructor(username, provider, permissionString) {
        this.username = username;
        this.provider = provider;
        this.permissions = new Set();

        this.loadPermissions(permissionString);
    }

    loadPermissions(permissionString) {
        this.permissions.clear();

        for(let i = 0; i<permissionString.length; i++) {
            let p = permissionString.charAt(i);

            switch(p) {
                case "a":
                    this.permissions.add("a");
                case "w":
                    this.permissions.add("w");
                case "r":
                    this.permissions.add("r");
                    break;

                default:
                    console.warn("Unknown permission: ", p);
            }
        }
    }

    setPermission(perm) {
        this.permissions.clear();

        switch(perm) {
            case "a":
                this.permissions.add("a");
            case "w":
                this.permissions.add("w");
            case "r":
                this.permissions.add("r");
            default:
                console.warn("Unknown permission: ", perm);
        }
    }

    hasPermission(perm) {
        return this.permissions.has(perm);
    }

    toJson() {
        return {
            username: this.username,
            provider: this.provider,
            permissions: Array.from(this.permissions).join("")
        };
    }
}

window.WebstrateComponents.Permission = Permission;

//Load right away
WebstrateComponents.PermissionManager.singleton = new PermissionManager();

</SCRIPT><SCRIPT id="webstrate-permission-manager-ui-script" type="disabled">
/**
 *  Permission Manager UI
 *  UI code for controller permissions on a Webstrate
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

class PermissionManagerUI {
    constructor() {
        let self = this;

        this.topLevelComponent = document.body;

        this.html = WebstrateComponents.Tools.loadTemplate("#webstrate-components-permission-ui-tpl");

        this.html.querySelectorAll(".mdc-button").forEach((button)=>{
            new mdc.ripple.MDCRipple(button);
        });

        EventSystem.registerEventCallback("PermissionManager.Permissions.Changed", ({detail:{permissions: permissions}})=>{
            self.reload(permissions);
        });

        this.reload(WebstrateComponents.PermissionManager.singleton.permissions);

        this.html.querySelector("button.addPermission").addEventListener("click", ()=>{
            self.showAddDialog();
        });

        this.html.querySelector("button.savePermissions").addEventListener("click", ()=>{
            if(WebstrateComponents.PermissionManager.singleton.save()) {
                EventSystem.triggerEvent("PermissionManagerUI.Saved", this);
            }
        });
    }

    setTopLevelComponent(component){
        this.topLevelComponent = component;
    }

    async showAddDialog() {
        let dialogTpl = WebstrateComponents.Tools.loadTemplate("#webstrate-components-permission-add-permission-dialog-tpl");

        let dialog = new WebstrateComponents.ModalDialog(dialogTpl);
        let transient = document.createElement("transient");
        transient.appendChild(dialog.html);
        this.topLevelComponent.appendChild(transient);

        let permissionTpl = WebstrateComponents.Tools.loadTemplate("#webstrate-components-permission-adduser-tpl");
        dialogTpl.querySelector("tbody").appendChild(permissionTpl);

        new mdc.textField.MDCTextField(permissionTpl.querySelector('.mdc-text-field'));

        dialog.open();

        EventSystem.registerEventCallback('ModalDialog.Closed', function(evt) {
            //Remove template after use
            transient.remove();

            if(evt.detail.dialog===dialog && evt.detail.action === "add") {
                let usernameProvider = dialogTpl.querySelector(".username input").value.split(":");
                let permissionString = dialogTpl.querySelector("input[type='radio']:checked").value;

                if(usernameProvider.length === 2 && usernameProvider[0].trim() !== "" && usernameProvider[1].trim() !== "") {
                    let permission = new WebstrateComponents.Permission(usernameProvider[0], usernameProvider[1], permissionString);

                    WebstrateComponents.PermissionManager.singleton.setPermission(permission);
                } else {
                    alert("You mistyped something, must be 'username:provider'");
                }
            }
        });
    }

    reload(permissions) {
        let tbody = this.html.querySelector("tbody");

        //Empty tbody
        while(tbody.firstChild) tbody.firstChild.remove();

        permissions.forEach((perm)=>{
            let permissionTpl = WebstrateComponents.Tools.loadTemplate("#webstrate-components-permission-user-tpl");

            let prefix = perm.username+"_"+perm.provider+"_";

            //Rename all input id and name attributes
            permissionTpl.querySelectorAll("input").forEach((input)=>{
                input.id = prefix + input.id;
                input.name = prefix + input.name;

                input.addEventListener("input", ()=>{
                    perm.setPermission(input.value);
                });
            })

            //Rename all label for attributes
            permissionTpl.querySelectorAll("label").forEach((label)=>{
                label.setAttribute("for", prefix + label.getAttribute("for"));
            });

            permissionTpl.querySelectorAll('.mdc-radio').forEach((radio)=>{
                new mdc.radio.MDCRadio(radio);
            });

            permissionTpl.querySelectorAll('.mdc-form-field').forEach((formField)=>{
                new mdc.formField.MDCFormField(formField);
            });

            let checkedSelector = "";

            if(perm.hasPermission("a")) {
                checkedSelector = prefix+"admin";
            } else if(perm.hasPermission("w")) {
                checkedSelector = prefix+"write";
            } else if(perm.hasPermission("r")) {
                checkedSelector = prefix+"read";
            } else {
                checkedSelector = prefix+"none";
            }

            permissionTpl.querySelector("#"+checkedSelector).checked = true;

            permissionTpl.querySelector(".username").textContent = perm.username+(perm.provider.trim()===""?"":":"+perm.provider);

            if(perm.username === "anonymous" && perm.provider === "") {
                permissionTpl.querySelector(".deletePermission").remove();
            } else {
                permissionTpl.querySelector(".deletePermission").addEventListener("click", ()=>{
                    WebstrateComponents.PermissionManager.singleton.removePermission(perm);
                });
            }

            tbody.appendChild(permissionTpl);
        });
    }
}

window.WebstrateComponents.PermissionManagerUI = PermissionManagerUI;

</SCRIPT><TEMPLATE id="webstrate-components-permission-ui-tpl">
    <DIV class="webstrate-components-permission-ui">
        <TABLE class="mdc-data-table__table" aria-label="User permissions">
            <THEAD>
                <TR class="mdc-data-table__header-row">
                    <TH></TH>
                    <TH colspan="4" class role="columnheader" scope="col">Permissions</TH>
                    <TH class="mdc-data-table__header-cell" role="columnheader" scope="col"></TH>
                </TR>
                <TR>
                    <TH rowspan="2" class="mdc-data-table__header-cell wcp-user-column" role="columnheader" scope="col">User</TH>
                    <TH class="mdc-data-table__header-cell wcp-permission-column">Admin</TH>
                    <TH class="mdc-data-table__header-cell wcp-permission-column">Write & Read</TH>
                    <TH class="mdc-data-table__header-cell wcp-permission-column">Read Only</TH>
                    <TH class="mdc-data-table__header-cell wcp-permission-column">No Access</TH>
                </TR>
            </THEAD>
            <TBODY class="mdc-data-table__content">
            </TBODY>
            <TFOOT>
                <TR class="mdc-data-table__row mdc-data-table__footer-row">
                    <TD colspan="6">
                        <BUTTON class="mdc-button mdc-button--touch addPermission">
                            <DIV class="mdc-button__ripple"></DIV>
                            <I class="material-icons mdc-button__icon" aria-hidden="true">person_add</I>
                            <SPAN class="mdc-button__label">Add User</SPAN>
                            <DIV class="mdc-button__touch"></DIV>
                        </BUTTON>
                    </TD>
                </TR>
            </TFOOT>
        </TABLE>
        <DIV class="mdc-dialog__actions">
            <BUTTON class="mdc-button mdc-button--touch mdc-button--raised savePermissions" tabindex="1">
                <DIV class="mdc-button__ripple"></DIV>
                <SPAN class="mdc-button__label">Save</SPAN>
                <DIV class="mdc-button__touch"></DIV>
            </BUTTON>
        </DIV>
    </DIV>
</TEMPLATE><TEMPLATE id="webstrate-components-permission-user-tpl">
    <TR class="mdc-data-table__row">
        <TD class="mdc-data-table__cell username"></TD>
        <TD class="mdc-data-table__cell">
            <DIV class="mdc-form-field">
                <DIV class="mdc-radio">
                    <INPUT class="mdc-radio__native-control" type="radio" id="admin" value="a" name="permissions"/>
                    <DIV class="mdc-radio__background">
                        <DIV class="mdc-radio__outer-circle"></DIV>
                        <DIV class="mdc-radio__inner-circle"></DIV>
                    </DIV>
                    <DIV class="mdc-radio__ripple"></DIV>
                </DIV>
            </DIV>
        </TD><TD class="mdc-data-table__cell">
            <DIV class="mdc-form-field">
                <DIV class="mdc-radio">
                    <INPUT class="mdc-radio__native-control" type="radio" id="write" value="w" name="permissions"/>
                    <DIV class="mdc-radio__background">
                        <DIV class="mdc-radio__outer-circle"></DIV>
                        <DIV class="mdc-radio__inner-circle"></DIV>
                    </DIV>
                    <DIV class="mdc-radio__ripple"></DIV>
                </DIV>
            </DIV>
        </TD><TD class="mdc-data-table__cell">
            <DIV class="mdc-form-field">
                <DIV class="mdc-radio">
                    <INPUT class="mdc-radio__native-control" type="radio" id="read" value="r" name="permissions"/>
                    <DIV class="mdc-radio__background">
                        <DIV class="mdc-radio__outer-circle"></DIV>
                        <DIV class="mdc-radio__inner-circle"></DIV>
                    </DIV>
                    <DIV class="mdc-radio__ripple"></DIV>
                </DIV>
            </DIV>
        </TD><TD class="mdc-data-table__cell">
            <DIV class="mdc-form-field">
                <DIV class="mdc-radio">
                    <INPUT class="mdc-radio__native-control" type="radio" id="none" value name="permissions"/>
                    <DIV class="mdc-radio__background">
                        <DIV class="mdc-radio__outer-circle"></DIV>
                        <DIV class="mdc-radio__inner-circle"></DIV>
                    </DIV>
                    <DIV class="mdc-radio__ripple"></DIV>
                </DIV>
            </DIV>
        </TD>
        <TD class="mdc-data-table__cell">
            <BUTTON class="mdc-button mdc-button--touch deletePermission">
                <DIV class="mdc-button__ripple"></DIV>
                <SPAN class="mdc-button__label">Delete</SPAN>
                <DIV class="mdc-button__touch"></DIV>
            </BUTTON>
        </TD>
    </TR>
</TEMPLATE><TEMPLATE id="webstrate-components-permission-adduser-tpl">
    <TR class="mdc-data-table__row">
        <TD class="mdc-data-table__cell username">
            <LABEL class="mdc-text-field mdc-text-field--filled">
              <SPAN class="mdc-text-field__ripple"></SPAN>
              <INPUT placeholder="F.x. 'bob:au'" class="mdc-text-field__input" type="text" aria-labelledby="webstrate-components-permission-adduser-username"/>
              <SPAN class="mdc-floating-label" id="id=" webstrate-components-permission-adduser-username__>username:provider</SPAN>
              <SPAN class="mdc-line-ripple"></SPAN>
            </LABEL>
        </TD>
        <TD class="mdc-data-table__cell">
            <DIV class="mdc-form-field">
                <DIV class="mdc-radio">
                    <INPUT class="mdc-radio__native-control" type="radio" id="webstrate-components-permission-adduser-admin" value="a" name="webstrate-components-permission-adduser-permissions"/>
                    <DIV class="mdc-radio__background">
                        <DIV class="mdc-radio__outer-circle"></DIV>
                        <DIV class="mdc-radio__inner-circle"></DIV>
                    </DIV>
                    <DIV class="mdc-radio__ripple"></DIV>
                </DIV>
                <LABEL for="webstrate-components-permission-adduser-admin">Admin, Write and Read</LABEL>
            </DIV><BR/>
            <DIV class="mdc-form-field">
                <DIV class="mdc-radio">
                    <INPUT class="mdc-radio__native-control" type="radio" id="webstrate-components-permission-adduser-write" value="w" name="webstrate-components-permission-adduser-permissions"/>
                    <DIV class="mdc-radio__background">
                        <DIV class="mdc-radio__outer-circle"></DIV>
                        <DIV class="mdc-radio__inner-circle"></DIV>
                    </DIV>
                    <DIV class="mdc-radio__ripple"></DIV>
                </DIV>
                <LABEL for="webstrate-components-permission-adduser-write">Write and Read</LABEL>
            </DIV><BR/>
            <DIV class="mdc-form-field">
                <DIV class="mdc-radio">
                    <INPUT class="mdc-radio__native-control" type="radio" id="webstrate-components-permission-adduser-read" value="r" name="webstrate-components-permission-adduser-permissions"/>
                    <DIV class="mdc-radio__background">
                        <DIV class="mdc-radio__outer-circle"></DIV>
                        <DIV class="mdc-radio__inner-circle"></DIV>
                    </DIV>
                    <DIV class="mdc-radio__ripple"></DIV>
                </DIV>
                <LABEL for="webstrate-components-permission-adduser-read">Read Only</LABEL>
            </DIV><BR/>
            <DIV class="mdc-form-field">
                <DIV class="mdc-radio">
                    <INPUT class="mdc-radio__native-control" type="radio" id="webstrate-components-permission-adduser-none" value name="webstrate-components-permission-adduser-permissions" checked/>
                    <DIV class="mdc-radio__background">
                        <DIV class="mdc-radio__outer-circle"></DIV>
                        <DIV class="mdc-radio__inner-circle"></DIV>
                    </DIV>
                    <DIV class="mdc-radio__ripple"></DIV>
                </DIV>
                <LABEL for="webstrate-components-permission-adduser-none">None</LABEL>
            </DIV>
        </TD>
    </TR>
</TEMPLATE><TEMPLATE id="webstrate-components-permission-add-permission-dialog-tpl">
    <DIV>
        <TABLE class="mdc-data-table__table" aria-label="User permissions">
            <THEAD>
            <TR class="mdc-data-table__header-row">
                <TH class="mdc-data-table__header-cell" role="columnheader" scope="col">User</TH>
                <TH class="mdc-data-table__header-cell" role="columnheader" scope="col">Permissions</TH>
            </TR>
            </THEAD>
            <TBODY class="mdc-data-table__content">
            </TBODY>
        </TABLE>
        <DIV class="mdc-dialog__actions">
            <BUTTON type="button" class="mdc-button mdc-dialog__button" data-mdc-dialog-action="cancel">
                <DIV class="mdc-button__ripple"></DIV>
                <SPAN class="mdc-button__label">Cancel</SPAN>
            </BUTTON>
            <BUTTON type="button" class="mdc-button mdc-dialog__button mdc-button--raised" data-mdc-dialog-action="add">
                <DIV class="mdc-button__ripple"></DIV>
                <SPAN class="mdc-button__label">Add</SPAN>
            </BUTTON>
        </DIV>
    </DIV>
</TEMPLATE></WPM-PACKAGE><WPM-PACKAGE data-repository="webstrate-components-repos" id="EdgeDocker" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Edge Docking Area",
    "description": "Creates a dockable area and reflows the rest of the parent around it like regular built-in developer tools",
    "dependencies": [
        "wpm_js_libs #CaviTouch",
        "WebstrateComponents_Tools"
    ],
    "assets": [],
    "version": "0.9",
    "license": "Apache 2.0",
    "changelog": {
        "0.8": "Initial checkin based on linear editor docking system",
        "0.9": "Support for moving around rest of document when docking"
    }
}

</SCRIPT><STYLE id="main-style">
/**
 *  EdgeDocker Styles
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
html {
  height: 100vh; }
  html[transient-data-docking-area-component-mode~="minimized"] .docking-area-resizer {
    display: none; }
  html[transient-data-docking-area-component-mode~="minimized"] .docking-area-component {
    display: none; }
  html[transient-data-docking-area-component-mode~="embedded"] .docking-area-resizer {
    display: none; }
  html[transient-data-docking-area-component-mode~="embedded"] .docking-area-component {
    width: 100%;
    height: 100%; }
  html[transient-data-docking-area-component-mode~="maximized"] > *:not(.docking-area-component):not(.docking-area--ignore) {
    /* Hide other items without breaking Monaco */
    opacity: 0;
    overflow: hidden;
    width: 1em;
    height: 1em; }
  html[transient-data-docking-area-component-mode~="maximized"] .docking-area-resizer {
    display: none; }
  html[transient-data-docking-area-component-mode~="maximized"] .docking-area-component {
    position: fixed !important;
    display: block;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important; }
  html[transient-data-docking-area-component-mode~="floating"] .docking-area-resizer {
    display: none; }
  html[transient-data-docking-area-component-mode~="floating"] .docking-area-component {
    position: fixed;
    display: block;
    top: 0;
    left: 0;
    width: 35em;
    height: 22em;
    overflow: auto;
    resize: both;
    z-index: 999999;
    box-sizing: border-box;
    border: 1px outset #ababab;
    box-shadow: 0.1em 0.1em 0.5em rgba(0, 0, 0, 0.15); }
  html[transient-data-docking-area-component-mode~="edge"] {
    overflow: hidden;
    display: flex; }
    html[transient-data-docking-area-component-mode~="edge"] > *:not(.docking-area--ignore) {
      flex: 1 1 auto;
      overflow: auto;
      contain: paint; }
    html[transient-data-docking-area-component-mode~="edge"] > .docking-area-resizer {
      flex: 0 0 auto;
      min-height: 1px;
      min-width: 1px;
      cursor: ew-resize;
      position: relative;
      margin: -2px;
      border: 2px solid transparent;
      contain: none;
      overflow: visible;
      z-index: 5; }
      html[transient-data-docking-area-component-mode~="edge"] > .docking-area-resizer:before {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(128, 128, 128, 0.5);
        content: ""; }
      html[transient-data-docking-area-component-mode~="edge"] > .docking-area-resizer:hover {
        margin: -0.5em;
        border: 0.5em solid transparent; }
        html[transient-data-docking-area-component-mode~="edge"] > .docking-area-resizer:hover:before {
          margin: -1px;
          border: 1px solid rgba(128, 128, 128, 0.1); }
    html[transient-data-docking-area-component-mode~="edge"] > .docking-area-component {
      contain: none;
      position: relative;
      flex: 0 0 auto;
      min-width: 20vw;
      min-height: 20vh; }
    html[transient-data-docking-area-component-mode~="edge"][transient-data-docking-area-component-mode~="left"] > .docking-area-resizer {
      order: -1; }
    html[transient-data-docking-area-component-mode~="edge"][transient-data-docking-area-component-mode~="left"] > .docking-area-component {
      order: -2;
      height: auto; }
    html[transient-data-docking-area-component-mode~="edge"][transient-data-docking-area-component-mode~="right"] > .docking-area-resizer {
      order: 1; }
    html[transient-data-docking-area-component-mode~="edge"][transient-data-docking-area-component-mode~="right"] > .docking-area-component {
      order: 2;
      height: auto; }
    html[transient-data-docking-area-component-mode~="edge"][transient-data-docking-area-component-mode~="bottom"] {
      flex-direction: column; }
      html[transient-data-docking-area-component-mode~="edge"][transient-data-docking-area-component-mode~="bottom"] > .docking-area-resizer {
        order: 1;
        cursor: ns-resize; }
      html[transient-data-docking-area-component-mode~="edge"][transient-data-docking-area-component-mode~="bottom"] > .docking-area-component {
        order: 2; }
  html .docking-area-visualizer {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 15em;
    height: 10em;
    background: rgba(10, 10, 255, 0.25);
    border: 1px solid rgba(0, 0, 255, 0.3);
    box-sizing: border-box;
    transition: all 0.1s;
    opacity: 0;
    display: block;
    pointer-events: none;
    z-index: 1000000; }
  html[transient-data-docking-area-component-drag~="dragging"] {
    overflow: hidden; }
    html[transient-data-docking-area-component-drag~="dragging"] .docking-area-visualizer {
      opacity: 1; }
    html[transient-data-docking-area-component-drag~="dragging"][transient-data-docking-area-component-drag~="float"] .docking-area-visualizer {
      opacity: 0;
      transition: none; }
    html[transient-data-docking-area-component-drag~="dragging"][transient-data-docking-area-component-drag~="left"] .docking-area-visualizer {
      left: 0 !important;
      top: 0 !important;
      right: 90% !important;
      bottom: 0 !important;
      width: auto;
      height: auto; }
    html[transient-data-docking-area-component-drag~="dragging"][transient-data-docking-area-component-drag~="right"] .docking-area-visualizer {
      left: 90% !important;
      right: 0 !important;
      top: 0 !important;
      bottom: 0 !important;
      width: auto;
      height: auto; }
    html[transient-data-docking-area-component-drag~="dragging"][transient-data-docking-area-component-drag~="bottom"] .docking-area-visualizer {
      left: 0 !important;
      right: 0 !important;
      top: 90% !important;
      bottom: 0 !important;
      width: auto;
      height: auto; }
    html[transient-data-docking-area-component-drag~="dragging"][transient-data-docking-area-component-drag~="maximized"] .docking-area-visualizer {
      left: 0 !important;
      top: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      width: auto;
      height: auto; }
</STYLE><SCRIPT id="edgedocker-component-script" type="disabled">
/**
 *  EdgeDocker
 *  Provides Developer-Console-like behaviour in browsers
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/**
 * @typedef {object} EdgeDocker~config
 * @property {Element} [parent=html] - The parent to attach the docker too.
 * @property {EdgeDocker.MODE} [mode=RIGHT] - The edge to attach too.
 */

/**
 * EdgeDocker can dock its container along the edges of the browser, just like Dev console does.
 */
class EdgeDocker {
    /**
     * Create a new EdgeDocker
     * @param {EdgeDocker~config} options
     */
    constructor(options) {
        let self = this;

        this.parent = WebstrateComponents.Tools.fromConfig(options, "parent", document.querySelector("html"));

        // Add the resizer and content areas
        this.resizeHandle = document.createElement("transient");
        this.resizeHandle.classList.add("docking-area-resizer");
        this.parent.appendChild(this.resizeHandle);
        this.componentArea = document.createElement("transient");
        this.componentArea.classList.add("docking-area-component");
        this.parent.appendChild(this.componentArea);
        this.visualizerHandle = document.createElement("transient");
        this.visualizerHandle.classList.add("docking-area-visualizer");
        this.parent.appendChild(this.visualizerHandle);

        this.dragging = false;

        // init resize
        this.setupResizeHandle(this.resizeHandle);
        this.setMode(WebstrateComponents.Tools.fromConfig(options, "mode", EdgeDocker.MODE.RIGHT));

        this.positionAnimationFrame = null;
        this.boundsAnimationFrame = null;

        let oldStyleWidth = null;
        let oldStyleHeight = null;

        //Crude observer to check for docker resizeing
        let observer = new MutationObserver(()=>{
            let doEvent = false;


            if(self.boundsAnimationFrame != null) {
                cancelAnimationFrame(this.boundsAnimationFrame);
                self.boundsAnimationFrame = null;
            }

            self.boundsAnimationFrame = requestAnimationFrame(()=>{
                if(self.componentArea.style.width != oldStyleWidth) {
                    doEvent = true;
                    oldStyleWidth = parseInt(self.componentArea.style.width);
                }

                if(self.componentArea.style.height != oldStyleHeight) {
                    doEvent = true;
                    oldStyleHeight = parseInt(self.componentArea.style.height);
                }

                if(doEvent) {
                    self.setBounds(parseInt(this.componentArea.style.left), parseInt(this.componentArea.style.top), oldStyleWidth, oldStyleHeight);
                    window.dispatchEvent(new Event('resize'));
                }
            });
        });

        observer.observe(this.componentArea, {
            attributes: true,
            attributeFilter: ["style"]
        });
    }

    setupResizeHandle() {
        let self = this;

        this.resizeAnimFrame = null;

        let preventEvents = ["move"];
        if(navigator.userAgent.toLowerCase().indexOf('firefox') > -1){
            preventEvents.push("down");
        }

        this.deltaWidth = 0;
        this.deltaHeight = 0;

        new CaviTouch(this.resizeHandle, {
            minDragDistance: 0
        });

        this.resizeHandle.addEventListener("caviDrag", (evt)=>{
            switch(self.currentMode) {
                case EdgeDocker.MODE.MAXIMIZED:
                    break;
                case EdgeDocker.MODE.BOTTOM:
                    self.deltaHeight -= evt.detail.caviEvent.deltaPosition.y;
                    break;
                case EdgeDocker.MODE.LEFT:
                    self.deltaWidth += evt.detail.caviEvent.deltaPosition.x;
                    break;
                case EdgeDocker.MODE.RIGHT:
                    self.deltaWidth -= evt.detail.caviEvent.deltaPosition.x;
                    break;
                case EdgeDocker.MODE.FLOAT:
                    self.deltaWidth += evt.detail.caviEvent.deltaPosition.x;
                    self.deltaHeight += evt.detail.caviEvent.deltaPosition.y;
                    break;
            }

            if(self.resizeAnimFrame === null) {
                cancelAnimationFrame(self.resizeAnimFrame);
            }
            self.resizeAnimFrame = requestAnimationFrame(()=>{
                self.resizeAnimFrame = null;
                let width = self.componentArea.offsetWidth + self.deltaWidth;
                let height = self.componentArea.offsetHeight + self.deltaHeight;

                self.deltaWidth = 0;
                self.deltaHeight = 0;

                this.setBounds(parseInt(this.componentArea.style.left), parseInt(this.componentArea.style.top), width, height);
                /*
                self.componentArea.style.width = width+"px";
                self.componentArea.style.height = height+"px";
                */
            });
        });
    }

    setupDragHandle(element) {
        let self = this;

        new CaviTouch(element, {
            preventDefaultEvents: []
        });

        let currentSelectedMode = null;
        let oldSelectedMode = null;

        let currentX = 0;
        let currentY = 0;

        element.addEventListener("caviDoubleTap", ()=>{
            if(self.currentMode !== EdgeDocker.MODE.MAXIMIZED){
                self.setMode(EdgeDocker.MODE.MAXIMIZED);
            } else {
                self.setMode(EdgeDocker.MODE.FLOAT);
            }
        });

        element.addEventListener("caviDragStart", (evt)=>{
            self.dragging = true;

            oldSelectedMode = self.currentMode;

            if(self.currentMode !== EdgeDocker.MODE.FLOAT) {
                self.setMode(EdgeDocker.MODE.FLOAT);

                let bounds = element.getBoundingClientRect();

                self.setPosition(evt.detail.caviEvent.position.x-bounds.width / 2.0, evt.detail.caviEvent.position.y-bounds.height / 2.0, true);
            }

            self.parent.setAttribute("transient-data-docking-area-component-drag", "dragging");

            let bounds = self.componentArea.getBoundingClientRect();
            currentX = bounds.x;
            currentY = bounds.y;
        });

        element.addEventListener(("caviDrag"), (evt)=>{
            let percentWidth = self.parent.offsetWidth * 0.1;
            let percentHeight = self.parent.offsetHeight * 0.1;

            currentX += evt.detail.caviEvent.deltaPosition.x;
            currentY += evt.detail.caviEvent.deltaPosition.y;

            if(evt.detail.caviEvent.position.x < percentWidth) {
                self.parent.setAttribute("transient-data-docking-area-component-drag", "dragging left");
                currentSelectedMode = EdgeDocker.MODE.LEFT;
            } else if(self.parent.offsetWidth - evt.detail.caviEvent.position.x < percentWidth) {
                self.parent.setAttribute("transient-data-docking-area-component-drag", "dragging right");
                currentSelectedMode = EdgeDocker.MODE.RIGHT;
            } else if(evt.detail.caviEvent.position.y - self.parent.scrollTop < percentHeight) {
                self.parent.setAttribute("transient-data-docking-area-component-drag", "dragging maximized");
                currentSelectedMode = EdgeDocker.MODE.MAXIMIZED;
            } else if(self.parent.offsetHeight - (evt.detail.caviEvent.position.y - self.parent.scrollTop) < percentHeight) {
                self.parent.setAttribute("transient-data-docking-area-component-drag", "dragging bottom");
                currentSelectedMode = EdgeDocker.MODE.BOTTOM;
            } else {
                self.parent.setAttribute("transient-data-docking-area-component-drag", "dragging float");
                currentSelectedMode = EdgeDocker.MODE.FLOAT;
            }

            self.setPosition(currentX, currentY);
        });

        element.addEventListener("caviDragStop", (evt)=>{

            self.setMode(currentSelectedMode, false);

            if(oldSelectedMode !== currentSelectedMode) {
                self.saveMode();
            }

            if(currentSelectedMode === EdgeDocker.MODE.FLOAT) {
                self.saveBounds(currentSelectedMode, true);
            }

            self.parent.setAttribute("transient-data-docking-area-component-drag", "");

            if(currentSelectedMode === EdgeDocker.MODE.FLOAT) {
                self.setPosition(currentX, currentY, true);
            }

            setTimeout(()=>{
                self.dragging = false;
            });
        });

        element.style.cursor = "move";
    }

    /**
     * Sets the position of this EdgeDocker, Ignored if not in FLOAT mode
     * @param {Number} x
     * @param {Number} y
     */
    setPosition(x, y, immediately=false) {
        if(this.currentMode === EdgeDocker.MODE.FLOAT) {
            let self = this;

            if(this.positionAnimationFrame != null) {
                cancelAnimationFrame(this.positionAnimationFrame);
                this.positionAnimationFrame = null;
            }

            if(immediately) {
                self.componentArea.style.left = x + "px";
                self.componentArea.style.top = y + "px";
                self.visualizerHandle.style.left = x + "px";
                self.visualizerHandle.style.top = y + "px";
            } else {
                this.positionAnimationFrame = requestAnimationFrame(()=>{
                    if(self.currentMode === EdgeDocker.MODE.FLOAT) {
                        self.componentArea.style.left = x + "px";
                        self.componentArea.style.top = y + "px";
                        self.visualizerHandle.style.left = x + "px";
                        self.visualizerHandle.style.top = y + "px";
                    }
                });
            }
        }
    }

    /**
     * Sets the bounds of this EdgeDocker
     * @param {Number} x
     * @param {Number} y
     * @param {Number} width
     * @param {Number} height
     * @param {boolean} [doSave=true] - Determines if the bounds should be saved or not
     */
    setBounds(x, y, width, height, doSave = true) {
        this.setPosition(x, y, true);

        let maxWidth = this.parent.offsetWidth * 0.8;
        let maxHeight = this.parent.offsetHeight * 0.8;

        width = Math.min(width, maxWidth);
        height = Math.min(height, maxHeight);

        switch(this.currentMode) {
            case EdgeDocker.MODE.LEFT:
            case EdgeDocker.MODE.RIGHT:
                //Only Set Width
                this.componentArea.style.width = width + "px";
                break;

            case EdgeDocker.MODE.BOTTOM:
                //Only Set height
                this.componentArea.style.height = height + "px";
                break;

            case EdgeDocker.MODE.FLOAT:
                //Set Width and Height
                this.componentArea.style.width = width + "px";
                this.componentArea.style.height = height + "px";
                break;
        }

        if(doSave) {
            this.saveBounds(this.currentMode);
        }
    }

    /**
     * Sets the current dock mode of this EdgeDocker
     * @param {EdgeDocker.MODE} mode
     * @param {boolean} [doLoad=true] - Determines if this setMode should load bounds from storage or not.
     */
    setMode(mode, doLoad = true){
        let oldWidth = parseInt(this.componentArea.style.height);
        let oldHeight = parseInt(this.componentArea.style.width);
        let oldMode = this.currentMode;

        this.parent.setAttribute("transient-data-docking-area-component-mode", mode);
        this.currentMode = mode;

        if(this.currentMode === EdgeDocker.MODE.MAXIMIZED || this.currentMode === EdgeDocker.MODE.EMBEDDED) {
            this.componentArea.style.width = "";
            this.componentArea.style.height = "";
        } else if(this.currentMode === EdgeDocker.MODE.LEFT || this.currentMode === EdgeDocker.MODE.RIGHT) {
            this.componentArea.style.height = "";
            this.componentArea.style.width = (this.parent.offsetWidth*0.5)+"px"; //Overidden if any saved mode exists
        } else if(this.currentMode === EdgeDocker.MODE.BOTTOM) {
            this.componentArea.style.width = "";
            this.componentArea.style.height = (this.parent.offsetHeight*0.33)+"px"; //Overidden if any saved mode exists
        } else if(this.currentMode === EdgeDocker.MODE.FLOAT && oldMode !== EdgeDocker.MODE.FLOAT) {
            this.componentArea.style.width = "";
            this.componentArea.style.height = "";
        }

        if (this.currentMode !== EdgeDocker.MODE.FLOAT){
            this.componentArea.style.top = null;
            this.componentArea.style.left = null;
        }

        if(doLoad) {
            this.loadBounds(this.currentMode);
        }

        window.dispatchEvent(new Event('resize'));
    }

    dockInto(parentElement){
        if (parentElement){
            // Move into the element if one is given
            parentElement.appendChild(this.componentArea);
        } else {
            // Default to being shown before the visualizer
            this.visualizerHandle.parentElement.insertBefore(this.componentArea, this.visualizerHandle);
        }
    }

    loadBounds(mode) {
        let key = location.pathname + "_" + mode;

        let bounds = localStorage.getItem(key);

        if(bounds != null) {
            try {
                bounds = JSON.parse(bounds);
                this.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);
            } catch(e) {
                console.error(e);
            }
        }
    }

    saveBounds(mode, forceSave = false) {
        if(this.dragging && !forceSave) {
            return;
        }

        let key = location.pathname + "_" + mode;

        let bounds = this.componentArea.getBoundingClientRect();

        localStorage.setItem(key, JSON.stringify(bounds));
    }

    /**
     * Save the current mode
     */
    saveMode() {
        let key = location.pathname + "_Mode";
        localStorage.setItem(key, this.currentMode);
    }

    /**
     * Load the saved mode, or use fallback if no saved mode
     * @param {EdgeDocker.MODE} fallback - The mode to use if none is saved.
     */
    loadMode(fallback) {
        let key = location.pathname + "_Mode";
        let mode = localStorage.getItem(key);
        if(mode != null) {
            this.setMode(mode);
        } else {
            this.setMode(fallback);
        }
    }

    /**
     * Fetch the component area where DOM elements can be added to this EdgeDocker
     * @returns {HTMLElement}
     */
    getComponentArea(){
        return this.componentArea;
    }
}

/**
 * The supported modes of EdgeDocker
 * @readonly
 * @enum
 */
EdgeDocker.MODE = {
    MAXIMIZED: "maximized",
    MINIMIZED: "minimized",
    LEFT: "left edge",
    RIGHT: "right edge",
    BOTTOM: "bottom edge",
    FLOAT: "floating",
    EMBEDDED: "embedded"
};

window.EdgeDocker = EdgeDocker;

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="webstrate-components-repos" id="TreeBrowser" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Tree Browser",
    "description": "Generic component for rendering tree-like navigation structures",
    "dependencies": [
        "wpm_js_libs #material-design-components",
        "wpm_js_libs #material-design-icons",
        "wpm_js_libs #CaviDraggableHTML5",
        "wpm_js_libs #CaviTouch",
        "wpm_js_libs #UUIDGenerator",
        "#WebstrateComponents_Tools",
        "#wsc-icon-registry",
        "codestrates-repos #EventSystem"
    ],
    "assets": [],
    "version": "1.0",
    "license": "Apache 2.0",
    "changelog": {
        "1.0": "Initial version"
    }
}

</SCRIPT><STYLE id="mdc-treebrowser-style">
/**
 *  TreeBrowser Styles
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
@keyframes tree-browser-children-appear {
  from {
    opacity: 0;
    transform: translateX(-1em); }
  to {
    opacity: 1;
    transform: translateX(0); } }

@keyframes tree-browser-hoveractions-appear {
  from {
    opacity: 0; }
  to {
    opacity: 1; } }

ul.tree-browser {
  padding: 0;
  user-select: none; }
  ul.tree-browser .tree-browser-children {
    display: none;
    padding-left: 0.75em;
    padding-bottom: 0.1em; }

.tree-browser-node {
  height: 1.5em;
  align-items: center;
  padding: 0;
  contain: paint;
  overflow: hidden; }
  .tree-browser-node .rippley {
    width: 100%;
    position: absolute;
    left: 0;
    height: 100%;
    top: 0;
    overflow: hidden;
    pointer-events: none; }
  .tree-browser-node .mdc-list-item__graphic {
    margin-right: 0em; }
    .tree-browser-node .mdc-list-item__graphic .tree-browser-custom-icon {
      max-width: 24px;
      max-height: 80%; }
      .tree-browser-node .mdc-list-item__graphic .tree-browser-custom-icon .wsc-registry-icon {
        height: auto; }
  .tree-browser-node .tree-browser-navigator {
    transition: transform 0.1s ease-out; }
  .tree-browser-node .mdc-list-item__text {
    font-size: 0.8em;
    margin-left: 0.4em; }
  .tree-browser-node .tree-browser-hoveractions {
    display: none;
    width: initial;
    animation: 0.1s tree-browser-hoveractions-appear ease-out; }
  .tree-browser-node:hover > .tree-browser-hoveractions, .tree-browser-node:focus > .tree-browser-hoveractions {
    display: block; }
  .tree-browser-node .tree-browser-icons {
    display: flex;
    position: relative; }
  .tree-browser-node .tree-browser-icon {
    display: flex;
    margin: 0.1em; }
    .tree-browser-node .tree-browser-icon .tree-browser-icon-unfolded {
      display: none; }
  .tree-browser-node.tree-browser-unfolded > .tree-browser-navigator {
    transform: rotate(90deg); }
  .tree-browser-node.tree-browser-unfolded + li.tree-browser-children {
    display: block; }
  .tree-browser-node.tree-browser-unfolded .tree-browser-icon .tree-browser-icon-unfolded {
    display: initial; }
  .tree-browser-node.tree-browser-unfolded .tree-browser-icon .tree-browser-icon-closed {
    display: none; }
  .tree-browser-node.tree-browser-node-hidden {
    display: none; }
    .tree-browser-node.tree-browser-node-hidden + li.tree-browser-children {
      padding-left: 0; }

.tree-browser-modifier {
  position: absolute;
  top: 0;
  left: 0;
  filter: drop-shadow(1px 1px 2px white); }
  .tree-browser-modifier.tree-browser-modifier-a {
    transform: translate(45%, -30%) scale(0.4); }
  .tree-browser-modifier.tree-browser-modifier-b {
    transform: translate(-50%, -30%) scale(0.4); }

/* Playground */
.mdc-list-item::before {
  pointer-events: none; }
</STYLE><SCRIPT id="TreeBrowser-script" type="disabled">
/**
 *  TreeBrowser
 *  A navigation tool for presenting data as tree structures
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global mdc */

/**
 * Called when a TreeNode is selected in a TreeBrowser
 *
 * @event TreeBrowser#EventSystem:"TreeBrowser.Selection"
 * @type {CustomEvent}
 * @property {TreeNode} selection - The selected TreeNode
 */

/**
 * Called when a TreeNode's action is triggered. (Ie. double click it)
 *
 * @event TreeNode#EventSystem:"TreeBrowser.TreeNode.Action"
 * @type {CustomEvent}
 * @property {TreeNode} node - The node which had its action triggered
 */

/**
 * TreeBrowser can take a TreeNode and construct a browsable tree
 */
class TreeBrowser {
    /**
     * Create a TreeBrowser with the given TreeNode as root
     *
     * @param {TreeNode} rootNode
     * @param {TreeBrowser~options} options
     */
    constructor(rootNode) {
        let self = this;

        /** @member {TreeNode} - The root node used to build the tree */
        this.rootNode = rootNode;

        /** @member {Element} - The DOM Element of this Tree */
        this.html = WebstrateComponents.Tools.loadTemplate("TreeBrowser_Main");

        /** @member {MDCList} - The MDCList object from Material Design */
        this.mdcList = new mdc.list.MDCList(this.html);
        this.mdcList.singleSelection = true;

        this.html.mdcList = this.mdcList;

        this.mdcList.listen("MDCList:action", (evt)=>{
            let listItem = self.mdcList.listElements[evt.detail.index];

            EventSystem.triggerEvent("TreeBrowser.Selection", {
                selection: listItem.treeNode
            });
        });

        this.rootNode.insertIntoDom(this.html, null);

        this.rootNode.treeBrowser = this;

        this.html.treeBrowser = this;

        this.html.addEventListener("keyup", (evt)=>{
            let selectedItem = self.mdcList.listElements[self.mdcList.selectedIndex];

            if(selectedItem == null) {
                return;
            }

            EventSystem.triggerEvent("TreeBrowser.Keyup", {
                evt: evt,
                treeNode: selectedItem.treeNode
            });

            if(evt.key === "Enter") {
                selectedItem.treeNode.triggerAction();
            } else if(evt.key === "ArrowRight") {
                selectedItem.treeNode.unfold();
            } else if(evt.key === "ArrowLeft") {
                selectedItem.treeNode.fold();
            } else if(evt.key === "ArrowDown") {
                let focusedItem = self.mdcList.listElements[self.mdcList["foundation"].adapter.getFocusedElementIndex()];
                if(focusedItem != null) {
                    self.setSelected(focusedItem.treeNode);
                }
            } else if(evt.key === "ArrowUp") {
                let focusedItem = self.mdcList.listElements[self.mdcList["foundation"].adapter.getFocusedElementIndex()];
                if(focusedItem != null) {
                    self.setSelected(focusedItem.treeNode);
                }
            }
        });

        this.html.addEventListener("keydown", (evt)=>{
            let selectedItem = self.mdcList.listElements[self.mdcList.selectedIndex];

            if(selectedItem == null) {
                return;
            }

            EventSystem.triggerEvent("TreeBrowser.Keydown", {
                evt: evt,
                treeNode: selectedItem.treeNode
            });
        });
    }

    /**
     * Sets the given TreeNode as the current selection
     * @param {TreeNode} treeNode
     */
    setSelected(treeNode) {
        let index = -1;

        let i = 0;
        this.html.mdcList.listElements.forEach((elm)=>{
            if(elm === treeNode.html) {
                index = i;
            }

            i++;
        });

        if(index !== -1) {
            this.mdcList.selectedIndex = index;
            this.mdcList.foundation.adapter.focusItemAtIndex(index);
            EventSystem.triggerEvent("TreeBrowser.Selection", {
                selection: treeNode
            });
        }
    }

    /**
     * Finds all TreeNode's that has the given context
     * @param context
     * @returns {TreeNode[]}
     */
    findTreeNodeForContext(context) {
        function lookupContext(node) {
            let foundNodes = [];

            if(node.context === context) {
                foundNodes.push(node);
            }

            for(let child of node.childNodes) {
                foundNodes.push(...lookupContext(child));
            }

            return foundNodes;
        }

        return lookupContext(this.rootNode);
    }

    /**
     * Finds all TreeNodes that have the given lookupKey
     * @param key
     * @returns {TreeNode[]}
     */
    findTreeNode(lookupKey) {
        function lookupTheLookupKey(node) {
            let foundNodes = [];

            if(node.lookupKey === lookupKey) {
                foundNodes.push(node);
            }

            for(let child of node.childNodes) {
                foundNodes.push(...lookupTheLookupKey(child));
            }

            return foundNodes;
        }

        return lookupTheLookupKey(this.rootNode);
    }

    /**
     * Find all TreeBrowsers currently in the DOM
     * @returns {TreeBrowser[]}
     */
    static findAllTreeBrowsers() {
        return Array.from(document.querySelectorAll(".tree-browser-root")).map((dom)=>{
            return dom.treeBrowser;
        });
    }
}

window.TreeBrowser = TreeBrowser;

/**
 * @typedef {Object} TreeNode~config
 * @property {string} type - The type of this TreeNode, ex. "DomTreeNode", "AssetNode", "AssetRootNode"
 * @property {*} context - The context of this TreeNode
 * @property {boolean} [alwaysOpen=false] - If this TreeNode should stay unfolded
 * @property {*} [lookupKey=context] - The lookupkey to use when TreeGenerator saves this TreeNode for later lookup
 * @property {boolean} [startOpen=false] - If this TreeNode should start unfolded
 * @property {boolean} [hideSelf=false] - If this TreeNode should be hidden.
 */

/**
 * Represents a tree node
 */
class TreeNode {
    /**
     * Create a new TreeNode with the given configuration
     * @param {TreeNode~config} config - The configuration for this TreeNode
     */
    constructor(config) {
        let self = this;

        this.config = config;

        /** @memeber {string} - The type of this TreeNode */
        this.type = this.getProperty("type");
        /** @memeber {*} - The context of this TreeNode */
        this.context = this.getProperty("context");

        /** @memeber {boolean} - If this TreeNode should always stay unfolded */
        this.alwaysOpen = this.getProperty("alwaysOpen", false);

        this.startOpen = this.getProperty("startOpen", false);

        this.lookupKey = this.getProperty("lookupKey", this.context);

        /** @member {TreeNode[]} - The children of this TreeNode */
        this.childNodes = [];

        /** @member {Element} - The DOM Element of this TreeNode */
        this.html = WebstrateComponents.Tools.loadTemplate("TreeBrowser_Leaf");
        this.html.treeNode = this;

        this.hideSelf = this.getProperty("hideSelf", false);

        this.childrenHtml = WebstrateComponents.Tools.loadTemplate("TreeBrowser_Children");
        this.childrenUl = this.childrenHtml.querySelector("ul.tree-browser");

        /** @member {TreeNode} - The parent node of this TreeNode */
        this.parentNode = null;

        /** @member {Element[]} - Meta icons of this TreeNode */
        this.metaIcons = [];

        this.html.addEventListener("mouseup", (evt)=>{
            if(evt.button === 2) {
                self.select();
            }
        });

        this.onDecoratedCallbacks = new Set();

        self.html.querySelector(".tree-browser-navigator").addEventListener("click", ()=>{
            if(!self.isLeaf()) {
                if(self.alwaysOpen) {
                    self.unfold();
                } else {
                    self.toggleFold();
                }
            }
        });

        if(this.startOpen) {
            this.unfold();
            console.log("Opening up!");
        } else {
            this.fold();
        }

        this.setupContextMenu();

        this.setupMetaMenu();

        this.setupDragging();

        this.render();

        this.setupClickListeners();
    }

    get hideSelf() {
        return this.html.classList.contains("tree-browser-node-hidden");
    }

    set hideSelf(hide) {
        if(hide) {
            this.html.classList.add("tree-browser-node-hidden");
        } else {
            this.html.classList.remove("tree-browser-node-hidden");
        }
    }

    /**
     * Return the TreeBrowser at the top of the tree this TreeNode is in, if any
     * @returns {null|TreeBrowser}
     */
    getTreeBrowser() {
        if(this.treeBrowser != null) {
            return this.treeBrowser;
        } else if(this.parentNode != null) {
            return this.parentNode.getTreeBrowser();
        }

        return null;
    }

    /**
     * @private
     * @param parent
     */
    insertIntoDom(parent) {
        parent.appendChild(this.html);
        parent.insertBefore(this.childrenHtml, this.html.nextElementSibling);
    }

    /**
     * @private
     */
    removeFromDom() {
        this.html.remove();
        this.childrenHtml.remove();
        if(this.nextAnimFrame != null) {
            cancelAnimationFrame(this.nextAnimFrame);
            this.nextAnimFrame = null;
        }
    }

    /**
     * Retrieve the value of the given property
     * @param {String} propertyName
     * @param {*} [defaultValue] - The default value if the property does not exist
     * @returns {*}
     */
    getProperty(propertyName, defaultValue = null) {
        return WebstrateComponents.Tools.fromConfig(this.config, propertyName, defaultValue);
    }

    /**
     * Sets the value of the given property
     * @param {String} propertyName
     * @param {*} value
     */
    setProperty(propertyName, value) {
        this.config[propertyName] = value;
    }

    /**
     * Add a meta icon to this TreeNode
     * @param {*} icon
     */
    addMetaIcon(icon) {
        this.metaIcons.push(icon);
        this.render();
    }

    /**
     * Remove a meta icon from this TreeNode
     * @param {*} icon
     */
    removeMetaIcon(icon) {
        this.metaIcons.splice(this.metaIcons.indexOf(icon),1);
        this.render();
    }

    /**
     * Add a child node to this node at a given index
     * @param {Number} index
     * @param {TreeNode} node
     */
    addNode(node, index = -1) {
        node.parentNode = this;

        if(this.isFolded()) {
            node.html.classList.remove("mdc-list-item");
        } else {
            node.html.classList.add("mdc-list-item");
        }

        if(index === -1) {
            this.childNodes.push(node);
        } else {
            this.childNodes.splice(index, 0, node);
        }

        this.updateChildren();
    }

    /**
     * Remove a child node from this node
     * @param {TreeNode} node
     */
    removeNode(node) {
        if(this.childNodes.indexOf(node) !== -1) {
            this.childNodes.splice(this.childNodes.indexOf(node), 1);
            node.removeFromDom();
        }
    }

    /**
     * Removes all child nodes from this TreeNode
     */
    clearNodes() {
        let self = this;
        let childNodeClone = this.childNodes.slice();
        childNodeClone.forEach((child)=>{
            self.removeNode(child);
        });
    }

    /**
     * Checks if this TreeNode has any children
     * @returns {boolean} True/False depending on if this TreeNode has any children
     */
    isLeaf() {
        let visibleChildNodes = this.childNodes.filter((child)=>{
            return !child.hideSelf;
        });

        return visibleChildNodes.length === 0;
    }

    /**
     * Unfold this TreeNode
     */
    unfold() {
        if(!this.isLeaf()) {
            this.html.classList.add("tree-browser-unfolded");

            this.childNodes.forEach((child)=>{
                child.html.classList.add("mdc-list-item");
            });
        }
    }

    /**
     * Fold this TreeNode
     */
    fold() {
        if(this.alwaysOpen) {
            return;
        }

        this.html.classList.remove("tree-browser-unfolded");

        this.childNodes.forEach((child)=>{
            child.html.classList.remove("mdc-list-item");
        });
    }

    /**
     * Toggle fold state of this TreeNode
     */
    toggleFold() {
        if(this.html.classList.contains("tree-browser-unfolded")) {
            this.fold();
        } else {
            this.unfold();
        }
    }

    /**
     * Check wether this TreeNode is folded or unfolded
     * @returns {boolean} - True of this TreeNode is folded, false if unfolded
     */
    isFolded() {
        return !this.html.classList.contains("tree-browser-unfolded");
    }

    /**
     * Make this TreeNode the selected node in the tree
     */
    select() {
        let self = this;

        let treeBrowser = this.getTreeBrowser();

        if(treeBrowser != null) {
            treeBrowser.setSelected(this);
            EventSystem.triggerEvent("TreeBrowser.Selection", {
                selection: self
            });
        }
    }

    /**
     * Make this TreeNode and all parent TreeNode's unfold,
     */
    reveal() {
        this.unfold();

        if(this.parentNode != null) {
            this.parentNode.reveal();
        }
    }

    /**
     * Called when we are removed from the tree
     */
    onRemoved() {
        this.removeFromDom();
    }

    /**
     * Called when this TreeNode has been decorated
     */
    onDecorated() {
        let self = this;

        this.render();

        this.onDecoratedCallbacks.forEach((callback)=>{
            callback(self);
        });
    }

    /**
     * @private
     */
    setupContextMenu() {
        let self = this;

        if(window.MenuSystem != null) {
            this.html.addEventListener("contextmenu", (evt)=>{
                evt.preventDefault();
            });

            let contextMenu = null;

            this.html.addEventListener("mouseup", (evt)=>{
                if(evt.button !== 2) {
                    return;
                }
                self.select();

                //Find top component after html
                let parent = self.html;
                while(parent.parentNode != null && !parent.parentNode.matches("html")) {
                    parent = parent.parentNode;
                }

                //Setup context menus
                if(contextMenu == null) {
                    contextMenu = MenuSystem.MenuManager.createMenu("TreeBrowser.TreeNode.ContextMenu", {
                        context: self,
                        groupDividers: true
                    });

                    contextMenu.registerOnCloseCallback(() => {
                        if (contextMenu.html.parentNode != null) {
                            contextMenu.html.parentNode.removeChild(contextMenu.html);
                        }
                    });
                }

                parent.appendChild(contextMenu.html);
                contextMenu.open({
                    x: evt.pageX,
                    y: evt.pageY
                });
                evt.stopPropagation();
                evt.preventDefault();
            });
        }
    }

    /**
     * @private
     */
    updateChildren() {
        let self = this;

        this.render();

        if(this.updateChildrenAnimFrame != null) {
            return;
        }

        this.updateChildrenAnimFrame = requestAnimationFrame(()=>{
            //Reinsert all nodes?
            self.childNodes.forEach((child)=>{
                child.insertIntoDom(self.childrenUl);
            });

            self.updateChildrenAnimFrame = null;
        });
    }

    /**
     * @private
     */
    render() {
        let self = this;

        if(this.nextAnimFrame != null) {
            //We are already scheduled to render
            return;
        }

        this.nextAnimFrame = requestAnimationFrame(()=>{
            let content = self.getProperty("content");

            let contentContainer = self.html.querySelector(":scope > .tree-browser-content");
            while(contentContainer.lastChild) contentContainer.lastChild.remove();

            if(content != null) {
                if (typeof content === "string") {
                    contentContainer.textContent = content;
                } else if (content instanceof Element) {
                    contentContainer.appendChild(content);
                } else {
                    contentContainer.textContent = "Unknown 'content' [" + (typeof content) + "]:[" + JSON.stringify(content) + "]";
                }
            }

            // Tooltips
            let tooltip = self.getProperty("tooltip");
            if (tooltip != null){
                self.html.setAttribute("title", tooltip);
            }

            let icon = self.getProperty("icon");

            let iconContainer = self.html.querySelector(":scope > .tree-browser-icons");

            let oldIcon = iconContainer.querySelector(".tree-browser-icon");
            if(oldIcon != null) {
                oldIcon.remove();
            }

            if(icon != null) {
                if(typeof icon === "string") {
                    //Probabely wrong!
                    let textSpan = document.createElement("span");
                    textSpan.textContent = icon;
                    icon = textSpan;
                }

                icon.classList.add("tree-browser-icon");
                iconContainer.append(icon);
            }

            ["a", "b", "c", "d"].forEach((modifierType)=>{
                //Remove old modifier
                let oldModifier = iconContainer.querySelector(".tree-browser-modifier-"+modifierType);

                if(oldModifier != null) {
                    oldModifier.remove();
                }

                let modifier = self.getProperty("modifier-"+modifierType);

                if(modifier != null) {
                    let tpl = WebstrateComponents.Tools.loadTemplate("TreeBrowser_Modifier");
                    tpl.classList.add("tree-browser-modifier-"+modifierType);

                    if(typeof modifier === "string") {
                        let textSpan = document.createElement("span");
                        textSpan.textContent = modifier;
                        modifier = textSpan;
                    }

                    tpl.appendChild(modifier);

                    iconContainer.appendChild(tpl);
                }
            });

            let metaIconContainer = self.html.querySelector(":scope > .mdc-list-item__meta");
            while(metaIconContainer.lastChild) metaIconContainer.lastChild.remove();

            self.metaIcons.forEach((icon)=>{
                metaIconContainer.appendChild(icon);
            });

            if(self.isLeaf()) {
                if(!self.html.classList.contains("tree-browser-leaf")) {
                    self.html.querySelector(".tree-browser-navigator").innerHTML = "";
                    self.html.classList.add("tree-browser-leaf");
                }

                this.fold();
            } else {
                if(self.html.classList.contains("tree-browser-leaf")) {
                    let icon = (IconRegistry.createIcon("mdc:chevron_right"));
                    self.html.querySelector(".tree-browser-navigator").appendChild(icon);
                    self.html.classList.remove("tree-browser-leaf");
                }

                if(self.alwaysOpen) {
                    self.unfold();
                }
            }

            self.nextAnimFrame = null;
        });
    }

    /**
     * @private
     */
    setupDragging() {
        let self = this;

        let uuid = UUIDGenerator.generateUUID();

        this.html.setAttribute("transient-drag-id", uuid);

        let hoverStartTime = -1;

        new CaviDraggableHTML5(this.html, {
            onDragStart: (evt)=>{
                evt.dataTransfer.setData("treenode/href", location.href);
                evt.dataTransfer.setData("treenode/uuid", uuid);
                evt.dataTransfer.setData("treenodedata/uuid|"+uuid, "");
                TreeGenerator.decorateDataTransfers(self, evt.dataTransfer);
            },
            onDragComplete: (evt)=>{
                if(evt.dataTransfer.dropEffect !== "none") {
                    EventSystem.triggerEvent("TreeBrowser.TreeNode.DragEnd", {
                        draggedNode: self,
                        dropEffect: evt.dataTransfer.dropEffect,
                        dragEvent: evt
                    });
                }
            }
        });

        new CaviDroppableHTML5(this.html, {
            onDragLeave: (evt)=>{
                hoverStartTime = -1;
                EventSystem.triggerEvent("TreeBrowser.TreeNode.DragLeave", {
                    node: self,
                    dragEvent: evt
                });
            },
            onDragOver: (evt)=>{
                evt.dataTransfer.dropEffect = "none";

                if(hoverStartTime === -1) {
                    hoverStartTime = Date.now();
                }

                let hoverTime = Date.now() - hoverStartTime;

                if(hoverTime > 1000) {
                    self.unfold();
                }

                EventSystem.triggerEvent("TreeBrowser.TreeNode.DragOver", {
                    node: self,
                    dragEvent: evt
                });
            },
            onDrop: (evt, dropEffect)=>{
                let otherWebstrate = null;

                if(evt.dataTransfer.types.includes("treenode/href")) {
                    otherWebstrate = evt.dataTransfer.getData("treenode/href");
                }

                if(evt.dataTransfer.types.includes("treenode/uuid")) {
                    try {
                        let dragUUID = evt.dataTransfer.getData("treenode/uuid");
                        let dragged = document.querySelector("[transient-drag-id='" + dragUUID + "']");
                        if (dragged != null && dragged.treeNode != null) {
                            EventSystem.triggerEvent("TreeBrowser.TreeNode.Dropped", {
                                draggedNode: dragged.treeNode,
                                droppedNode: self,
                                dropEffect: dropEffect,
                                otherWebstrate: otherWebstrate,
                                dragEvent: evt
                            });
                            return;
                        }
                    } catch(e) {
                        console.log("Error accepting drop as treenode/uuid", );
                    }
                }

                if(evt.dataTransfer.types.includes("Files")) {
                    try {
                        EventSystem.triggerEvent("TreeBrowser.Files.Dropped", {
                            files: evt.dataTransfer.files,
                            droppedNode: self,
                            otherWebstrate: otherWebstrate,
                            dragEvent: evt
                        });

                        return;
                    } catch(e) {
                        console.log("Error accepting drop as Files", e);
                    }
                }

                if(evt.dataTransfer.types.includes("treenode/asset")) {
                    try {
                        let assetUrl = evt.dataTransfer.getData("treenode/asset");
                        EventSystem.triggerEvent("TreeBrowser.Asset.Dropped", {
                            assetUrl: assetUrl,
                            droppedNode: self,
                            otherWebstrate: otherWebstrate,
                            dragEvent: evt
                        });

                        return;
                    } catch(e) {
                        console.log("Error accepting drop as Asset", e);
                    }
                }

                if(evt.dataTransfer.types.includes("text/plain")) {
                    try {
                        let text = evt.dataTransfer.getData("text/plain");

                        let tpl = document.createElement("template");
                        tpl.innerHTML = text;

                        WPMv2.stripProtection(tpl.content);

                        EventSystem.triggerEvent("TreeBrowser.DomFragment.Dropped", {
                            fragment: tpl.content,
                            droppedNode: self,
                            otherWebstrate: otherWebstrate,
                            dragEvent: evt
                        });

                        return;
                    } catch(e) {
                        console.log("Error accepting drop as text/plain", e);
                    }
                }

                console.log("No supported data transfers:", evt.dataTransfer.types.slice());

                evt.dataTransfer.types.forEach((type)=>{
                    console.log(type, evt.dataTransfer.getData(type));
                });
            }
        });
    }

    /**
     * @private
     */
    setupClickListeners() {
        let self = this;
        this.html.addEventListener("dblclick", ()=>{
            self.triggerAction();
        });
    }

    /**
     * Trigger the action listeners of this TreeNode
     */
    triggerAction() {
        let preventDefault = EventSystem.triggerEvent("TreeBrowser.TreeNode.Action", {
            node: this,
            treeBrowser: this.getTreeBrowser()
        });

        if(!preventDefault && !this.alwaysOpen) {
            this.toggleFold();
        }
    }

    registerOnDecoratedCallback(callback) {
        this.onDecoratedCallbacks.add(callback);
    }

    deregisterOnDecoratedCallback(callback) {
        this.onDecoratedCallbacks.delete(callback);
    }

    setupMetaMenu() {
        this.metaMenu = MenuSystem.MenuManager.createMenu("TreeBrowser.TreeNode.MetaMenu", {
            context: this.context,
            keepOpen: true,
            layoutDirection: MenuSystem.Menu.LayoutDirection.HORIZONTAL,
            layoutWrapping: false,
            layoutCompact: true,
            defaultFocusState: mdc.menu.DefaultFocusState.NONE
        });

        this.addMetaIcon(this.metaMenu.html);
    }
}

window.TreeNode = TreeNode;

</SCRIPT><SCRIPT id="TreeGenerator-script" type="disabled">
/**
 *  TreeGenerator
 *  Superclass for generators of trees
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/**
 * A generator that builds trees from some context
 * @abstract
 */
class TreeGenerator {
    /**
     * Create a new TreeGenerator
     */
    constructor() {
        this.treeNodeLookup = new Map();
    }

    /**
     * Lookup the TreeNode associated with lookupKey
     * @param {*} lookupKey
     * @returns {TreeNode} The found TreeNode or null if no TreeNode could be found
     * @protected
     */
    lookupTreeNode(lookupKey) {
        return this.treeNodeLookup.get(lookupKey);
    }

    /**
     * Save the reference from lookupKey to TreeNode
     * @param {TreeNode} node - The TreeNode to save
     * @protected
     */
    saveTreeNode(node) {
        this.treeNodeLookup.set(node.lookupKey, node);
    }

    /**
     * Remove the reference from lookupKey to TreeNode
     * @param {TreeNode} node
     * @protected
     */
    deleteTreeNode(node) {
        let self = this;

        this.treeNodeLookup.delete(node.lookupKey);

        node.childNodes.forEach((child)=>{
            self.deleteTreeNode((child));
        });
    }

    /**
     * Runs through all registered decorators and tries to decorate the given node, the first decorator to do something wins.
     * @param {TreeNode} node - The TreeNode to decorate
     * @protected
     */
    static decorateNode(node) {
        for(let decorator of TreeGenerator.decorators) {
            if(typeof decorator.decorator.decorate === "function" && decorator.decorator.decorate(node)) {
                //First decorator that decorates our node, wins!
                node.onDecorated();
                break;
            }
        }
    }

    /**
     * Runs through all registered decorators and gives them a chance to add DataFlavors to the given dnd DataTransfer
     * @param {TreeNode} node
     * @param {DataTransfer} dataTransfer
     */
    static decorateDataTransfers(node, dataTransfer) {
        for(let decorator of TreeGenerator.decorators) {
            if(typeof decorator.decorator.decorateDataTransfer === "function" && decorator.decorator.decorateDataTransfer(node, dataTransfer)) {
                break;
            }
        }
    }

    /**
     * Register a decorator
     * @param decorator
     * @param {Number} priority
     */
    static registerDecorator(decorator, priority) {
        TreeGenerator.decorators.push({
            decorator: decorator,
            priority: priority
        });

        //Sort decorators according to priority
        TreeGenerator.decorators.sort((i1, i2)=>{
            return i2.priority - i1.priority;
        });
    }
}

window.TreeGenerator = TreeGenerator;

TreeGenerator.decorators = [];

</SCRIPT><SCRIPT id="DomTreeGenerator-script" type="disabled">
/**
 *  DOM Tree Generator
 *  Generates trees based on DOM nodes
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate */

/**
 * @typedef {Object} DomTreeGenerator~config
 * @property {String[]} [includeRules] - An array of CSS selectors that represents what should be included even if excluded or transient. If empty, everything that is not excluded will be included.
 * @property {String[]} [excludeRules] - An array of CSS selectors that represents what should be excluded.
 * @property {boolean} [includeWebstrateTransients=false] - Should webstrate transient elements be included true/false
 * @property {boolean} [live=true] - Is the Tree live, ie. does changes to the dom reflect in the tree.
 */

/**
 * DomTreeGenerator can traverse DOM and generate TreeNode trees from the visited DOM Nodes
 */
class DomTreeGenerator extends TreeGenerator {
    /**
     * Create a new DomTreeGenerator with the given configuration
     * @param {DomTreeGenerator~config}config
     */
    constructor(config) {
        super();

        this.excludeRules = WebstrateComponents.Tools.fromConfig(config, "excludeRules", []);
        this.includeRules = WebstrateComponents.Tools.fromConfig(config, "includeRules", []);

        //Hardcode that .tree-browser is not observed, could lead to nasty infinite loops if not?
        if(this.excludeRules.indexOf(".tree-browser") === -1) {
            this.excludeRules.push(".tree-browser");
        }

        this.includeWebstrateTransients = WebstrateComponents.Tools.fromConfig(config, "includeWebstrateTransients", false);

        this.live = WebstrateComponents.Tools.fromConfig(config, "live", true);

        if(this.live) {
            this.setupObserver();
        }
    }

    /**
     * Start generation of a tree
     * @param {Element} root - The element to use as the root for this tree
     * @returns {TreeNode}
     */
    generateTree(root) {
        let self = this;

        let node = new TreeNode({
            type: "DomTreeNode",
            context: root
        });

        this.saveTreeNode(node);

        TreeGenerator.decorateNode(node);

        Array.from(root.children).forEach((child)=>{
            if(self.shouldInclude(child)) {
                let childNode = self.generateTree(child);
                node.addNode(childNode, self.findChildIndex(child));
            }
        });

        return node;
    }

    /**
     * Checks if the given HTML element should be included in the tree
     * @param {Element} node
     * @returns {boolean}
     * @private
     */
    shouldInclude(node) {
        for(let includeRule of this.includeRules) {
            if(node.matches(includeRule)) {
                return true;
            }
        }

        for(let excludeRule of this.excludeRules) {
            if(node.matches(excludeRule)) {
                return false;
            }
        }

        if((typeof webstrate !== "undefined") && !this.includeWebstrateTransients) {
            if(webstrate.config.isTransientElement(node)) {
                return false;
            }
        }

        if(this.includeRules.length === 0) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Returns the child index the given node has in its parents children NodeList
     * @param {Element} node
     * @returns {number}
     * @private
     */
    findChildIndex(node) {
        let parent = node.parentNode;

        if(parent != null) {
            let i = 0;
            for(let child of parent.children) {
                if(this.shouldInclude(child)) {
                    if(child === node) {
                        return i;
                    }

                    i++;
                }
            }
        }

        return -1;
    }

    /**
     * Setup the Live observer
     * @private
     */
    setupObserver() {
        let self = this;

        let observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                let targetTreeNode = self.lookupTreeNode(mutation.target);

                mutation.removedNodes.forEach((removedNode) => {
                    if(removedNode instanceof Element) {
                        //Removed node
                        let removedTreeNode = self.lookupTreeNode(removedNode);
                        if (removedTreeNode != null) {
                            self.deleteTreeNode(removedTreeNode);
                            removedTreeNode.onRemoved();
                            if (targetTreeNode != null) {
                                targetTreeNode.removeNode(removedTreeNode);
                            }
                        }
                    }
                });
                mutation.addedNodes.forEach((addedNode) => {
                    if(addedNode instanceof Element) {
                        if (targetTreeNode != null) {
                            if (self.shouldInclude(addedNode)) {
                                //Check if node is already added to the tree
                                if(self.lookupTreeNode(addedNode) == null) {
                                    //Added children to a treeNode
                                    let addedTreeNode = self.generateTree(addedNode);
                                    targetTreeNode.addNode(addedTreeNode, self.findChildIndex(addedNode));
                                }
                            }
                        }
                    }
                });

                if(targetTreeNode != null) {
                    TreeGenerator.decorateNode(targetTreeNode);
                }
            });
        });

        observer.observe(document, {
            childList: true,
            attributes: true,
            subtree: true,
            characterData: true
        });
    }
}

window.DomTreeGenerator = DomTreeGenerator;

</SCRIPT><SCRIPT id="AssetTreeGenerator-script" type="disabled">
/**
 *  Asset Tree Generator
 *  Generates trees based on assets uploaded to a Webstrate
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

class AssetTreeGenerator extends TreeGenerator {
    constructor(config) {
        super();

        this.live = WebstrateComponents.Tools.fromConfig(config, "live", true);

        if(this.live) {
            this.setupObserver();
        }

        this.rootNode = null;
    }

    generateTree() {
        let self = this;

        this.rootNode = new TreeNode({
            type: "AssetRootNode",
            context: null
        });
        if(webstrate != null && webstrate.assets && webstrate.assets.forEach!=null) {

            let filteredAssets = new Map();

            webstrate.assets.forEach((asset)=>{
                if(filteredAssets.has(asset.fileName)) {
                    let oldAsset = filteredAssets.get(asset.fileName);

                    if(asset.v > oldAsset.v) {
                        filteredAssets.set(asset.fileName, asset);
                    }
                } else {
                    filteredAssets.set(asset.fileName, asset);
                }
            });

            let sortedArray = Array.from(filteredAssets.values()).sort((a1, a2)=>{
                return a1.fileName.localeCompare(a2.fileName);
            });

            sortedArray.forEach((asset)=>{
                if(asset.deletedAt != null) {
                    //Deleted asset, skip
                    return;
                }

                let treeNode = AssetTreeGenerator.createNodeFromAsset(asset);

                self.rootNode.addNode(treeNode, self.findAssetIndex(asset));

                self.saveTreeNode(treeNode);
            });
        }

        TreeGenerator.decorateNode(this.rootNode);

        return this.rootNode;
    }

    /**
     * Create a TreeNode from an asset json
     * @param {JSON} asset
     * @returns {TreeNode}
     * @private
     */
    static createNodeFromAsset(asset) {
        let assetNode = null;
        if (asset.fileName.endsWith(".zip")){
            assetNode = new TreeNode({
                lookupKey: asset.fileName,
                context: asset,
                type: "AssetContainer"
            });

            // Explore the first zip level
            AssetTreeGenerator.exploreZipLevel(assetNode);
        } else {
            assetNode = new TreeNode({
                lookupKey: asset.fileName,
                context: asset,
                type: "AssetNode"
            });
        }

        TreeGenerator.decorateNode(assetNode);

        return assetNode;
    }

    /**
     * Finds an asset with the given name
     * @param {string} assetName
     * @returns {JSON} - The found asset
     */
    static findAssetFromName(assetName) {
        let filteredAssets = new Map();
        if (webstrate && webstrate.assets && webstrate.assets.forEach){
            webstrate.assets.forEach((asset)=>{
                if(filteredAssets.has(asset.fileName)) {
                    let oldAsset = filteredAssets.get(asset.fileName);

                    if(asset.v > oldAsset.v) {
                        filteredAssets.set(asset.fileName, asset);
                    }
                } else {
                    filteredAssets.set(asset.fileName, asset);
                }
            });
            return filteredAssets.get(assetName);
        } else {
            return null;
        }

    }

    /**
     * Returns the index of this asset
     * @param {JSON} asset
     * @returns {number}
     * @private
     */
    findAssetIndex(asset) {
        let filteredAssets = new Map();

        webstrate.assets.forEach((asset)=>{
            if(filteredAssets.has(asset.fileName)) {
                let oldAsset = filteredAssets.get(asset.fileName);

                if(asset.v > oldAsset.v) {
                    filteredAssets.set(asset.fileName, asset);
                }
            } else {
                filteredAssets.set(asset.fileName, asset);
            }
        });

        let sortedArray = Array.from(filteredAssets.keys()).sort((a1, a2)=>{
            return a1.localeCompare(a2);
        });

        return sortedArray.indexOf(asset.fileName);
    }

    setupObserver() {
        let self = this;

        if(webstrate != null) {
            webstrate.on("asset", (asset)=>{
                console.log("Asset event:", asset);

                let oldTreeNode = self.lookupTreeNode(asset.fileName);

                if(oldTreeNode == null) {
                    //New asset, just add
                    self.rootNode.addNode(AssetTreeGenerator.createNodeFromAsset(asset), self.findAssetIndex(asset));
                } else {
                    //Already existed, update context and redocorate
                    oldTreeNode.context = asset;
                    TreeGenerator.decorateNode(oldTreeNode);
                }
            });
        }
    }

    static exploreZipLevel(assetNode){
        // TODO: For now it explores the entire zip

        var xhr = new XMLHttpRequest();
        xhr.open('GET', assetNode.context.fileName+"/?dir", true);
        xhr.responseType = 'json';
        xhr.onload = function() {
            var status = xhr.status;
            if (status === 200) {
                xhr.response.forEach((entry)=>{
                    if (!entry.endsWith("/")){
                        let node = new TreeNode({
                            lookupKey: assetNode.context.fileName,
                            context: {
                                fileName: assetNode.context.fileName+"/"+entry,
                                v: 0
                            },
                            type: "AssetNode"
                        });
                        TreeGenerator.decorateNode(node);
                        assetNode.addNode(node);
                    }
                });
            } else {
                console.log("Couldn't unzip zip");
            }
        };
        xhr.send();
    }
}

window.AssetTreeGenerator = AssetTreeGenerator;

</SCRIPT><SCRIPT id="TreeBrowserHtmlDecorator-script" type="disabled">
/**
 *  HTML Decorator
 *  Decorates HTML nodes in a tree
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/**
 * Decorator that decorates HTML elements
 */
class TreeBrowserHtmlDecorator {
    /**
     * Attempts to decorate the given TreeNode
     * @param {TreeNode} node - The node to decorate
     * @returns {boolean} True/False depending on if the node was decorated
     */
    static decorate(node) {
        if(node.type === "DomTreeNode") {

            let id = (node.context.id!=null && node.context.id.trim().length > 0)?" #"+node.context.id:"";
            let name = (node.context.getAttribute("name")!=null && node.context.getAttribute("name").trim().length > 0)?" "+node.context.getAttribute("name"):"";

            node.setProperty("content", node.context.tagName.toLowerCase()+id+name);

            let icon = null;
            switch (node.context.tagName.toLowerCase()){
                case "script":
                    icon = "mdc:code";
                    break;
            }
            if (icon){
                node.setProperty("icon", IconRegistry.createIcon(icon));
            } else {
                // Set open/closed icons in the default case
                let iconNode = document.createElement("span");
                let closedNode = IconRegistry.createIcon("mdc:folder");
                closedNode.classList.add("tree-browser-icon-closed");
                iconNode.appendChild(closedNode);
                let unfoldedNode = IconRegistry.createIcon("mdc:folder_open");
                unfoldedNode.classList.add("tree-browser-icon-unfolded");
                iconNode.appendChild(unfoldedNode);
                node.setProperty("icon", iconNode);
            }

            return true;
        }

        return false;
    }

    /**
     * Attempts to decorate the given DataTransfer based on the given TreeNode
     * @param {TreeNode} node
     * @param {DataTransfer} dataTransfer
     * @returns {boolean} True/False depending on if the DataTransfer was decorated
     */
    static decorateDataTransfer(node, dataTransfer) {
        if(node.type === "DomTreeNode") {
            dataTransfer.setData("text/plain", node.context.outerHTML);

            return true;
        }

        return false;
    }
}

window.TreeBrowserHtmlDecorator = TreeBrowserHtmlDecorator;

TreeGenerator.registerDecorator(TreeBrowserHtmlDecorator, 0);

</SCRIPT><SCRIPT id="TreeBrowserFragmentDecorator-script" type="disabled">
/**
 *  Fragment Decorator
 *  Decorates Codestrate Fragments in a tree
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/**
 * Decorator that decorates Codestrate fragments
 */
class TreeBrowserFragmentDecorator {
    /**
     * Attempts to decorate the given TreeNode
     * @param {TreeNode} node - The node to decorate
     * @returns {boolean} True/False depending on if the node was decorated
     */
    static decorate(node) {
        if(node.type === "DomTreeNode") {
            if(node.context.matches("code-fragment")) {
                let content = "";
                let name = node.context.getAttribute("name");
                if (name != null && name != ""){
                    content = name+" ";
                }
                if(node.context.id != null && node.context.id!="") {
                    content += "#"+node.context.id;
                }
                if (!content){
                    content = node.context.tagName.toLowerCase();

                    if(typeof cQuery !== "undefined") {
                        let fragment = cQuery(node.context).data("Fragment");

                        if(fragment != null) {
                            content = fragment.constructor.name;
                        }
                    }
                }
                let type = node.context.getAttribute("data-type");

                // Find a proper icon either from an icon provider or a default one
                node.setProperty("icon", IconRegistry.createIcon(["code-fragment:"+type, "mdc:insert_drive_file"]));
                node.setProperty("content", content);
                node.setProperty("tooltip", node.context.tagName.toLowerCase()+" ("+type+")");

                if(node.context.getAttribute("auto") != null) {
                    node.setProperty("modifier-a", IconRegistry.createIcon(["A", "mdc:play_circle_outline"]));
                } else {
                    node.setProperty("modifier-a", null);
                }

                return true;
            }
        }

        return false;
    }
}

window.TreeBrowserFragmentDecorator = TreeBrowserFragmentDecorator;

TreeGenerator.registerDecorator(TreeBrowserFragmentDecorator, 10);

</SCRIPT><SCRIPT id="TreeBrowserAssetDecorator-script" type="disabled">
/**
 *  Asset Decorator
 *  Decorates Asset nodes in a tree
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/**
 * Decorator that decorates Assets
 */
class TreeBrowserAssetDecorator {
    /**
     * Attempts to decorate the given TreeNode
     * @param {TreeNode} node - The node to decorate
     * @returns {boolean} True/False depending on if the node was decorated
     */
    static decorate(node) {
        if(node.type === "AssetNode") {
            let version = " v"+node.context.v;
            node.setProperty("content", node.context.fileName+version);
            node.setProperty("icon", IconRegistry.createIcon("mdc:attachment"));
            return true;
        } else if(node.type === "AssetContainer") {
            let version = " v"+node.context.v;
            let iconNode = document.createElement("div");
            iconNode.classList.add("tree-browser-custom-icon");
            let icon = IconRegistry.createIcon("mdc:work_outline");
            icon.classList.add("tree-browser-icon-closed");
            iconNode.appendChild(icon);
            icon = IconRegistry.createIcon("mdc:work");
            icon.classList.add("tree-browser-icon-unfolded");
            iconNode.appendChild(icon);
            node.setProperty("content", node.context.fileName+version);
            node.setProperty("icon", iconNode);
            return true;
        } else if(node.type === "AssetRootNode") {
            node.setProperty("content", "Assets");
            node.setProperty("icon", IconRegistry.createIcon("mdc:cloud"));
            return true;
        }

        return false;
    }

    /**
     * Attempts to decorate the given DataTransfer based on the given TreeNode
     * @param {TreeNode} node
     * @param {DataTransfer} dataTransfer
     * @returns {boolean} True/False depending on if the DataTransfer was decorated
     */
    static decorateDataTransfer(node, dataTransfer) {
        if(node.type === "AssetNode") {
            let uri = location.href + node.context.fileName;
            dataTransfer.setData("treenode/asset", uri);
            dataTransfer.setData("text/uri-list", uri);
            dataTransfer.setData("text/plain", uri);
            return true;
        }

        return false;
    }
}

window.TreeBrowserAssetDecorator = TreeBrowserAssetDecorator;

TreeGenerator.registerDecorator(TreeBrowserAssetDecorator, 10);

</SCRIPT><SCRIPT id="TreeBrowserWPMDecorator-script" type="disabled">
/**
 *  WPM Decorator
 *  Handles decoration of WPM package nodes in a tree
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/**
 * Decorator that decorates HTML elements
 */
class TreeBrowserWPMDecorator {
    /**
     * Attempts to decorate the given TreeNode
     * @param {TreeNode} node - The node to decorate
     * @returns {boolean} True/False depending on if the node was decorated
     */
    static decorate(node) {
        if(node.type === "DomTreeNode" && node.context.matches("wpm-package")) {
            let id = (node.context.id!=null && node.context.id.trim().length > 0)?" #"+node.context.id:"";
            node.setProperty("content", node.context.tagName.toLowerCase() + id);

            // TODO: add disabled/live state to classes

            let assetRootNode = node.assetRootNode;

            node.childNodes.forEach((child)=>{
                if(child.type === "AssetRootNode") {
                    assetRootNode = child;
                }
            });

            let descriptor = node.context.querySelector("code-fragment[data-type='wpm/descriptor']");

            if(descriptor != null && typeof cQuery !== "undefined") {
                let descFrag = cQuery(descriptor).data("Fragment");

                if(descFrag != null) {

                    if(assetRootNode == null) {
                        assetRootNode = new TreeNode({
                            type: "AssetRootNode"
                        });
                        TreeGenerator.decorateNode(assetRootNode);

                        node.assetRootNode = assetRootNode;

                        //Setup event to look for asset updates

                        let self = this;

                        if(webstrate != null) {
                            webstrate.on("asset", (asset)=>{
                                updateAssets();
                            });
                        }

                        function updateAssets() {
                            if(assetRootNode != null && descFrag != null) {
                                assetRootNode.clearNodes();

                                descFrag.require().then((descJson) => {
                                    descJson.assets.forEach((assetJson) => {
                                        if (typeof assetJson === "string") {
                                            let asset = AssetTreeGenerator.findAssetFromName(assetJson);
                                            if (asset != null) {
                                                let assetNode = AssetTreeGenerator.createNodeFromAsset(asset);
                                                assetRootNode.addNode(assetNode);
                                            }
                                        }
                                    });

                                    if (assetRootNode.isLeaf()) {
                                        node.removeNode(assetRootNode);
                                    } else {
                                        node.addNode(assetRootNode, 9999);
                                        assetRootNode.render();
                                    }
                                });
                            }
                        }

                        descFrag.registerOnFragmentChangedHandler(()=>{
                            updateAssets();
                        });

                        updateAssets();
                    }
                }
            } else {
                if(assetRootNode != null) {
                    node.removeNode(assetRootNode);
                    node.assetRootNode = null;
                    assetRootNode = null;
                }
            }

            // Set open/closed icons in the default case
            let iconNode = document.createElement("span");
            iconNode.classList.add("tree-browser-custom-icon");

            let icon = IconRegistry.createIcon(["webstrates:wpm-package-closed", "mdc:insert_drive_file"]);
            icon.classList.add("tree-browser-icon-closed");
            iconNode.appendChild(icon);
            icon = IconRegistry.createIcon(["webstrates:wpm-package-open", "mdc:insert_drive_file"]);
            icon.classList.add("tree-browser-icon-unfolded");
            iconNode.appendChild(icon);

            node.setProperty("icon", iconNode);
            return true;
        }

        //Hide wpm-descriptor inside descriptor code-fragment
        if(node.type === "DomTreeNode" && node.context.matches("wpm-descriptor")) {
            if(node.context.parentNode != null && node.context.parentNode.matches("code-fragment[data-type='wpm/descriptor']")) {
                node.hideSelf = true;
            }
        }

        return false;
    }
}

window.TreeBrowserWPMDecorator = TreeBrowserWPMDecorator;

TreeGenerator.registerDecorator(TreeBrowserWPMDecorator, 10);

</SCRIPT><TEMPLATE id="TreeBrowser_Main">
    <UL class="mdc-list tree-browser tree-browser-root" role="list">
    </UL>
</TEMPLATE><TEMPLATE id="TreeBrowser_Leaf">
    <LI tabindex="-1" class="mdc-list-item tree-browser-leaf tree-browser-node">
        <DIV class="rippley"><SPAN class="mdc-list-item__ripple"></SPAN></DIV>
        <SPAN class="mdc-list-item__graphic tree-browser-navigator" aria-hidden="true"></SPAN>
        <SPAN class="mdc-list-item__graphic tree-browser-icons" aria-hidden="true"></SPAN>
        <SPAN class="mdc-list-item__text tree-browser-content"></SPAN>
        <SPAN aria-hidden="true" class="mdc-list-item__meta"></SPAN>
    </LI>
</TEMPLATE><TEMPLATE id="TreeBrowser_Children">
    <LI class="tree-browser-children">
        <UL class="mdc-list tree-browser" role="list">
        </UL>
    </LI>
</TEMPLATE><TEMPLATE id="TreeBrowser_Modifier">
    <SPAN class="tree-browser-modifier" aria-hidden="true"></SPAN>
</TEMPLATE></WPM-PACKAGE><WPM-PACKAGE data-repository="webstrate-components-repos" id="ModalDialog" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Modal Dialog",
    "description": "Generic Modal Dialog",
    "dependencies": [
        "wpm_js_libs #material-design-components",
        "wpm_js_libs #material-design-icons",
        "wpm_js_libs #UUIDGenerator",
        "#WebstrateComponents_Tools",
        "codestrates-repos #EventSystem"
    ],
    "assets": [
    ],
    "version": "1.0",
    "license": "Apache 2.0",
    "changelog": {
        "1.0": "Initial version"
    }
}

</SCRIPT><STYLE id="main-style">
/**
 *  Modal styles
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
.wc-modal-dialog {
  z-index: 9000; }
  .wc-modal-dialog .mdc-dialog__surface {
    max-width: 95%; }
  .wc-modal-dialog .mdc-dialog__content.flexcontent {
    display: flex;
    padding: 0; }
  .wc-modal-dialog.wc-modal-maximized .mdc-dialog__container {
    min-width: 85%; }
    .wc-modal-dialog.wc-modal-maximized .mdc-dialog__container .mdc-dialog__surface {
      min-width: 100%;
      height: 100%; }
</STYLE><SCRIPT id="ModalDialog-script" type="disabled">
/**
 *  Modal
 *  Provides a way to open modal dialogs
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global mdc */

/**
 * @typedef {Object} ModalDialog~ModalDialogOptions
 * @property {string} [title=""] - The dialog title
 * @property {boolean} [closeOnOutsideClick=true] - Automatically close the dialog when clicking outside the dialog
 * @property {boolean} [closeOnEscape=true] - Automatically close the dialog when ESCAPE is pressed
 * @property {boolean} [autoStackButtons=true] - Automatically stack buttons if they do not fit horizontally
 */

/**
 * Modal component using MDCDialog as a framework
 */
class ModalDialog {

    /**
     * Creates a new ModalDialog
     * @param {Node} content - The content to place inside the Dialog
     * @param {ModalDialog~ModalDialogOptions} [options]
     */
    constructor(content, options = {}) {
        const self = this;

        const defaultOptions = {
            title: "",
            classes: [],
            closeOnOutsideClick: true,
            closeOnEscape: true,
            autoStackButtons: true,
            maximize: false,
            flexContent: false,
            actions: {}
        };

        this.uuid = UUIDGenerator.generateUUID("dialog-");

        this.options = Object.assign({}, defaultOptions, options);

        this.html = WebstrateComponents.Tools.loadTemplate("#webstrate-components-modal-dialog-tpl");

        this.title = this.html.querySelector(".mdc-dialog__title");
        this.content = this.html.querySelector(".mdc-dialog__content");
        this.actions = this.html.querySelector(".mdc-dialog__actions");

        this.title.id = this.uuid + "-title";
        this.content.id = this.uuid + "-content";

        this.html.querySelector(".mdc-dialog__surface").setAttribute("aria-labelledby", this.title.id);
        this.html.querySelector(".mdc-dialog__surface").setAttribute("aria-describedby", this.content.id);

        // Action buttons
        if (this.options.actions === null || Object.keys(this.options.actions).length===0){
                this.actions.remove();
        } else {
                for (const [action, actionOptions] of Object.entries(this.options.actions)) {
                        let actionButton = document.createElement("button");
                        actionButton.classList.add("mdc-button");
                        actionButton.classList.add("mdc-dialog__button");
                        if (actionOptions.primary){
                                actionButton.classList.add("mdc-button--raised");
                        }
                        actionButton.setAttribute("data-mdc-dialog-action", action);

                        if (actionOptions.mdcIcon){
                                let icon = document.createElement("i");
                                icon.classList.add("material-icons");
                                icon.classList.add("mdc-button__icon");
                                icon.innerText = actionOptions.mdcIcon;
                                actionButton.appendChild(icon);
                        }

                        let ripple = document.createElement("div");
                        ripple.classList.add("mdc-button__ripple");
                        actionButton.appendChild(ripple);

                        let label = document.createElement("span");
                        label.classList.add("mdc-button__label");
                        if (actionOptions.label){
                                label.innerText = actionOptions.label;
                        } else {
                                label.innerText = action;
                        }
                        actionButton.append(label);

                        this.actions.appendChild(actionButton);
                }
        }

        if (this.options.flexContent){
            this.content.classList.add("flexcontent");
        }
        this.content.appendChild(content);
        if(this.options.title != null && this.options.title.trim() !== "") {
            this.title.textContent = this.options.title.trim();
        } else {
            this.title.remove();
        }

        if(this.options.classes != null) {
            let classes = this.options.classes;
            if(!Array.isArray(classes)) {
                classes = [classes];
            }

            classes.forEach((c)=>{
                this.html.classList.add(c);
            });
        }

        if (this.options.maximize){
            this.html.classList.add("wc-modal-maximized");
        }

        this.dialog = new mdc.dialog.MDCDialog(this.html);

        //Dont add anything to body!
        this.dialog.foundation.adapter.addBodyClass = ()=>{};

        this.dialog.autoStackButtons = this.options.autoStackButtons;

        if(!this.options.closeOnEscape) {
            this.dialog.escapeKeyAction = "";
        }

        if(!this.options.closeOnOutsideClick) {
            this.dialog.scrimClickAction = "";
        }

        this.dialog.listen("MDCDialog:opening", (evt)=>{
            EventSystem.triggerEvent("ModalDialog.Opening", {
                dialog: self
            });
        });

        this.dialog.listen("MDCDialog:opened", (evt)=>{
            EventSystem.triggerEvent("ModalDialog.Opened", {
                dialog: self
            });
        });

        this.dialog.listen("MDCDialog:closing", (evt)=>{
            EventSystem.triggerEvent("ModalDialog.Closing", {
                dialog: self,
                action: evt.detail.action
            });
        });

        this.dialog.listen("MDCDialog:closed", (evt)=>{
            EventSystem.triggerEvent("ModalDialog.Closed", {
                dialog: self,
                action: evt.detail.action
            });
        });

        mdc.autoInit(this.html);
    }

    open() {
        this.dialog.open();
    }

    close(action = null) {
        this.dialog.close(action);
    }
}

window.WebstrateComponents.ModalDialog = ModalDialog;

</SCRIPT><TEMPLATE id="webstrate-components-modal-dialog-tpl">
    <DIV class="wc-modal-dialog mdc-dialog">
        <DIV class="mdc-dialog__container">
            <DIV class="mdc-dialog__surface" role="alertdialog" aria-modal="true" aria-labelledby="my-dialog-title" aria-describedby="my-dialog-content">
                <H2 class="mdc-dialog__title" id="my-dialog-title"></H2>
                <DIV class="mdc-dialog__content" id="my-dialog-content"></DIV>
                <DIV class="mdc-dialog__actions"></DIV>
            </DIV>
        </DIV>
        <DIV class="mdc-dialog__scrim"></DIV>
    </DIV>
</TEMPLATE></WPM-PACKAGE><WPM-PACKAGE data-repository="webstrate-components-repos" id="ButtonSystem_MaterialDesign" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Buttons",
    "description": "Buttons for all",
    "dependencies": [
        "#WebstrateComponents_Tools",
        "#ButtonSystem"
    ],
    "assets": [
    ],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="buttons-material-script" type="disabled">
/**
 *  Material Buttons
 *  Provides MDC buttons
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

ButtonSystem.MaterialBuilder = class MaterialBuilder {
    static buildButton(button) {
        let buttonHtml = WebstrateComponents.Tools.loadTemplate("ButtonSystem_MaterialDesign_Button");

        buttonHtml.querySelector(".mdc-button__label").textContent = button.text;

        let buttonType = WebstrateComponents.Tools.fromConfig(button.options, "style", "text");

        switch(buttonType) {
            case "text":
                break;
            case "outlined":
            case "raised":
            case "unelevated":
                buttonHtml.classList.add("mdc-button--"+buttonType);
                break;
        }

        let icon = WebstrateComponents.Tools.fromConfig(button.options, "icon", null);

        if(icon != null) {
            let filteredClasses = Array.from(icon.classList.values()).filter((c)=>{
                return c.startsWith("material-icons");
            });
            if(filteredClasses.length > 0) {
                icon.classList.add("mdc-button__icon");
            }

            if(WebstrateComponents.Tools.fromConfig(button.options, "iconTrailing", false)) {
                buttonHtml.appendChild(icon);
            } else {
                buttonHtml.insertBefore(icon, buttonHtml.firstChild);
            }
        }

        mdc.ripple.MDCRipple.attachTo(buttonHtml);

        return buttonHtml;
    }
}

ButtonSystem.ButtonFactory.setDefaultBuilder(ButtonSystem.MaterialBuilder);

</SCRIPT><TEMPLATE id="ButtonSystem_MaterialDesign_Button">
    <BUTTON class="mdc-button"><SPAN class="mdc-button__ripple"></SPAN><SPAN class="mdc-button__label"></SPAN></BUTTON>
</TEMPLATE></WPM-PACKAGE><WPM-PACKAGE data-repository="webstrate-components-repos" id="MaterialMenu" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "MaterialMenu",
    "description": "MDC bindings for MenuSystem visualization",
    "dependencies": [
        "wpm_js_libs #material-design-components",
        "wpm_js_libs #material-design-icons",
        "#wsc-icon-registry",
        "#MenuSystem"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="MaterialMenu-script" type="disabled">
/**
 *  MaterialMenuBuilder
 *  MDC binding for visual presentation of menus
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/*global mdc*/

window.MenuSystem.MaterialMenuBuilder = class MaterialMenuBuilder extends MenuSystem.MenuBuilder {
    static buildMenuHtml(menu) {
        let tpl = WebstrateComponents.Tools.loadTemplate("MenuSystem_MaterialMenu_Menu");

        //Setup MDC menu
        tpl.mdcMenu =  new mdc.menu.MDCMenu(tpl);

        if(menu.options.defaultFocusState != null) {
            tpl.mdcMenu.setDefaultFocusState(menu.options.defaultFocusState);
        }

        //Hook mdc-menu-surface close
        let origClose = tpl.mdcMenu.menuSurface.foundation.close;
        tpl.mdcMenu.realClose = function () {
            origClose.call(tpl.mdcMenu.menuSurface.foundation);
        };
        tpl.mdcMenu.menuSurface.foundation.close = function() {
            //Empty on purpose
        };

        //Setup listeners
        tpl.mdcMenu.listen("MDCMenu:selected", (evt)=>{
            menu.handleItemAction(evt.detail.item.menuItem);
        });

        return tpl;
    }

    static buildMenuItemHtml(menuItem) {
        let tpl = WebstrateComponents.Tools.loadTemplate("MenuSystem_MaterialMenu_MenuItem");

        tpl.querySelector(".mdc-list-item__text").textContent = menuItem.label;
        tpl.menuItem = menuItem;

        if(menuItem.icon != null) {
            let iconTpl = WebstrateComponents.Tools.loadTemplate("MenuSystem_MaterialMenu_MenuItem_Icon");
            tpl.insertBefore(iconTpl, tpl.firstChild);
            if(typeof menuItem.icon === "string") {
                iconTpl.textContent = menuItem.icon;
            } else if(menuItem.icon instanceof HTMLElement || menuItem.icon instanceof SVGElement) {
                iconTpl.appendChild(menuItem.icon.cloneNode(true));
            }
        }

        if(menuItem.metaIcon != null) {
            let metaIconTpl = WebstrateComponents.Tools.loadTemplate("MenuSystem_MaterialMenu_MenuItem_MetaIcon");
            tpl.insertBefore(metaIconTpl, tpl.lastChild.nextSibling);
            if(typeof menuItem.metaIcon === "string") {
                metaIconTpl.textContent = menuItem.metaIcon;
            } else if(menuItem.metaIcon instanceof HTMLElement) {
                metaIconTpl.appendChild(menuItem.metaIcon.cloneNode(true));
            }
        }

        if (menuItem.tooltip != null){
            tpl.setAttribute("title", menuItem.tooltip);
        }

        mdc.ripple.MDCRipple.attachTo(tpl);

        if (menuItem.checked != null){
            // This is a toggle-able item, upgrade it with additional UI elements and update the state
            let checkmarkTemplate = WebstrateComponents.Tools.loadTemplate("MenuSystem_MaterialMenu_Checkmark");
            tpl.insertBefore(checkmarkTemplate, tpl.lastChild.nextSibling);
            tpl.classList.add("mdc-menu__selection-group");

            let wrapper = document.createElement("div");
            wrapper.classList.add("mdc-menu__selection-group");
            wrapper.appendChild(tpl);
            tpl = wrapper;
        }
        return tpl;
    }

    static clearMenuItems(menu) {
        let menuItemInsertLocation = menu.html.querySelector(".mdc-list");
        while(menuItemInsertLocation.lastChild) {
            menuItemInsertLocation.removeChild(menuItemInsertLocation.lastChild);
        }
    }

    static attachMenuItems(menu, groups) {
        let menuItemInsertLocation = menu.html.querySelector(".mdc-list");

        let first = true;

        groups.forEach((group)=>{
            if(first) {
                first = false;
            } else {
                if(menu.groupDividers) {
                    let groupDivider = WebstrateComponents.Tools.loadTemplate("MenuSystem_MaterialMenu_GroupDivider");
                    menuItemInsertLocation.appendChild(groupDivider);
                }
            }

            group.forEach((item)=>{
                menuItemInsertLocation.appendChild(item.html);

                // Update checked status
                if (item.checked!==null){
                    try {
                        if (item.checked()){
                            item.html.querySelector(".mdc-list-item").classList.add("mdc-menu-item--selected");
                        } else {
                            item.html.querySelector(".mdc-list-item").classList.remove("mdc-menu-item--selected");
                        }
                    } catch (ex){
                        console.warn("MenuItem caused exception in .checked ",item,ex);
                    }
                }
            });
        });
    }

    static open(menu, source) {
        if(source != null) {
            if(source.x != null && source.y != null) {
                menu.html.mdcMenu.setFixedPosition(true);
                menu.html.mdcMenu.setAbsolutePosition(source.x, source.y);
            } else if(source instanceof HTMLElement) {
                //Try fixed always if using anchor source?
                menu.html.mdcMenu.setFixedPosition(true);

                menu.html.mdcMenu.setAnchorElement(source);

                switch(menu.growDirection) {
                    case MenuSystem.Menu.GrowDirection.DOWN:
                        menu.html.mdcMenu.setAnchorCorner(mdc.menuSurface.Corner.BOTTOM_LEFT);
                        break;
                    case MenuSystem.Menu.GrowDirection.RIGHT:
                    default:
                        menu.html.mdcMenu.setAnchorCorner(mdc.menuSurface.Corner.TOP_RIGHT);
                        menu.html.mdcMenu.setAnchorMargin({
                            top: -10
                        });
                }
            }
            menu.html.style.zIndex = 9000;
        }

        if (menu.layoutDirection==MenuSystem.Menu.LayoutDirection.HORIZONTAL){
            menu.html.classList.add("mdc-tweaks-horizontal-menu");
        }
        if (menu.layoutWrapping===false){
            menu.html.classList.add("mdc-tweaks-nonwrapping-menu");
        }
        if (menu.layoutCompact===true){
            menu.html.classList.add("mdc-tweaks-compact-menu");
        }

        if(!menu.defaultFocus) {
            menu.html.mdcMenu.setDefaultFocusState(0);
        }

        menu.html.mdcMenu.open = true;
    }

    static close(menu) {
        menu.html.mdcMenu.realClose();
    }

    static destroyMenu(menu) {
        menu.html.mdcMenu.destroy();
        delete menu.html["mdcMenu"];
    }

    static destroyMenuItem(item) {
    }

    static setItemActive(item, active){
        if(active) {
            item.html.classList.add("mdc-list-item--activated");
        } else {
            item.html.classList.remove("mdc-list-item--activated");
        }
    }

    static createSubmenuIcon() {
        return IconRegistry.createIcon("mdc:chevron_right");
    }
};

MenuSystem.MenuManager.createMaterialMenu = (menuName, menuConfig = {}) => {
    menuConfig.builder = MenuSystem.MaterialMenuBuilder;
    return MenuSystem.MenuManager.createMenu(menuName, menuConfig);
};

MenuSystem.MenuManager.setDefaultBuilder(MenuSystem.MaterialMenuBuilder);

</SCRIPT><TEMPLATE id="MenuSystem_MaterialMenu_Menu">
    <DIV class="mdc-menu mdc-menu-surface">
        <UL class="mdc-list" role="menu" aria-hidden="true" aria-orientation="vertical" tabindex="-1">
        </UL>
      </DIV>
</TEMPLATE><TEMPLATE id="MenuSystem_MaterialMenu_MenuItem">
    <LI class="mdc-list-item" role="menuitem">
        <SPAN class="mdc-list-item__ripple"></SPAN>
        <SPAN class="mdc-list-item__text"></SPAN>
    </LI>
</TEMPLATE><TEMPLATE id="MenuSystem_MaterialMenu_MenuItem_Icon">
    <SPAN class="mdc-list-item__graphic"></SPAN>
</TEMPLATE><TEMPLATE id="MenuSystem_MaterialMenu_MenuItem_MetaIcon">
    <SPAN class="mdc-list-item__meta"></SPAN>
</TEMPLATE><TEMPLATE id="MenuSystem_MaterialMenu_GroupDivider">
    <LI class="mdc-list-divider" role="separator"></LI>
</TEMPLATE><TEMPLATE id="MenuSystem_MaterialMenu_Checkmark">
    <SPAN class="mdc-list-item__graphic mdc-menu__selection-group-icon material-icons">check</SPAN>
</TEMPLATE><STYLE id="main-style">
/**
 *  MaterialMenuBuilder Styles
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
.menusystem-menu.mdc-menu {
  /* Horizontally layouted menus require emulation */ }
  .menusystem-menu.mdc-menu .mdc-list-item.MenuSystem_MenuItem_Active {
    background: red;
    /* deprecated, remove? */ }
  .menusystem-menu.mdc-menu .mdc-list-item__meta {
    display: flex; }
  .menusystem-menu.mdc-menu.mdc-tweaks-horizontal-menu {
    position: relative;
    max-width: none;
    max-height: none;
    overflow: initial;
    box-shadow: none;
    background: transparent;
    min-width: auto; }
    .menusystem-menu.mdc-menu.mdc-tweaks-horizontal-menu > .mdc-list {
      display: flex;
      flex-wrap: wrap;
      padding: 0; }
      .menusystem-menu.mdc-menu.mdc-tweaks-horizontal-menu > .mdc-list > .mdc-list-item {
        height: 1.75em;
        font-size: 0.8em; }
        .menusystem-menu.mdc-menu.mdc-tweaks-horizontal-menu > .mdc-list > .mdc-list-item > .mdc-list-item__meta {
          display: none; }
  .menusystem-menu.mdc-menu.mdc-tweaks-nonwrapping-menu > .mdc-list {
    flex-wrap: nowrap; }
  .menusystem-menu.mdc-menu.mdc-tweaks-compact-menu > .mdc-list > .mdc-list-item {
    padding: 0; }
</STYLE></WPM-PACKAGE><WPM-PACKAGE data-repository="webstrate-components-repos" id="WPMPackageBrowser" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Manage WPMv2 packages in your webstrate",
    "description": "Easily install, update or remove packages in your webstrate with a visual UI",
    "dependencies": [
        "#WebstrateComponents_Tools"
    ],
    "optionalDependencies": [
        "wpm_js_libs #material-design-components",
        "wpm_js_libs #material-design-icons",
        "#MaterialDesignOutlinedIcons",
        "#ModalDialog",
        "#MenuSystem",
        "#MaterialMenu"
    ],
    "assets": [],
    "version": "2.0",
    "license": "Apache 2.0",
    "changelog": {
        "1.0": "Initial version",
        "2.0": "No longer initial version"
    }
}

</SCRIPT><STYLE id="mdc-package-browser-style">
/**
 *  Package Browser Styles
 *
 *  Copyright 2021 Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
.package-browser-base {
  display: flex;
  flex-direction: column;
  position: relative; }
  .package-browser-base #packageBrowserMain {
    border-top: 1px solid lightgray;
    display: flex;
    height: 100%;
    width: 100%;
    min-height: 0; }
    .package-browser-base #packageBrowserMain .tabcontent {
      display: flex;
      flex-direction: column;
      width: 100%;
      min-height: 0; }
      .package-browser-base #packageBrowserMain .tabcontent.padded {
        padding: 1em; }
    .package-browser-base #packageBrowserMain .split {
      display: flex;
      flex: 1 1 auto;
      min-height: 0; }
      .package-browser-base #packageBrowserMain .split > .mdc-list {
        flex: 0 0 auto;
        width: 20em;
        max-width: 25vw;
        min-height: 0;
        overflow-y: auto;
        background: rgba(100, 100, 100, 0.2);
        padding: 0; }
        .package-browser-base #packageBrowserMain .split > .mdc-list .mdc-list-item {
          padding-right: 0; }
        .package-browser-base #packageBrowserMain .split > .mdc-list .repository-name {
          text-transform: capitalize; }
      .package-browser-base #packageBrowserMain .split > .scroller {
        flex: 1 1 auto;
        min-height: 0;
        overflow-y: auto; }
    .package-browser-base #packageBrowserMain .install-options-icon {
      position: absolute;
      line-height: 1.5em;
      margin-left: 0.3em;
      color: var(--mdc-theme-text-icon-on-light);
      user-select: none; }
    .package-browser-base #packageBrowserMain .mdc-data-table__row.missing {
      background: rgba(255, 0, 0, 0.6); }
    .package-browser-base #packageBrowserMain .mdc-data-table {
      border: none;
      display: block; }
    .package-browser-base #packageBrowserMain .mdc-data-table__table-container {
      overflow-x: hidden; }
    .package-browser-base #packageBrowserMain .mdc-data-table__table {
      width: 100%;
      border-spacing: 0;
      border-collapse: initial; }
      .package-browser-base #packageBrowserMain .mdc-data-table__table .mdc-data-table__header-cell {
        background: rgba(0, 0, 255, 0.1); }
      .package-browser-base #packageBrowserMain .mdc-data-table__table .mdc-data-table__cell {
        height: 43px;
        border-top: 1px dotted var(--mdc-theme-text-secondary-on-background); }
      .package-browser-base #packageBrowserMain .mdc-data-table__table tbody tr:first-child .mdc-data-table__cell {
        border-top: 1px solid var(--mdc-theme-text-secondary-on-background); }
    .package-browser-base #packageBrowserMain .package-required[data-indirect-requirement] .mdc-checkbox__background:after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 100, 255, 0.22); }
    .package-browser-base #packageBrowserMain .package-required, .package-browser-base #packageBrowserMain .package-embedded {
      width: 3.5rem; }
    .package-browser-base #packageBrowserMain .package-name {
      width: 12rem; }
    .package-browser-base #packageBrowserMain .package-version {
      width: 6rem; }
    .package-browser-base #packageBrowserMain .package-license {
      width: 9rem; }
    .package-browser-base #packageBrowserMain .package-options {
      width: 1rem; }
    .package-browser-base #packageBrowserMain .package-description {
      width: 100%;
      overflow: hidden; }
</STYLE><SCRIPT id="webstrate-package-browser-script" type="disabled">
/**
 *  Package Browser
 *  Visual browser for installing WPM packages into a Webstrate
 *
 *  Copyright 2021 Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interacion, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

window.WPMPackageBrowser = class WPMPackageBrowser {
    constructor(autoOpen=true) {
        let self = this;
        self.topLevelComponent = document.documentElement;

        self.itemTemplate = WebstrateComponents.Tools.loadTemplate("#packageBrowserPackageItem");
        self.html = WebstrateComponents.Tools.loadTemplate("#packageBrowserBase");
        self.mainView = self.html.querySelector("#packageBrowserMain");

        wpm.require(["material-design-components", "material-design-icons","ModalDialog","MenuSystem","MaterialMenu","MaterialDesignOutlinedIcons"]).then(()=>{
            mdc.autoInit(self.html);
            let tabs = self.html.querySelector(".mdc-tab-bar").MDCTabBar;

            tabs.listen("MDCTabBar:activated", (evt)=> {
                // Switch tabs
                switch (evt.detail.index){
                    case 0:
                        self.showRepositories();
                        break;
                    default:
                        self.showSystem();
                }
            });

            try {
                tabs.activateTab(0); //self.showRepositories();
            } catch (ex){
                tabs.activateTab(1); //self.showSystem();
            }

            self.repositoryURLDialog = this.getURLDialog();
            self.repositoryDevURLDialog = this.getDevURLDialog();
        });

        if (autoOpen) this.openInBody();
    }

    openInBody(){
        let parent = document.createElement("transient");
        parent.appendChild(this.html);
        document.body.appendChild(parent);
    }

    setTopLevelComponent(component){
        this.topLevelComponent = component;
    }

    getURLDialog(){
        let self = this;
        let repoAddTemplate = WebstrateComponents.Tools.loadTemplate("#packageBrowserRepositoryURL");
        let repositoryURLDialog = new WebstrateComponents.ModalDialog(
                repoAddTemplate,
                {
                    "title":"Repository URL",
                    "actions": {
                            "cancel":{},
                            "set": {primary: true, mdcIcon: "add_link"}
                    }
                }
        );
        this.topLevelComponent.appendChild(repositoryURLDialog.html);

        repositoryURLDialog.setTarget = (target)=>{
            repositoryURLDialog.target = target;

            let stepRepositoryRegistrations = WPMv2.getRegisteredRepositories(false);
            if (stepRepositoryRegistrations[target]){
                repoAddTemplate.querySelector("#repourl").value = stepRepositoryRegistrations[target];
            }
        };

        EventSystem.registerEventCallback('ModalDialog.Closing', function(evt) {
            if(evt.detail.dialog===repositoryURLDialog && evt.detail.action === "set") {
                let bootConfig = self.getBootConfig();

                if (bootConfig.require && Array.isArray(bootConfig.require)){
                    let repo = {};
                    repo[repositoryURLDialog.target] = repoAddTemplate.querySelector("#repourl").value;
                    if (bootConfig.require.length===0){
                        bootConfig.require = {
                            repositories: repo,
                            dependencies: []
                        };
                    } else {
                        let oldRepos = bootConfig.require[0].repositories;
                        if (!oldRepos){
                            bootConfig.require[0].repositories = repo;
                        } else {
                            bootConfig.require[0].repositories = {...bootConfig.require[0].repositories, ...repo};
                        }
                    }

                    // Effectuate immediately too
                    WPMv2.registerRepository(repositoryURLDialog.target, repo[repositoryURLDialog.target]);
                }

                self.setBootConfig(bootConfig);
                self.showRepositories();
            }
        });

        return repositoryURLDialog;
    }

    getDevURLDialog(){
        let self = this;
        let repoDevTemplate = WebstrateComponents.Tools.loadTemplate("#packageBrowserRepositoryDevURL");
        let repositoryDevURLDialog = new WebstrateComponents.ModalDialog(
                repoDevTemplate,
                {
                    "title":"Repository Dev Override",
                    "actions": {
                            "cancel":{},
                            "remove":{},
                            "set": {primary: true, mdcIcon: "add_link"}
                    }
                }
        );
        this.topLevelComponent.appendChild(repositoryDevURLDialog.html);

        repositoryDevURLDialog.setTarget = (target)=>{
            repositoryDevURLDialog.target = target;

            let stepRepositoryRegistrations = WPMv2.getRegisteredRepositories(true);
            if (stepRepositoryRegistrations[target]){
                repoDevTemplate.querySelector("#repodevurl").value = stepRepositoryRegistrations[target];
            }
        };

        EventSystem.registerEventCallback('ModalDialog.Closing', function(evt) {
            if(evt.detail.dialog===repositoryDevURLDialog){
                let value = repoDevTemplate.querySelector("#repodevurl").value;
                if (evt.detail.action === "remove" || (evt.detail.action === "set" && value.trim().length===0)){
                    WPMv2.unregisterRepository(repositoryDevURLDialog.target, true);
                } else if (evt.detail.action === "set"){
                    WPMv2.registerRepository(repositoryDevURLDialog.target, value, true);
                }
            }
            self.showRepositories();
        });

        return repositoryDevURLDialog;
    }


    async renderRepository(repositoryName, repositoryView){
        let self = this;
        let repositoryPackages = await WPMv2.getPackagesFromRepository(repositoryName);
        let bootConfig = this.getBootConfig();

        let repositoryRepositoryTemplate = WebstrateComponents.Tools.loadTemplate("#packageBrowserRepositoryItem_repository");
        let repositoryBodyTemplate = WebstrateComponents.Tools.loadTemplate("#packageBrowserRepositoryItem_body");
        let repoListDiv = repositoryView.querySelector(".repository-list");
        repoListDiv.innerHTML = "";
        repoListDiv.appendChild(repositoryRepositoryTemplate);
        repoListDiv.appendChild(repositoryBodyTemplate);

        let renderBody = ()=>{
            let installedFromRepository = WPMv2.getCurrentlyInstalledPackages().filter(pkg=>pkg.repository&&pkg.repository==repositoryName);
            // TODO: Handle packages that are in the bootConfig requirestep for this repo but aren't in the repo
            let repositoryIsThisPage = WPMv2.getLocalRepositoryURL && (repositoryName == WPMv2.getLocalRepositoryURL());

            for (let packageInfo of repositoryPackages){
                if (packageInfo.repository && packageInfo.repository!=repositoryName) continue; // This package is not actually from here but somewhere else
                repositoryBodyTemplate.appendChild(self.renderPackageItem(packageInfo, bootConfig, {repositoryIsThisPage:repositoryIsThisPage}));
                installedFromRepository = installedFromRepository.filter(pkg=>pkg.name!=packageInfo.name);
            }

            // Render packages that claim to be in this repository, but aren't
            installedFromRepository.forEach((packageInfo)=>{
                repositoryBodyTemplate.appendChild(self.renderPackageItem(packageInfo, bootConfig, {missingInRepository:true}));
            });
        };
        await renderBody();

        // Repository-wide override buttons
        repositoryRepositoryTemplate.querySelector(".repository-require input").checked = self.isConfigDirectlyRequiringRepository(bootConfig, repositoryName);
        repositoryRepositoryTemplate.querySelector(".repository-require input").addEventListener("click", async (evt)=>{
            // Enabled repository-wide require option, remove any per-package settings from bootConfig
            for (let packageInfo of repositoryPackages){
                await self.removePackageRequire(packageInfo);
            }

            if (evt.target.checked){
                await self.addRepositoryRequire(repositoryName);
            } else {
                await self.removeRepositoryRequire(repositoryName);
            }

            bootConfig = self.getBootConfig();
            repositoryBodyTemplate.innerHTML = "";
            await renderBody();
        });

        repositoryRepositoryTemplate.querySelector(".repository-embed").addEventListener("click", async (evt)=>{
            let embedMenu = MenuSystem.MenuManager.createMenu("PackageBrowser.RepositoryEmbed", {
                growDirection: MenuSystem.Menu.GrowDirection.DOWN
            });
            embedMenu.addItem({
                label: "Embed In-Use",
                order: 100,
                group: "Fetching",
                groupOrder: 200,
                icon: IconRegistry.createIcon("mdc:downloading"),
                onAction: async ()=>{
                    let packagesToEmbed = [];
                    for (let packageInfo of repositoryPackages){
                        let inUse = self.getLocalPackageElement(packageInfo.name);
                        if (inUse && (self.isTransientPackageElement(inUse))){
                            packagesToEmbed.push(packageInfo);
                        }
                    }
                    console.log(packagesToEmbed);
                    await self.embedPackages(packagesToEmbed);
                    self.renderRepository(repositoryName, repositoryView);
                }
            });
            embedMenu.addItem({
                label: "Embed All",
                icon: IconRegistry.createIcon("mdc:download_for_offline"),
                group: "Fetching",
                groupOrder: 200,
                order: 200,
                onAction: async ()=>{
                    if (confirm("This will bloat the page, the repository may not be designed to have ALL packages embedded and newly added packages will not be included")){
                        let packagesToEmbed = []
                        for (let packageInfo of repositoryPackages){
                            let localPackageElement = self.getLocalPackageElement(packageInfo.name);

                            if ((!localPackageElement)||self.isTransientPackageElement(localPackageElement)){
                                packagesToEmbed.push(packageInfo);
                            }
                        }
                        await self.embedPackages(packagesToEmbed);
                        self.renderRepository(repositoryName, repositoryView);
                    }
                }
            });
            embedMenu.addItem({
                label: "Remove All Embedded",
                icon: IconRegistry.createIcon("mdc:delete"),
                group: "Destruction",
                groupOrder: 999,
                order: 999,
                onAction: async ()=>{
                    let packagesOnlyOnThisPage = 0;
                    let packagesToUnembed = [];
                    for (let packageInfo of repositoryPackages){
                        let localPackageElement = self.getLocalPackageElement(packageInfo.name);
                        if (localPackageElement && !self.isTransientPackageElement(localPackageElement)){
                            if (packageInfo.repository && WPMv2.getLocalRepositoryURL && packageInfo.repository==WPMv2.getLocalRepositoryURL()){
                                packagesOnlyOnThisPage++;
                            }
                            packagesToUnembed.push(packageInfo);
                        }
                    }

                    if ((!packagesOnlyOnThisPage) || confirm("This will permanently delete "+packagesOnlyOnThisPage+" packages that ONLY exist in this page"))
                    for (let pkg of packagesToUnembed){
                        await self.unembedPackage(pkg);
                    }

                    self.renderRepository(repositoryName, repositoryView);
                }
            });

            embedMenu.registerOnCloseCallback(() => {
                if (embedMenu.html.parentNode !== null) {
                    embedMenu.html.parentNode.removeChild(embedMenu.html);
                }
            });

            self.html.appendChild(embedMenu.html);

            embedMenu.open({
                x: evt.clientX,
                y: evt.clientY
            });
            evt.stopPropagation();
            evt.preventDefault();
        });
    };

    showRepositories() {
        let self = this;
        this.mainView.innerHTML="";

        let repositoryView = WebstrateComponents.Tools.loadTemplate("#packageBrowserRepositoryList");

        // General actions for repositories
        let repoAddTemplate = WebstrateComponents.Tools.loadTemplate("#packageBrowserRepositoryAdder");
        let addRepositoryDialog = new WebstrateComponents.ModalDialog(
                repoAddTemplate,
                {
                    "title":"Add Repository",
                    "actions": {
                            "cancel":{},
                            "next": {primary: true, mdcIcon: "add_link"}
                    }
                }
        );
        self.topLevelComponent.appendChild(addRepositoryDialog.html);
        EventSystem.registerEventCallback('ModalDialog.Closing', function(evt) {
            if(evt.detail.dialog===addRepositoryDialog && evt.detail.action === "next") {
                let bootConfig = self.getBootConfig();
                let value = repoAddTemplate.querySelector("#repoid").value.trim();
                if (value.length>0){
                    if ((!bootConfig.knownRepositories) || !Array.isArray(bootConfig.knownRepositories)){
                        bootConfig.knownRepositories = []; // Destructive conformity
                    }
                    bootConfig.knownRepositories.push(repoAddTemplate.querySelector("#repoid").value);
                    self.setBootConfig(bootConfig);
                    self.showRepositories();

                    // TODO: .scrollIntoView() ?
                }
            }
        });

        // Gather a list of used repositories, both site-wide from WPM and previously added from this browser
        let knownRepositories = [];
        let installedPackages = WPMv2.getCurrentlyInstalledPackages();
        for (let packageInfo of installedPackages){
            if (packageInfo.repository && !knownRepositories.includes(packageInfo.repository)){
                knownRepositories.push(packageInfo.repository);
            }
        }
        let bootConfig = this.getBootConfig();
        if (bootConfig.knownRepositories && Array.isArray(bootConfig.knownRepositories)){
            for (let repoName of bootConfig.knownRepositories){
                if (!knownRepositories.includes(repoName)){
                    knownRepositories.push(repoName);
                }
            }
        }

        // Sort it and show it
        let sortedRepositories = knownRepositories.sort();
        let overviewAddItemTemplate = WebstrateComponents.Tools.loadTemplate("#packageBrowserAddListItem");
        for (let repositoryName of sortedRepositories){
            let overviewListItemTemplate = WebstrateComponents.Tools.loadTemplate("#packageBrowserRepositoryListItem");
            if (WPMv2.getLocalRepositoryURL && repositoryName == WPMv2.getLocalRepositoryURL()){
                overviewListItemTemplate.querySelector(".repository-name").innerHTML = "⌂ This Page";
                overviewListItemTemplate.querySelector(".repository-url").innerText = repositoryName;
            } else {
                overviewListItemTemplate.querySelector(".repository-name").title = repositoryName;
                overviewListItemTemplate.querySelector(".repository-name").innerText = repositoryName.replace("-repos","").replaceAll("_"," ").replaceAll("-", " ");
            }

            // Check if this is mapped somewhere with the bootloader
            // STUB: Currently this uses WPMv2 instead of the bootstep to resolve it
            let stepRepositoryRegistrations = WPMv2.getRegisteredRepositories(false);
            if (stepRepositoryRegistrations[repositoryName]){
                overviewListItemTemplate.querySelector(".repository-url").innerText = stepRepositoryRegistrations[repositoryName];
                overviewListItemTemplate.querySelector(".repository-url").title = stepRepositoryRegistrations[repositoryName];
            }

            // Check if this is mapped somewhere with any overrides
            // STUB: Currently this uses WPMv2 instead of the bootstep to resolve it
            let overrideRepositoryRegistrations = WPMv2.getRegisteredRepositories(true);
            if (overrideRepositoryRegistrations[repositoryName]){
                overviewListItemTemplate.querySelector(".repository-url").title = overviewListItemTemplate.querySelector(".repository-url").innerText+ " overridden by site-wide developer setting in this browser";
                overviewListItemTemplate.querySelector(".repository-url").innerText = overrideRepositoryRegistrations[repositoryName];
                overviewListItemTemplate.querySelector(".repository-url").style.color="red";
            }

            overviewListItemTemplate.querySelector(".repository-more").addEventListener("click", (evt)=>{
                let moreMenu = MenuSystem.MenuManager.createMenu("PackageBrowser.RepositoryMore", {
                    growDirection: MenuSystem.Menu.GrowDirection.DOWN
                });
                moreMenu.addItem({
                    label: "Remove",
                    order: 10,
                    icon: IconRegistry.createIcon("mdc:delete_outline"),
                    onAction: ()=>{
                        let bootConfig = self.getBootConfig();
                        if ((!bootConfig.knownRepositories) || !Array.isArray(bootConfig.knownRepositories)){
                            console.log("Couldn't understand bootConfig.knownRepositories", bootConfig.knownRepositories);
                            return;
                        } else {
                            bootConfig.knownRepositories = bootConfig.knownRepositories.filter(e => e !== repositoryName);
                            self.setBootConfig(bootConfig);
                            self.showRepositories();
                        }
                    }
                });
                moreMenu.addItem({
                    label: "Source URL...",
                    icon: IconRegistry.createIcon("mdc:link"),
                    order: 900,
                    onAction: ()=>{
                        self.repositoryURLDialog.setTarget(repositoryName);
                        self.repositoryURLDialog.open();
                    }
                });
                moreMenu.addItem({
                    label: "Dev Override...",
                    icon: IconRegistry.createIcon("mdc:assistant_direction"),
                    order: 999,
                    onAction: ()=>{
                        self.repositoryDevURLDialog.setTarget(repositoryName);
                        self.repositoryDevURLDialog.open();
                    }
                });

                moreMenu.registerOnCloseCallback(() => {
                    if (moreMenu.html.parentNode !== null) {
                        moreMenu.html.parentNode.removeChild(moreMenu.html);
                    }
                });

                self.html.appendChild(moreMenu.html);
                moreMenu.open({
                    x: evt.clientX,
                    y: evt.clientY
                });
                evt.stopPropagation();
                evt.preventDefault();
            });

            // Insert into overview of repositories
            repositoryView.querySelector(".repository-overview").appendChild(overviewListItemTemplate);
        }
        repositoryView.querySelector(".repository-overview").appendChild(overviewAddItemTemplate);
        repositoryView.querySelector(".add-repository").addEventListener("click", ()=>{
            addRepositoryDialog.html.querySelector("#repoid").value = "";
            addRepositoryDialog.open();
        });

        mdc.autoInit(repositoryView);
        let list = repositoryView.querySelector(".repository-overview").MDCList;
        list.singleSelection = true;
        list.listen("MDCList:action", async (evt)=>{
            if (evt.detail.index > sortedRepositories.length) return;
            let repositoryName = sortedRepositories[evt.detail.index];
            self.renderRepository(repositoryName, repositoryView);
        });
        list.selectedIndex = 0;
        if (sortedRepositories.length>0) self.renderRepository(sortedRepositories[0], repositoryView);

        this.mainView.appendChild(repositoryView);
    }

    showSystem(){
        let self = this;
        this.mainView.innerHTML="";

        let systemView = WebstrateComponents.Tools.loadTemplate("#packageBrowserSystem");
        this.mainView.appendChild(systemView);
        let wpmInfo = systemView.querySelector("#wpm-info");
        let bootLoaderInfo = systemView.querySelector("#bootloader-info");
        let bootLoaderConfig = systemView.querySelector("#bootloader-config");

        // Package Manager
        if (WPMv2){
            wpmInfo.querySelector(".name").innerText = "WPMv2";
            if (WPMv2.version){
                wpmInfo.querySelector(".version").innerText = WPMv2.version;
                wpmInfo.querySelector(".wpm-version-warning").remove();
            }
            if (WPMv2.revision){
                wpmInfo.querySelector(".revision").innerText = WPMv2.revision;
            }
        }

        // Config

    }


    getBootConfig(){
        try {
            let element = document.querySelector("script[type='text/json+bootconfig']");
            if (!element) throw Error("No bootconfig defined");

            let j = JSON.parse(element.textContent);
            return j;
        } catch (ex){
            console.log("PackageBrowser error", ex);
        }

        // We assume that we may create a new empty boot config if it doesn't exist
        let bootConfig = {
            creator: "WPMPackageManager",
            created: Date.now(),
            require: []
        };

        return bootConfig;
    }

    setBootConfig(config){
        let element = document.querySelector("script[type='text/json+bootconfig']");
        if (!element) {
            element = document.createElement("script");
            element.setAttribute("type", "text/json+bootconfig");
            WPMv2.stripProtection(element);
            document.head.appendChild(element);
            console.warn("Installing new boot config");
        }

        config["updated"] = Date.now();
        element.textContent = JSON.stringify(config, null, 4);
    }

    isLive(packageElement){
        return packageElement.getAttribute("transient-wpm-live")!==null;
    }

    isConfigDirectlyRequiringPackage(config, name){
        if (!config) throw new Error("Boot config is undefined");
        if (!config.require) throw new Error("Boot config does not contain require");
        if (!Array.isArray(config.require)) throw new Error("Boot config require is not an array");

        for (let requireStep of config.require){
            if (!requireStep.dependencies) continue;
            if (!Array.isArray(requireStep.dependencies)) continue;
            for (let dependency of requireStep.dependencies){
                if (dependency.package && dependency.package===name){
                    return true;
                }
            }
        }
        return false;
    }

    isConfigDirectlyRequiringRepository(config, name){
        if (!config) throw new Error("Boot config is undefined");
        if (!config.require) throw new Error("Boot config does not contain require");
        if (!Array.isArray(config.require)) throw new Error("Boot config require is not an array");

        for (let requireStep of config.require){
            if (!requireStep.dependencies) continue;
            if (!Array.isArray(requireStep.dependencies)) continue;
            for (let dependency of requireStep.dependencies){
                if (dependency.repository && dependency.repository===name && !dependency.package){
                    return true;
                }
            }
        }
        return false;
    }



    getLocalPackageElement(packageName){
        return document.querySelector(".packages .package#" + packageName + ", wpm-package#" + packageName);
    }

    isTransientPackageElement(packageElement){
        if (typeof webstrate !== "undefined"){
            // In webstrate mode webstrates defines what is transient
            if (webstrate.config.isTransientElement(packageElement)) return true;
        } else {
            // Otherwise we assume a transient-element tag is used to mark it
            console.log("Trying to match ", packageElement.tagName);
            if (packageElement.closest("[transient-wpmid]")){
                return true;
            } else {
                return false;
            }
        }

        let parent = packageElement.parentElement;
        if (parent){
            return this.isTransientPackageElement(parent);
        } else {
            return false;
        }
    }

    isForcedEmbeddedPackage(packageInfo){
        if (packageInfo.descriptor){
            if (packageInfo.descriptor.forceEmbedding) {
                return true;
            }
        }
        return false;
    }

    /**
     * Adds a package to the boot config and installs it
     *
     * @param {type} packageInfo
     * @param {type} step
     * @returns {undefined}
     */
    async addPackageRequire(packageInfo, step=-1){
        let config = this.getBootConfig();

        if (step===-1 || step > config.require.length){
            step = config.require.length-1;
        }
        if (step===-1){
            config.require.push({dependencies:[], options:{}});
            step = 0;
        }

        // Add it and load it
        let packageRequire = {package:packageInfo.name, repository:packageInfo.repository};
        await WPMv2.require(packageRequire); // also install it right away
        config.require[step].dependencies.push(packageRequire);
        this.setBootConfig(config);
    }

    async removePackageRequire(packageInfo){
        let config = this.getBootConfig();

        let removedIt = false;
        for (let requireStep of config.require){
            if (!requireStep.dependencies) continue;
            if (!Array.isArray(requireStep.dependencies)) continue;

            let newDependencies = [];
            for (let dependency of requireStep.dependencies){
                if (dependency.package && dependency.package===packageInfo.name){
                    removedIt = true;
                } else {
                    newDependencies.push(dependency);
                }
            }
            requireStep.dependencies = newDependencies;
        }

        if (removedIt){
            let localPackageElement = this.getLocalPackageElement(packageInfo.name);
            if (this.isTransientPackageElement(localPackageElement)){
                localPackageElement.remove();
                document.querySelector("[transient-wpmid='"+packageInfo.name+"']")?.remove();
            }
        }

        this.setBootConfig(config);
    }

    async removeRepositoryRequire(repositoryURL){
        let config = this.getBootConfig();

        let removedIt = false;
        for (let requireStep of config.require){
            if (!requireStep.dependencies) continue;
            if (!Array.isArray(requireStep.dependencies)) continue;

            let newDependencies = [];
            for (let dependency of requireStep.dependencies){
                if (dependency.repository && dependency.repository===repositoryURL && !dependency.package){
                    removedIt = true;
                } else {
                    newDependencies.push(dependency);
                }
            }
            requireStep.dependencies = newDependencies;
        }

        if (removedIt){
            // TODO: Figure out if something else also depends on it
            // If not, remove it from runtime too
        }

        this.setBootConfig(config);
    }

    /**
     * Adds a package to the boot config and installs it
     *
     * @param {type} repositoryURL
     * @param {type} step
     * @returns {undefined}
     */
    async addRepositoryRequire(repositoryURL, step=-1){
        let config = this.getBootConfig();

        if (step===-1 || step > config.require.length){
            step = config.require.length-1;
        }
        if (step===-1){
            config.require.push({dependencies:[], options:{}});
            step = 0;
        }

        // Add it and load it
        let repositoryRequire = {repository:repositoryURL};
        await WPMv2.require(repositoryRequire); // also install it right away
        config.require[step].dependencies.push(repositoryRequire);
        this.setBootConfig(config);
    }

    async embedPackages(wpmPackages){
        // Prepare for this package to be embedded
        let requiredPackages = [];
        wpmPackages.forEach((wpmPackage)=>{
            let localPackageElement = this.getLocalPackageElement(wpmPackage.name);
            if (localPackageElement && this.isTransientPackageElement(localPackageElement)){
                // Already installed transiently, remove first
                localPackageElement.remove();
                //Also remove wpm transient element if found
                document.querySelector("[transient-wpmid='"+wpmPackage.name+"']")?.remove();
            };
            requiredPackages.push({package:wpmPackage.name, repository:wpmPackage.repository, appendTarget:"head"});
        });

        await WPMv2.require(requiredPackages, {"bootstrap":"false"}); // install it right away
    }

    async unembedPackage(wpmPackage){
        let localPackageElement = this.getLocalPackageElement(wpmPackage.name); // update the package element
        localPackageElement.remove();

        if (this.isConfigDirectlyRequiringPackage(this.getBootConfig(), wpmPackage.name)){
            // Re-install transiently if required
            await WPMv2.require(wpmPackage);
        };
    }

    renderPackageItem(wpmPackage, bootConfig, displayOptions={}){
        let self = this;

        let packageItemTemplate = WebstrateComponents.Tools.loadTemplate("#packageBrowserPackageItem");
        if (displayOptions.missingInRepository){
            packageItemTemplate.classList.add("missing");
            packageItemTemplate.title="This package could not be found in the repository";
        };

        if (!wpmPackage.name){
            return WebstrateComponents.Tools.loadTemplate("#packageBrowserPackageItemError");
        }
        packageItemTemplate.querySelector(".package-name").innerText = wpmPackage.name;
        packageItemTemplate.querySelector(".package-name").title = wpmPackage.name;

        ["version", "description", "license"].forEach((packageProperty)=>{
            if (wpmPackage[packageProperty]){
                packageItemTemplate.querySelector(".package-"+packageProperty).innerText = wpmPackage[packageProperty];
                packageItemTemplate.querySelector(".package-"+packageProperty).title = wpmPackage[packageProperty];
            }
        });

        let localPackageElement = this.getLocalPackageElement(wpmPackage.name);
        if (localPackageElement) {
            // Check if required directly or because of dependency/system
            if (this.isConfigDirectlyRequiringPackage(bootConfig, wpmPackage.name)){
                packageItemTemplate.querySelector(".package-required input").checked = true;
            } else {
                if (this.isLive(localPackageElement)){
                    packageItemTemplate.querySelector(".package-required").setAttribute("data-indirect-requirement","true");
                    packageItemTemplate.querySelector(".package-required .mdc-checkbox").setAttribute("title", "Indirectly required by another package at runtime");

                    try {
                        // Add which package pulled this in
                        let pulledInBy = [];
                        WPMv2.getCurrentlyInstalledPackages().forEach(function(pkg){
                            pkg.dependencies.forEach(function(dep){
                                if (typeof dep === "string" && dep.indexOf("#"+wpmPackage.name)!=-1){
                                    pulledInBy.push(pkg);
                                }
                            });
                        });
                        if (pulledInBy.length > 0){
                            packageItemTemplate.querySelector(".package-required .mdc-checkbox").setAttribute("title", "Indirectly required by "+pulledInBy);
                        }
                    } catch (ex){
                        console.warn(ex);
                    }
                }
            }

            // Embedding status
            packageItemTemplate.querySelector(".package-embedded input").checked = !this.isTransientPackageElement(localPackageElement);
            if (this.isForcedEmbeddedPackage(wpmPackage)){
                packageItemTemplate.querySelector(".package-embedded input").setAttribute("title", "This package wants to be embedded when installed");
            }
        }


        // Click handlers
        packageItemTemplate.querySelector(".package-required input").addEventListener("click", async (box)=>{
            if (box.target.checked){
                // Require a package
                if (self.isForcedEmbeddedPackage(wpmPackage) && !packageItemTemplate.querySelector(".package-embedded input").checked){
                    await self.embedPackages([wpmPackage]);
                    packageItemTemplate.querySelector(".package-embedded input").checked = true;

                }
                await self.addPackageRequire(wpmPackage);
            } else {
                if (self.isForcedEmbeddedPackage(wpmPackage) && packageItemTemplate.querySelector(".package-embedded input").checked){
                    await self.unembedPackage(wpmPackage);
                    packageItemTemplate.querySelector(".package-embedded input").checked = false;
                }

                // Remove require for a package
                await self.removePackageRequire(wpmPackage);
            }
            localPackageElement = self.getLocalPackageElement(wpmPackage.name); // update the package element
        });

        packageItemTemplate.querySelector(".package-embedded input").addEventListener("click",async (box)=>{
            if (box.target.checked){
                await self.embedPackages([wpmPackage]);
                packageItemTemplate.querySelector(".package-embedded input").checked = true;
            } else {
                if (((!displayOptions.missingInRepository) || confirm("This package is missing in the repository, removing it will permanently delete it"))
                        &&
                       ((!displayOptions.repositoryIsThisPage) || confirm("The package only exists in this page, removing it will permanently delete it"))) {
                    await self.unembedPackage(wpmPackage);
                    packageItemTemplate.querySelector(".package-embedded input").checked = false;
                    if (self.isForcedEmbeddedPackage(wpmPackage) && packageItemTemplate.querySelector(".package-required input").checked){
                        await self.removePackageRequire(wpmPackage);
                        packageItemTemplate.querySelector(".package-required input").checked = false;
                    }
                } else {
                    packageItemTemplate.querySelector(".package-embedded input").checked = true;
                }
            }
            localPackageElement = self.getLocalPackageElement(wpmPackage.name); // update the package element
        });


        // Check repository includes
        if (wpmPackage.repository && self.isConfigDirectlyRequiringRepository(bootConfig, wpmPackage.repository)){
            packageItemTemplate.querySelector(".package-required input").disabled = true;
            packageItemTemplate.querySelector(".package-required input").checked = true;
            packageItemTemplate.querySelector(".package-embedded input").disabled = true;
        }

        return packageItemTemplate;
    }
};

</SCRIPT><TEMPLATE id="packageBrowserBase">
    <DIV class="package-browser-base">
        <DIV class="mdc-tab-bar package-browser-tabs" role="tablist" data-mdc-auto-init="MDCTabBar">
            <DIV class="mdc-tab-scroller">
                <DIV class="mdc-tab-scroller__scroll-area">
                    <DIV class="mdc-tab-scroller__scroll-content">
                        <BUTTON class="mdc-tab" role="tab">
                            <SPAN class="mdc-tab__content">
                                <SPAN class="mdc-tab__icon material-icons" aria-hidden="true">inventory</SPAN>
                                <SPAN class="mdc-tab__text-label">Browse Repositories</SPAN>
                            </SPAN>
                            <SPAN class="mdc-tab-indicator">
                                <SPAN class="mdc-tab-indicator__content mdc-tab-indicator__content--underline"></SPAN>
                            </SPAN>
                            <SPAN class="mdc-tab__ripple"></SPAN>
                        </BUTTON>
                        <BUTTON class="mdc-tab" role="tab">
                            <SPAN class="mdc-tab__content">
                                <SPAN class="mdc-tab__icon material-icons" aria-hidden="true">settings</SPAN>
                                <SPAN class="mdc-tab__text-label">System Setup</SPAN>
                            </SPAN>
                            <SPAN class="mdc-tab-indicator">
                                <SPAN class="mdc-tab-indicator__content mdc-tab-indicator__content--underline"></SPAN>
                            </SPAN>
                            <SPAN class="mdc-tab__ripple"></SPAN>
                        </BUTTON>
                    </DIV>
                </DIV>
            </DIV>
        </DIV>

        <DIV id="packageBrowserMain"></DIV>
    </DIV>
</TEMPLATE><TEMPLATE id="packageBrowserSystem">
    <DIV class="tabcontent padded">
        <DIV id="wpm-info">
            <H2>Webstrate Package Manager</H2>
            <TABLE>

                <TBODY><TR><TH>Name</TH><TD class="name">Unknown Platform</TD></TR>
                <TR><TH>API</TH><TD class="version">Legacy</TD></TR>
                <TR><TH>Specific Revision</TH><TD class="revision">?</TD></TR>
            </TBODY></TABLE>
            <DIV class="wpm-version-warning">
                <H2>Warning!</H2>
                <P>
                    The version of WPM you are running may not be compatible with this package manager or the required bootloader script.<BR/>
                    Please consider upgrading before continuing!
                </P>
            </DIV>
        </DIV>

        <DIV id="bootloader-config">
            <H2>Boot Config</H2>
            <P>
                You may manually edit the boot configuration JSON here if you like.<BR/>
                <B>Be careful, you were warned!</B>
            </P>

            <DIV class="editor">
            </DIV>
        </DIV>
    </DIV>
</TEMPLATE><TEMPLATE id="packageBrowserBootloaderSyntaxError">
    <DIV class="bootconfig-missing-warning">
        <H2>Syntax Error!</H2>
        <P class="error"></P>
        <P>
            The boot configuration contains a syntax error and is guaranteed to crash the page!<BR/>
            Please correct the errors before saving.
        </P>
    </DIV>
</TEMPLATE><TEMPLATE id="packageBrowserPackageItemError">
    <TR class="mdc-data-table__row">
        <TD>
           ?
        </TD>
    </TR>
</TEMPLATE><TEMPLATE id="packageBrowserPackageItem">
    <TR class="mdc-data-table__row">
        <TD class="mdc-data-table__cell mdc-data-table__cell--checkbox package-required">
            <DIV class="mdc-checkbox mdc-data-table__row-checkbox" data-mdc-auto-init="MDCCheckbox">
                <INPUT type="checkbox" class="mdc-checkbox__native-control" value="on"/>
                <DIV class="mdc-checkbox__background">
                    <svg class="mdc-checkbox__checkmark" viewBox="0 0 24 24">
                    <path class="mdc-checkbox__checkmark-path" fill="none" d="M1.73,12.91 8.1,19.28 22.79,4.59"></path>
                    </svg>
                    <DIV class="mdc-checkbox__mixedmark"></DIV>
                </DIV>
                <DIV class="mdc-checkbox__ripple"></DIV>
            </DIV>
        </TD>
        <TD class="mdc-data-table__cell mdc-data-table__cell--checkbox package-embedded">
            <DIV class="mdc-checkbox mdc-data-table__row-checkbox" data-mdc-auto-init="MDCCheckbox">
                <INPUT type="checkbox" class="mdc-checkbox__native-control" value="on"/>
                <DIV class="mdc-checkbox__background">
                    <svg class="mdc-checkbox__checkmark" viewBox="0 0 24 24">
                    <path class="mdc-checkbox__checkmark-path" fill="none" d="M1.73,12.91 8.1,19.28 22.79,4.59"></path>
                    </svg>
                    <DIV class="mdc-checkbox__mixedmark"></DIV>
                </DIV>
                <DIV class="mdc-checkbox__ripple"></DIV>
            </DIV>
        </TD>
        <TH class="mdc-data-table__cell package-name" scope="row">[unnamed]</TH>
        <TD class="mdc-data-table__cell package-version">[version-less]</TD>
        <TD class="mdc-data-table__cell package-license"></TD>
        <TD class="mdc-data-table__cell package-description"></TD>
        <TD class="mdc-data-table__cell package-options"></TD>
    </TR>
</TEMPLATE><TEMPLATE id="packageBrowserRepositoryItem_repository">
    <THEAD>
        <TR>
            <TH class="package-required mdc-data-table__header-cell mdc-data-table__header-cell--checkbox repository-require" role="columnheader" scope="col" title="Require entire repository at boot">
                <DIV class="mdc-checkbox mdc-data-table__header-row-checkbox mdc-checkbox--selected" title="Automatically require at boot">
                    <I class="material-icons install-options-icon">play_arrow</I>
                    <INPUT type="checkbox" class="mdc-checkbox__native-control" value="on"/>
                    <DIV class="mdc-checkbox__background">
                        <svg class="mdc-checkbox__checkmark" viewBox="0 0 24 24">
                        <path class="mdc-checkbox__checkmark-path" fill="none" d="M1.73,12.91 8.1,19.28 22.79,4.59"></path>
                        </svg>
                        <DIV class="mdc-checkbox__mixedmark"></DIV>
                    </DIV>
                    <DIV class="mdc-checkbox__ripple"></DIV>
                </DIV>
            </TH>
            <TH class="package-embedded mdc-data-table__header-cell mdc-data-table__header-cell--checkbox repository-embed" role="columnheader" scope="col">
                <DIV class="mdc-checkbox mdc-data-table__header-row-checkbox mdc-checkbox--selected" title="Embed locally into webstrate">
                    <I class="material-icons install-options-icon">archive</I>
                    <INPUT type="checkbox" class="mdc-checkbox__native-control" disabled value="on"/>
                    <DIV class="mdc-checkbox__background">
                        <svg class="mdc-checkbox__checkmark" viewBox="0 0 24 24">
                        <path class="mdc-checkbox__checkmark-path" fill="none" d="M1.73,12.91 8.1,19.28 22.79,4.59"></path>
                        </svg>
                        <DIV class="mdc-checkbox__mixedmark"></DIV>
                    </DIV>
                    <DIV class="mdc-checkbox__ripple"></DIV>
                </DIV>
            </TH>
            <TH class="package-name mdc-data-table__header-cell" role="columnheader" scope="col">Package</TH>
            <TH class="mdc-data-table__header-cell package-version" role="columnheader" scope="col">Version</TH>
            <TH class="mdc-data-table__header-cell package-license" role="columnheader" scope="col">License</TH>
            <TH class="mdc-data-table__header-cell package-description" role="columnheader" scope="col">Description</TH>
            <TH class="mdc-data-table__header-cell package-options" role="columnheader" scope="col">
            </TH>
        </TR>
    </THEAD>
</TEMPLATE><TEMPLATE id="packageBrowserRepositoryItem_body">
    <TBODY class="mdc-data-table__content package-browser-package-rows">
    </TBODY>
</TEMPLATE><TEMPLATE id="packageBrowserRepositoryList">
    <DIV class="tabcontent">
        <DIV class="split">
            <UL class="mdc-list mdc-list--two-line repository-overview" data-mdc-auto-init="MDCList">
            </UL>
            <DIV class="scroller">
                <DIV class="mdc-data-table">
                    <DIV class="mdc-data-table__table-container">
                        <TABLE class="mdc-data-table__table repository-list">
                        </TABLE>
                    </DIV>
                </DIV>
            </DIV>
        </DIV>
    </DIV>
</TEMPLATE><TEMPLATE id="packageBrowserRepositoryAdder">
    <DIV>
        <LABEL class="mdc-text-field mdc-text-field--filled" data-mdc-auto-init="MDCTextField">
          <SPAN class="mdc-text-field__ripple"></SPAN>
          <SPAN class="mdc-floating-label" id="repo-label-id">Repository Identifier</SPAN>
          <INPUT class="mdc-text-field__input" type="text" aria-labelledby="repo-label-id" aria-controls="repo-helper-text" aria-describedby="repo-helper-text" id="repoid"/>
          <SPAN class="mdc-line-ripple"></SPAN>
        </LABEL>
        <DIV class="mdc-text-field-helper-line">
          <DIV id="repo-helper-text" class="mdc-text-field-helper-text" aria-hidden="true">
            Identification token - e.g. 'cauldron-repos'
          </DIV>
        </DIV>
        WPM will search for the repository in:
        <UL style="margin: 0px;">
            <LI>/[identifier]/?raw - using Webstrates</LI>
            <LI>./[identifier]/index.html - on filesystem</LI>
        </UL>
    </DIV>
</TEMPLATE><TEMPLATE id="packageBrowserRepositoryURL">
    <DIV>
        Specify the URL to use load this repository
        <LABEL class="mdc-text-field mdc-text-field--filled" data-mdc-auto-init="MDCTextField">
          <SPAN class="mdc-text-field__ripple"></SPAN>
          <SPAN class="mdc-floating-label" id="repo-label-id">Repository Source</SPAN>
          <INPUT class="mdc-text-field__input" type="text" aria-labelledby="repo-label-id" aria-controls="repo-helper-text" aria-describedby="repo-helper-text" id="repourl"/>
          <SPAN class="mdc-line-ripple"></SPAN>
        </LABEL>
        <DIV class="mdc-text-field-helper-line">
          <DIV id="repo-helper-text" class="mdc-text-field-helper-text" aria-hidden="true">
            Repository URL - e.g. 'https://mydomain.com/awesome-repos'
          </DIV>
        </DIV>
        <UL style="margin: 0px;">
            <LI>Absolute https://mydomain.com/awesome-repos</LI>
            <LI>Relative ./something/index.html</LI>
            <LI>Server-relative: /something/?raw</LI>
        </UL>
    </DIV>
</TEMPLATE><TEMPLATE id="packageBrowserRepositoryDevURL">
    <DIV>
        Specify the Dev Override URL to use locally for this repository
        <LABEL class="mdc-text-field mdc-text-field--filled" data-mdc-auto-init="MDCTextField">
          <SPAN class="mdc-text-field__ripple"></SPAN>
          <SPAN class="mdc-floating-label" id="repo-label-id">Repository Override</SPAN>
          <INPUT class="mdc-text-field__input" type="text" aria-labelledby="repo-label-id" aria-controls="repo-helper-text" aria-describedby="repo-helper-text" id="repodevurl"/>
          <SPAN class="mdc-line-ripple"></SPAN>
        </LABEL>
        <DIV class="mdc-text-field-helper-line">
          <DIV id="repo-helper-text" class="mdc-text-field-helper-text" aria-hidden="true">
            Repository Override - e.g. '/something/?raw'
          </DIV>
        </DIV>
        <UL style="margin: 0px;">
            <LI>Absolute https://mydomain.com/awesome-repos</LI>
            <LI>Relative ./something/index.html</LI>
            <LI>Server-relative: /something/?raw</LI>
        </UL>
    </DIV>
</TEMPLATE><TEMPLATE id="packageBrowserRepositoryListItem">
    <LI class="mdc-list-item" data-mdc-auto-init="MDCRipple" tabindex="0">
        <SPAN class="mdc-list-item__ripple"></SPAN>
        <SPAN class="mdc-list-item__text">
            <SPAN class="mdc-list-item__primary-text repository-name">Two-line item
            </SPAN>
            <SPAN class="mdc-list-item__secondary-text repository-url">Automatic Repository URL</SPAN>
        </SPAN>
        <BUTTON data-mdc-ripple-is-unbounded class="mdc-list-item__meta mdc-icon-button material-icons repository-more">
        more_vert
    </BUTTON>
    </LI>
</TEMPLATE><TEMPLATE id="packageBrowserAddListItem">
    <LI class="mdc-list-item add-repository" data-mdc-auto-init="MDCRipple" tabindex="0">
        <SPAN class="mdc-list-item__ripple"></SPAN>
        <I class="material-icons" aria-hidden="true">add</I>
        <SPAN>
            Add Repository
        </SPAN>
    </LI>
</TEMPLATE></WPM-PACKAGE><WPM-PACKAGE data-repository="codestrates-repos" id="EventSystem" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "EventSystem",
    "description": "Can register and fire events",
    "dependencies": [],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="eventsystem-script" type="disabled">
/**
 *  EventSystem
 *  General system for registering and handling events
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/**
 * Handles sending / recieving named events
 * @hideconstructor
 */
class EventSystem {
    /**
     * Register a callback to be called when the given event is triggered
     *
     * @example
     * registerEventCallback("myEvent", ({detail: detail})=>{
     *     //My event has triggered
     *     console.log("MyEvent triggered with details:", detail);
     * });
     *
     * @param {string} eventName - The name of the event to register
     * @param {Function} callback - The callback to call when the event triggers
     *
     * @returns {object} - An object with a method delete(), that removes the registered callback
     */
    static registerEventCallback(eventName, callback) {
        let callbacks = EventSystem.callbackMap.get(eventName);
        if(callbacks == null){
            callbacks = new Set();
            EventSystem.callbackMap.set(eventName, callbacks);
        }

        callbacks.add(callback);

        return {
            delete: () => {
                callbacks.delete(callback);
            }
        };
    }

    /**
     * Trigger the event with the given name
     *
     * @example
     * triggerEvent("myEvent", {
     *     someData: "MyEventData"
     * });
     *
     * @param {string} eventName - The name of the event to trigger
     * @param {*} [detail] - The event detail to supply to the CustomEvent
     * @returns {boolean} - true/false depending on if any callback asked to prevent default
     */
    static triggerEvent(eventName, detail = null){
        let event = new CustomEvent(eventName, {
            detail: detail
        });

        let preventDefault = false;

        let callbacks = EventSystem.callbackMap.get(eventName);
        if(callbacks != null) {
            for(let callback of callbacks) {
                if(callback(event) === true) {
                    preventDefault = true;
                }
            }
        }

        return preventDefault;
    }

    /**
     * Trigger the event with the given name
     *
     * @example
     * triggerEvent("myEvent", {
     *     someData: "MyEventData"
     * });
     *
     * @param {string} eventName - The name of the event to trigger
     * @param {*} [detail] - The event detail to supply to the CustomEvent
     * @returns {Promise<boolean>} - true/false depending on if any callback asked to prevent default
     */
    static async triggerEventAsync(eventName, detail = null){
        let event = new CustomEvent(eventName, {
            detail: detail
        });

        let preventDefault = false;

        let callbacks = EventSystem.callbackMap.get(eventName);

        if(callbacks != null) {
            for (let callback of callbacks) {
                let callbackReturn = callback(event);

                let result = null;

                result = (callbackReturn instanceof Promise)?await callbackReturn:callbackReturn;

                if (result === true) {
                    preventDefault = true;
                }
            }
        }

        return preventDefault;
    }}

EventSystem.callbackMap = new Map();

window.EventSystem = EventSystem;

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="codestrates-repos" id="fragment_core" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "The base fragment core required by all fragments",
    "dependencies": [
        "wpm_js_libs #cQuery",
        "wpm_js_libs #Observer",
        "wpm_js_libs #fastdiff",
        "wpm_js_libs #diffHTML",
        "wpm_js_libs #UUIDGenerator"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</SCRIPT><STYLE id="base-style">
code-fragment {
    display: none;
}
</STYLE><SCRIPT id="fragment_core-script" type="disabled">
/**
 *  Fragment
 *  The base class for all code fragments in Codestrates
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global cQuery, webstrate, HTMLElement, NodeList, UUIDGenerator, Observer, WPMv2, Text, DIFF_INSERT, DIFF_DELETE, wpm */

const dmp = new diff_match_patch();

/**
 * @namespace Fragments
 */

/**
 * Codestrate Fragment representing a <code-fragment></code-fragment> tag in codestrates.
 * @abstract
 * @hideconstructor
 * @memberof Fragments
 */
class Fragment {
    /**
     * Create a new fragment using the given cQuery object as its base.
     * @param {cQuery} html - The cQuery object to use as base.
     */
    constructor(html) {
        let self = this;

        this.html = html;

        this.html.data("Fragment", this);

        this.textInsertedCallbacks = [];
        this.textDeletedCallbacks = [];
        this.fragmentChangedCallbacks = [];
        this.fragmentUnloadedCallbacks = [];
        this.fragmentClassChangedCallbacks = [];
        this.fragmentAutoChangedCallbacks = [];

        this.uuid = UUIDGenerator.generateUUID("fragment-");

        //Setup autodom and make it able to wait until it is complete.
        this.autoDomDirty = true;
        this.autoDomReady = false;
        this.setupAutoDomHandling();

        this.html[0].setAttribute("transient-fragment-uuid", this.uuid);

        this.setupObservers();
        this.startObserver();
    }

    /**
     * Get the node that holds the text content of this fragment
     * @protected
     * @ignore
     * @returns {Text}
     */
    getTextContentNode() {
        let textContentNode = this.html[0];

        this.checkTextContentNode(textContentNode);

        return textContentNode;
    }

    /**
     * Checks the given node for its feasibility of being the textContentNode
     * @protected
     * @ignore
     * @param {Text} textContentNode - The text node to check
     */
    checkTextContentNode(textContentNode) {
        if(textContentNode.childNodes.length > 1) {
            console.warn("More than 1 childnode...", textContentNode.childNodes);
        }
    }

    /**
     * Triggers all callback handlers for the given type insert/delete
     * @private
     * @param {number} pos - The position the event happened
     * @param {string} val - The value of the event
     * @param {insert|delete} type - The type of the event
     */
    insertDeleteCallback(pos, val, type) {
        switch (type) {
            case "insert":
            {
                this.textInsertedCallbacks.forEach((callback) => {
                    callback(pos, val);
                });

                break;
            }
            case "delete":
            {
                this.textDeletedCallbacks.forEach((callback) => {
                    callback(pos, val);
                });

                break;
            }
        }
    }

    /**
     * Handle the given mutations
     * @private
     * @param {Mutation[]} mutations - The mutations to handle
     */
    mutationCallback(mutations) {
        let self = this;

        let characterDataTargets = [];

        let sendUpdateCallback = false;

        mutations.forEach((mutation) => {
            if(mutation.type === "attributes") {
                sendUpdateCallback = true;
            }

            if (mutation.type === "attributes" && mutation.attributeName === "auto" && mutation.target === self.html[0]) {
                //If auto attribute changed, trigger onAutoChanged
                self.onAutoChanged(self.auto);
                sendUpdateCallback = false;
            } else if (mutation.type === "attributes" && mutation.attributeName === "class" && mutation.target === self.html[0]) {
                //If auto attribute changed, trigger onAutoChanged
                self.onClassChanged(this.html[0].classList);
                sendUpdateCallback = false;
            } else if(mutation.type === "characterData") {
                if(mutation.target.characterDataAlreadyHandled) {
                    return;
                }

                sendUpdateCallback = true;

                characterDataTargets.push(mutation.target);
                let newValue = mutation.target.nodeValue;
                let oldValue = mutation.oldValue;
                mutation.target.characterDataAlreadyHandled = true;

                //If characterData mutation, generate insert/delete ops
                let patches = dmp.patch_make(oldValue, newValue);
                Array.from(patches).forEach((patch)=>{
                    let offset = patch.start1;
                    patch.diffs.forEach((diff) => {
                        let type = diff[0];
                        let value = diff[1];

                        switch(type) {
                            case DIFF_INSERT:
                                self.insertDeleteCallback(offset, value, "insert");
                                offset += value.length;
                                break;
                            case DIFF_DELETE:
                                self.insertDeleteCallback(offset, value, "delete");
                                break;
                            case DIFF_EQUAL:
                                offset += value.length;
                                break;
                        }
                    });
                });
            } else if(mutation.type === "childList") {
                sendUpdateCallback = true;
            }
        });

        characterDataTargets.forEach((target)=>{
            target.characterDataAlreadyHandled = false;
        });

        //Only send
        if(this.html[0].parentNode != null && sendUpdateCallback) {
            //Dont do changed callbacks if we are not in the dom?
            this.triggerFragmentChanged(this);
        }
    }

    /**
     * @private
     * @param context
     */
    triggerFragmentChanged(context) {
        this.fragmentChangedCallbacks.slice().forEach((callback) => {
            try {
                callback(context);
            } catch(e) {
                console.group("Error: "+e);
                console.log("Callback:", callback);
                console.log("Context:", context);
                console.groupCollapsed("Trace");
                console.trace();
                console.groupEnd();
                console.groupEnd();
            }
        });
    }

    /**
     * Sets up the mutation observer for this fragment
     * @ignore
     * @protected
     */
    setupObservers() {
        let self = this;

        this.mutationHandler = (mutations) => {
            self.mutationCallback(mutations);
        };

        this.observer = new MutationObserver(this.mutationHandler);
    }

    /**
     * Starts this fragments mutation observer
     * @ignore
     * @protected
     */
    startObserver() {
        if(this.observer == null) {
            return;
        }

        this.observer.observe(this.html[0], {
            attributes: true,
            childList: true,
            subtree: true,
            characterData: true,
            characterDataOldValue: true
        });
    }

    /**
     * Stops this fragments mutation observer, handling any mutations that is queued before stopping.
     * @ignore
     * @protected
     */
    stopObserver() {
        if(this.observer == null) {
            return;
        }

        let mutations = this.observer.takeRecords();

        if (mutations.length > 0) {
            this.mutationCallback(mutations);
        }

        this.observer.disconnect();
    }

    /**
     * Run the given method without triggering the mutation observer on this fragment, then trigger fragment changed callbacks with the given context
     * @ignore
     * @protected
     * @param {Function} method - Method to call. Important: cannot be async or return a promise, the observer will be restarted as soon as this method returns.
     * @param {Object} context - Context to pass along to the callbacks
     */
    executeObserverless(method, context, skipChangeCheck=false) {
        this.stopObserver();

        let before = null;

        if(!skipChangeCheck) {
            before = this.raw;
        }

        //Run our method, potentially adding mutations
        method();

        this.startObserver();

        if(skipChangeCheck || before !== this.raw) {
            this.triggerFragmentChanged(context);
        }
    }

    /**
     * The raw representation of this fragment, can be used to set/get the raw value.
     *
     * @example
     * //Get the raw value of a fragment
     * let fragmentValue = myFragment.raw;
     *
     * @example
     * //Set the raw value of a fragment
     * myFragment.raw = myNewFragmentValue;
     *
     * @type {string}
     */
    get raw() {
        if(this.getTextContentNode().firstChild instanceof Text) {
            return this.getTextContentNode().firstChild.nodeValue;
        } else {
            return this.getTextContentNode().textContent;
        }
    }

    set raw(content) {
        if(this.getTextContentNode().firstChild instanceof Text) {
            this.getTextContentNode().firstChild.nodeValue = content;
        } else {
            this.getTextContentNode().textContent = content;
        }
    }

    /**
     * The auto attribute of this fragment, toggles automatic behaviour on/off
     * @type {boolean}
     */
    get auto() {
        return this.html[0].hasAttribute("auto");
    }

    set auto(auto) {
        if (auto) {
            this.html[0].setAttribute("auto", "");
        } else {
            this.html[0].removeAttribute("auto");
        }
    }

    /**
     * @callback Fragments.Fragment~fragmentChangedCallback
     * @param {Fragment|Object} context - The context that called the callback
     */

    /**
     * Register a callback to be run when this fragments content changes.
     *
     * @example
     * Fragment.one("#myFragment").registerOnFragmentChangedHandler((context)=>{
     *     //Fragment has changed
     * });
     *
     * @param {Fragments.Fragment~fragmentChangedCallback} callback - The callback that is run when fragment content changes
     */
    registerOnFragmentChangedHandler(callback) {
        let self = this;

        this.fragmentChangedCallbacks.push(callback);

        return {
            delete: ()=>{
                self.unRegisterOnFragmentChangedHandler(callback);
            }
        }
    }

    /**
     * Unregister a callback handler
     * @param {Fragments.Fragment~fragmentChangedCallback} callback - The callback to unregister
     */
    unRegisterOnFragmentChangedHandler(callback) {
        this.fragmentChangedCallbacks.splice(this.fragmentChangedCallbacks.indexOf(callback), 1);
    }

    /**
     * @callback Fragments.Fragment~fragmentUnloadedCallback
     * @param {Fragments.Fragment} fragment - The fragment that called the callback
     */

    /**
     * Register a callback to run when this fragment is unloaded
     *
     * @example
     * Fragment.one("#myFragment").registerOnFragmentUnloadedHandler(()=>{
     *     //Fragment is unloaded
     * });
     *
     * @param {Fragments.Fragment~fragmentUnloadedCallback} callback - The callback to run when the fragment is unloaded
     */
    registerOnFragmentUnloadedHandler(callback) {
        let self = this;

        this.fragmentUnloadedCallbacks.push(callback);

        return {
            delete: ()=>{
                self.unRegisterOnFragmentUnloadedHandler(callback);
            }
        }
    }

    /**
     * Unregister a callback handler
     * @param {Fragments.Fragment~fragmentUnloadedCallback} callback - The callback to unregister
     */
    unRegisterOnFragmentUnloadedHandler(callback) {
        this.fragmentUnloadedCallbacks.splice(this.fragmentUnloadedCallbacks.indexOf(callback), 1);
    }

    /**
     * @callback Fragments.Fragment~autoChangedCallback
     * @param {Fragments.Fragment} fragment - The fragment
     * @param {boolean} auto - The new value of auto
     */

    /**
     * Register a callback to run when auto attribute changes on fragment
     *
     * @example
     * Fragment.one("#myFragment").registerOnAutoChangedHandler((fragment, auto)=>{
     *     //Fragment auto attribute changed
     * });
     *
     * @param {Fragments.Fragment~autoChangedCallback} callback - The callback to run when auto changes
     */
    registerOnAutoChangedHandler(callback) {
        let self = this;

        this.fragmentAutoChangedCallbacks.push(callback);

        return {
            delete: ()=>{
                self.unRegisterOnAutoChangedHandler(callback);
            }
        }
    }

    /**
     * Unregister a callback handler
     * @param {Fragments.Fragment~autoChangedCallback} callback - The callback to unregister
     */
    unRegisterOnAutoChangedHandler(callback) {
        this.fragmentAutoChangedCallbacks.splice(this.fragmentAutoChangedCallbacks.indexOf(callback), 1);
    }

    /**
     * @callback Fragments.Fragment~textInsertedCallback
     * @param {number} position - The position where the text was inserted
     * @param {string} value - The value of inserted text
     */

    /**
     * Register a callback to run when text is inserted into this fragment
     *
     * @example
     * Fragment.one("#myFragment").registerOnTextInsertedHandler((position, value)=>{
     *     //Text "value" has been inserted into this fragment at "position"
     * });
     *
     * @param {Fragments.Fragment~textInsertedCallback} callback - The callback to run when text is inserted
     */
    registerOnTextInsertedHandler(callback) {
        let self = this;

        this.textInsertedCallbacks.push(callback);

        return {
            delete: ()=>{
                self.textInsertedCallbacks.splice(self.textInsertedCallbacks.indexOf(callback), 1);
            }
        }
    }

    /**
     * @callback Fragments.Fragment~textDeletedCallback
     * @param {number} position - The position where the text was deleted
     * @param {string} value - The value of deleted text
     */

    /**
     * Register a callback to run when text is deleted from this fragment
     *
     * @example
     * Fragment.one("#myFragment").registerOnTextDeletedHandler((position, value)=>{
     *     //Text "value" has been deleted from this fragment at "position"
     * });
     *
     * @param {Fragments.Fragment~textDeletedCallback} callback - The callback to run when text is deleted
     */
    registerOnTextDeletedHandler(callback) {
        let self = this;

        this.textDeletedCallbacks.push(callback);

        return {
            delete: ()=>{
                self.textDeletedCallbacks.splice(self.textDeletedCallbacks.indexOf(callback), 1);
            }
        }
    }

    /**
     * @callback Fragments.Fragment~fragmentClassChangedCallback
     * @param {string[]} classes - The classes that changed
     */

    /**
     * Register a callback to run when the classes of this fragment changes
     *
     * @example
     * Fragment.one("#myFragment").registerOnClassChangedHandler((classes)=>{
     *     //Some classes changed on this fragment
     * });
     *
     * @param {Fragments.Fragment~fragmentClassChangedCallback} callback - The callback to run when classes change on the fragment
     */
    registerOnClassChangedHandler(callback) {
        let self = this;

        this.fragmentClassChangedCallbacks.push(callback);

        return {
            delete: ()=>{
                self.fragmentClassChangedCallbacks.splice(self.fragmentClassChangedCallbacks.indexOf(callback), 1);
            }
        }
    }

    /**
     * Handles when classes change on the fragment
     * @private
     * @param classes
     */
    onClassChanged(classes) {
        this.fragmentClassChangedCallbacks.slice().forEach((cb)=>{
            cb(classes);
        });
    }

    /**
     * The type of this fragment
     * @type {string}
     * @readonly
     */
    get type() {
        return this.html[0].getAttribute("data-type");
    }

    /**
     * Require this fragment and return the result. What require does depends on what type of fragment it is.
     * @example
     * let result = await Fragment.one("#myFragment").require()
     *
     * @abstract
     * @param {json} [options] - The options to pass to require
     * @returns {*} result of the require action
     */
    async require(options = {}) {
        //Ovewritten in subclass
    }

    /**
     * Tell this fragment to unload itself
     * @example
     * Fragment.one("#myFragment").unload();
     */
    unload() {
        let self = this;

        this.fragmentUnloadedCallbacks.slice().forEach((callback)=>{
            callback(self);
        });

        if(this.supportsAutoDom()) {
            this.clearAutoDom();
        }

        this.stopObserver();
        this.html.data("Fragment", null);
        this.html = null;
    }

    /**
     * Called when all fragments are loaded
     * @private
     */
    async onFragmentsLoaded() {
        if (this.auto && !Fragment.disableAutorun) {
            await this.insertAutoDom();
        }
    }

    /**
     * @private
     * @returns {boolean} - True/False depending on if this fragments supports automatic behaviour
     */
    supportsAuto() {
        return this.supportsAutoDom();
    }

    /**
     * @private
     * @returns {boolean} True/False depending on if this fragment supports automatic dom insertion
     */
    supportsAutoDom() {
        //Override in subclass
        return false;
    }


    /**
     * Setup handling of automatic dom insertion
     * @private
     * @returns {Promise<void>}
     */
    setupAutoDomHandling() {
        if(!this.supportsAutoDom()) {
            return;
        }

        let self = this;

        this.registerOnFragmentChangedHandler((context) => {
            self.autoDomDirty = true;
            if (self.auto && !Fragment.disableAutorun) {
                self.insertAutoDom();
            }
        });
    }

    /**
     * Called when auto attribute is changed on this fragment
     * @private
     * @param {boolean} auto - The new state of auto
     */
    onAutoChanged(auto) {
        this.fragmentAutoChangedCallbacks.forEach((cb)=>{
            cb(this, auto);
        });

        if(!this.supportsAutoDom()) {
            return;
        }

        if (auto && !Fragment.disableAutorun) {
            this.insertAutoDom();
        } else {
            this.clearAutoDom();
        }
    }

    /**
     * Create an instance of the automatic dom
     * @private
     * @returns {Promise<*>}
     */
    async createAutoDom() {
        if(!this.supportsAutoDom()) {
            return;
        }

        try {
            return await this.require();
        } catch(e) {
            return null;
        }
    }

    /**
     * Ask this fragment to insert its automatic dom (regardless of Fragment.disableAutorun)
     * @ignore
     * @returns {Promise<void>} - Promise that resolves when the automatic dom is inserted into the document
     */
    insertAutoDom() {
        let self = this;

        if(!this.supportsAutoDom()) {
            return;
        }

        if(!this.autoDomDirty) {
            console.debug("Not inserting autoDom, as it is already present and not flagged dirty:", this.uuid);
            return new Promise(async (resolve)=>{
                while(!self.autoDomReady) {
                    await new Promise((timeoutPromiseResolve)=>{
                        setTimeout(()=>{
                            timeoutPromiseResolve();
                        }, 10);
                    });
                }
                resolve();
            });
        }

        this.autoDomDirty = false;
        this.autoDomReady = false;

        return new Promise(async (resolve, reject)=>{

            try {
                let autoDomContent = await this.createAutoDom();

                let oldTransient = cQuery("transient.autoDom#" + self.uuid);

                if(oldTransient.length > 0) {
                    oldTransient[0].setAttribute("class", "autoDom");

                    //Fix missing classes
                    self.html[0].classList.forEach((c)=>{
                        oldTransient[0].addClass(c);
                    });

                    try {
                        diff.innerHTML(oldTransient[0], autoDomContent, { parser: { strict: true } });
                    } catch (ex){
                        console.error("Failed to perform autoDOM diffing", ex);
                        diff.release(oldTransient[0]); // Reset state trackers since the patch was not applied
                    }

                    function cssPath(element, path= []) {
                        if(element.parentNode == null) {
                            // Document fragment is the top node
                            return path.reverse().join(" > ");
                        }

                        const parent = element.parentNode;
                        const childIndex = Array.from(parent.children).indexOf(element) + 1;
                        path.push(element.nodeName.toLowerCase()+":nth-child("+childIndex+")");
                        return cssPath(parent, path);
                    }

                    // Update innerHTML for each template, as this is not part of the dom, and would not be updated otherwise
                    cQuery(autoDomContent).find("template").forEach((template)=>{
                        let path = cssPath(template);
                        oldTransient[0].querySelector(path).innerHTML = autoDomContent.querySelector(path).innerHTML;
                    });
                } else {
                    let transient = cQuery("<transient></transient>");
                    transient[0].setAttribute("id", self.uuid);
                    transient.addClass("autoDom");

                    self.html[0].classList.forEach((c)=>{
                        transient.addClass(c);
                    });

                    if (autoDomContent != null && autoDomContent !== "") {
                        transient.append(autoDomContent);
                    }
                    self.html[0].parentNode.insertBefore(transient[0], self.html[0].nextSibling);
                }

                self.autoDomReady = true;

                resolve();
            } catch(e) {
                console.warn("Unable to insertAutoDom: ", e);
                self.autoDomDirty = true;
                reject();
            }
        });
    }

    /**
     * Clear this fragments automatic dom from the document
     * @ignore
     */
    clearAutoDom() {
        if(!this.supportsAutoDom()) {
            return;
        }
        cQuery("transient.autoDom#" + this.uuid).remove();
        this.autoDomDirty = true;
        this.autoDomReady = false;
    }

    /**
     * Returns whether this fragment supports the run flag
     * @private
     * @returns {boolean}
     */
    supportsRun() {
        return false;
    }

    /**
     * Returns a dompath for finding this fragment
     */
    getDomPath() {
        let child = this.html[0];
        let parent = this.html[0].parentNode;

        let domPath = [];

        while(parent.parentNode != null) {
            let children = Array.from(parent.childNodes);

            let childIndex = children.indexOf(child);

            domPath.push({
                parent: parent.tagName,
                childIndex: childIndex
            });

            child = parent;
            parent = parent.parentNode;
        }

        domPath.reverse()

        return domPath;
    }

    static findFromDomPath(domPath) {
        let currentParent = document.querySelector(domPath[0].parent);

        for(let dp of domPath) {
            if(currentParent.tagName !== dp.parent) {
                throw new Error("DomPath invalid, should have seen "+dp.parent+" saw "+currentParent.tagName);
            }
            currentParent = Array.from(currentParent.childNodes)[dp.childIndex];
        }

        return currentParent;
    }

    /**
     * Create a fragment of the given type.
     *
     * If no Fragment is registered for the given type, null is returned.
     *
     * @example
     * let myJSFragment = Fragment.create("text/javascript");
     *
     * @param {string} type the type of fragment to create
     * @returns {Fragments.Fragment} the created fragment, or null
     */
    static create(type) {
        if (!Fragment.fragmentTypes.has(type)) {
            console.error("Creating fragment of unregistered type:", type);
            return null;
        }

        let fragmentDom = cQuery("<code-fragment data-type='" + type + "'></code-fragment>");

        Fragment.setupFragment(fragmentDom);

        return fragmentDom.data("Fragment");
    }

    /**
     * Registers a new fragment type
     * @ignore
     * @param {string} fragmentClass the fragment type to register
     */
    static registerFragmentType(fragmentClass) {
        if (Fragment.fragmentTypes.has(fragmentClass.type())) {
            console.error("Already have registered fragment type:", fragmentClass.type());
            return;
        }
        Fragment.fragmentTypes.set(fragmentClass.type(), fragmentClass);

        return Fragment.loadUnknownFragments(fragmentClass.type());
    }

    /**
     * Unregisters a fragment type, this also triggers unload on all fragments of this type that is currently loaded
     * @ignore
     * @param {string} fragmentClass the fragment type to unregister
     */
    static unRegisterFragmentType(fragmentClass) {
        Fragment.fragmentTypes.delete(fragmentClass.type());

        //Go through all fragments of this type, and do stuff
        cQuery("code-fragment[data-type='" + fragmentClass.type() + "']").forEach((fragmentElement) => {
            let fragment = cQuery(fragmentElement).data("Fragment");

            if (fragment != null) {
                //Unload the fragment
                fragment.unload();
            }

            //Reinsert this fragment as unknown
            Fragment.saveUnknownFragment(fragmentElement, fragmentClass.type());
        });
    }

    /**
     * Sets up the given fragment
     * @private
     * @param {cQuery} fragment - the fragment to set up
     */
    static setupFragment(fragment) {
        if (fragment.data("Fragment") != null) {
            //Already setup as fragment
            return null;
        }

        let fragmentType = fragment[0].getAttribute("data-type");

        if (!Fragment.fragmentTypes.has(fragmentType)) {
            //Unknown fragment type

            if (fragmentType != null) {
                Fragment.saveUnknownFragment(fragment, fragmentType);
            }

            return null;
        }

        let fragmentClass = Fragment.fragmentTypes.get(fragmentType);
        return new fragmentClass(fragment);
    }

    /**
     * Tries to setup all current and future fragments on the DOM
     * @ignore
     */
    static async setupFragments() {
        let foundFragments = [];

        //Check fragments already in DOM
        cQuery("code-fragment").forEach((fragmentDom) => {
            fragmentDom = cQuery(fragmentDom);
            let fragment = Fragment.setupFragment(fragmentDom);

            if (fragment !== null) {
                foundFragments.push(fragment);
            }
        });

        await Fragment.runFragmentsLoaded();

        //Observe newly added fragments, and deleted fragments
        let observer = new MutationObserver(async (mutations) => {

            let foundFragments = [];

            mutations.forEach((mutation) => {
                Array.from(mutation.addedNodes).forEach((node) => {
                    node = cQuery(node);
                    if (node.is("code-fragment")) {
                        let fragment = Fragment.setupFragment(node);
                        if(fragment != null) {
                            foundFragments.push(fragment);
                        }
                    } else {
                        if (node[0].querySelector != null) {
                            node.find("code-fragment").forEach((child) => {
                                child = cQuery(child);
                                let fragment = Fragment.setupFragment(child);
                                if(fragment != null) {
                                    foundFragments.push(fragment);
                                }
                            });
                        }
                    }
                });
                Array.from(mutation.removedNodes).forEach((node) => {
                    if(node.matches != null && node.matches("code-fragment")) {
                        cQuery(node).data("Fragment").unload();
                    } else if(node.querySelector != null) {
                        node.querySelectorAll("code-fragment").forEach((child)=>{
                            cQuery(child).data("Fragment").unload();
                        });
                    }
                });
            });

            await Fragment.runFragmentsLoaded();
        });

        observer.observe(document, {
            attributes: false,
            subtree: true,
            childList: true
        });
    }

    /**
     * Loads all currently unloaded fragments
     * @ignore
     * @returns {Promise<void>} - Promise that resolves when all unloaded fragments are done loading
     */
    static async runFragmentsLoaded() {
        if(!Fragment.allInstalledRun) {
            return;
        }

        //Check if currently loading
        while (Fragment.currentlyLoadingFragments) {
            await new Promise((resolve) => {
                setTimeout(() => {
                    resolve();
                }, 0);
            });
        }

        Fragment.currentlyLoadingFragments = true;

        let unloadedFragments = Fragment.find("code-fragment").filter((fragment)=>{
            let isLoaded = fragment.isLoaded;
            fragment.isLoaded = true;
            return !isLoaded;
        });

        for(let fragment of unloadedFragments) {
            fragment.isLoaded = true;
            await fragment.onFragmentsLoaded();
        }

        Fragment.currentlyLoadingFragments = false;
    }

    /**
     * Saves the given fragment for later loading when its no longer unknown
     * @private
     * @param {cQuery} fragment - the fragment to save
     * @param {string} type - the type of the fragment
     */
    static saveUnknownFragment(fragment, type) {

        //Unpack cQuery/jQuery objects, we want unique check of Set to work.
        if (fragment[0] != null) {
            fragment = fragment[0];
        }

        let fragmentsOfType = Fragment.unknownFragments.get(type);

        if (fragmentsOfType == null) {
            fragmentsOfType = new Set();
            Fragment.unknownFragments.set(type, fragmentsOfType);
        }

        fragmentsOfType.add(fragment);
    }

    /**
     * Loads all unknown fragments of a given type
     * @private
     * @param {type} type the fragment type to load
     */
    static loadUnknownFragments(type) {
        let unknownFragments = Fragment.unknownFragments.get(type);

        if (unknownFragments != null) {

            let unknownFragmentsCopy = Array.from(unknownFragments);

            //Clear the Set, fragments will be readded if not handled
            unknownFragments.clear();

            unknownFragmentsCopy.forEach((fragment) => {
                let frag = Fragment.setupFragment(cQuery(fragment));
            });

            return Fragment.runFragmentsLoaded();
        }

        return Promise.resolve();
    }

    /**
     * Returns the first fragment that is found from the given query
     *
     * This is the equivalent of taking the first result of Fragment.find(query)
     *
     * @example
     * let myFragment = Fragment.one("#myFragment");
     *
     * @param {string|cQuery|Array|Node} query - The query used to find fragments. Can be a css selector, a cQuery object, a dom element or an array of dom elements.
     * @returns {Fragments.Fragment} - the found fragment, or null if none could be found
     */
    static one(query) {
        let fragments = Fragment.find(query);

        if (fragments.length > 0) {
            return fragments[0];
        }

        return null;
    }

    /**
     * Finds all fragments based on a given query
     *
     * @example
     * let fragments = Fragment.find(".someClass");
     *
     * @param {string|cQuery|Array|Node} query - The query used to find fragments. Can be a css selector, a cQuery object, a dom element or an array of dom elements.
     * @returns {Fragments.Fragment[]} The found fragments
     */
    static find(query) {
        let fragments = [];

        if (query != null) {
            if (typeof query === "string") {
                cQuery(query).forEach((result) => {
                    result = cQuery(result);

                    let fragment = result.data("Fragment");

                    if (fragment != null) {
                        fragments.push(fragment);
                    }
                });

            } else if (Array.isArray(query) || query instanceof Array) {
                query.forEach((item) => {
                    fragments = fragments.concat(Fragment.find(item));
                });

            } else if (typeof query === "object") {
                if (query instanceof Fragment) {
                    fragments.push(query);
                } else if (query instanceof HTMLElement) {
                    let fragment = cQuery(query).data("Fragment");
                    if (fragment != null) {
                        fragments.push(fragment);
                    }
                } else if (query instanceof NodeList) {
                    fragments = fragments.concat(Fragment.find(Array.from(query)));
                }
            }
        }

        return fragments;
    }

    static fromFragmentUUID(uuid) {
        for(let fragmentDom of cQuery("code-fragment")) {
            let fragment = cQuery(fragmentDom).data("Fragment");

            if(fragment != null && fragment.uuid === uuid.replace("_", "-")) {
                return fragment;
            }
        }

        return null;
    }

    static addAllFragmentsLoadedCallback(callback) {
        Fragment.allFragmentsLoadedCallbacks.push(callback);
    }

}; window.Fragment = Fragment;

Fragment.allInstalledRun = false;
Fragment.fragmentTypes = new Map();
Fragment.unknownFragments = new Map();
Fragment.disableAutorun = false;
Fragment.currentlyLoadingFragments = false;
Fragment.allFragmentsLoadedCallbacks = [];

const urlParams = new URLSearchParams(location.search);
Fragment.disableAutorun = (urlParams.get("codestrates") === "false");

if(window.disableCodestratesFragmentsAutorun === true) {
    Fragment.disableAutorun = true;
}

Fragment.setupFragments();

wpm.onAllInstalled(()=>{
    Fragment.allInstalledRun = true;
    Fragment.runFragmentsLoaded().then(()=>{
        Fragment.allFragmentsLoadedCallbacks.forEach((callback)=>{
            callback();
        });
    });
});

</SCRIPT><SCRIPT id="stackwalker-script" type="disabled">
/**
 *  StackWalker
 *  An exception parser that that tries to clean out useless info from
 *  browser stack traces and provide only Codestrates-relevant parts
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/**
 * StackWalker can compactify stack traces to remove codestrates internal traces, thus making them easier to read
 */
class StackWalker {
    /**
     * Given a full stack trace, produces a reduced stacktrace where only codestrate
     * stack markers are used instead of every method invocation.
     *
     * @param {string[]} stack
     * @returns {string[]} The cleaned stack trace array
     */
    static compactify(stack){
        //Attempt to clean up some codestrates internal method code
        let cleanedStack = [];

        //If find pattern of Function.execute, codeStratesEvalInContext, eval, remove all 3
        stackLoop: for(let i = 0; i<stack.length; i++) {
            let si = stack[i];

            cleanPatternLoop: for(let cleanPattern of StackWalker.stackCleanPatterns) {
                try {
                    for(let j = 0; j<cleanPattern.pattern.length; j++) {
                        let pattern = cleanPattern.pattern[j];
                        let method = stack[i+j].method;

                        if(pattern.startsWith("~")) {
                            pattern = pattern.substring(1);
                            if(method.indexOf(pattern) === -1) {
                                //This pattern did not match
                                continue cleanPatternLoop;
                            }
                        } else {
                            if(method !== pattern) {
                                //This pattern did not match
                                continue cleanPatternLoop;
                            }
                        }
                    }

                    i += cleanPattern.pattern.length-1;

                    if(cleanPattern.output != null) {
                        let method = cleanPattern.output.method;

                        if(typeof method === "function") {
                            method = method(si);
                        }

                        cleanedStack.push({
                            method: method,
                            lineNumber: cleanPattern.output.lineNumber?si.lineNumber:null
                        });
                    }

                    continue stackLoop;
                } catch(e) {

                }
            }

            cleanedStack.push(si);
        }

        return cleanedStack;
    }
}

window.StackWalker = StackWalker;

StackWalker.stackCleanPatterns = [];

StackWalker.stackCleanPatterns.push({
    pattern: [
        "eval",
        "codeStratesEvalInContext",
        "Function.execute"
    ],
    output: null
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "codeStratesEvalInContext",
        "Function.execute",
        "~.require"
    ],
    output: null
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "_setup",
        "_start",
        "new _",
        "internalP5Function"
    ],
    output: null
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "_.n.default.redraw",
        "_draw"
    ],
    output: null
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "~.require",
        "~.onFragmentsLoaded",
        "Function.runFragmentsLoaded"
    ],
    output: {
        method: "<Codestrate Autostart>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "~.require",
        "eval",
        "eval",
        "Set.forEach",
        "Function.triggerEvent",
        "MenuItem.onAction",
        "MenuItem.triggerOnAction",
        "Menu.handleItemAction",
        "HTMLDivElement.eval",
        "h.a.emit",
        "Object.notifySelected",
        "_.handleItemAction",
        "HTMLDivElement.handleItemAction_",
        "d.a.emit",
        "Object.notifyAction",
        "d.handleClick",
        "d.handleClickEvent_"
    ],
    output: {
        method: "<Codestrate Run>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "TypeScriptAutoRunInternal",
        "eval",
        "Object.execCb",
        "e.check",
        "eval",
        "eval",
        "eval",
        "each",
        "emit",
        "e.check",
        "enable",
        "e.init",
        "a",
        "Object.completeLoad",
        "HTMLScriptElement.onScriptLoad"
    ],
    output: {
        method: "<Codestrate Autorun>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "eval",
        "Object.execCb",
        "e.check",
        "eval",
        "eval",
        "eval",
        "each",
        "emit",
        "e.check",
        "enable",
        "e.init",
        "a",
        "Object.completeLoad",
        "HTMLScriptElement.onScriptLoad"
    ],
    output: {
        method: "<Codestrate Run>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "eval",
        "Object.execCb",
        "e.check",
        "enable",
        "e.init",
        "eval"
    ],
    output: {
        method: "<Codestrate Run>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "P5Fragment.require",
        "P5Fragment.createAutoDom",
        "P5Fragment.insertAutoDom",
        "eval",
        "eval",
        "Array.forEach",
        "P5Fragment.triggerFragmentChanged",
        "P5Fragment.mutationCallback",
        "MutationObserver.mutationHandler"
    ],
    output: {
        method: "<Codestrate Autorun>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "P5Fragment.require",
        "P5Fragment.createAutoDom",
        "P5Fragment.insertAutoDom",
        "P5Fragment.onFragmentsLoaded",
        "Function.runFragmentsLoaded"
    ],
    output: {
        method: "<Codestrate Autorun>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "P5Fragment.require",
        "P5Fragment.createAutoDom",
        "P5Fragment.insertAutoDom",
        "eval",
        "eval",
        "Array.forEach",
        "P5Fragment.triggerFragmentChanged",
        "P5Fragment.executeObserverless",
        "CodemirrorEditor.handleModelChanged",
        "eval",
        "signal",
        "endOperation_finish",
        "endOperations",
        "at",
        "finishOperation",
        "endOperation",
        "runInOp",
        "~",
        "HTMLTextAreaElement.<anonymous>"
    ],
    output: {
        method: "<Codestrate Autorun>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "P5Fragment.require",
        "P5Fragment.createAutoDom",
        "P5Fragment.insertAutoDom",
        "eval",
        "eval",
        "Array.forEach",
        "P5Fragment.triggerFragmentChanged",
        "P5Fragment.executeObserverless",
        "CodemirrorEditor.handleModelChanged",
        "eval",
        "signal",
        "endOperation_finish",
        "endOperations",
        "at",
        "finishOperation",
        "endOperation",
        "HTMLTextAreaElement.<anonymous>"
    ],
    output: {
        method: "<Codestrate Autorun>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "~CS_ASYNC_fragment_"
    ],
    output: {
        method: (si) =>{
            //Internal fragment
            let fragmentUUID = si.method.substring(si.method.indexOf("CS_ASYNC_fragment_")+9).replace("_", "-");
            let fragment = Fragment.fromFragmentUUID(fragmentUUID);

            let attrName = fragment.html[0].getAttribute("name");
            let attrId = fragment.html[0].getAttribute("id");

            let name = (attrName != null && attrName.trim() !== "" ? attrName : "code-fragment");

            if(attrId != null && attrId.trim() !== "") {
                name += "#"+attrId;
            }

            return fragment.constructor.name+" "+name;
        },
        lineNumber: true
    }
})

/**
 * A StackTrace object
 * @memberof StackWalker
 */
class StackTrace {
    constructor(name, stack, extraReason) {
        /** @member {string} */
        this.name = name;
        /** @member {string[]} */
        this.stack = stack;
        /** @member {string} */
        this.extraReason = extraReason;
    }
};

window.StackWalker.StackTrace = StackTrace;

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="codestrates-repos" id="js-eval-engine" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "Javascript Evaluator Engine",
    "dependencies": [
        "#EventSystem"
    ],
    "assets": [],
    "license": "Apache 2.0",
    "version": "1"
}

</SCRIPT><SCRIPT id="jsEvalEngine-script" type="disabled">
/**
 *  JsEvalEngine
 *  Evaluate js while keeping track of it
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

function codeStratesEvalInContext(code, context) {
    with(context) {
        eval(code);
    }
}

window.JsEvalEngine = class JsEvalEngine {
    static async execute(code, options, fragment = null) {

        options = Object.assign({}, JsEvalEngine.defaultOptions(fragment), options);

        let resolver = null;
        let rejector = null;

        let asyncPromise = new Promise((resolve, reject)=>{
            resolver = resolve;
            rejector = reject;
        });

        let clonedConsole = Object.assign({}, console, options.customConsole);

        let context = {
            exports: {},
            asyncResolve: resolver,
            asyncReject: rejector,
            console: clonedConsole,
            fragmentSelfReference: fragment,
            error: (e)=>{
                let parsedStack = JsEvalEngine.parseErrorStack(e.name, e.stack, e);
                EventSystem.triggerEvent("Codestrates.Fragment.Error", {
                    messages: [parsedStack],
                    fragment: fragment
                });
                let compactStack = StackWalker.compactify(parsedStack.stack);
                let lineNumber = compactStack[0].lineNumber;
                JsEvalEngine.doLog(console.error, fragment, lineNumber, parsedStack.extraReason, compactStack);
            }
        };

        if(options.context != null) {
            context = Object.assign({}, context, options.context);
        }

        let asyncCode = code;

        if(options.async) {
            asyncCode = JsEvalEngine.wrapInAsync(code, fragment != null ? "CS_ASYNC_" + fragment.uuid.replace("-", "_") : null);
        }

        try {
            codeStratesEvalInContext.call(null, asyncCode, context);
            if(!options.async) {
                context.asyncResolve();
            }
        } catch(e) {
            context.error(e);
            throw e;
        }

        await asyncPromise.catch((e)=>{context.error(e); throw e});

        return context[options.exportsName];
    }

    static wrapInAsync(code, methodName) {
        if(methodName == null) {
            methodName = "anonymousAsyncEval";
        }

        //Make code async
        return `(async function ${methodName}() { ${code} \n })().then(()=>{asyncResolve();}).catch((e)=>{asyncReject(e);});`;
    }

    static parseErrorStack(name, stack, error) {
        let parsedStackTrace = [];
        let extraReason = null;

        if(stack == null) {
            console.warn("parseErrorStack: empty stack!");
            return new StackWalker.StackTrace(
                error,
                [],
                null
            );
        }

        if(window.chrome) {
            let stackSplit = stack.split("\n");

            if(!stackSplit[0].trim().startsWith("at")) {
                extraReason = stackSplit[0];
            }

            stackSplit.filter((line)=>{
                return line.trim().startsWith("at");
            }).forEach((line)=>{
                let trimmedLine = line.trim();

                let functionName = trimmedLine.substring(3, trimmedLine.indexOf("(")).trim();

                let lineNumberAndPosition = trimmedLine.substring(trimmedLine.indexOf("),")+2).trim().split(":");

                let lineNumber = parseInt(lineNumberAndPosition[1]);

                if(Number.isNaN(lineNumber)) {
                    lineNumber = null;
                }

                parsedStackTrace.push({
                    method: functionName,
                    lineNumber: lineNumber,
                    debug: trimmedLine
                });
            });
        } else if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
            let stackSplit = stack.split("\n");

            stackSplit.forEach((line) => {
                let trimmedLine = line.trim();

                let functionName = trimmedLine.substring(0, trimmedLine.indexOf("@")).trim();

                let lineNumberAndPosition = trimmedLine.substring(trimmedLine.lastIndexOf(">") + 2).trim().split(":");

                let lineNumber = parseInt(lineNumberAndPosition[1]);

                if (Number.isNaN(lineNumber)) {
                    lineNumber = null;
                }

                parsedStackTrace.push({
                    method: functionName,
                    lineNumber: lineNumber,
                    debug: trimmedLine
                });
            });
        } else {
            console.log("Unsupported browser for parsing stack trace: ", stack);
            parsedStackTrace = stack;
        }

        return new StackWalker.StackTrace(
            name,
            parsedStackTrace,
            extraReason
        );
    }

    static defaultOptions(fragment = null) {
        return {
            context: null,
            exportsName: "exports",
            async: true,
            customConsole: {
                log: (...messages)=> {
                    JsEvalEngine.doLog(console.log, fragment, null, ...messages);
                    if(typeof EventSystem !== "undefined") {
                        EventSystem.triggerEvent("Codestrates.Fragment.Log", {
                            messages: messages,
                            fragment: fragment
                        });
                    }
                },
                warn: (...messages)=>{
                    JsEvalEngine.doLog(console.warn, fragment, null, ...messages);
                    if(typeof EventSystem !== "undefined") {
                        EventSystem.triggerEvent("Codestrates.Fragment.Warn", {
                            messages: messages,
                            fragment: fragment
                        });
                    }
                },
                error: (...messages)=>{
                    JsEvalEngine.doLog(console.error, fragment, null, ...messages);
                    if(typeof EventSystem !== "undefined") {
                        EventSystem.triggerEvent("Codestrates.Fragment.Error", {
                            messages: messages,
                            fragment: fragment
                        });
                    }
                }
            }
        };
    }

    static doLog(logger, fragment, lineNumber, ...messages) {
        if(fragment != null) {
            let name = fragment.html[0].getAttribute("name");
            let id = fragment.html[0].getAttribute("id");

            logger("Fragment ["+(name!=null&&name.trim()!==""?name:fragment.type)+(id!=null&&id.trim()!==""?"#"+id:"")+(lineNumber!=null?":"+lineNumber:"")+"]", ...messages);
        } else {
            logger(...messages);
        }
    }
};

window.addEventListener("unhandledrejection", (evt)=>{
    if(evt.reason != null) {
        let parsedStack = JsEvalEngine.parseErrorStack(evt.reason.name, evt.reason.stack);
        EventSystem.triggerEvent("Codestrates.Fragment.Error", {
            messages: ["Uncaught rejection in promise: ", parsedStack]
        });
    } else {
        console.warn("Did not include a reason property:", evt);
    }
});

window.addEventListener("error", (evt)=>{
    if(evt.error != null) {
        let parsedStack = JsEvalEngine.parseErrorStack(evt.error.message, evt.error.stack);
        EventSystem.triggerEvent("Codestrates.Fragment.Error", {
            messages: ["Uncaught exception: ", parsedStack]
        });
    } else {
        console.warn("Did not include an error property:", evt);
    }
});

//Setup infinite stack depth
Error.stackTraceLimit = Infinity;

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="codestrates-repos" id="fragment_html" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "HTML Fragment support for Codestrates",
    "dependencies": [
        "#fragment_core"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</SCRIPT><SCRIPT id="fragment_html-script" type="disabled">
/**
 *  HtmlFragment
 *  Fragments with html that can be injected into the page in the same place
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, wpm */

wpm.onRemoved(()=>{
    Fragment.unRegisterFragmentType(HtmlFragment);
});

/**
 * A fragment containing html
 *
 * Supports autodom insertion
 * @extends Fragments.Fragment
 * @hideconstructor
 * @memberof Fragments
 */
class HtmlFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    supportsAutoDom() {
        return true;
    }

    /**
     * Get a document fragment containing the html from this fragment
     *
     * @example
     * let documentFragment = Fragment.one("#myHtmlFragment").require();
     *
     * @returns {Promise<DocumentFragment>}
     */
    async require(options) {
        let domFragment = document.createDocumentFragment();

        let dom = cQuery("<div>"+this.raw+"</div>");

        Array.from(dom[0].childNodes).forEach((node)=>{
            domFragment.appendChild(node);
        });

        return domFragment;
    }

    getTextContentNode() {
        if(this.html[0].childNodes.length > 1 || (this.html[0].firstChild != null && !(this.html[0].firstChild instanceof Text))) {
            //We have at least one child, first of those is not a Text node, convert
            let textNode = document.createTextNode("");
            let content = this.html[0].innerHTML;
            this.html[0].innerHTML = "";
            this.html[0].appendChild(textNode);
            textNode.nodeValue = content;
            console.log("Converted HTML to single textNode");
        }

        return super.getTextContentNode();
    }

    static type() {
        return "text/html";
    }
}; window.HtmlFragment = HtmlFragment;

Fragment.registerFragmentType(HtmlFragment);

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="codestrates-repos" id="fragment_json" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "JSON-data Fragment for Codestrates",
    "dependencies": [
        "#fragment_core"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</SCRIPT><SCRIPT id="fragment_json-script" type="disabled">
/**
 *  JSONFragment
 *  Fragments with json data that can be included
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, wpm */

wpm.onRemoved(()=>{
    Fragment.unRegisterFragmentType(JSONFragment);
});

/**
 * A fragment that contains json
 *
 * @extends Fragments.Fragment
 * @memberof Fragments
 * @hideconstructor
 */
class JSONFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    /**
     * Get the contained json as an object
     * @example
     * let jsonElement = Fragment.one("#myJsonFragment").require();
     * @returns {Promise<Object>} - Promise that resolves to the json object with the json from this fragment.
     */
    async require(options = {}) {
        return JSON.parse(this.raw);
    }

    static type() {
        return "application/json";
    }
}; window.JSONFragment = JSONFragment;

Fragment.registerFragmentType(JSONFragment);

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="codestrates-repos" id="fragment_wpm-descriptor" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "WPM package descriptor Fragment for Codestrates",
    "dependencies": [
        "#fragment_core"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</SCRIPT><SCRIPT id="fragment_descriptor-script" type="disabled">
/**
 *  DescriptorFragment
 *  Support for WPM package descriptors in Codestrates
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, wpm, WPMv2 */

wpm.onRemoved(() => {
    Fragment.unRegisterFragmentType(DescriptorFragment);
});

/**
 * A fragment containing a WPM descriptor
 *
 * @extends Fragments.Fragment
 * @hideconstructor
 * @memberof Fragments
 */
class DescriptorFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    getTextContentNode() {
        let self = this;

        let descriptor = this.html.find("wpm-descriptor");

        if (descriptor.length === 0) {
            this.executeObserverless(() => {
                descriptor = cQuery(document.createElement("wpm-descriptor"));
                self.html.append(descriptor);
                WPMv2.stripProtection(descriptor);
                descriptor[0].textContent = `{
    "description": "",
    "dependencies": [
    ],
    "assets": [],
    "version": "1"
}`;
            },null, true);
        }

        this.checkTextContentNode(descriptor[0]);

        return descriptor[0];
    }

    /**
     *  A json object containing the descriptor json
     * @example
     * let descriptorJson = Fragment.one("#myDescriptorFragment").require();
     * @returns {Promise<Object>}
     */
    async require(options = {}) {
        return JSON.parse(this.raw);
    }

    static type() {
        return "wpm/descriptor";
    }
};

window.DescriptorFragment = DescriptorFragment;
Fragment.registerFragmentType(DescriptorFragment);

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="codestrates-repos" id="fragment_css" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "CSS Fragment for Codestrates",
    "dependencies": [
        "#fragment_core"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</SCRIPT><SCRIPT id="fragment_css-script" type="disabled">
/**
 *  CSSFragment
 *  Fragments with css that can be injected into the page
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/


/* global webstrate, cQuery, Fragment, wpm */
wpm.onRemoved(()=>{
    Fragment.unRegisterFragmentType(CSSFragment);
});

/**
 * A fragment that contains css code
 *
 * Supports autodom insertion
 * @hideconstructor
 * @memberof Fragments
 * @extends Fragments.Fragment
 */
class CSSFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    /**
     * Creates a new style element with the styles represented by this css fragment inserted.
     *
     * @example
     * let styleElm = Fragment.one("#myCssFragment").require();
     *
     * @returns {Promise<HTMLStyleElement>} - Promise that resolves to the style element
     */
    async require(options = {}) {
        let style = document.createElement("style");

        style.textContent = this.raw;

        return style;
    }

    supportsAutoDom() {
        return true;
    }

    static type() {
        return "text/css";
    }
}; window.CSSFragment = CSSFragment;

Fragment.registerFragmentType(CSSFragment);

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="codestrates-repos" id="fragment_scss" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "SCSS Fragment for Codestrates",
    "dependencies": [
        "#fragment_core",
        "wpm_js_libs #sass_js"
    ],
    "license": "Apache 2.0 (w/MIT)",
    "assets": [],
    "version": "1"
}

</SCRIPT><SCRIPT id="fragment_scss-script" type="disabled">
/**
 *  SCSSFragment
 *  Compose and compile SCSS-scripts in Codestrates
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, fetchSassWorkerBlob, URL, wpm */

wpm.onRemoved(() => {
    Fragment.unRegisterFragmentType(SCSSFragment);
});

/**
 * A fragment containing scss
 *
 * Supports autodom insertion
 * @extends Fragments.Fragment
 * @hideconstructor
 * @memberof Fragments
 */
class SCSSFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    /**
     * Create a style element containing the css rules resulting from compiling this fragments scss
     * @example
     * let styleElm = Fragment.one("#myScssFragment").require();
     * @returns {Promise<HTMLStyleElement>}
     */
    require(options) {
        let self = this;

        return new Promise(async (resolve, reject) => {
            // Check cached data
            if (typeof AutoDOMCache !== "undefined"){
                let cache = await AutoDOMCache.get(self);
                if (cache!==null){
                    let style = document.createElement("style");
                    style.textContent = cache;
                    resolve(style);
                    return;
                }
            }

            let start = Date.now();

            //Check for compiler
            await new Promise((resolveCompiler)=>{
                if(SCSSFragment.compiler == null) {
                    requirejs(["sass/sass"], (Sass)=> {
                        fetchSassWorkerBlob().then((blob) => {
                            SCSSFragment.compiler = new Sass(URL.createObjectURL(blob));
                            resolveCompiler();
                        });
                    });
                } else {
                    resolveCompiler();
                }
            });

            SCSSFragment.compiler.compile(self.raw, async (result) => {
                if (result.status === 0) {
                    let style = document.createElement("style");
                    style.textContent = result.text;

                    // Store in cache for later too
                    if (typeof AutoDOMCache !== "undefined"){
                         await AutoDOMCache.set(self, result.text);
                    }

                    resolve(style);
                } else {
                    reject(result.message);
                }
            });
        });
    }

    supportsAutoDom() {
        return true;
    }

    static type() {
        return "text/x-scss";
    }
}; window.SCSSFragment = SCSSFragment;

Fragment.registerFragmentType(SCSSFragment);

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="codestrates-repos" id="editor_core" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "The base editor core required by all Codestrate editors",
    "dependencies": [
        "wpm_js_libs #cQuery",
        "wpm_js_libs #CaviTouch",
        "#fragment_core",
        "#EventSystem"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</SCRIPT><SCRIPT id="editor_core-script" type="disabled">
/**
 *  Editor and EditorManager
 *  Base classes for handling editors in Codestrates
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global cQuery, webstrate */

/**
 * Triggers when a selection changes inside an editor
 * @event Editors.Editor.EventSystem:"Codestrates.Editor.Selection"
 * @type {Event}
 * @property {Editors.Editor} editor - The editor that triggered the event
 * @property {Editors.Editor~cursorSelection} selection - The selection
 */

/**
 * Triggers when an editor looses focus
 * @event Editors.Editor.EventSystem:"Codestrates.Editor.Blur"
 * @type {Event}
 * @property {Editors.Editor} editor - The editor that triggered the event
 */

/**
 * Triggers when an editor gains focus
 * @event Editors.Editor.EventSystem:"Codestrates.Editor.Focus"
 * @type {Event}
 * @property {Editors.Editor} editor - The editor that triggered the event
 */
/**
 * Triggers when an editor is closed
 * @event Editors.Editor.EventSystem:"Codestrates.Editor.Closed"
 * @type {Event}
 * @property {Editors.Editor} editor - The editor that triggered the event
 */
/**
 * Triggers when an editor is opened
 * @event Editors.Editor.EventSystem:"Codestrates.Editor.Opened"
 * @type {Event}
 * @property {Editors.Editor} editor - The editor that triggered the event
 */

/**
 * @namespace Editors
 */

/**
 * EditorManager
 *
 * @memberof Editors
 */
class EditorManager {
    /**
     * @private
     */
    static registerEditor(editor) {
        editor.types().forEach((type)=>{
            EditorManager.registerEditorType(type, editor);
        });
    }

    static registerEditorType(type, editor) {
        let editors = EditorManager.editorTypes.get(type);
        if(editors == null) {
            editors = new Set();
            EditorManager.editorTypes.set(type, editors);
        }

        editors.add(editor);
    }

    /**
     * @private
     */
    static unregisterEditor(editor, editorClassName) {
        for(let editors of EditorManager.editorTypes.values()) {
            editors.delete(editor);
        }

        cQuery("."+editorClassName).forEach((editor)=>{
            editor = cQuery(editor).data("Editor");
            if(editor != null) {
                editor.unload();
            }
        });
    }

    /**
     * @typedef {Object} EditorManager~EditorConfig
     * @property {Editors.Editor} [editor] - The editor to use.
     * @property {string} [theme] -  The theme to use, supports "light" or "dark".
     * @property {string} [mode] - The editor mode, supports "inline" or "full".
     * @property {boolean} [readOnly] - Should the editor be read only.
     */

    /**
     * Create an editor for the given fragment/array of fragments.
     *
     * <pre><code>config options:
     *  editor: null | EditorClass -- If not null, tries to create the specified editor
     *  theme: "light" | "dark" -- The theme to use for the editor
     *  mode: "inline" | "full" -- Inline fills the space its in, full resizes the editor to show all lines.
     *  readOnly: true|false -- Should the editor be read only</code></pre>
     *
     * @example
     * let editor = EditorManager.create(Fragment.one("#myFragment"), {theme:"light", mode: "full"})[0];
     *
     * @param {Fragments.Fragment|Fragments.Fragment[]} fragment - The fragment, or array of fragments to create the editors from
     * @param {EditorManager~EditorConfig} config - The editor config to use
     * @returns {Editors.Editor[]} the created editors
     */
    static createEditor(fragment, config = {}) {
        let result = [];

        let defaultConfig = {
            editor: null,
            theme: "light",
            mode: "inline",
            readOnly: false
        };

        config = Object.assign({}, defaultConfig, config);

        if(Array.isArray(fragment)) {
            for(let frag of fragment) {
                result = result.concat(EditorManager.createEditor(frag, config));
            }
        } else {
            if(config.editor != null) {
                if(config.editor.types().includes(fragment.type)) {
                    result.push(new config.editor(fragment, config));
                } else {
                    let newConfig = Object.assign({}, config);
                    newConfig.editor = null;
                    result = result.concat(EditorManager.createEditor(fragment, newConfig));
                    if(result.length === 0) {
                        console.warn(config.editor.name+" does not support fragment type:", fragment.constructor.type());
                        console.warn("Auto editor discovery did not find any usable editors.");
                    } else {
                        console.log(config.editor.name+" does not support fragment type:", fragment.constructor.type());
                        console.log("Auto editor discovery: ", result);
                    }
                }
            } else {
                let editors = EditorManager.editorTypes.get(fragment.type);

                if(editors == null) {
                    editors = new Set();
                    EditorManager.editorTypes.set(fragment.type, editors);
                }

                //Filter preview editor from auto discovery, as it can not edit.
                const availableEditors = Array.from(editors).filter((editor)=>{
                    return editor !== PreviewEditor;
                });

                if(availableEditors.length > 0) {
                    //TODO: Maybee not just use the first editor available?
                    result.push( new (availableEditors[0])(fragment, config));
                }
            }
        }

        return result;
    }

    /**
     * Used to load CSS for implementing editors
     * @private
     */
    static loadCss(url) {
        return new Promise((resolve, reject)=>{
            let link = document.createElement("link");
            link.type = "text/css";
            link.rel = "stylesheet";
            link.href = url;

            link.setAttribute("transient-element", "");

            document.head.append(link);

            link.onload = ()=>{
                resolve();
            };
        });
    }
}; window.EditorManager =  EditorManager;

EditorManager.editorTypes = new Map();

/**
 * Editor represents a fragment editor
 * @abstract
 * @memberof Editors
 * @hideconstructor
 */
class Editor {
    constructor(htmlClass, fragment, options = {}) {
        this.html = cQuery("<div class='codestrates-editor-core'></div>");
        this.html.data("Editor", this);

        this.fragment = fragment;
        this.handleModelChanges = true;

        this.options = options;

        this.editorDiv = cQuery("<div class='codestrates-editor-core-view "+htmlClass+"'></div>");

        this.html.append(this.editorDiv);

        this.foreignSelections = new Map();

        this.eventDeleters = [];

        if(options.mode === "inline") {
            this.verticalResizeHandle = cQuery("<div class=\"codestrates-editor-core-resizer\"></div>");
            this.html.append(this.verticalResizeHandle);
            this.setupResizer();
            this.html.addClass("resizeable");
        } else if(options.mode === "component") {
            this.html.addClass("component");
        } else if(options.mode === "full") {
            //Do nothing atm.
        }

        let self = this;

        this.eventDeleters.push(this.fragment.registerOnFragmentChangedHandler((context)=>{
            if(context === self) {
                return;
            }

            self.handleFragmentChanged();
        }));

        this.eventDeleters.push(this.fragment.registerOnTextInsertedHandler((pos, val)=>{
            self.handleTextInserted(pos, val);
        }));

        this.eventDeleters.push(this.fragment.registerOnTextDeletedHandler((pos, val)=>{
            self.handleTextDeleted(pos, val);
        }));

        this.resizeHandler = function() {
            self.onSizeChanged();
        };

        this.focusOutHandler = function() {
            self.triggerEditorLostFocus();
        };

        this.focusInHandler = function() {
            self.triggerEditorGainedFocus();
        };

        window.addEventListener("resize", this.resizeHandler);

        this.html[0].addEventListener("focusout", this.focusOutHandler);

        this.html[0].addEventListener("focusin", this.focusInHandler);

        //Setup live query to listen for cursors
        this.otherCursorLiveQuery = this.html.liveQuery("[class*='otherCursor_']", {
            added: (obj)=>{
                obj.classList.add("otherCursor");
            }
        });
        this.otherSelectorLiveQuery = this.html.liveQuery("[class*='otherSelector_']", {
            added: (obj)=>{
                obj.classList.add("otherSelector");
            }
        });

        this.waitForDomInsertion().then(()=>{
            self.waitForDisplay().then(()=>{
                self.onSizeChanged();
            });
        });
    }

    setWordwrap(state) {
        //Override me
        console.warn("Changing word wrap is not supported in this editor:"+this.constructor.name);
    }

    waitForDisplay() {
        let self = this;

        return new Promise((resolve, reject)=>{
            function checkDisplay() {
                try {
                    if (self.html[0].offsetWidth > 0) {
                        resolve();
                    } else {
                        setTimeout(checkDisplay, 100);
                    }
                } catch(e) {

                }
            }

            checkDisplay();
        });
    }

    waitForDomInsertion() {
        let self = this;

        return new Promise((resolve, reject)=>{
            let observer = new MutationObserver((mutations)=>{
                let foundEditor = false;
                mutations.forEach((mutation)=>{
                    Array.from(mutation.addedNodes).forEach((addedNode)=>{
                        if(addedNode === self.html[0]) {
                            foundEditor = true;
                        } else {
                            let parent = self.html[0].parentNode;

                            while(parent != null) {
                                if(parent === addedNode) {
                                    foundEditor = true;
                                    break;
                                }

                                parent = parent.parentNode;
                            }
                        }
                    });
                });

                if(foundEditor) {
                    observer.disconnect();
                    resolve();
                }
            });

            observer.observe(document, {
                childList: true,
                subtree: true
            });
        });
    }

    /**
     * Focuses the editor
     */
    focus() {
        //Override in subclass
    }

    /**
     * Sets the currently active line
     */
    setLine(line, column=1) {
        //Override in subclass
    }


    /**
     * @typedef {object} Editors.Editor~cursorSelection
     * @property {number} startLine
     * @property {number} startColumn
     * @property {number} endLine
     * @property {number} endColumn
     * @property {number} positionLine
     * @property {number} positionColumn
     */

    /**
     * Sets a forign client selection marker in this editor
     * @param {String} remoteClient - Webstrate clientId of the remote client that has a selection in the fragment this editor is editing
     * @param {Editors.Editor~cursorSelection} cursorSelection - The selection
     */
    setForeignSelection(remoteClient, cursorSelection) {
        if(cursorSelection == null) {
            this.foreignSelections.delete(remoteClient);
        } else {
            this.foreignSelections.set(remoteClient, cursorSelection);
        }
        this.updateForeignSelections(remoteClient);
    }

    /**
     * @private
     */
    updateForeignSelections(remoteClient=null) {
        //Overrite in subclass
    }

    /**
     * @private
     */
    triggerCursorSelection(selection) {
        EventSystem.triggerEvent("Codestrates.Editor.Selection", {
            editor: this,
            selection: selection
        });
    }

    /**
     * @private
     */
    triggerEditorLostFocus() {
        EventSystem.triggerEvent("Codestrates.Editor.Blur", {
            editor: this
        });
    }

    /**
     * @private
     */
    triggerEditorGainedFocus() {
        EventSystem.triggerEvent("Codestrates.Editor.Focus", {
            editor: this
        });
    }

    /**
     * @private
     */
    triggerEditorClosed() {
        EventSystem.triggerEvent("Codestrates.Editor.Closed", {
            editor: this
        });
    }

    /**
     * @private
     */
    triggerEditorOpened() {
        EventSystem.triggerEvent("Codestrates.Editor.Opened", {
            editor: this
        });
    }

    /**
     * @private
     */
    onSizeChanged() {
        //Overwrite in subclass
    }

    /**
     * @private
     */
    setupResizer() {
        let self = this;

        new CaviTouch(this.verticalResizeHandle, {
            dragMinDistance: 0
        });

        this.verticalResizeHandle.on("caviDrag", (evt)=>{
            let height = self.html[0].clientHeight + evt.detail.caviEvent.deltaPosition.y;
            self.html[0].style.height = height+"px";
            self.onSizeChanged();
        });
    }

    /**
     * @private
     */
    handleFragmentChanged() {
        let self = this;

        this.handleModelChanges = false;
        try {
            let editorValue = this.getValue();
            let fragmentValue = this.fragment.raw;

            if(editorValue !== fragmentValue) {
                this.setValue(this.fragment.raw);
            }
        } catch(e) {
            console.error("Error setting fragment value:", e);
        }

        setTimeout(()=>{
            self.handleModelChanges = true;
        },0);
    }

    /**
     * @private
     */
    handleTextInserted(pos, val) {
        let self = this;

        this.handleModelChanges = false;
        try {
            this.insertText(pos, val);
        } catch(e) {
            console.error("Error setting fragment value:", e);
        }

        setTimeout(()=>{
            self.handleModelChanges = true;
        },0);
    }

    /**
     * @private
     */
    handleTextDeleted(pos, val) {
        let self = this;

        this.handleModelChanges = false;
        try {
            this.deleteText(pos, val);
        } catch(e) {
            console.error("Error setting fragment value:", e);
        }

        setTimeout(()=>{
            self.handleModelChanges = true;
        },0);
    }

    /**
     * @private
     */
    handleModelChanged() {
        let self = this;

        if(this.handleModelChanges) {
            let changedValue = this.getValue();

            if(changedValue !== self.fragment.raw) {
                this.fragment.executeObserverless(() => {
                    EventSystem.triggerEvent("Codestrates.Editor.BeforeModelChanged", {
                        editor: this
                    });
                    self.fragment.raw = changedValue;
                    EventSystem.triggerEvent("Codestrates.Editor.AfterModelChanged", {
                        editor: this
                    });
                }, this);
            }
        }
    }

    /**
     * Get the current string value of this editor
     * @returns {string}
     */
    getValue() {
        //Override in subclass
        console.warn("getValue not overridden", this);
    }

    /**
     * Sets the current string value of this editor
     * @param {string} value
     */
    setValue(value) {
        //Override in subclass
        console.warn("setValue not overridden", this);
    }

    /**
     * Inserts text into this editor
     * @param {number} pos - The position to insert at
     * @param {string} val - The value to insert
     */
    insertText(pos, val) {
        //Override in subclass
        console.warn("insertText not overridden", this);
    }

    /**
     * Inserts text into this editor
     * @param {number} pos - The position to delete from
     * @param {string} val - The value to delete
     */
    deleteText(pos, val) {
        //Override in subclass
        console.warn("deleteText not overridden", this);
    }

    /**
     * Inserts the given text at the current selection, if no selection just insert at the cursor position, else replace the current selection.
     * @param {string} text - The text to insert
     */
    insertAtSelection(text) {
        //Override in subclass
        console.warn("insertAtSelection not overridden", this, text);
    }

    setTheme(themeName){
        console.warn("editor.setTheme not supported for ", themeName, this);
    }

    /**
     * Unloads this editor
     */
    unload() {
        this.triggerEditorClosed();

        this.eventDeleters.forEach((deleter)=>{
            deleter.delete();
        });

        window.removeEventListener("resize", this.resizeHandler);

        this.html[0].removeEventListener("focusout", this.focusOutHandler);

        this.html[0].removeEventListener("focusin", this.focusInHandler);

        this.otherCursorLiveQuery.stop();
        this.otherSelectorLiveQuery.stop();
        this.html.remove();
        this.html.data("Editor", null);
        this.html = null;
    }
}; window.Editor = Editor;

</SCRIPT><STYLE id="base-style">
/**
 *  Editor styles
 *  Base classes for handling editors in Codestrates
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

.codestrates-editor-core {
    position: relative;
}

.codestrates-editor-core.unsaved {
    border: crimson solid 2px;
}

.codestrates-editor-core-view {
    height: 100%;
}

.codestrates-editor-core.component {
    height: 100%;
}

.codestrates-editor-core.resizeable {
    min-height: 6em;
    height: 6em;
}
.codestrates-editor-core.resizeable .codestrates-editor-core-resizer {
    position: absolute;
    cursor: ns-resize;
    left: 0;
    top: 100%;
    width: 100%;
    opacity: 0.2;
    height: 0.5em;
    border-top: 0.2em solid rgba(0,0,0,0.5);
    transition: opacity 0.20s ease-out, border-top-width 0.20s ease-out;
    z-index: 4;
}
.codestrates-editor-core.resizeable .codestrates-editor-core-resizer:hover {
    opacity: 1;
    border-top-width: 0.75em;
}
</STYLE></WPM-PACKAGE><WPM-PACKAGE data-repository="codestrates-repos" id="fragment_js" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "Javascript Fragment for Codestrates",
    "dependencies": [
        "#fragment_core",
        "#js-eval-engine"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</SCRIPT><SCRIPT id="fragment_js-script" type="disabled">
/**
 *  JavascriptFragment
 *  Fragments with js that can be executed
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, wpm, JsEvalEngine */

wpm.onRemoved(()=>{
    Fragment.unRegisterFragmentType(JavascriptFragment);
});

/**
 * A fragment that contains js code
 *
 * Supports auto - executes require() on load
 * @extends Fragments.Fragment
 * @hideconstructor
 * @memberof Fragments
 */
class JavascriptFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    /**
     * An object describing the options for require.
     *
     * Example:
     * <pre><code>{
     *     context: {
     *         someVariable: "test"
     *     },
     *     customConsole: {
     *         log: (...messages)=>{
     *              console.log("Custom:", ...messages);
     *         }
     *     }
     * }
     * </code></pre>
     *
     * @typedef {Object} JavascriptFragment~RequireOptions
     * @property {Object} [context] - The context to pass to the javascript environment
     * @property {Object} [customConsole] - A custom object used instead of window.console, ie. to make custom log methods.
     */

    /**
     * Evaluates the javascript inside this fragment and returns the export object
     *
     * @example
     * let exportedObject = Fragment.one("#myJsFragment").require();
     *
     * @param {JavascriptFragment~RequireOptions} [options] - Object containing any custom options.
     * @returns {Promise<Object>}
     */
    require(options = {}) {
        return JsEvalEngine.execute(this.raw, options, this);;
    }

    async onFragmentsLoaded() {
        if(this.auto && !Fragment.disableAutorun) {
            await this.require();
        }
    }

    supportsRun() {
        return true;
    }

    supportsAuto() {
        return true;
    }

    static type() {
        return "text/javascript";
    }
}; window.JavascriptFragment = JavascriptFragment;

Fragment.registerFragmentType(JavascriptFragment);

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="codestrates-repos" id="editor_monaco" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "Plugin to use Monaco Editor",
    "dependencies": [
        "wpm_js_libs #monaco_editor",
        "#editor_core"
    ],
    "license": "Apache 2.0 (w/MIT)",
    "assets": [],
    "version": "1"
}

</SCRIPT><SCRIPT id="editor_monaco-script" type="disabled">
/**
 *  MonacoEditor
 *  Wrapper for using the Monaco editor in Codestrates
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Editor, monaco, EditorManager */

wpm.onRemoved(()=>{
    EditorManager.unregisterEditor(MonacoEditor, "monaco-editor");
});

/**
 * An editor implementation using Monaco
 *
 * @memberof Editors
 * @extends Editors.Editor
 */
class MonacoEditor extends Editor {
    constructor(fragment, options = {}) {
        super("monaco-editor", fragment, options);

        this.options = options;

        this.foreignDecorators = new Map();

        this.setupEditor();
    }

    static registerExtraType(mimeType, language) {
        MonacoEditor.extraTypes.set(mimeType, language);
        EditorManager.registerEditorType(mimeType, this);
    }

    async setupEditor() {
        let self = this;

        let language = "text";

        switch (self.fragment.type) {
            case "text/x-latex":
                language = "plaintext";
                break;

            case "text/javascript":
                language = "javascript";
                break;

            case "text/p5js":
                language = "javascript";
                break;

            case "text/whenjs":
                language = "javascript";
                break;

            case "text/python":
                language = "python";
                break;

            case "text/markdown":
                language = "markdown";
                break;

            case "text/html":
                language = "html";
                break;

            case "text/css":
                language = "css";
                break;

            case "text/x-scss":
                language = "scss";
                break;

            case "application/x-lua":
                language = "lua";
                break;

            case "text/ruby":
                language = "ruby";
                break;

            case "text/x-typescript":
                language = "typescript";
                break;

            case "wpm/descriptor":
            case "application/json":
            case "text/whenv2":
                language = "json";
                break;
        }

        if(MonacoEditor.extraTypes.has(self.fragment.type)) {
            console.log("Using extra type:", self.fragment.type);
            language = MonacoEditor.extraTypes.get(self.fragment.type);
        }

        requirejs(["vs/editor/editor.main"], () => {
            EventSystem.triggerEvent("Codestrates.Editor.Monaco.Loaded", {
                monaco: monaco
            });

            let theme = "vs";

            if (self.options.theme === "dark") {
                theme = "vs-dark";
            }

            monaco.languages.json.jsonDefaults.diagnosticsOptions.enableSchemaRequest = true;

            self.editor = monaco.editor.create(self.editorDiv[0], {
                value: this.fragment.raw,
                language: language,
                theme: theme,
                minimap: {
                    enabled: false
                },
                automaticLayout: false,
                fixedOverflowWidgets: true,
                contextmenu: false,
                scrollBeyondLastLine: false,
                scrollBeyondLastColumn: 0,
                occurrencesHighlight: false,
                selectionHighlight: false,
                accessibilitySupport: "off",
                folding: false,
                guides: {
                    bracketPairs: true
                },
                readOnly: this.options.readOnly,
                bracketPairColorization: {
                    enabled: true
                },
                scrollbar: {
                    alwaysConsumeMouseWheel: false,
                    horizontal: 'auto',
                    vertical: 'auto',
                    horizontalScrollbarSize: 17
                }
            });

            self.editor.getModel().setEOL(0);

            if (self.options.mode === "full") {
                //Setup resizeing for all the lines

                self.editor.getModel().onDidChangeContent(()=>{self.updateSize();});
                self.editor.getModel().onDidChangeDecorations(()=>{
                    setTimeout(()=>{
                        self.updateSize();
                    }, 0);
                });

                self.updateSize();
            }

            self.editor.getModel().onDidChangeContent((evt) => {
                self.handleModelChanged();
            });

            self.editor.onDidChangeCursorSelection((evt)=>{
                self.triggerCursorSelection({
                    startLine: evt.selection.startLineNumber,
                    startColumn: evt.selection.startColumn,
                    endLine: evt.selection.endLineNumber,
                    endColumn: evt.selection.endColumn,
                    positionLine: evt.selection.positionLineNumber,
                    positionColumn: evt.selection.positionColumn
                });
            });

            self.triggerEditorOpened();
        });
    }

    focus() {
        let self = this;

        if(this.editor == null) {
            //Try to focus the editor as soon as its created.
            setTimeout(()=>{
                self.focus();
            }, 100);
        } else {
            this.editor.focus();
        }
    }

    setLine(line, column=1) {
        let self = this;

        if(this.editor == null) {
            //Try to focus the editor as soon as its created.
            setTimeout(()=>{
                self.setLine(line);
            }, 100);
        } else {
            this.editor.revealLineNearTop(line);
            this.editor.setPosition({
                column: column,
                lineNumber: line
            });
        }
    }

    updateSize() {
        let oldWidth = this.editor.getLayoutInfo().width;
        let numLines = this.editor._modelData.viewModel._lines.getViewLineCount();

        let height = 19;

        let viewLines = this.editorDiv.find("div.view-line");

        if (viewLines.length > 0) {
            height = viewLines[0].offsetHeight;
        }

        this.editor.layout({
            width: oldWidth,
            height: numLines * height
        });

        let scrollHeight = this.editor.getScrollHeight();

        if(this.editor.getLayoutInfo().height !== scrollHeight) {
            this.editor.layout({
                width: oldWidth,
                height: scrollHeight
            });
        }
    }

    onSizeChanged() {
        if (typeof this.editor!=="undefined"){

            this.editor.layout();

            if(this.mode === "full") {
                this.updateSize();
            }
        }
    }

    setTheme(themeName){
        // STUB: Monaco does not support individual themes yet
        // See this on why this will change all editors simultaneously: https://github.com/Microsoft/monaco-editor/issues/338
        switch (themeName){
            case "dark":
                // this.editor._themeService
                monaco.editor.setTheme("vs-dark");
                break
            default:
                monaco.editor.setTheme("vs");
        }
    }

    updateForeignSelections(remoteClient = null) {
        let self = this;

        if(this.editor == null) {
            //Editor not ready yet.
            return;
        }

        let clientsToUpdate = [];

        if(remoteClient != null) {
            clientsToUpdate.push(remoteClient);
        } else {
            clientsToUpdate = Array.from(this.foreignSelections.keys());
        }

        clientsToUpdate.forEach((client)=>{
            let cursorSelection = self.foreignSelections.get(client);
            let decorations = self.foreignDecorators.get(client);

            if(decorations == null) {
                decorations = [];
            }

            let updatedDecoration = [];

            if(cursorSelection != null) {
                updatedDecoration.push({
                    range: new monaco.Range(cursorSelection.positionLine, cursorSelection.positionColumn, cursorSelection.positionLine, cursorSelection.positionColumn),
                    options: {
                        className: "otherCursor_" + client,
                        zIndex: 1
                    }
                });

                if (cursorSelection.startLine != cursorSelection.endLine || cursorSelection.startColumn != cursorSelection.endColumn) {
                    updatedDecoration.push({
                        range: new monaco.Range(cursorSelection.startLine, cursorSelection.startColumn, cursorSelection.endLine, cursorSelection.endColumn),
                        options: {
                            className: "otherSelection_" + client,
                            zIndex: 0
                        }
                    });
                }
            }

            decorations = self.editor.deltaDecorations(decorations, updatedDecoration);

            self.foreignDecorators.set(client, decorations);
        });
    }

    getValue() {
        if(this.editor == null) {
            return null;
        }

        return this.editor.getModel().getValue();
    }

    setValue(value) {
        if(this.editor == null) {
            return;
        }

        this.editor.getModel().setValue(value);
    }

    insertText(pos, val) {
        if(this.editor == null) {
            return;
        }

        let startPosition = this.editor.getModel().getPositionAt(pos);
        let range = monaco.Range.fromPositions(startPosition, startPosition);

        this.editor.getModel().applyEdits([{
            forceMoveMarkers: true,
            range: range,
            text: val
        }]);

        this.updateForeignSelections();
    }

    deleteText(pos, val) {
        if(this.editor == null) {
            return;
        }

        let startPosition = this.editor.getModel().getPositionAt(pos);
        let endPosition = this.editor.getModel().getPositionAt(pos+val.length);
        let range = monaco.Range.fromPositions(startPosition, endPosition);

        this.editor.getModel().applyEdits([{
            range: range,
            text: ""
        }]);

        this.updateForeignSelections();
    }

    insertAtSelection(text) {
        this.editor.executeEdits("draggedIntoEditor", [{
            identifier: {
                major: 1,
                minor: 1
            },
            range: this.editor.getSelection(),
            text: text,
            forceMoveMarkers: true
        }]);
    }

    unload() {
        //Kill monaco?
        if(this.editor != null) {
            this.editor.getModel().dispose();
            this.editor.dispose();
            this.editor = null;
        }

        super.unload();
    }

    setWordwrap(state) {
        if(this.editor != null) {
            this.editor.updateOptions({"wordWrap": state?"on":"off"});
        }
    }

    static types() {
        return [
            "text/javascript",
            "text/p5js",
            "text/whenjs",
            "text/whenv2",
            "text/varv",
            "text/varvscript",
            "text/python",
            "text/markdown",
            "text/html",
            "text/css",
            "text/ruby",
            "text/x-scss",
            "text/x-typescript",
            "application/x-lua",
            "wpm/descriptor",
            "application/json",
            "text/x-latex",
            ...MonacoEditor.extraTypes.keys()
        ];
    }
}; window.MonacoEditor = MonacoEditor;
MonacoEditor.extraTypes = new Map();

EditorManager.registerEditor(MonacoEditor);

</SCRIPT><STYLE id="base-style">
.decorationsOverviewRuler {
    display: none;
}

.otherCursor::before {
    content: " ";
    width: 2px;
    height: 100%;
    display: block;
}

.otherSelection {
}
</STYLE></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="CauldronNamespace" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron namespace",
    "description": "Provides the cauldron namespace",
    "dependencies": [],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="namespace-script" type="disabled">
/**
 * @namespace Cauldron
 */
window.Cauldron = {};

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="CauldronCollaboration" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron collabration module",
    "description": "Provides features for showing collaborators in different ways",
    "dependencies": [
        "codestrates-repos #EventSystem",
        "wpm_js_libs #cQuery"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="collaboration-script" type="disabled">
/**
 *  Collaboration
 *  A collaboration overlay for showing other connected users' focus in Cauldron
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate */

class Collaboration {

    constructor(numColors) {
        let self = this;

        //Setup colors
        this.availableColors = new Set();

        //Select 16 different colors
        for(let i = 0; i<numColors; i++) {
            this.availableColors.add(Collaboration.selectColor(i, numColors));
        }

        //Setup transient to hold styles
        this.styleTransient = document.createElement("transient");
        this.styleTransient.id = "Collaboration-Styles";
        document.head.appendChild(this.styleTransient);

        //Client map that holds all our known remote clients
        this.clientMap = new Map();

        this.currentFocusFragment = null;
        this.currentSelection = null;

        //Listen for clients leaving
        webstrate.on("clientPart", (remoteClient)=>{
            self.onClientPart(remoteClient);
        });

        //Listen for clients joining
        webstrate.on("clientJoin", (remoteClient)=>{
            self.setupClient(remoteClient);
        });

        //Setup already connected clients
        webstrate.clients.forEach((client)=>{
            if(client === webstrate.clientId) {
                //Ignore self
                return;
            }

            self.setupClient(client);
        });

        this.setupObserver();

        this.setupEventHandlers();

        document.querySelectorAll("code-fragment").forEach((fragment)=>{
            self.handleFragmentFound(fragment);
        });

        webstrate.on("signal", (msg, sender)=>{
            self.handleSignal(msg, sender);
        });
    }

    handleSignal(msg, sender) {
        let self = this;

        //Ignore ourself
        if(sender === webstrate.clientId) {
            return;
        }

        if(msg.cmd != null) {
            switch (msg.cmd) {
                case "Collaboration.UserJoined": {
                    //Someone joined our webstrate, tell them who we are
                    self.sendUserInfoSignal(sender);

                    //Also tell them what we are currently focusing, and selecting
                    self.sendCurrentFocusAndSelection(sender);

                    break;
                }

                case "Collaboration.UserInfo": {
                    let client = self.getClient(sender);
                    client.info = msg.info;

                    break;
                }
            }
        }
    }

    getClient(clientId) {
        let client = this.clientMap.get(clientId);

        if(client == null) {
            client = {
                id: clientId
            };
            this.clientMap.set(clientId, client);
        }

        return client;
    }

    onClientPart(remoteClient) {
        let client = this.getClient(remoteClient);

        if(client.style != null) {
            client.style.remove();
            this.availableColors.add(client.color);
        }

        if(client.focusFragment != null) {
            EventSystem.triggerEvent("Collaboration.FragmentUnfocused", {
                client: client,
                fragment: client.focusFragment
            });
        }

        //Remove client info
        this.clientMap.delete(remoteClient);
    }

    setupEventHandlers() {
        let self = this;

        EventSystem.registerEventCallback("Collaboration.FragmentFocused", ({detail: {client: client, fragment: fragment}})=>{
            if(client.deleter != null) {
                client.deleter.delete();
            }

            let deleter = MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.MetaMenu", {
                icon: self.getClientIcon(client.id),
                onOpen: (menu, item)=>{
                    return menu.context === fragment.html[0];
                }
            });

            client.deleter = deleter;
        });

        EventSystem.registerEventCallback("Collaboration.FragmentUnfocused", ({detail: {client: client, fragment: fragment, userName: userName}})=>{
            if(client.deleter != null) {
                client.deleter.delete();
                client.deleter = null;
            }
        });

        EventSystem.registerEventCallback("Codestrates.Editor.Selection", ({detail: {editor: editor, selection: selection}})=>{
            if(self.currentFocusFragment !== editor.fragment) {
                self.setCurrentFocusedFragment(editor.fragment);
            }

            self.setCurrentSelection(selection);
        });

        EventSystem.registerEventCallback("Codestrates.Editor.Focus", ({detail: {editor: editor}})=>{
            if(self.currentFocusFragment !== editor.fragment) {
                self.setCurrentFocusedFragment(editor.fragment);
            }
        });

        EventSystem.registerEventCallback("Codestrates.Editor.Blur", ({detail: {editor: editor}})=>{
            if(self.currentFocusFragment === editor.fragment) {
                self.setCurrentFocusedFragment(null);
            }
        });

        EventSystem.registerEventCallback("Codestrates.Editor.Opened", ({detail: {editor: editor}})=>{
            self.clientMap.forEach((client)=>{
                if(client.focusFragment === editor.fragment) {
                    EventSystem.triggerEvent("Collaboration.FragmentSelection", {
                        client: client,
                        fragment: editor.fragment,
                        selection: client.selection
                    });
                }
            });
        });
    }

    setCurrentFocusedFragment(fragment) {
        if(this.currentFocusFragment != null) {
            //Send unfocus signal
            this.sendUnfocusedSignal(this.currentFocusFragment);
        }

        this.currentFocusFragment = fragment;

        //Send focus signal
        if(this.currentFocusFragment != null) {
            this.sendFocusedSignal(this.currentFocusFragment);
        }
    }

    setCurrentSelection(selection) {
        this.currentSelection = selection;
        this.sendSelectionSignal(this.currentFocusFragment);
    }

    getUserInfo() {
        return {
            userName: webstrate.user.displayName!=null?webstrate.user.displayName:webstrate.clientId,
            avatar:webstrate.user.avatarUrl!=null?webstrate.user.avatarUrl:null
        }
    }

    sendCurrentFocusAndSelection(receiver) {
        if(this.currentFocusFragment != null) {
            this.sendFocusedSignal(this.currentFocusFragment, receiver);
        }
        if(this.currentSelection != null) {
            this.sendSelectionSignal(this.currentFocusFragment, receiver);
        }
    }

    /**
     * Send our user info
     * @param receiver - The webstrate client to receive our user info, if null, everyone gets it
     */
    sendUserInfoSignal(receiver) {
        this.sendSignal({
            msg: {
                cmd: "Collaboration.UserInfo",
                info: this.getUserInfo()
            },
            receiver: receiver
        });
    }

    sendSelectionSignal(fragment, receiver) {
        this.sendSignal({
            msg: {
                cmd: "Collaboration.Fragment.Selection",
                selection: this.currentSelection
            },
            receiver: receiver,
            fragment: fragment
        });
    }

    sendSignal(options) {
        let channel = webstrate;

        if(options.fragment != null) {
            channel = options.fragment.html[0].webstrate;
        }

        if(channel != null) {
            if(options.receiver != null) {
                channel.signal(options.msg, [options.receiver]);
            } else {
                channel.signal(options.msg);
            }
        }
    }

    /**
     * Tell everyone that a fragment has been unfocused
     * @param fragment - The fragment that was unfocused
     */
    sendUnfocusedSignal(fragment, receiver) {
        this.sendSignal({
            msg: {
                cmd: "Collaboration.Fragment.Unfocused"
            },
            receiver: receiver,
            fragment: fragment
        });
    }

    /**
     * Tell everyone that a fragment has been focused
     * @param fragment - The fragment that was unfocused
     */
    sendFocusedSignal(fragment, receiver) {
        this.sendSignal({
            msg: {
                cmd: "Collaboration.Fragment.Focused"
            },
            receiver: receiver,
            fragment: fragment
        });
    }

    /**
     * Tell everyone that we joined the webstrate
     */
    sendJoinSignal() {
        this.sendSignal({
            msg: {
                cmd: "Collaboration.UserJoined"
            }
        });
    }

    setupClient(remoteClient) {
        let client = this.getClient(remoteClient);

        if(client.style == null) {
            client.style = document.createElement("style");
        }

        let colorArray = Array.from(this.availableColors.values());
        let random = Math.floor(Math.random() * colorArray.length);
        let color = colorArray[random];
        this.availableColors.delete(color);

        client.color = color;

        client.style.innerHTML = `
.otherCursor_${remoteClient}::before {
    background-color: hsl(${color}, 100%, 65%);
}

.otherSelection_${remoteClient} {
    background-color: hsla(${color}, 100%, 50%, 0.1);
}`

        this.styleTransient.appendChild(client.style);
    }

    getClientIcon(remoteClient) {
        let client = this.getClient(remoteClient);

        let icon = WebstrateComponents.Tools.loadTemplate("Collaboration_icon");
        cQuery(icon).one("#initials").appendChild(document.createTextNode(client.info.userName.substring(0, 2)));
        cQuery(icon).one("#name").appendChild(document.createTextNode(client.info.userName));
        if(client.info.avatar != null) {
            cQuery(icon).one("image").setAttribute("href", client.info.avatar);
        } else {
            cQuery(icon).one("image").remove();
        }
        icon.style.color = `hsl(${client.color}, 100%, 15%)`;
        icon.style.fill = `hsl(${client.color}, 100%, 75%)`;
        icon.classList.add("collaboration-client-icon");
        return icon;
    }

    handleFragmentFound(fragmentElement) {
        let self = this;

        let fragment = cQuery(fragmentElement).data("Fragment");

        //Check if fragment is transient
        if(webstrate.config.isTransientElement(fragmentElement)) {
            //No colaboration possible on transient elements
            return;
        }

        //Setup fragment listening of clients
        fragmentElement.webstrate.on("signal", (msg, sender)=>{
            if(sender === webstrate.clientId) {
                //Skip self
                return;
            }

            let client = self.getClient(sender);

            if(msg.cmd === "Collaboration.Fragment.Selection" || msg.cmd === "Collaboration.Fragment.Focused") {
                if(client.focusFragment !== fragment) {
                    client.focusFragment = fragment;
                    EventSystem.triggerEvent("Collaboration.FragmentFocused", {
                        client: client,
                        fragment: fragment
                    });
                }

                if(msg.selection != null) {
                    client.selection = msg.selection;
                    EventSystem.triggerEvent("Collaboration.FragmentSelection", {
                        client: client,
                        fragment: fragment,
                        selection: msg.selection
                    });
                }
            } else if(msg.cmd === "Collaboration.Fragment.Unfocused") {
                if(client.focusFragment === fragment) {
                    client.focusFragment = null;
                    EventSystem.triggerEvent("Collaboration.FragmentUnfocused", {
                        client: client,
                        fragment: fragment
                    });
                }
            }
        });
    }

    setupObserver() {
        let self = this;

        this.observer = new MutationObserver((mutations)=>{
            mutations.forEach((mutation)=>{
                Array.from(mutation.addedNodes).forEach((addedNode)=>{
                    if(addedNode.matches != null && addedNode.matches("code-fragment")) {
                        self.handleFragmentFound(addedNode);
                    }

                    if(addedNode.querySelectorAll != null) {
                        addedNode.querySelectorAll("code-fragment").forEach((fragment)=>{
                            self.handleFragmentFound(fragment);
                        });
                    }
                });
            });
        });

        this.observer.observe(document, {
            childList: true,
            subtree: true
        });
    }

    //Get a color from a HSL divided spectrum
    static selectColor(colorNum, colors){
        if (colors < 1) colors = 1; // defaults to one color - avoid divide by zero
        return (colorNum * (360 / colors) % 360);
    }
}

if (typeof webstrate !== "undefined"){
    // We only support collaboration with a webstrates server backend
    Cauldron.Collaboration = new Collaboration(16);

    //Signal everyon on the webstrate that we are here, and who we are
    Cauldron.Collaboration.sendJoinSignal();
    Cauldron.Collaboration.sendUserInfoSignal();
}

</SCRIPT><TEMPLATE id="Collaboration_icon">
<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title id="name"></title>
    <defs>
        <linearGradient id="g" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop offset="60%" stop-color="#EEE"></stop>
          <stop offset="90%" stop-color="#000"></stop>
        </linearGradient>
        <mask id="m">
            <rect x="0" y="0" width="100" height="100" fill="url(#g)"></rect>
        </mask>
        <clipPath id="c"><circle cx="50" cy="50" r="44" fill="#FFF"></circle></clipPath>
     </defs>
    <circle cx="50" cy="50" r="47" stroke-width="6" stroke="currentColor"></circle>
    <image mask="url(#m)" opacity="0.5" preserveAspectRatio="xMidYMid slice" clip-path="url(#c)" x="3" y="3" width="94" height="94" xlink:href></image>
    <text id="initials" font-size="55" x="50%" y="50%" fill="currentColor" stroke="currentColor" dominant-baseline="central" text-anchor="middle" stroke-width="3"></text>
</svg>
</TEMPLATE><STYLE id="main-style">
/**
 *  Collaboration Styles
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
.cauldron-editor-component-clientarea {
  display: flex; }
  .cauldron-editor-component-clientarea .collaboration-client-icon {
    margin-left: -0.4em; }

.collaboration-client-icon {
  width: 1.5em;
  height: 1.5em;
  transition: transform 0.1s ease-out;
  user-select: none; }
  .collaboration-client-icon:hover {
    transform: scale(1.1); }
</STYLE></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="CauldronSettings" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron Editor Settings",
    "description": "Settings for cauldron",
    "dependencies": [
        "codestrates-repos #EventSystem"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="settings-script" type="disabled">
/**
 *  Cauldron Settings
 *  Provides settings that are preserved via localStorage
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 **/

class CauldronSettings {
    /**
     * Sets word-wrap state
     * @param {boolean} state - true/false state of word-wrap
     */
    static setWordwrap(state) {
        CauldronSettings.setSetting(CauldronSettings.SETTINGS.wordWrap, state);
    }

    /**
     *
     * @returns {boolean} true/false depending on if word wrap should be enabled or not
     */
    static getWordwrap() {
        return CauldronSettings.getSetting(CauldronSettings.SETTINGS.wordWrap, false);
    }


    static setTheme(theme) {
        CauldronSettings.setSetting(CauldronSettings.SETTINGS.theme, theme);
    }

    static getTheme(){
        // Try to detect the browser default theme if not set
        let defaultTheme = "light";
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            defaultTheme = "dark";
        }

        return CauldronSettings.getSetting(CauldronSettings.SETTINGS.theme, defaultTheme);
    }

    /**
     *
     * @param {string} key
     * @param {any} setting
     */
    static setSetting(key, setting) {
        let settings = CauldronSettings.getSettings();
        settings[key] = setting;
        CauldronSettings.setSettings(settings);
    }

    /**
     *
     * @param {string} key
     * @param {any} defaultValue
     */
    static getSetting(key, defaultValue) {
        let settings = CauldronSettings.getSettings();
        if(settings.hasOwnProperty(key)) {
            return settings[key];
        }

        return defaultValue;
    }

    /**
     *
     * @param {Object} settings
     */
    static setSettings(settings) {
        localStorage.setItem(CauldronSettings.STORAGE_KEY, JSON.stringify(settings));

        EventSystem.triggerEvent("Cauldron.Settings.Updated", settings);
        console.log("Settings updated:", settings);
    }

    /**
     *
     * @returns {Object}
     */
    static getSettings() {
        try {
            let settings = JSON.parse(localStorage.getItem(CauldronSettings.STORAGE_KEY));

            if(settings == null || typeof settings !== "object") {
                settings = {};
            }

            return settings;
        } catch(e) {
            //Ignore
            console.warn("Unable to load CauldronSettings, resetting...");
        }

        return {}
    }
}

window.Cauldron.CauldronSettings = CauldronSettings;

CauldronSettings.SETTINGS = {
    "wordWrap": "wordWrap",
    "theme" : "theme"
};

CauldronSettings.STORAGE_KEY = "Cauldron.Settings.Key";

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="CauldronActionMenu" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Main Actionbar",
    "description": "Provides a small area for prominent actions",
    "dependencies": [
        "webstrate-components-repos #MenuSystem"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="actionmenu-script" type="disabled">
/**
 *  CauldronActionMenu
 *  A menu for prominent Cauldron actions like closing Cauldron
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

window.CauldronActionMenu = class MainActions {
    constructor(){
        this.menu = MenuSystem.MenuManager.createMenu("Cauldron.MainActions", {
            keepOpen: true,
            layoutDirection: MenuSystem.Menu.LayoutDirection.HORIZONTAL
        });

        this.menu.open();
        this.menu.html.classList.add("cauldron-actionmenu");
    }

    get html(){
        return this.menu.html;
    }
}

</SCRIPT><STYLE id="actionmenu-style">
/**
 *  CauldronActionMenu Styles
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
.cauldron-actionmenu {
  opacity: 0.7;
  /* Material Design STUB */ }
  .cauldron-actionmenu:hover {
    opacity: 1; }
  .cauldron-actionmenu .mdc-list-item {
    padding: 0; }
    .cauldron-actionmenu .mdc-list-item .mdc-list-item__graphic {
      margin: 0; }
</STYLE></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="CauldronMainMenu" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Main Menu",
    "description": "Provides the main menu for the editor",
    "dependencies": [
        "webstrate-components-repos #MenuSystem"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="mainmenu-script" type="disabled">
/**
 *  CauldronMainMenu
 *  The primary top menu of Cauldron
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

window.CauldronMainMenu = class MainMenu {
    constructor(){
        this.menu = MenuSystem.MenuManager.createMenu("Cauldron.MainMenu", {
            keepOpen: true,
            layoutDirection: MenuSystem.Menu.LayoutDirection.HORIZONTAL
        });

        // Register the basic submenus etc. that are always there
        let fileMenu = MenuSystem.MenuManager.createMenu("Cauldron.File", {
            groupDividers: true,
            growDirection: MenuSystem.Menu.GrowDirection.DOWN
        });
        this.menu.addItem({
            label: "File",
            order: 0,
            submenu: fileMenu,
            submenuOnHover: false
        });

        // Register the basic submenus etc. that are always there
        let settingsMenu = MenuSystem.MenuManager.createMenu("Cauldron.Settings", {
            groupDividers: true,
            growDirection: MenuSystem.Menu.GrowDirection.DOWN
        });
        this.menu.addItem({
            label: "Settings",
            order: 100,
            submenu: settingsMenu,
            submenuOnHover: false
        });

        let viewMenu = MenuSystem.MenuManager.createMenu("Cauldron.View", {
            groupDividers: true,
            growDirection: MenuSystem.Menu.GrowDirection.DOWN
        });
        this.menu.addItem({
            label: "View",
            order: 200,
            submenu: viewMenu,
            submenuOnHover: false
        });

        let helpMenu = MenuSystem.MenuManager.createMenu("Cauldron.Help", {
            growDirection: MenuSystem.Menu.GrowDirection.DOWN
        });
        this.menu.addItem({
            label: "Help",
            order: 999,
            submenu: helpMenu,
            submenuOnHover: false
        });


        this.menu.open();
        this.menu.html.classList.add("cauldron-mainmenu");
    }

    get html(){
        return this.menu.html;
    }
}

</SCRIPT><STYLE id="mainmenu-style">
.cauldron-mainmenu {
    flex: 1 1 auto;
}
</STYLE></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="CauldronConsole" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Console",
    "description": "Show a log of fragment output with easy filtering and search",
    "dependencies": [
        "#CauldronNamespace"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="console-script" type="disabled">
/**
 *  Cauldron Console
 *  A textual console for error logging
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

window.Cauldron.CauldronConsole = class CauldronConsole {
    constructor() {
        let self = this;

        this.html = document.createElement("div");
        this.html.classList.add("cauldron-console-content");

        this.consoleUl = document.createElement("ul");

        this.html.appendChild(this.consoleUl);

        this.contextMenu = MenuSystem.MenuManager.createMenu("Cauldron.Inspector.ContextMenu");

        //Make errors able to be JSON.stringifyied
        if (!('toJSON' in Error.prototype)) {
            Object.defineProperty(Error.prototype, 'toJSON', {
                value: function () {
                    let alt = {};

                    Object.getOwnPropertyNames(this).forEach(function (key) {
                        alt[key] = this[key];
                    }, this);

                    return alt;
                },
                configurable: true,
                writable: true
            });
        }

        MenuSystem.MenuManager.registerMenuItem("Cauldron.Inspector.ContextMenu", {
            label: "Clear console",
            onAction:()=>{
                self.consoleUl.innerHTML = "";
            }
        });

        MenuSystem.MenuManager.registerMenuItem("Cauldron.Inspector.ContextMenu", {
            label: "Filter",
            onAction:()=>{
                let filter = prompt("Enter filter string:");

                let entries = Array.from(self.consoleUl.querySelectorAll(".cauldron-console-entry"));

                entries.forEach((entry)=>{
                    entry.classList.add("cauldron-console-entry-filtered");
                });

                entries.filter((entry)=>{
                    if(filter == null || filter.trim() === "") {
                        return true;
                    } else {
                        return entry.textContent.toLowerCase().indexOf(filter.trim().toLowerCase()) !== -1;
                    }
                }).forEach((entry)=>{
                    entry.classList.remove("cauldron-console-entry-filtered");
                });
            }
        });

        this.html.addEventListener("contextmenu", (evt)=>{
            evt.preventDefault();
        });

        this.html.addEventListener("mouseup", (evt)=>{
            if(evt.button !== 2) {
                return;
            }

            try {
                //Find top component after html
                let parent = self.html;
                while(parent.parentNode != null && !parent.parentNode.matches("html")) {
                    parent = parent.parentNode;
                }
                parent.appendChild(self.contextMenu.html);

                self.contextMenu.open({
                    x: evt.pageX,
                    y: evt.pageY
                });
            } catch(e) {
                console.error(e);
            }
            evt.preventDefault();
        });

        EventSystem.registerEventCallback("Codestrates.Fragment.Error", ({detail: {messages: messages, fragment: fragment}})=>{
            self.handleMessages(messages, "error", fragment);
        });

        EventSystem.registerEventCallback("Codestrates.Fragment.Log", ({detail: {messages: messages, fragment: fragment}})=>{
            self.handleMessages(messages, "log", fragment);
        });

        EventSystem.registerEventCallback("Codestrates.Fragment.Warn", ({detail: {messages: messages, fragment: fragment}})=>{
            self.handleMessages(messages, "warn", fragment);
        });
    }

    handleMessages(messages, type, fragment) {
        let li = document.createElement("li");
        li.classList.add("cauldron-console-entry");

        let source = document.createElement("span");
        source.classList.add("cauldron-console-source");
        let sourceName = "";

        if (fragment){
            source.appendChild(IconRegistry.createIcon(["code-fragment:"+fragment.type, "mdc:insert_drive_file"]));
            if (fragment.html[0].getAttribute("name")) sourceName = fragment.html[0].getAttribute("name")+" ";
            if (fragment.html[0].id) sourceName += "#"+fragment.html[0].id;
            if (sourceName==="") sourceName = fragment.html[0].tagName.toLowerCase();

            new CaviTouch(source);

            source.addEventListener("caviTap", ()=>{
                TreeBrowser.findAllTreeBrowsers().forEach((tb)=>{
                    tb.findTreeNodeForContext(fragment.html[0]).forEach((tn)=>{
                        tn.reveal();
                        tn.select();
                    });
                });
            });

            source.addEventListener("caviDoubleTap", ()=>{
                TreeBrowser.findAllTreeBrowsers().forEach((tb)=>{
                    tb.findTreeNodeForContext(fragment.html[0]).forEach((tn)=>{
                        tn.triggerAction();
                    });
                });
            });
        }
        let sourceTitle = document.createElement("span");
        sourceTitle.textContent = sourceName;
        source.appendChild(sourceTitle);
        li.appendChild(source);

        switch(type) {
            case "log":
                li.classList.add("cauldron-console-entry-log");
                break;
            case "error":
                li.classList.add("cauldron-console-error");
                break;
            case "warn":
                li.classList.add("cauldron-console-warn");
                break;
        }

        messages.forEach((msg)=>{
            let item = document.createElement("span");
            if(typeof msg === "object") {
                function parseDom(dom) {
                    let tagName = dom.tagName.toLowerCase();

                    let attributes = "";

                    Array.from(dom.attributes).forEach((attr)=>{
                        if(attr.specified) {
                            attributes += " "+attr.name+"='"+attr.value+"'";
                        }
                    });

                    let result = "<"+tagName+attributes+"></"+tagName+">";

                    return result;
                }

                if (msg instanceof Element) {
                    item.textContent = parseDom(msg);
                    item.classList.add("cauldron-console-entry-dom");
                } else if (msg instanceof StackWalker.StackTrace){
                    item.textContent = msg.extraReason;
                    let trace = document.createElement("ul");
                    trace.classList.add("cauldron-console-entry-stacktrace");

                    let stack = msg.stack;
                    stack = StackWalker.compactify(msg.stack);

                    stack.forEach((stackLine)=>{
                        let li = document.createElement("li");
                        li.textContent = stackLine.method + (stackLine.lineNumber != null?":" + stackLine.lineNumber:"");
                        trace.appendChild(li);
                    });
                    item.appendChild(trace);
                    item.classList.add("cauldron-console-entry-object", "cauldron-console-entry-folded");
                    item.addEventListener("click", ()=>{
                        item.classList.toggle("cauldron-console-entry-folded");
                    });
                } else {
                    let cache = [];

                    function convertObject(obj) {
                        if (obj instanceof Error) {
                            obj = obj.toJSON();
                        }

                        if (obj instanceof Set) {
                            obj = {
                                "Set": Array.from(obj)
                            };
                        }

                        if (obj instanceof Map) {
                            let objMap = {};

                            obj.forEach((value, key) => {
                                objMap[key] = value;
                            });

                            obj = {
                                "Map": objMap
                            };
                        }

                        return obj;
                    }

                    item.textContent = JSON.stringify(msg, (key, value) => {
                        if (typeof value === "object" && value != null) {
                            if (value instanceof Element) {
                                return parseDom(value);
                            }

                            if(cache.includes(value)) {
                                return;
                            }

                            cache.push(value);

                            return convertObject(value);
                        }

                        return value;
                    }, 2);;
                    item.classList.add("cauldron-console-entry-object", "cauldron-console-entry-folded");
                    item.addEventListener("click", ()=>{
                        item.classList.toggle("cauldron-console-entry-folded");
                    });
                }
            } else {
                item.textContent = msg;
                item.classList.add("cauldron-console-entry-text");
            }

            li.appendChild(item);
        });

        this.consoleUl.appendChild(li);
        this.html.scrollTo(0, this.html.scrollHeight);
    }
};

</SCRIPT><STYLE id="main-style">
/**
 *  Console Styles
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
.cauldron-console-content {
  width: 100%;
  height: 100%;
  overflow: auto;
  font-size: 0.9em; }
  .cauldron-console-content ul {
    margin: 0;
    padding: 0; }
  .cauldron-console-content .cauldron-console-entry {
    font-family: monospace;
    list-style: none;
    padding: 1px 0.5em 1px 0;
    border-bottom: 1px solid rgba(100, 100, 100, 0.08); }
    .cauldron-console-content .cauldron-console-entry.cauldron-console-entry-filtered {
      display: none; }
    .cauldron-console-content .cauldron-console-entry .cauldron-console-source {
      font-size: 0.9em;
      cursor: pointer;
      margin-right: 0.5em;
      background: rgba(100, 100, 100, 0.1);
      display: inline-flex;
      align-items: center;
      padding: 0.25em;
      vertical-align: sub; }
      .cauldron-console-content .cauldron-console-entry .cauldron-console-source .wsc-registry-icon {
        height: 1.5em;
        width: 1.25em;
        margin-right: 0.25em; }
    .cauldron-console-content .cauldron-console-entry.cauldron-console-error {
      color: red;
      background: rgba(255, 0, 0, 0.05); }
      .cauldron-console-content .cauldron-console-entry.cauldron-console-error .cauldron-console-entry-object {
        color: darkred; }
        .cauldron-console-content .cauldron-console-entry.cauldron-console-error .cauldron-console-entry-object::before {
          color: darkred; }
    .cauldron-console-content .cauldron-console-entry.cauldron-console-warn {
      color: #756600;
      background: rgba(250, 242, 85, 0.1); }
      .cauldron-console-content .cauldron-console-entry.cauldron-console-warn .cauldron-console-entry-object {
        color: #4f4500; }
        .cauldron-console-content .cauldron-console-entry.cauldron-console-warn .cauldron-console-entry-object::before {
          color: #4f4500; }
    .cauldron-console-content .cauldron-console-entry .cauldron-console-entry-dom {
      color: hotpink;
      display: inline-block; }
    .cauldron-console-content .cauldron-console-entry .cauldron-console-entry-text {
      padding-right: 1em; }
    .cauldron-console-content .cauldron-console-entry .cauldron-console-entry-object {
      white-space: pre;
      display: block; }
      .cauldron-console-content .cauldron-console-entry .cauldron-console-entry-object.cauldron-console-entry-folded {
        white-space: nowrap;
        text-overflow: ellipsis;
        max-width: 100%;
        overflow: hidden;
        display: block;
        height: 1em; }
        .cauldron-console-content .cauldron-console-entry .cauldron-console-entry-object.cauldron-console-entry-folded::before {
          content: "[+]"; }
      .cauldron-console-content .cauldron-console-entry .cauldron-console-entry-object::before {
        content: "[-]"; }
</STYLE></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="CauldronInspector" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="inspector-script" type="disabled">
/**
 *  CauldronInspector
 *  Visual inspector of various elements that can be edited in Cauldron
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

class CauldronInspector {
    constructor(){
        let self = this;

        this.html = document.createElement("div");
        this.html.classList.add("cauldron-inspector");

        this.fields = document.createElement("div");
        this.fields.classList.add("cauldron-inspector-fields");
        this.html.appendChild(this.fields);
        this.currentSelection = null;

        this.currentInspectElements = [];

        EventSystem.registerEventCallback("TreeBrowser.Selection", ({detail: {selection: selection}})=>{
            self.inspect(selection);
        });
    }

    /**
     *
     * @param {TreeNode} selection
     */
    inspect(selection) {
        let self = this;
        this.currentSelection = selection;

        this.html.scrollTo(0, 0);

        let inspectorElements = null;
        for(let inspector of CauldronInspector.contentBindings) {
            inspectorElements = inspector.contentBinding.inspect(selection, this);

            if(inspectorElements != null) {
                //First inspector to return something wins.
                break;
            }
        }

        //Remove old elements
        this.currentInspectElements.forEach((inspectElement)=>{
            inspectElement.destroy();
        });

        this.currentInspectElements = [];

        if(inspectorElements != null) {
            inspectorElements.forEach((element)=>{
                self.fields.append(element.html);
                self.currentInspectElements.push(element);
            });
        }
    }

    reinspect(){
        this.inspect(this.currentSelection);
    }

    /**
     * Register a content binding for the CauldronInspector component
     * @param contentBinding
     * @param {Number} priority
     */
    static registerContentBinding(contentBinding, priority) {
        CauldronInspector.contentBindings.push({
            contentBinding: contentBinding,
            priority: priority
        });

        //Sort decorators according to priority
        CauldronInspector.contentBindings.sort((i1, i2)=>{
            return i2.priority - i1.priority;
        });
    }
};

CauldronInspector.contentBindings = [];

window.Cauldron.CauldronInspector = CauldronInspector;

class InspectorSegment {
    constructor(name, parentList){
        this.html = document.createElement("div");
        this.html.classList.add("cauldron-inspector-section");
        let sectionHeader = document.createElement("div");
        sectionHeader.classList.add("cauldron-inspector-header");
        sectionHeader.innerText = name;
        this.html.appendChild(sectionHeader);
        this.parentList = parentList;
    }

    push(element){
        this.parentList.push(element);
    }

    destroy() {
        this.html.remove();
    }
}
window.Cauldron.InspectorSegment = InspectorSegment;


class InspectorElement {
    constructor() {
        this._html = document.createElement("div");
        this._html.classList.add("cauldron-inspector-element");
    }

    setFailing(failing){
        if (failing){
            if (!this._html.classList.contains("failing-element")) this._html.classList.toggle("failing-element");
        } else {
            if (this._html.classList.contains("failing-element")) this._html.classList.toggle("failing-element");
        }
    }

    get html() {
        return this._html;
    }

    destroy() {
        this.html.remove();
    }
}
window.Cauldron.InspectorElement = InspectorElement;

class InspectorHTMLElement extends InspectorElement {
    constructor(html) {
        super();

        this.html.appendChild(html);
    }
}

window.Cauldron.InspectorHTMLElement = InspectorHTMLElement;

</SCRIPT><SCRIPT id="InspectorHTMLBinding-script" type="disabled">
/**
 *  Inspector HTML Bindings
 *  Visual inspector of HTML and DOM elements
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

class InspectorHTMLBinding {
    /**
     * Inspects the given TreeNode and if supported, returns a map of editable attributes
     * @param {TreeNode} treeNode
     * @returns {Cauldron.InspectorElement[]}
     */
    static inspect(treeNode, inspector) {
        if(treeNode.type === "DomTreeNode") {
            let elements = [];

            InspectorHTMLBinding.focusEditor = new Cauldron.InspectorAttributeEditor(treeNode.context, "id");

            let primaryFold = new Cauldron.InspectorSegment("Attributes", elements);
            elements.push(primaryFold);
            primaryFold.push(InspectorHTMLBinding.focusEditor);
            let primaryAttributes = ["class", "name"];

            switch (treeNode.context.tagName){
                case "IMG":
                    primaryAttributes = [...primaryAttributes, "src", "alt", "width", "height"];
                    break;
                case "SCRIPT":
                    primaryAttributes = [...primaryAttributes, "src", "type"];
                    break;
                case "IFRAME":
                    primaryAttributes.push("src");
                    break;
                case "A":
                    primaryAttributes.push("href");
                    break;
                case "INPUT":
                    primaryAttributes = [...primaryAttributes, "type", "value"];
                    break;
                case "OPTION":
                    primaryAttributes.push("value");
                    break;
                case "LINK":
                    primaryAttributes = [...primaryAttributes, "type", "rel", "href"];
                    break;
                case "LABEL":
                    primaryAttributes.push("for");
                    break;
                case "BUTTON":
                    primaryAttributes.push("type");
                    break;
                case "FORM":
                    primaryAttributes = [...primaryAttributes, "action", "method"];
                    break;
            }
            for (let attribute of primaryAttributes){
                primaryFold.push(new Cauldron.InspectorAttributeEditor(treeNode.context, attribute));
            }
            primaryAttributes.push("id"); // We already added this manually

            // Add other attributes present which are not primary ones
            let fold = new Cauldron.InspectorSegment("Additional Attributes", elements);
            elements.push(fold);
            for (let attributeEntry of treeNode.context.attributes){
                if (!primaryAttributes.includes(attributeEntry.name)){
                    fold.push(new Cauldron.InspectorAttributeEditor(treeNode.context, attributeEntry.name));
                }
            }
            fold.push(new Cauldron.InspectorAttributeAdder(treeNode.context, inspector));

            return elements;
        }

        return null;
    }
}

window.Cauldron.InspectorHTMLBinding = InspectorHTMLBinding;

Cauldron.CauldronInspector.registerContentBinding(InspectorHTMLBinding, 10);

class InspectorAttributeAdder extends Cauldron.InspectorElement {
    constructor(domElement, inspector){
        super();
        let label = document.createElement("label");
        label.classList.add("cauldron-inspector-element-label");
        let adderButton = document.createElement("button");
        adderButton.innerText = "Add Attribute";
        adderButton.classList.add("cauldron-inspector-element-editor");
        this.html.append(label);
        this.html.append(adderButton);

        adderButton.addEventListener("click", ()=>{
            let attributeName = prompt("Attribute Name:");
            if (attributeName !== null && attributeName!==""){
                domElement.setAttribute(attributeName,"");
                inspector.reinspect();
            }
        });
    }
}
window.Cauldron.InspectorAttributeAdder = InspectorAttributeAdder;


class InspectorAttributeEditor extends Cauldron.InspectorElement {
    /**
     *
     * @param {Element} domElement
     * @param {String} attrName
     * @param {String} overrideLabel
     */
    constructor(domElement, attrName, overrideLabel= null) {
        super();

        let self = this;

        this.domElement = domElement;
        this.attrName = attrName;

        this.editor = document.createElement("input");
        this.editor.classList.add("cauldron-inspector-element-field");
        this.editor.classList.add("cauldron-inspector-element-editor");
        this.editor.setAttribute("contenteditable", "true");
        this.editor.setAttribute("spellcheck", "false");

        this.label = document.createElement("span");
        this.label.classList.add("cauldron-inspector-element-label");
        this.label.textContent = overrideLabel==null?this.attrName:overrideLabel;

        this.html.append(this.label);
        this.html.appendChild(this.editor);
        this.html.classList.add("inspector-htmlnode");

        this.editor.value = this.domElement.getAttribute(this.attrName);

        this.observer = new MutationObserver((mutations)=>{
            //handleMutations(mutations);
        });

        function handleMutations(mutations) {
            //Attribute changed, update editor
            if(mutations.length > 0) {
                self.editor.value = self.domElement.getAttribute(self.attrName);
            }
        }

        function startObserver() {
            self.observer.observe(self.domElement, {
                attributes: true,
                attributeFilter: [self.attrName]
            });
        }

        function pauseObserver() {
            let mutationRecords = self.observer.takeRecords();
            self.observer.disconnect();
            handleMutations(mutationRecords);
        }

        startObserver();

        this.html.addEventListener("keydown", (event)=>{
            if(event.code === "Enter") {
                event.preventDefault();
            }
        });

        this.html.addEventListener("input", (evt)=>{
            pauseObserver();
            self.domElement.setAttribute(self.attrName, self.editor.value);
            setTimeout(()=>{
                startObserver();
            }, 0);
        });
    }

    destroy() {
        super.destroy();
        this.observer.disconnect();
    }

    focus(){
        this.editor.select();
    }
}

window.Cauldron.InspectorAttributeEditor = InspectorAttributeEditor;

EventSystem.registerEventCallback("TreeBrowser.Keyup", ({detail: {evt: evt, treeNode: treeNode}})=>{
    console.log(evt);
    if(evt.key === "F2" && InspectorHTMLBinding.focusEditor) {
        InspectorHTMLBinding.focusEditor.focus();
    }
});

</SCRIPT><SCRIPT id="InspectorAssetBinding-script" type="disabled">
/**
 *  Asset Inspector
 *  Visual inspector for webstrate assets
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

class InspectorAssetBinding {
    /**
     * Inspects the given TreeNode and if supported, returns a map of inspector elements
     * @param {TreeNode} treeNode
     * @returns {Cauldron.InspectorElement[]}
     */
    static inspect(treeNode) {
        if(treeNode.type === "AssetNode" || treeNode.type === "AssetContainer") {
            let elements = [];

            elements.push(new Cauldron.InspectorAssetPreviewElement(treeNode));
            elements.push(new Cauldron.InspectorAssetAttributeElement(treeNode, "fileName", "name"));
            elements.push(new Cauldron.InspectorAssetAttributeElement(treeNode, "v", "version"));
            elements.push(new Cauldron.InspectorAssetAttributeElement(treeNode, "fileSize", "size", true));
            elements.push(new Cauldron.InspectorAssetAttributeElement(treeNode, "mimeType", "type"));

            let downloadButton = ButtonSystem.ButtonFactory.createButton("Download", {
                onAction: ()=>{
                    EventSystem.triggerEvent("Cauldron.Asset.Download", {
                        asset: treeNode.context
                    });
                },
                style: "outlined",
                icon: IconRegistry.createIcon("mdc:get_app"),
            });

            elements.push(new Cauldron.InspectorHTMLElement(downloadButton.html));

            downloadButton.html.style.gridColumn = "1/3";

            return elements;
        }

        return null;
    }
}

window.Cauldron.InspectorAssetBinding = InspectorAssetBinding;

Cauldron.CauldronInspector.registerContentBinding(InspectorAssetBinding, 10);

class InspectorAssetAttributeElement extends Cauldron.InspectorElement {
    /**
     *
     * @param {TreeNode} treeNode
     * @param {String} attrName
     * @param {String} overrideLabel
     */
    constructor(treeNode, attrName, overrideLabel = null, formatSize = false) {
        super();

        let self = this;

        this.formatSize = formatSize;

        this.treeNode = treeNode;
        this.attrName = attrName;

        this.label = document.createElement("span");
        this.label.classList.add("cauldron-inspector-element-label");
        this.label.textContent = overrideLabel==null?this.attrName+":":overrideLabel;

        this.content = document.createElement("span");
        this.content.classList.add("cauldron-inspector-element-field");

        this.html.appendChild(this.label);
        this.html.appendChild(this.content);

        this.handleAssetUpdated = function() {
            self.assetUpdated();
        };

        this.treeNode.registerOnDecoratedCallback(this.handleAssetUpdated);

        this.assetUpdated();
    }

    destroy() {
        super.destroy();
        this.treeNode.deregisterOnDecoratedCallback(this.handleAssetUpdated);
    }

    assetUpdated() {
        let value = this.treeNode.context[this.attrName];

        if(this.formatSize) {
            let unit = "B";

            value = parseInt(value);

            if(value > 1024) {
                value /= 1024;
                unit = "KiB";

                if(value > 1024) {
                    value /= 1024;
                    unit = "MiB";

                    if(value > 1024) {
                        value /= 1024;
                        unit = "GiB";

                        if(value > 1024) {
                            value /= 1024;
                            unit = "TiB";
                        }
                    }
                }
            }



            value = value.toFixed(2) + " " + unit;
        }

        this.content.textContent = value;
    }
}

window.Cauldron.InspectorAssetAttributeElement = InspectorAssetAttributeElement;

class InspectorAssetPreviewElement extends Cauldron.InspectorElement {
    constructor(treeNode) {
        super();
        let self = this;

        this.treeNode = treeNode;

        this.handleAssetUpdated = function() {
            self.assetUpdated();
        };

        this.treeNode.registerOnDecoratedCallback(this.handleAssetUpdated);

        this.assetUpdated();
        this.html.classList.add("inspector-asset");
    }

    destroy() {
        super.destroy();
        this.treeNode.deregisterOnDecoratedCallback(this.handleAssetUpdated);
    }

    assetUpdated() {
        while(this.html.firstChild) this.html.firstChild.remove();

        let element = null;
        switch(this.treeNode.context["mimeType"]){
            case "image/svg+xml":
            case "image/gif":
            case "image/jpeg":
            case "image/bmp":
            case "image/x-icon":
            case "image/png":
                element = document.createElement("img");
                element.src = location.href.split("?")[0] + this.treeNode.context["fileName"];
                break;

            case "video/x-matroska":
            case "video/quicktime":
            case "video/mp4":
            case "video/webm":
            case "video/opgg":
                element = document.createElement("video");
                element.src = location.href.split("?")[0] + this.treeNode.context["fileName"];
                element.setAttribute("controls", true);
                break;

            case "audio/mp3":
            case "audio/wav":
            case "audio/ogg":
            case "audio/mpeg":
                element = document.createElement("audio");
                element.src = location.href.split("?")[0] + this.treeNode.context["fileName"];
                element.setAttribute("controls", true);
                break;

            default:
                console.log("Unhandled mimeType:", this.treeNode.context["mimeType"]);
                return;
        }

        element.classList.add("cauldron-inspector-element-asset-preview");
        element.setAttribute("tabindex","0");
        this.html.appendChild(element);

    }
}

window.Cauldron.InspectorAssetPreviewElement = InspectorAssetPreviewElement;

</SCRIPT><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron Inspector",
    "description": "Provides a list view of editable attributes and parameters",
    "dependencies": [
        "#CauldronNamespace"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><STYLE id="main-style">
/**
 *  CauldronInspector Styles
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
@keyframes cauldron-inspector-asset-preview-appears {
  from {
    opacity: 0;
    transform: scaleY(0.2); }
  to {
    opacity: 1;
    transform: scaleY(1); } }

.cauldron-inspector {
  overflow-y: auto;
  height: 100%;
  font-size: 0.9em; }
  .cauldron-inspector .cauldron-inspector-fields {
    display: grid;
    grid-template-columns: [label] 0fr [field] 1fr [extras] 0fr; }
    .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-section {
      grid-column-start: 1;
      grid-column-end: -1; }
      .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-section:not(:first-child) {
        padding-top: 1em; }
      .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-section .cauldron-inspector-header {
        padding-left: 0.5em;
        opacity: 0.7;
        border-bottom: 1px solid rgba(0, 0, 0, 0.2); }
    .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element {
      display: contents; }
      .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element .cauldron-inspector-element-label {
        grid-column-start: label;
        text-align: right;
        padding: 0.25em 0.5em;
        background: rgba(100, 100, 100, 0.1);
        opacity: 0.7;
        display: flex;
        align-items: center;
        justify-content: right; }
      .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element:focus-within .cauldron-inspector-element-label {
        opacity: 1; }
      .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element.failing-element * {
        background: red !important; }
      .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element .cauldron-inspector-element-field {
        background: rgba(100, 100, 100, 0.1);
        grid-column-start: field;
        justify-self: stretch;
        padding: 0.25em;
        display: flex; }
      .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element .cauldron-inspector-element-editor {
        background: transparent;
        border: 0;
        border-bottom: 1px solid rgba(100, 100, 100, 0.15);
        min-width: 2em;
        width: 95%;
        color: var(--mdc-theme-primary-on-background); }
      .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element .cauldron-inspector-element-asset-preview {
        grid-column: 1/-1;
        height: 5em;
        max-width: 100%;
        justify-self: center;
        cursor: pointer;
        position: relative; }
        .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element .cauldron-inspector-element-asset-preview:focus, .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element .cauldron-inspector-element-asset-preview:focus-within {
          position: fixed;
          left: 10%;
          width: 80%;
          top: 10%;
          height: 80%;
          background: rgba(0, 0, 0, 0.8);
          box-shadow: 0 0 1em;
          z-index: 9000;
          animation: 0.1s cauldron-inspector-asset-preview-appears ease-out; }
</STYLE></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="CauldronEditor" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron Editor",
    "description": "Component that can show a Codestrates Editor",
    "dependencies": [
        "#CauldronNamespace"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="editor-component-script" type="disabled">
/**
 *  CauldronEditor
 *  Binding for editing Codestrate Fragments
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/**
 * CauldronEditor is a component that can edit Codestrate Fragments
 * @memberof Cauldron
 */
class CauldronEditor {
    /**
     * Create a new CauldronEditor that edits the given Fragment
     * @param {Fragments.Fragment} fragment - The fragment to edit
     */
    constructor(fragment, options) {
        let self = this;

        /** @member {Fragments.Fragment} - The fragment this CauldronEditor edits */
        this.fragment = fragment;

        this.options = options;

        /** @member {Element} - The DOM element of this CauldronEditor */
        this.html = document.createElement("div");
        this.html.classList.add("cauldron-editor-component");

        /** @member {Editors.Editor} - The codestrates editor of this CauldronEditor */
        this.editor = EditorManager.createEditor(fragment, {
            editor: this.options.editorClass,
            theme: Cauldron.CauldronSettings.getTheme(),
            mode: "component"
        })[0];

        this.toolbar = document.createElement("div");
        this.toolbar.classList.add("cauldron-editor-component-toolbar");
        this.southArea = document.createElement("div");
        this.southArea.classList.add("cauldron-editor-component-south");

        this.toolbarMenu = MenuSystem.MenuManager.createMenu("Cauldron.Editor.Toolbar", {
            context: self.fragment,
            keepOpen: true,
            layoutDirection: MenuSystem.Menu.LayoutDirection.HORIZONTAL,
            defaultFocus: false
        });

        this.toolbar.appendChild(this.toolbarMenu.html);

        this.html.appendChild(this.toolbar);

        if(this.editor != null) {
            this.html.appendChild(this.editor.html[0]);
        } else {
            //Show warning instead of editor
            let warningDiv = document.createElement("div");
            this.html.appendChild(warningDiv);
            warningDiv.textContent = "No suitable editors could be found for fragment type ["+this.fragment.type+"] - Maybe require more editors.";
        }

        this.html.appendChild(this.southArea);

        this.fragment.registerOnAutoChangedHandler(()=>{
            //Update menu when fragment changes
            self.toolbarMenu.update();
        });

        function unloadHandler() {
            try {
                self.html.glContainer.close();
                self.destroy();
            } catch(e) {
                //Silent ignore
            }
            self.fragment.unRegisterOnFragmentUnloadedHandler(unloadHandler);
        }

        this.fragment.registerOnFragmentUnloadedHandler(unloadHandler);

        this.html.addEventListener("keydown", (evt)=> {
            if(evt.key === "s" && evt.ctrlKey) {
                evt.preventDefault();
            }
        });

        this.clientIcons = new Map();

        this.clientIconArea = document.createElement("div");
        this.clientIconArea.classList.add("cauldron-editor-component-clientarea");
        this.toolbar.insertBefore(this.clientIconArea, self.toolbar.firstChild);

        this.eventDeleters = [];

        this.eventDeleters.push(EventSystem.registerEventCallback("Collaboration.FragmentFocused", ({detail: { client:client, fragment: fragment}})=>{
            if(fragment === self.fragment) {
                self.addClientIcon(client);
            }
        }));

        this.eventDeleters.push(EventSystem.registerEventCallback("Collaboration.FragmentSelection", ({detail: { client:client, fragment: fragment, selection: selection}})=>{
            if(fragment === self.fragment) {
                if(self.editor != null) {
                    self.editor.setForeignSelection(client.id, selection);
                }
                self.addClientIcon(client);
            }
        }));

        this.eventDeleters.push(EventSystem.registerEventCallback("Collaboration.FragmentUnfocused", ({detail: { client:client, fragment: fragment}})=>{
            if(fragment === self.fragment) {
                if(self.editor != null) {
                    self.editor.setForeignSelection(client.id, null);
                }
                self.removeClientIcon(client);
            }
        }));

        // Handle live theme updates
        this.eventDeleters.push(EventSystem.registerEventCallback("Cauldron.Theme", (event)=>{
            if(self.editor !== null && event.detail.theme !== null) {
                self.editor.setTheme(event.detail.theme);
            }
        }));


        if(this.editor != null) {
            this.setupDropZone();

            //Setup settings on editor opened, and settings updated
            EventSystem.registerEventCallback("Cauldron.Settings.Updated", ({detail: settings}) => {
                self.editor.setWordwrap(Cauldron.CauldronSettings.getWordwrap());
            });

            EventSystem.registerEventCallback("Codestrates.Editor.Opened", ({detail: {editor}})=>{
                editor.setWordwrap(Cauldron.CauldronSettings.getWordwrap());
            });
        }
    }

    addClientIcon(client) {
        if(!this.clientIcons.has(client.id)) {
            let icon = Cauldron.Collaboration.getClientIcon(client.id);
            this.clientIcons.set(client.id, icon);
            this.clientIconArea.appendChild(icon);
        }
    }

    removeClientIcon(client) {
        if(this.clientIcons.has(client.id)) {
            let icon = this.clientIcons.get(client.id);
            this.clientIcons.delete(client.id);
            icon.remove();
        }
    }

    onSizeChanged() {
        if(this.editor != null) {
            this.editor.onSizeChanged();
        }
    }

    get title() {
        let content = "";
        let name = this.fragment.html[0].getAttribute("name");
        if (name != null && name != ""){
            content = name+" ";
        } else if(this.fragment.html[0].id != null && this.fragment.html[0].id!="") {
            content += "#"+this.fragment.html[0].id;
        }
        if (!content){
            content = this.fragment.html[0].tagName.toLowerCase();
        }
        if(typeof this.options.titleWrapper === "function") {
            return this.options.titleWrapper(content);
        } else {
            return content;
        }
    }

    get tooltip(){
        let type = this.fragment.type;
        let id = this.fragment.html[0].getAttribute("id");

        let tooltip = "Fragment";

        if (id != null && id.trim() !== "") {
            tooltip += "#" + id;
        }

        tooltip += " [" + type + "]";
        return tooltip;
    }

    focus() {
        if(this.editor != null) {
            this.editor.focus();
        }
    }

    setLine(line, column=1) {
        if(this.editor != null) {
            this.editor.setLine(line, column);
        }
    }

    destroy() {
        if(this.editor != null) {
            this.editor.unload();
        }

        this.editor = null;

        this.eventDeleters.forEach((deleter)=>{
            deleter.delete();
        });
    }

    setupDropZone() {
        let self = this;

        new CaviDroppableHTML5(this.html, {
            onDragLeave: (evt)=>{
            },
            onDragOver: (evt)=>{
                evt.dataTransfer.dropEffect = "none";

                if(evt.dataTransfer.types.includes("treenode/uuid")) {
                    let dragUUID = null;

                    evt.dataTransfer.types.forEach((type)=>{
                        if(type.indexOf("treenodedata/uuid") !== -1) {
                            dragUUID = type.split("|")[1];
                        }
                    });

                    let dragged = document.querySelector("[transient-drag-id='" + dragUUID + "']");
                    if (dragged != null && dragged.treeNode != null) {
                        let allowedRequireFragments = ["text/javascript", "text/typescript", "text/ruby", "text/python", "application/x-lua"];

                        if (dragged.treeNode.context.matches != null && dragged.treeNode.context.matches("code-fragment") && dragged.treeNode.context.hasAttribute("id") && allowedRequireFragments.includes(self.fragment.type)) {
                            evt.dataTransfer.dropEffect = "copy";
                        } else if(dragged.treeNode.type === "AssetNode" && allowedRequireFragments.includes(self.fragment.type) && (dragged.treeNode.context.fileName.endsWith(".js") || dragged.treeNode.context.fileName.endsWith(".css") )) {
                            evt.dataTransfer.dropEffect = "copy";
                        } else if(dragged.treeNode.type === "AssetNode" && self.fragment.type === "wpm/descriptor") {
                            evt.dataTransfer.dropEffect = "copy";
                        }
                    }
                }
            },
            onDrop: (evt, dropEffect)=>{
                let otherWebstrate = null;

                if(evt.dataTransfer.types.includes("treenode/href")) {
                    otherWebstrate = evt.dataTransfer.getData("treenode/href");
                }

                if(evt.dataTransfer.types.includes("treenode/uuid")) {
                    try {
                        let dragUUID = evt.dataTransfer.getData("treenode/uuid");
                        let dragged = document.querySelector("[transient-drag-id='" + dragUUID + "']");
                        if (dragged != null && dragged.treeNode != null) {
                            //Found the dragged TreeNode

                            let requireData = null;

                            if(dragged.treeNode.type === "DomTreeNode") {
                                requireData = cQuery(dragged.treeNode.context).data("Fragment");
                            } else if(dragged.treeNode.type === "AssetNode") {
                                requireData = dragged.treeNode.context;

                                if(self.fragment.type === "wpm/descriptor") {
                                    //Special insert here
                                    self.fragment.require().then((descJson)=>{
                                        if(!descJson.assets.includes(requireData.fileName)) {
                                            descJson.assets.push(requireData.fileName);
                                            self.fragment.raw = JSON.stringify(descJson, null, 2);
                                        }
                                    });
                                    return;
                                }
                            }

                            let requireLine = self.createRequireFromType(self.fragment.type, requireData);
                            self.editor.insertAtSelection(requireLine);
                            return;
                        }
                    } catch(e) {
                        console.log("Error accepting drop as treenode/uuid", e);
                    }
                }

                console.log("No supported data transfers:", evt.dataTransfer.types.slice());

                evt.dataTransfer.types.forEach((type)=>{
                    console.log(type, evt.dataTransfer.getData(type));
                });
            }
        });
    }

    createRequireFromType(type, requireData) {
        let requireLine = null;

        if(requireData instanceof Fragment) {
            let fragmentId = requireData.html[0].getAttribute("id");
            switch(type) {
                case "text/javascript":
                case "text/typescript":
                    requireLine = "let "+fragmentId+" = await Fragment.one(\"#"+fragmentId+"\").require();\n";
                    break;

                case "text/ruby":
                    requireLine = "Native(`Fragment`.JS.one(\"#"+fragmentId+"\").JS.require()).then { |result|\n" +
                        "    result = Native(result);\n" +
                        "}";
                    break;
                case "text/python":
                    requireLine = fragmentId+" = await window.Fragment.one(\"#"+fragmentId+"\").require()\n";
                    break;
                case "application/x-lua":
                    requireLine = "local "+fragmentId+" = pwait(js.global.Fragment:one(\"#"+fragmentId+"\"):require())\n";
                    break;

                default:
                    console.log("Unknown type for require creation: ", type);
            }
        } else if(requireData.fileName != null) {
            //Assume asset if fileName exists
            switch(type) {
                case "text/javascript":
                case "text/typescript":
                    requireLine = "await wpm.requireExternal(\""+location.href+requireData.fileName+"\");\n";
                    break;
                case "text/python":
                    requireLine = "load(\""+location.href+requireData.fileName+"\");\n";
                    break;

                default:
                    console.log("Unknown type for require creation: ", type);
            }
        }

        return requireLine;
    }
}

window.Cauldron.CauldronEditor = CauldronEditor;

</SCRIPT><STYLE id="main-style">
/**
 *  CauldronEditor Styles
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
.cauldron-editor-component {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column; }
  .cauldron-editor-component .cauldron-editor-component-toolbar {
    background: var(--mdc-theme-surface, rgba(255, 255, 255, 0.6));
    border-bottom: 1px solid #8a8a8a40;
    display: flex;
    justify-content: flex-end;
    opacity: 0.7; }
    .cauldron-editor-component .cauldron-editor-component-toolbar:hover {
      opacity: 1; }
  .cauldron-editor-component .codestrates-editor-core {
    height: 0;
    /** Layouting bug? **/
    flex: 1 1 auto; }
  .cauldron-editor-component .cauldron-editor-component-south {
    background: rgba(255, 255, 255, 0.6);
    display: flex;
    justify-content: flex-start;
    opacity: 0.7; }
    .cauldron-editor-component .cauldron-editor-component-south:not(:empty), .cauldron-editor-component .cauldron-editor-component-south.unsaved-changes {
      border-top: 1px solid #8a8a8a40;
      padding: 0.25em; }
    .cauldron-editor-component .cauldron-editor-component-south.unsaved-changes {
      background-color: rgba(255, 0, 0, 0.5); }
      .cauldron-editor-component .cauldron-editor-component-south.unsaved-changes::before {
        content: "Unsaved changes!"; }
</STYLE></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="CauldronBase" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron Editor",
    "description": "The base core functionality of Cauldron",
    "dependencies": [
        "wpm_js_libs #cQuery",
        "wpm_js_libs #CaviTouch",
        "wpm_js_libs #golden-layout",
        "wpm_js_libs #golden-layout_material-design-theme",
        "wpm_js_libs #Uploader",
        "webstrate-components-repos #EdgeDocker",
        "webstrate-components-repos #FragmentLogoIcons",
        "webstrate-components-repos #WebstrateIcons",
        "webstrate-components-repos #MaterialDesignOutlinedIcons",
        "webstrate-components-repos #MaterialMenu",
        "webstrate-components-repos #TreeBrowser",
        "webstrate-components-repos #ButtonSystem",
        "webstrate-components-repos #ButtonSystem_MaterialDesign",
        "webstrate-components-repos #RevisionBrowser",
        "webstrate-components-repos #PermissionManager",
        "webstrate-components-repos #WPMPackageBrowser",
        "webstrate-components-repos #HeadEditorComponent",
        "webstrate-components-repos #ModalDialog",
        "codestrates-repos #editor_monaco",
        "#CauldronNamespace",
        "#CauldronSettings",
        "#CauldronMainMenu",
        "#CauldronActionMenu",
        "#CauldronInspector",
        "#CauldronConsole",
        "#CauldronEditor"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="base-script" type="disabled">
/**
 *  Cauldron Base
 *  The core IDE of Cauldron
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global GoldenLayout */

/**
 * Triggered when a Cauldron is opened.
 * @event Cauldron.Cauldron#EventSystem:"Cauldron.OnOpen"
 * @type {CustomEvent}
 * @property {Cauldron.Cauldron} cauldron - The Cauldron that was opened
 */

/**
 * Triggered when a Cauldron is closed.
 * @event Cauldron.Cauldron#EventSystem:"Cauldron.OnClose"
 * @type {Event}
 * @property {Cauldron.Cauldron} cauldron - The Cauldron that was closed
 */

/**
 * Triggered when a Cauldron is initialized.
 * @event Cauldron.Cauldron#EventSystem:"Cauldron.OnInit"
 * @type {Event}
 * @property {Cauldron.Cauldron} cauldron - The Cauldron that was initialized
 */

/**
 * Tirgger to open a FragmentEditor
 * @event Cauldron.Cauldron#EventSystem:"Cauldron.Open.FragmentEditor"
 * @type {Event}
 * @property {Fragment} fragment - The fragment to open in a FragmentEditor
 */

/**
 * The Cauldron editor
 * @memberOf Cauldron
 * @alias Cauldron
 */
class CauldronBase {
    /**
     * Create a new Cauldron editor
     */
    constructor(config={}) {
        let defaultConfig = {
            edgeDockerMode: EdgeDocker.MODE.MINIMIZED,
            edgeDockerLoadMode: true,
            console: true,
            inspector: true,
            actionMenu: true,
            tabContextMenu: true,
            mainMenu: true,
            dragAndDrop: true,
            goldenLayoutSaveState: true
        };

        this.config = Object.assign({}, defaultConfig, config);

        this.setupGoldenLayoutPromise = null;

        //Setup EdgeDocker
        this.docker = new EdgeDocker({
            mode: this.config.edgeDockerMode
        });
        this.docker.getComponentArea().classList.add("cauldron-themeable");
        this.docker.getComponentArea().setAttribute("cauldron-theme", Cauldron.CauldronSettings.getTheme());

        //Setup container divs
        this.editorContentArea = document.createElement("div");
        this.editorContentArea.classList.add("cauldron-base-content");
        this.docker.getComponentArea().appendChild(this.editorContentArea);

        //Setup main menu
        if(this.config.mainMenu) {
            this.topBar = document.createElement("div");
            this.topBar.classList.add("cauldron-base-top");
            this.mainMenu = new CauldronMainMenu();
            this.docker.setupDragHandle(this.mainMenu.html);
        }

        // Action menu
        if(this.config.actionMenu) {
            this.actionMenu = new CauldronActionMenu();
            this.topBar.appendChild(this.actionMenu.html);
            this.topBar.appendChild(this.mainMenu.html);
            this.editorContentArea.appendChild(this.topBar);
        }

        // Inspector
        if(this.config.inspector) {
            this.inspector = new Cauldron.CauldronInspector();
        }

        //Console
        if(this.config.console) {
            this.console = new Cauldron.CauldronConsole();
        }

        this.goldenLayoutArea = document.createElement("div");
        this.goldenLayoutArea.classList.add("cauldron-layout");
        this.editorContentArea.appendChild(this.goldenLayoutArea);

        this.goldenLayoutInitDone = false;

        //Added components
        this.registeredComponentNames = new Set();

        if(this.config.mainMenu) {
            this.setupMenuItems();
        }

        if(this.config.dragAndDrop) {
            this.setupDragAndDrop();
        }

        this.setupEvents();
    }

    /**
     * Opens Cauldron IDE
     * Optionally inside another element
     */
    async open(optionalParentElement=false) {
        await this.setupGoldenLayout(this.goldenLayoutArea);

        this.docker.dockInto(optionalParentElement);
        if (optionalParentElement){
            this.docker.setMode(EdgeDocker.MODE.EMBEDDED);
        } else {
            if(this.config.edgeDockerLoadMode) {
                this.docker.loadMode(EdgeDocker.MODE.RIGHT);
            } else {
                this.docker.setMode(EdgeDocker.MODE.RIGHT, false);
            }
        }

        await EventSystem.triggerEventAsync("Cauldron.OnOpen", {
            cauldron: this
        });

        if(!this.goldenLayoutInitDone) {
            let initialisedPromise = new Promise((resolve, reject)=>{
                this.goldenLayout.on("initialised", ()=>{
                    resolve();
                });
            });
            this.goldenLayout.init();
            await initialisedPromise;
            this.goldenLayoutInitDone = true;
            EventSystem.triggerEvent("Cauldron.OnInit", {
                cauldron: this
            });
        }
    }


    /**
     * Closes Cauldron IDE
     */
    close() {
        this.docker.setMode(EdgeDocker.MODE.MINIMIZED);

        EventSystem.triggerEvent("Cauldron.OnClose", {
            cauldron: this
        });
    }

    /**
     * Check wether this Cauldron editor is open
     * @returns {boolean} true/false depending on if Cauldron is open or not
     */
    isOpen() {
        return this.docker.currentMode !== EdgeDocker.MODE.MINIMIZED;
    }

    /**
     * Sets the bounds of this Cauldron
     * @param {Number} x
     * @param {Number} y
     * @param {Number} width
     * @param {Number} height
     */
    setBounds(x, y, width, height) {
        this.docker.setBounds(x, y, width, height);
    }

    /**
     * @private
     */
    setupEvents() {
        let self = this;

        EventSystem.registerEventCallback("Cauldron.ResetLayout", ()=>{
            if(confirm("This will reset Cauldron layout, and reload the page, continue?")) {
                let key = "Cauldron-Saved-State-" + location.pathname.replace(/\//g, "");
                localStorage.setItem(key, null);
                location.reload();
            }
        });

        EventSystem.registerEventCallback("Cauldron.Minimize", ()=>{
            self.close();
        });

        EventSystem.registerEventCallback("Cauldron.Dock", ({detail:{pos: pos}})=>{
            self.docker.setMode(pos);
        });

        EventSystem.registerEventCallback("Cauldron.Theme", ({detail:{theme: theme}})=>{
            if (theme){
                self.docker.getComponentArea().setAttribute("cauldron-theme", theme);
            }
        });

        EventSystem.registerEventCallback("TreeBrowser.TreeNode.Action", ({detail:{node: node, treeBrowser: treeBrowser}})=>{
            if(node.type === "DomTreeNode" && node.context != null && node.context.matches("code-fragment")) {
                let fragment = cQuery(node.context).data("Fragment");

                EventSystem.triggerEvent("Cauldron.Open.FragmentEditor", {
                    fragment: fragment
                });

                return true; //Prevent default event
            }
        });

        EventSystem.registerEventCallback("Cauldron.Open.FragmentEditor", async ({detail: {fragment: fragment, line: line, column:column, editorClass: editorClass, titleWrapper: titleWrapper}})=>{

            if(editorClass == null) {
                editorClass = MonacoEditor;
            }

            if(titleWrapper == null) {
                titleWrapper = (t) => {
                    return t;
                }
            }

            //Make sure cauldron is open?
            if(!this.goldenLayoutInitDone) {
                await new Promise((resolve)=>{
                    EventSystem.registerEventCallback("Cauldron.OnInit", ()=>{
                        //Since goldenLayout has just opened, lets step back and wait a tick
                        setTimeout(()=>{
                            resolve();
                        }, 0);
                    });
                })
            }

            self.createComponent("FragmentEditor", {
                fragment: fragment,
                line: line,
                column: column,
                editorClass: editorClass,
                titleWrapper: titleWrapper
            }, false);
        });

        EventSystem.registerEventCallback("Cauldron.Open.Preview", ({detail: {fragment: fragment}})=>{
            self.createComponent("FragmentEditor", {
                fragment: fragment,
                editorClass: PreviewEditor
            });
        });

        EventSystem.registerEventCallback("Cauldron.Open.InnerHTMLEditor", ({detail: {element: element}}) => {
            self.createComponent("DomElementEditor", {
                element: element
            });
        });
    }

    /**
     * Selects a Golden Layout ContentItem, making it the active item in the Stack it lives inside.
     * @param item - The Golden Layout ContentItem to select
     * @private
     */
    selectItem(item) {
        //Check for stack parent
        if(item.parent != null && item.parent.type === "stack") {
            item.parent.setActiveContentItem(item);
        }
    }

    /**
     * @private
     */
    setupMenuItems() {
        let self = this;

        MenuSystem.MenuManager.registerMenuItem("Cauldron.View", {
            label: "Console",
            icon: IconRegistry.createIcon("mdc:laptop"),
            order: 100,
            onAction: ()=>{
                self.createComponent("Console", {}, false);
            }
        });

        MenuSystem.MenuManager.registerMenuItem("Cauldron.View", {
            label: "Inspector",
            icon: IconRegistry.createIcon("mdc:image_search"),
            order: 101,
            onAction: ()=>{
                self.createComponent("Inspector", {}, false);
            }
        });

        if (typeof webstrate !== "undefined"){
            // Only show revisions and permissions if running in webstrate mode
            MenuSystem.MenuManager.registerMenuItem("Cauldron.File", {
                label: "Revisions...",
                group: "FileMeta",
                groupOrder: 0,
                icon: IconRegistry.createIcon("mdc:restore"),
                order: 0,
                onAction: ()=>{
                    let revisionBrowser = new RevisionBrowser();

                    let dialog = new WebstrateComponents.ModalDialog(revisionBrowser.html, {maximize: true});
                    self.docker.getComponentArea().appendChild(dialog.html);
                    dialog.open();

                    EventSystem.registerEventCallback("RevisionBrowser.OnRestore", (evt)=>{
                        if(evt.detail === revisionBrowser) {
                            dialog.close();
                        }
                    });

                }
            });

            MenuSystem.MenuManager.registerMenuItem("Cauldron.File", {
                label: "Permissions...",
                group: "FileMeta",
                groupOrder: 0,
                icon: IconRegistry.createIcon("mdc:admin_panel_settings"),
                order: 0,
                onAction: ()=>{
                    let pmui = new WebstrateComponents.PermissionManagerUI();
                    pmui.setTopLevelComponent(self.docker.getComponentArea());

                    let dialog = new WebstrateComponents.ModalDialog(pmui.html);
                    self.docker.getComponentArea().appendChild(dialog.html);
                    dialog.open();

                    EventSystem.registerEventCallback("PermissionManagerUI.Saved", (evt)=>{
                        if(evt.detail === pmui) {
                            dialog.close();
                        }
                    });
                }
            });
        }

        MenuSystem.MenuManager.registerMenuItem("Cauldron.File", {
            label: "Properties...",
            group: "FileMeta",
            groupOrder: 0,
            icon: IconRegistry.createIcon("mdc:build_circle"),
            order: 0,
            onAction: ()=>{
                let headEditor = new HeadEditorComponent(false);
                let dialog = new WebstrateComponents.ModalDialog(headEditor.html, {
                    title: "File Properties",
                    actions: {
                        "Close":{primary:true}
                    }
                });
                self.docker.getComponentArea().appendChild(dialog.html);
                dialog.open();

                EventSystem.registerEventCallback("HeadEditorComponent.OnClose", (evt)=>{
                    if(evt.detail === headEditor) {
                        dialog.close();
                    }
                });
            }
        });

        MenuSystem.MenuManager.registerMenuItem("Cauldron.File", {
            label: "Packages...",
            group: "FileMeta",
            groupOrder: 0,
            icon: IconRegistry.createIcon("mdc:extension"),
            order: 0,
            onAction: ()=>{
                let packageBrowser = new WPMPackageBrowser(false);
                packageBrowser.setTopLevelComponent(self.docker.getComponentArea());

                let dialog = new WebstrateComponents.ModalDialog(packageBrowser.html, {flexContent: true});
                self.docker.getComponentArea().appendChild(dialog.html);
                dialog.open();

                EventSystem.registerEventCallback("WPMPackageBrowser.OnClose", (evt)=>{
                    if(evt.detail === packageBrowser) {
                        dialog.close();
                    }
                });
            }
        });
    }

    /**
     * Setup golden layout
     * @param {Element} container - The DOM element to use as a container for golden layout
     * @private
     */
    async setupGoldenLayout(container) {
        let self = this;

        if(this.setupGoldenLayoutPromise != null) {
            await this.setupGoldenLayoutPromise;
            return;
        }

        this.setupGoldenLayoutPromise = new Promise(async (resolve)=>{

            await loadGoldenLayout(self.goldenLayoutArea);

            let config = {
                settings: {
                    showPopoutIcon: false,
                    constrainDragToContainer: true
                },
                content: [
                    {
                        type: "row",
                        content: [
                            {
                                type: "column",
                                width: 25,
                                content: [
                                    {
                                        type: 'component',
                                        componentName: 'TreeBrowser',
                                        componentState: {},
                                        isClosable: false
                                    },
                                    {
                                        type: 'component',
                                        height: 25,
                                        componentName: 'Inspector',
                                        componentState: {},
                                        isClosable: true
                                    }
                                ]
                            },
                            {
                                type: "column",
                                width: 75,
                                content: [
                                    {
                                        type: "stack",
                                        id: "editors",
                                        isClosable: false,
                                        content: []
                                    },
                                    {
                                        type: "component",
                                        componentName: "Console",
                                        componentState: {},
                                        height: 25
                                    }
                                ]
                            }
                        ]
                    }
                ]
            };

            if(self.config.goldenLayoutConfig) {
                config = self.config.goldenLayoutConfig;
            }

            if(self.config.goldenLayoutSaveState) {
                let savedState = null;
                try {
                    let key = "Cauldron-Saved-State-" + location.pathname.replace(/\//g, "");

                    savedState = JSON.parse(localStorage.getItem(key), (key, value) => {
                        if (key === "content" && value instanceof Array) {
                            value = value.filter((arrayValue) => {
                                return arrayValue !== null;
                            });

                            //Fix any content with a missing content array?
                            value.forEach((child) => {
                                if (child.content == null) {
                                    child.content = [];
                                }

                                let activeItem = null;

                                if (child.activeItemIndex != null) {
                                    activeItem = child.content[child.activeItemIndex];
                                }

                                //Remove any components that did not deserialize correctly
                                value = value.filter((child) => {
                                    if (child.componentState != null && child.componentState.deserializeSuccess != null && child.componentState.deserializeSuccess !== true) {
                                        return false;
                                    }

                                    return true;
                                });

                                if (child.activeItemIndex != null) {
                                    child.activeItemIndex = Math.max(0, child.content.indexOf(activeItem));
                                }
                            });

                        }

                        if (key === "componentState" && value.serializer != null) {
                            //Use serializer if present
                            value.serializer.serialize = eval(value.serializer.serialize);
                            value.serializer.deserialize = eval(value.serializer.deserialize);
                            value.deserializeSuccess = value.serializer.deserialize(value);
                        }

                        return value;
                    });
                } catch (e) {
                    console.error("Error loading saved state:", e);
                }

                if (savedState != null) {
                    self.goldenLayout = new GoldenLayout(savedState, container);
                } else {
                    self.goldenLayout = new GoldenLayout(config, container);
                }

                let stateChangedTimeoutId = null;

                self.goldenLayout.on('stateChanged', function () {
                    if (stateChangedTimeoutId != null) {
                        clearTimeout(stateChangedTimeoutId);
                        stateChangedTimeoutId = null;
                    }

                    stateChangedTimeoutId = setTimeout(() => {
                        stateChangedTimeoutId = null;
                        let config = self.goldenLayout.toConfig();

                        let cache = [];

                        let key = "Cauldron-Saved-State-" + location.pathname.replace(/\//g, "");

                        localStorage.setItem(key, JSON.stringify(config, (key, value) => {
                            if (key === "componentState" && value.serializer != null) {
                                //Take copy, overriding serializer
                                let clone = Object.assign({}, value, {serializer: {}});
                                delete clone.deserializeSuccess;

                                //Use serializer if present
                                value.serializer.serialize(clone);

                                clone.serializer.serialize = value.serializer.serialize.toString();
                                clone.serializer.deserialize = value.serializer.deserialize.toString();

                                return clone;
                            }

                            return value;
                        }));
                    }, 250);
                });
            } else {
                self.goldenLayout = new GoldenLayout(config, container);
            }

            //Register TreeBrowser
            await self.registerComponent("TreeBrowser", (state)=>{
                let rootNode = new TreeNode({
                    context: null,
                    type: "",
                    hideSelf: true,
                    alwaysOpen: true
                });

                let bodyNode = new DomTreeGenerator().generateTree(document.querySelector("html > body"));
                bodyNode.unfold();
                rootNode.addNode(bodyNode);

                if (typeof webstrate !== "undefined"){
                    // If we are in a webstrate, also show its assets
                    let assetNode = new AssetTreeGenerator().generateTree();
                    assetNode.unfold();
                    rootNode.addNode(assetNode);
                }

                EventSystem.triggerEvent("Cauldron.TreeBrowserSpawned", {
                    root: rootNode
                });

                let tree = new TreeBrowser(rootNode);

                let treeContainer = document.createElement("div");
                treeContainer.classList.add("cauldron-navigator");
                treeContainer.appendChild(tree.html);

                return treeContainer;
            });

            //Register FragmentEditor
            await self.registerComponent("FragmentEditor", (state)=>{

                const options = {
                };

                if(state.editorClass) {
                    options.editorClass = state.editorClass;
                }

                if(state.titleWrapper) {
                    options.titleWrapper = state.titleWrapper;
                }

                let editorComponent = new Cauldron.CauldronEditor(state.fragment, options);

                return {
                    dom: editorComponent.html,
                    serializer: {
                        serialize: (state)=>{
                            //Serialized needed state into string
                            if(state.fragment != null && typeof state.fragment !== "string") {
                                state.fragment = state.fragment.html[0].__wid;
                            }
                            if(state.editorClass != null && typeof state.editorClass !== "string") {
                                state.editorClass = state.editorClass.prototype.constructor.name;
                            }
                            if(state.titleWrapper != null && typeof state.titleWrapper === "function") {
                                state.titleWrapper = state.titleWrapper.toString();
                            }
                            if(state.line) {
                                delete state.line;
                            }
                        },
                        deserialize: (state)=>{
                            //Deserialize state, and return true/false if success
                            state.fragment = Fragment.find("code-fragment").find((frag)=>{
                                return frag.html[0].__wid === state.fragment;
                            });

                            if(state.editorClass != null) {
                                state.editorClass = window[state.editorClass];
                            }

                            if(state.titleWrapper != null) {
                                state.titleWrapper = eval(state.titleWrapper);
                            }

                            return state.fragment != null;
                        }
                    },
                    onResize: ()=>{
                        editorComponent.onSizeChanged();
                    },
                    onShow: ()=>{
                        //On show is called right before the container is actually shown?
                        setTimeout(()=>{
                            editorComponent.onSizeChanged();
                            editorComponent.focus();
                            if(state.line != null) {
                                if (state.column!=null){
                                    editorComponent.setLine(state.line, state.column);
                                } else {
                                    editorComponent.setLine(state.line);
                                }
                                //Only do this once
                                delete state.line;
                                delete state.column;
                            }
                        }, 0);
                    },
                    onTab: (tab)=>{
                        let lastTitle = null;
                        let lastTooltop = null;

                        function updateTab() {
                            if(lastTooltop !== editorComponent.tooltip || lastTitle !== editorComponent.title) {
                                tab.element[0].title = editorComponent.tooltip;
                                tab.titleElement[0].innerText = editorComponent.title;

                                tab.titleElement.find(".cauldron-editor-tab-icon").remove();
                                let icon = IconRegistry.createIcon(["code-fragment:" + state.fragment.type, "mdc:insert_drive_file"]);
                                icon.classList.add("cauldron-editor-tab-icon");
                                if (icon) {
                                    tab.titleElement.prepend(icon);
                                }

                                // Setup context menu for tab
                                tab.element[0].addEventListener("contextmenu", (e)=>{
                                    e.preventDefault();
                                });
                                tab.element[0].addEventListener("mouseup", (e)=>{
                                    if(e.button !== 2) {
                                       return;
                                    }

                                    if(!self.config.tabContextMenu) {
                                        return;
                                    }

                                    let contextMenu = MenuSystem.MenuManager.createMenu("Cauldron.Tab.ContextMenu", {
                                        context: {tab:tab, editor:editorComponent},
                                        groupDividers: true
                                    });
                                    contextMenu.registerOnCloseCallback(()=>{
                                        if(contextMenu.html.parentNode != null) {
                                            contextMenu.html.parentNode.removeChild(contextMenu.html);
                                        }
                                    });

                                    //Find top component after html
                                    let parent = tab.element[0];
                                    while(parent.parentNode != null && !parent.parentNode.matches("html")) {
                                        parent = parent.parentNode;
                                    }
                                    parent.appendChild(contextMenu.html);
                                    contextMenu.open({
                                        x: e.pageX,
                                        y: e.pageY
                                    });
                                    e.stopPropagation();
                                    e.preventDefault();
                                });

                                lastTooltop = editorComponent.tooltip;
                                lastTitle = editorComponent.title;
                            }
                        }

                        state.fragment.registerOnFragmentChangedHandler(()=>{
                            updateTab();
                        });

                        updateTab();
                    },
                    onDestroy: ()=>{
                        editorComponent.destroy();
                    }
                };
            });

            //Register innerHTML editor
            await self.registerComponent("DomElementEditor", (state)=>{
                let element = state.element;

                let fragmentType = "text/html";
                let tabTitle = "Dom HTML";

                if(element.matches("style")) {
                    fragmentType = "text/css";
                    tabTitle = "Dom CSS";
                } else if(element.matches("script[type='text/javascript'], script:not([type])")) {
                    fragmentType = "text/javascript";
                    tabTitle = "Dom JS";
                }

                let fakeFragment = Fragment.create(fragmentType);
                fakeFragment.raw = element.innerHTML;

                fakeFragment.supportsAuto = ()=>{
                    return false;
                };

                fakeFragment.supportsRun = ()=>{
                    return false;
                };

                if(fragmentType === "text/css" || fragmentType === "text/javascript") {
                    //Setup direct editing of style / script

                } else {
                    fakeFragment.isInnerHtmlEditor = true;

                    //Indirect editing with save button for the rest
                    fakeFragment.save = ()=>{
                        let test = document.createElement(element.tagName.toLowerCase());
                        test.innerHTML = fakeFragment.raw;

                        if(test.innerHTML != fakeFragment.raw) {
                            if(!confirm("Your HTML does not parse correctly, the browser did some change, sure you want to save?")) {
                                return false;
                            }
                        }

                        element.innerHTML = fakeFragment.raw;

                        editorComponent.southArea.classList.remove("unsaved-changes");
                    };
                }

                let observer = null;

                let removed = false;

                const options = {
                    editorClass: MonacoEditor
                };

                if(state.editorClass) {
                    options.editorClass = state.editorClass;
                }

                if(state.titleWrapper) {
                    options.titleWrapper = state.titleWrapper;
                }

                let editorComponent = new Cauldron.CauldronEditor(fakeFragment, options);

                if(fragmentType === "text/css" || fragmentType === "text/javascript") {
                    //Read back changes into dom
                    fakeFragment.registerOnFragmentChangedHandler(()=>{
                        if(!removed && element.parentNode != null) {
                            observer.disconnect();
                            if (element.firstChild instanceof Text) {
                                element.firstChild.nodeValue = fakeFragment.raw;
                            } else {
                                element.textContent = fakeFragment.raw;
                            }
                            setTimeout(() => {
                                startObserver();
                            }, 0);
                        }
                    });
                } else {
                    //Setup direct editing of style / script
                    let oldHandleModelChanged = editorComponent.editor.handleModelChanged;

                    editorComponent.editor.handleModelChanged = function() {
                        oldHandleModelChanged.bind(editorComponent.editor)();

                        //Model changed, warn user
                        editorComponent.southArea.classList.add("unsaved-changes");
                    };

                    editorComponent.html.addEventListener("keyup", (evt)=>{
                        if(evt.key === "s" && evt.ctrlKey) {
                            fakeFragment.save();
                        }
                    });
                }

                observer = new MutationObserver((mutations)=>{
                    mutations.forEach((mutation)=>{
                        Array.from(mutation.removedNodes).forEach((removedNode)=>{
                            if(removedNode === element) {
                                fakeFragment.unload();
                                observer.disconnect();
                                removed = true;
                            }
                        });

                        if(!removed) {
                            if (fragmentType === "text/css" || fragmentType === "text/javascript") {
                                if (element.firstChild instanceof Text) {
                                    fakeFragment.raw = element.innerHTML;
                                } else {
                                    fakeFragment.raw = element.textContent;
                                }
                            }
                        }
                    });
                });

                function startObserver() {
                    observer.observe(element.parentNode, {
                        childList: true,
                        characterData: true,
                        subtree: true
                    });
                }

                startObserver();

                return {
                    dom: editorComponent.html,
                    serializer: {
                        serialize: (state)=>{
                            //Serialized needed state into string
                            if(state.element != null && typeof state.element !== "string") {
                                state.element = state.element.tagName+":"+state.element.__wid;
                            }
                        },
                        deserialize: (state)=>{
                            //Deserialize state, and return true/false if success
                            let split = state.element.split(":");
                            state.element = Array.from(document.querySelectorAll(split[0])).find((elm)=>{
                                return elm.__wid === split[1];
                            });

                            return state.element != null;
                        }
                    },
                    onTab: (tab)=>{
                        tab.titleElement[0].innerText = tabTitle+": "+element.tagName.toLowerCase();
                    },
                    onShow: ()=>{
                        //On show is called right before the container is actually shown?
                        setTimeout(()=>{
                            editorComponent.onSizeChanged();
                        }, 0);
                    },
                    onDestroy: (container)=>{
                        if(fragmentType === "text/css" || fragmentType === "text/javascript") {

                        } else {
                            if (editorComponent.southArea.classList.contains("unsaved-changes")) {
                                if (confirm("You have unsaved changes, save them now?")) {
                                    fakeFragment.save();
                                }
                            }
                        }
                    }
                };
            });

            //Register Inspector
            await self.registerComponent("Inspector", (state)=>{
                return self.inspector.html;
            });

            //Register Console
            await self.registerComponent("Console", (state)=>{
                return self.console.html;
            });


            function resizeGoldenLayout(){
                let bounds = {width: self.editorContentArea.offsetWidth, height:self.editorContentArea.offsetHeight};

                let topBarHeight = 0;
                if(self.topBar != null) {
                    topBarHeight = self.topBar.offsetHeight;
                }
                self.goldenLayout.updateSize(bounds.width, bounds.height - topBarHeight);
            }

            window.addEventListener("resize", ()=>{
                resizeGoldenLayout();
            });
            let resizeObserver = new ResizeObserver((entries) => {
                resizeGoldenLayout();
            });
            resizeObserver.observe(self.docker.getComponentArea());

            resolve();
        });

        await this.setupGoldenLayoutPromise;
    }

    hasComponent(componentName) {
        return this.registeredComponentNames.has(componentName);
    }

    /**
     * This callback is used to create components
     * @callback Cauldron.Cauldron~creatorCallback
     * @param {object} state - The state of the component
     * @returns {Cauldron.Cauldron~creatorCallbackResult|Element}
     */

    /**
     * This object is used to describe the serialize / deserialize of component state that cannot serialize correctly
     * using only JSON stringify/parse.
     * @typedef {object} Cauldron.Cauldron~serializer
     * @property {Function} serialize
     * @property {Function} deserialize
     */

    /**
     * Represents the result of a component creator function
     * @typedef {object} Cauldron.Cauldron~creatorCallbackResult
     * @property {Element} dom - The dom element of the component
     * @property {Cauldron.Cauldron~serializer} [serializer] - Serializer to use when state cannot serialize correctly using JSON stringify/parse
     * @property {Cauldron.Cauldron~componentResizedCallback} [onResize] - Callback that is called when component is resized
     * @property {Cauldron.Cauldron~tabCreatedCallback} [onTab] - Callback that is called when component has a tab created
     * @property {Cauldron.Cauldron~componentDestroyCallback} [onDestroy] - Callback that is called when component is destroyed
     * @property {Cauldron.Cauldron~componentShowCallback} [onShow] - Callback that is called when component is shown
    */

    /**
     * @callback Cauldron.Cauldron~componentShowCallback
     * @param {object} container - The Golden Layout container
     */

    /**
     * @callback Cauldron.Cauldron~componentResizedCallback
     * @param {object} container - The Golden Layout container
     */

    /**
     * @callback Cauldron.Cauldron~componentDestroyCallback
     * @param {object} container - The Golden Layout container
     */

    /**
     * @callback Cauldron.Cauldron~tabCreatedCallback
     * @param {object} tab - The tab that was created
     * @param {object} container - The Golden Layout container
     */

    /**
     * Register a component with Cauldron
     *
     * @example
     * registerComponent("MyComponent", (state)=>{
     *     let myComponentDom = document.createElement("div");
     *     myComponentDom.textContent = state.someState;
     *
     *     return myComponentDom;
     * });
     *
     * @example
     * registerComponent("MyComponent", (state)=>{
     *     let myComponentDom = document.createElement("div");
     *     myComponentDom.textContent = state.someState;
     *
     *     return {
     *         dom: myComponentDom,
     *         onResize: ()=>{
     *             //The component has been resized, do something
     *         },
     *         onTab: (tab)=>{
     *             //The component has created a tab, do something to it
     *         },
     *         onShow: ()=>{
     *             //Called when the component is made visible, ie. its tab is switched to
     *         },
     *         onDestroy: ()=>{
     *             //Called when the component is destroyed
     *         }
     *     };
     * });
     *
     * @example
     * registerComponent("MyComponent", (state)=>{
     *     let myComponentDom = document.createElement("div");
     *     myComponentDom.textContent = state.someState;
     *
     *     return {
     *         dom: myComponentDom,
     *
     *         //Setup serializer to handle state that cannot JSON stringify/parse correctly
     *         serializer: {
     *             serialize: (state)=>{
     *                 //Serialize all state that cannot JSON stringify/parse correctly
     *             },
     *             deserialize: (state)=>{
     *                 //Deserialize all state that cannot JSON stringify/parse correctly
     *             }
     *         }
     *     };
     * });
     *
     * @param {String} componentName - The name of the component
     * @param {Cauldron.Cauldron~creatorCallback} creator
     */
    async registerComponent(componentName, creator) {
        if(this.hasComponent(componentName)) {
            //Already registered
            return;
        }

        if(this.goldenLayout == null) {
            await this.setupGoldenLayout(this.goldenLayoutArea);
        }

        this.registeredComponentNames.add(componentName);

        await this.goldenLayout.registerComponent(componentName, function(container, state) {
            try {
                let componentConfig = creator(state, container);

                if(componentConfig.serializer != null) {
                    state.serializer = componentConfig.serializer;
                    container.setState(state);
                }

                if(componentConfig instanceof Element) {
                    container.getElement()[0].appendChild(componentConfig);
                    componentConfig.glContainer = container;
                } else {
                    container.getElement()[0].appendChild(componentConfig.dom);
                    componentConfig.dom.glContainer = container;

                    if(componentConfig.onResize != null) {
                        container.on("resize", () => {
                            componentConfig.onResize(container);
                        });
                    }

                    if(componentConfig.onShow != null) {
                        container.on("show", () => {
                            componentConfig.onShow(container);
                        });
                    }

                    if(componentConfig.onTab != null) {
                        container.on("tab", (tab) => {
                            componentConfig.onTab(tab, container);
                        });
                    }

                    if(componentConfig.onDestroy != null) {
                        container.on("destroy", () => {
                            componentConfig.onDestroy(container);
                        });
                    }
                }
            } catch(e) {
                console.error("Error creating component:", e);
                let errorDiv = document.createElement("div");
                errorDiv.innerHTML = "Something broke!";
                container.getElement()[0].appendChild(errorDiv);
                errorDiv.glContainer = container;
            }
        });
    }

    /**
     * Create a component with the given name and state
     *
     * @example
     * createComponent("MyComponent", {
     *     someState: "ImportantStateData"
     * });
     *
     * @param {String} componentName
     * @param {object} [state]
     * @param {boolean} [allowMultipleInstances=false] - Determines if multiple components with the same state are allowed, if set to true a new component will always be created. If false and a component with the same state already exists, then that component will be selected instead.
     */
    async createComponent(componentName, state = {}, allowMultipleInstances = false) {
        if(!allowMultipleInstances) {
            function compare(obj1, obj2) {
                //Check if these are equal
                if (Object.is(obj1, obj2)) {
                    return true;
                }

                //Check if both are same type
                if (typeof obj1 !== typeof obj2) {
                    return false;
                }

                //Since both were not equal, if one is null or undefined the other by definition is not
                if (obj1 == null || obj2 == null) {
                    return false;
                }

                //Handle object
                if (typeof obj1 === "object") {

                    //Only deep compare objects that are of constructor Object or Array
                    if(obj1.constructor.name !== obj2.constructor.name) {
                        return false;
                    }

                    if(obj1.constructor.name !== "Array" && obj1.constructor.name !== "Object") {
                        //We already tested that constructor names are equal, and only want Array or Object
                        return false;
                    }

                    for (let key in obj1) {
                        if(obj1.hasOwnProperty(key)) {
                            let obj1Value = obj1[key];
                            let obj2Value = obj2[key];

                            if (!compare(obj1Value, obj2Value)) {
                                return false;
                            }
                        }
                    }

                    for (let key in obj2) {
                        if(obj2.hasOwnProperty(key)) {
                            //Property existed in obj2 but not in obj1, everything else has already been tested
                            if (typeof obj1[key] === "undefined") {
                                return false;
                            }
                        }
                    }

                    return true;
                }

                if(typeof obj1 === "function") {
                    let equals = obj1.toString() === obj2.toString();

                    return equals;
                }

                //Nothing else failed, equal i guess?

                return true;
            }

            //Check for already present editor
            let foundComponents = this.goldenLayout.root.getItemsByFilter((item) => {
                if (item.componentName === componentName) {
                    let componentState = item.container.getState();

                    //Remove all our serializer stuff from state before comparing
                    let compareClone1 = Object.assign({}, componentState, {
                        componentName: null,
                        deserializeSuccess: null,
                        serializer: {},
                        line: null,
                        column: null
                    });
                    let compareClone2 = Object.assign({}, state, {
                        componentName: null,
                        deserializeSuccess: null,
                        serializer: {},
                        line: null,
                        column: null
                    });

                    let equal = compare(compareClone1, compareClone2);

                    return equal;
                }
            });

            if (foundComponents.length > 0) {
                //Attempt to update state
                foundComponents[0].config.componentState = Object.assign(foundComponents[0].config.componentState, state);

                //Select the already found component
                this.selectItem(foundComponents[0]);
                return;
            }
        }

        this.goldenLayout.root.getItemsById("editors")[0].addChild({
            type: "component",
            componentName: componentName,
            componentState: state
        });
    }

    /**
     * @private
     */
    setupDragAndDrop() {
        function addAssetToDescriptor(descFrag, assetFileName) {
            if(descFrag != null) {
                descFrag.require().then((descJson)=>{
                    if(!descJson.assets.includes(assetFileName)) {
                        descJson.assets.push(assetFileName);
                        descFrag.raw = JSON.stringify(descJson, null, 2);
                    }
                });
            }
        }

        EventSystem.registerEventCallback("TreeBrowser.TreeNode.Dropped", ({detail: { draggedNode: draggedNode, droppedNode: droppedNode, dropEffect: dropEffect, dragEvent: dragEvent}})=>{
            if(draggedNode.type === "DomTreeNode" && droppedNode.type === "DomTreeNode") {
                if(dragEvent.altKey && dropEffect === "move") {
                    //Move to before target
                    droppedNode.context.parentNode.insertBefore(draggedNode.context, droppedNode.context);
                } else if(!droppedNode.context.matches("code-fragment")) {
                    try {
                        if(dropEffect === "move") {
                            //Move inside target
                            droppedNode.context.appendChild(draggedNode.context);
                        } else if(dropEffect === "copy") {
                            let clone = draggedNode.context.cloneNode(true);
                            WPMv2.stripProtection(clone);
                            droppedNode.context.appendChild(clone);
                        }
                        droppedNode.unfold();
                    } catch(e) {
                        //Hide errors
                        console.error(e);
                    }
                }
            }

            if(draggedNode.type === "AssetNode" && droppedNode.type === "DomTreeNode") {
                let descFrag = cQuery(droppedNode.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");

                addAssetToDescriptor(descFrag, draggedNode.context.fileName);
            }

            if(draggedNode.type === "AssetNode" && droppedNode.type === "AssetRootNode") {
                let parentNode = droppedNode.parentNode;
                if(parentNode != null && parentNode.type === "DomTreeNode" && parentNode.context.matches("wpm-package")) {

                    let descFrag = cQuery(parentNode.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");

                    addAssetToDescriptor(descFrag, draggedNode.context.fileName);
                }
            }
        });

        EventSystem.registerEventCallback("TreeBrowser.DomFragment.Dropped", ({detail: { fragment: fragment, droppedNode: droppedNode, otherWebstrate: otherWebstrate}})=>{
            if(droppedNode.type === "DomTreeNode") {
                let firstChild = fragment.firstChild;
                let descriptors = fragment.querySelectorAll("code-fragment[data-type='wpm/descriptor']");
                droppedNode.context.appendChild(fragment);
                if(otherWebstrate != null && otherWebstrate !== location.href) {
                    //Let fragment stuff complete
                    setTimeout(() => {
                        descriptors.forEach((desc) => {
                            let frag = Fragment.one(desc);
                            frag.require().then((descJson) => {
                                descJson.assets.forEach((asset) => {
                                    fetch(otherWebstrate + asset).then((response) => {
                                        response.blob().then((blob) => {
                                            Uploader.upload(location.href, blob, asset).then(() => {
                                                frag.triggerFragmentChanged(frag);
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    }, 0);
                }

                setTimeout(()=>{
                    //unfold the node we dropped into
                    TreeBrowser.findAllTreeBrowsers().forEach((tb)=>{
                        tb.findTreeNodeForContext(firstChild.parentNode).forEach((treeNode)=>{
                            treeNode.unfold();
                        });
                    });
                }, 0);
            }
        });

        EventSystem.registerEventCallback("TreeBrowser.Asset.Dropped", async ({detail: { assetUrl: assetUrl, droppedNode: droppedNode}})=>{
            let assetName = assetUrl.substring(assetUrl.lastIndexOf("/")+1);

            if(droppedNode.type === "AssetNode" || droppedNode.type === "AssetRootNode" || droppedNode) {
                let parentNode = droppedNode.parentNode;

                fetch(assetUrl).then((response)=>{
                    response.blob().then((blob)=>{
                        Uploader.upload(location.href, blob, assetName).then(()=>{
                            if(parentNode != null && parentNode.type === "DomTreeNode" && parentNode.context.matches("wpm-package")) {

                                let descFrag = cQuery(parentNode.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");
                                addAssetToDescriptor(descFrag, assetName);
                            }
                        });
                    });
                });
            }

            if(droppedNode.type === "DomTreeNode" && droppedNode.context.matches("wpm-package")) {
                let descFrag = cQuery(droppedNode.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");
                if(descFrag != null) {
                    fetch(assetUrl).then((response)=> {
                        response.blob().then((blob) => {
                            Uploader.upload(location.href, blob, assetName).then(() => {
                                addAssetToDescriptor(descFrag, assetName);
                            });
                        });
                    });
                }
            }
        });

        EventSystem.registerEventCallback("TreeBrowser.Files.Dropped", async ({detail: { files: files, droppedNode: droppedNode}})=>{
            if(droppedNode.type === "AssetNode" || droppedNode.type === "AssetRootNode") {
                let parentNode = droppedNode.parentNode;

                for(let file of Array.from(files)) {
                    await Uploader.upload(location.href, file, file.name);
                    if(parentNode != null && parentNode.type === "DomTreeNode" && parentNode.context.matches("wpm-package")) {

                        let descFrag = cQuery(parentNode.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");

                        addAssetToDescriptor(descFrag, file.name);
                    }
                }
            }

            if(droppedNode.type === "DomTreeNode" && droppedNode.context.matches("wpm-package")) {
                let descFrag = cQuery(droppedNode.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");
                if(descFrag != null) {
                    for(let file of Array.from(files)) {
                        await Uploader.upload(location.href, file, file.name);
                        addAssetToDescriptor(descFrag, file.name);
                    }
                }

            }
        });

        EventSystem.registerEventCallback("TreeBrowser.TreeNode.DragOver", ({detail: {node: node, dragEvent: evt}})=>{

            let defaultDropEffect = false;
            let handled = false;

            if(node.type === "DomTreeNode") {
                if(evt.dataTransfer.types.includes("Files")) {
                    if(node.context.matches("wpm-package")) {
                        let descFrag = cQuery(node.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");
                        if(descFrag != null) {
                            evt.dataTransfer.dropEffect = "copy";
                            handled = true;
                        }
                    }
                } else if(evt.dataTransfer.types.includes("treenode/uuid")){
                    let dragUUID = null;

                    evt.dataTransfer.types.forEach((type)=>{
                        if(type.indexOf("treenodedata/uuid") !== -1) {
                            dragUUID = type.split("|")[1];
                        }
                    });


                    let dragged = document.querySelector("[transient-drag-id='" + dragUUID + "']");
                    if (dragged != null && dragged.treeNode != null) {
                        handled = true;
                        if(dragged.treeNode.type === "DomTreeNode" ) {
                            if(evt.altKey) {
                                //We are insertingBefore, not appending, only non allowed action is wpm-package inside wpm-package?
                                let draggedIsWpmPackage = dragged.treeNode.context.matches("wpm-package") || dragged.treeNode.context.querySelector("wpm-package") != null;
                                let droppedIsInsideWpmPackage = !node.context.matches("wpm-package") && node.context.closest("wpm-package") != null;

                                let droppedIsBody = node.context.matches("body");

                                if(!droppedIsBody && (!droppedIsInsideWpmPackage || !draggedIsWpmPackage)) {
                                    defaultDropEffect = true;
                                }
                            } else if(!node.context.matches("code-fragment, wpm-package") && node.context.closest("wpm-package") == null) {
                                //We are not dragging inside code-fragment or wpm-package
                                if (!dragged.treeNode.context.contains(node.context)) {
                                    defaultDropEffect = true;
                                }
                            } else if(node.context.matches("wpm-package")) {
                                //We are dragging into a wpm-package, make sure we dont ourselves include a wpm-package
                                if(!dragged.treeNode.context.matches("wpm-package") && dragged.treeNode.context.querySelector("wpm-package") == null) {
                                    defaultDropEffect = true;
                                }
                            }
                        } else if(dragged.treeNode.type === "AssetNode") {
                            if(node.context.matches("wpm-package")) {
                                let descFrag = cQuery(node.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");
                                if(descFrag != null) {
                                    evt.dataTransfer.dropEffect = "copy";
                                }
                            }
                        }
                    }
                }

                if(!handled && evt.dataTransfer.types.includes("text/plain")) {
                    if(!node.context.matches("code-fragment")) {
                        defaultDropEffect = true;
                    }
                }
            } else if(node.type === "AssetRootNode") {
                if(evt.dataTransfer.types.includes("Files") || evt.dataTransfer.types.includes("treenode/asset")) {
                    evt.dataTransfer.dropEffect = "copy";
                }
            }

            if(defaultDropEffect) {
                if(evt.ctrlKey) {
                    evt.dataTransfer.dropEffect = "copy";
                } else {
                    evt.dataTransfer.dropEffect = "move";
                }
            }
        });
    }
}

window.Cauldron.Cauldron = CauldronBase;

</SCRIPT><STYLE id="main-style">
/**
 *  Base Cauldron Styles
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
@keyframes cauldron-logo-appears {
  0% {
    transform: scale(0) translateY(-5%) scaleX(6);
    opacity: 0; }
  100% {
    transform: scale(0.5) translateY(-5%);
    opacity: 0.08; } }

@keyframes cauldron-content-appears {
  0% {
    opacity: 0; }
  100% {
    opacity: 1; } }

.cauldron-navigator {
  overflow-y: auto;
  height: 100%;
  overflow-x: hidden; }

.cauldron-base-top {
  background: #8484840f;
  border-bottom: 1px solid rgba(100, 100, 100, 0.1);
  display: flex;
  flex-direction: row-reverse;
  justify-content: space-between;
  flex: 0 0 auto; }

.cauldron-base-content {
  display: flex;
  flex-direction: column;
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  overflow: hidden;
  background: var(--mdc-theme-background, #FFFFFF);
  color: var(--mdc-theme-text-primary-on-background, black);
  font-family: sans-serif; }
  .cauldron-base-content .cauldron-layout {
    flex: 1 1 auto; }
    .cauldron-base-content .cauldron-layout .lm_goldenlayout {
      background: none; }
    .cauldron-base-content .cauldron-layout .lm_title {
      height: 100%;
      margin-bottom: -5px; }
      .cauldron-base-content .cauldron-layout .lm_title .cauldron-editor-tab-icon {
        width: 1em;
        height: 100%;
        vertical-align: text-bottom;
        padding-right: 0.3em; }
    .cauldron-base-content .cauldron-layout .lm_tab {
      margin-right: 1px;
      padding-left: 0.3em;
      padding-right: 20px;
      display: flex; }
    .cauldron-base-content .cauldron-layout .lm_content {
      animation: 0.15s cauldron-content-appears ease-in; }
    .cauldron-base-content .cauldron-layout .lm_items:empty {
      position: relative; }
      .cauldron-base-content .cauldron-layout .lm_items:empty:after {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        content: "";
        background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAKAAQMAAAA2A1tgAAAABlBMVEUAAAAAAAClZ7nPAAAAAXRSTlMAQObYZgAADihJREFUeNrsnDGO3SAURT1x4dJL8DbSeWORzNJYCl1a0lEgiCKPfSBEjs17UlLYzfz/mX8E3AtcsGeG41r8oHstOWoDc9AGZqsNzOpArw3M6kCvDczqQKcMVHX3TrSaRG3njL+ASd3cdlBudNAEzrRZsYpWu4peu4pRfZ41g7IXnWoVN+21ZdY2zgedqNdmp93mMCjrnAbtNquHEqsKnHL22saJ2p2Y1DvRaHei0+5Er9BOV3Zi1Og4W7xOKkqUnWg0gL4YzlZ3MUFmEZAqrjmoADNvogaQhk6wZy8BRqxtzu60AmCJkU49c5Vf1+zOxmdJfo1nfQNA173c0eb5QM+SCLpRmzEnujYK5sEcTy1Ke0qqeL60AI0kvzpkLvzee6HAkj1ALxl/6ejPADCI8qv5fBXxUhBldvcpcwIYNQ5bcj6tlJNoSY6Hb8wJzLJ9Cqvg3quyjLweE9ecnQaQLDftPz/Y5guz3PipDkBBltvJEaDTyHKf4A2gMMttWQVIllt1akiWWyJAQVwky81hr6gQSJabvAqQLDc6JeCQP8eI1QGS5YxM5cU3CVsIzBZVdIBtlmNykG1qqZEQGE9VPCORCbZnF0CWw5UCIJkw/QbsjcTpgEBgGZUcl9JGFvo+YCDL8XEn8IO2IbMoLI20eQYhmRuWzJocZSOPRscisktWUZpXRC9JcKAXLTJLBgod5onsCmluzmcQ9sKBQo8R2XcywM42WyI7A0XSZn9EdnwdRGtywDcaQeTosDWb1tcfpj8dLtm2vl5CV7CxRWSfKuCW+tPhdHCbk43nxgm7OoajEhTzPRNE2muKaxLdEXucuKMSrokIlvvT4TdcE5jdHnciOeQrrvHloUmPKp7qAvyk+/4Uhg0d9OfDmhyCDW1Bj12qNCd2sqlxJ2DDXL/pUcXysqjU1gtckLK6a597gOQQbBgQuQtIDqltOAGcHvmb9QQbYqGMVZ/I/CcbrgDv31bjCKi14Qbw6SSx1pWqRE6fWrlnMrvShpXI8RMYnsnsWxtOAMdnY5ojIGyIyOETmJ75JpY2rET2x+fPfJNKG1Yi2y7glo9WAsz7ZQ6geeYbgw1tKXJm/9GxuV+POiFyAthhRCZAHkA6ga7DiGedEDkAfG7Ej7NOiMwpqn9oxON7eByFngOHHE8dfCWy6QRuARuWAy/3rvirx4aVyL3AxWJDRKZDHwNngw3Lged7gRM2rER2vU3+8psNJ1zTB8QpoRZZAMSGaJIkQGzIwIsSIDZEkyABYkM08RIgNkQTKwBiQzTJBrmeAmsbZlwDsNuGaJIkQGyIJlEGxIYLrqHI9/naogmMuQdI2EQTKwKuVVCA3gkkbGLrTOW7gZG67nTBXXZ03XBNN5C9PLbGeetTIEo4bL3TpUCLrXcEQNs1UFhNS8T2FIhX6MKdLgWmsguz5B4QR6V0YaqBpgcYyi6MEiD3FOjCUFv0GQ6v0YUe4PPjFpRcc2PDUQKkxcg6Pj9hwhq0GBWmfqBBY1RgjeoAjvAAzo+BnF8v8FIN9F3AAI9OE8yv1RW0gX4QTYdjidr+ADQCoFnrNm5CYOI2bOGooR8YeHwOYBIA3Q5ELynQDmsLjB2BmBGyUqXeyF5P1CtVkkR25tUNIEO5G2h2YADYd3+YOWEHeunfUpUriWgoM76Y+KUjr9nQykceOdgdAlnRQAF4IoxkoLBNCQBFA6XeSI3yRZTVHKBgoEBxJzv1LlFcUADi6yfDlzNS1wJbX0/MStdAbiTN+IS0+RjIBZBwqAREfTkw1NFLBlz4dfbKGkBEdkpAorISENfoAHGNELjy6zynpgFkC6gEZAuoCGSTJgfyO0YPOOEaMRCRkw4QTaIikB2LFBjL4yY1IKdDcmAq/+WDHnCjXDrbZLow6AANfzymA7RnCLU6QH9+1QiBTKobxQrA/IMvagC5vBw4VUCrDRxkQPxMqQhIAd/TBToF4FACjQZwq7tQDlwBBhXgAtCpAGeAgwoQZ0cdIM52OkCMaBSAzV0pORCZnQ4QmQcVIEVBCch6pwck/MuBlFk1IH/wKgdC9IMOkOsFvsAX+AJf4At8gf8QuOagB2zu5rXhyTwELvlvAekZcLzqUBD3getFrOaRzvvAMV8Ef8ruA9kv2raClN0GjvliN1aU3Qaumcu0ElPFm8CPq4OaLXPFm8D66Ofq0MXcAvIw42/OQS77+dPfAo61e9LFU3/pFpC78Lysz/7oTHsHSHlzN/mjeRL9BnDCLFSxfOvKNzeAK8VUsXiXqnff/wrEzahqedM88nALGH/zXarmQSS/Cax13bhZ33xzvQlM7eQSzvqYZthcA9vhy+ftF7d7QFMVLBdnsPMtYGwLrsuuge06srYVpOwOsD37uj7TvQa2RdcrzA2ga4su1sD170A+QmjV0zn85hTjHH6XAmm1+e8C5wt8gS/wBb7AF/iTfTvIgRqEwgD8CAt2snXHTeRKLl0YIXHhMbwKxgN4BbwBS4yE39JOhToulIeJi85mAn18Ydo+mLy0N3iDN/gHoAqLQZMWgzYvBl1ZDKL+9yAWg241aFeDBn4l+Ir0UlCA1ACayAXlFXSZCypsZuhgXQ2CBdrYQLEORPoVtPAMUCKTvoKGBaoDpH8JahaoG1iXgoXMFTSgBaBbBcpnsDVfTYP0DNq9KfIkaMtDGHsIUVYGWC6gKySQFCZB8wQik2yg54H+kt0NDItAsYEaUTJAdwElIhmEeTD/BrTw60C1Sa6BkQViSMZAAHFAXEADL1CXgi3BF4IWG5A5oGhgHbdlzQHtDooBLGSQNjAsAlHIInJA2cDSQzI5BC4oBzAR4DfEs8DcMy8JJqg2UOU+OEqgfRMLTEPmqXZcc8BKegTNDtZpUKOSiUMqWxQmiAG0INdGmjILJvMFZEPflQW44Ad4F3oqSyC1mU+CLtkP+ATfU1ntoEvzoAQw7MrmGyKRi9Og+wV0XxuIefCdHDvwDZ8QSCBMg1UApYNAwyT8NFjEGApUuYM0C34rBKQhIrfZqToNfs/khisAxAbqMg0ik0UYQN9Ak+fBRAaX+kgDbeKAOg/tvIMuzoPxEmL3DU8gzIPhEvKCGqjg2eAYFU2lWdDCP0dlFAb426g8D1Z6+rBeNza/AR3g58HyO7DSNKjTM2iQ50EZn0GFuLiO/e7/K4zf4A3e4A3e4A3e4A3+FejiYhB5LSieH4CtLFA+Ot8MwZ43w7q7/ZBE4INjUU4hckBqndYPoEZiga4SISiEDmYWaBsYL2BhgaaSQJQLwUKygbGDlQ+GAZR8UCGIDhLAAm0mDT+CdjVo4Dmgy5tAI6iZYCJ7BRUCF6wD+JIkD0QiN4Jv2WAklKEQueMMUDQwd1BWIiYYxAiqSuQY4JF2aQDRrhML9AfoO2g5oIJXiGtBvQg08QHoozrcQTMHHvPQIPME5inQ5R2sZOGvoJ4DUR5bihvr1wqeCRYCaCFoH+DeoMwBXT1A0UC9g7LOga+JqK2CO5slKj0MfYDqL0FZ9594ggr1vFMMpkAD3+ZicKyvGvW8KS1IIvw1aBHIdNDsYNynOwe6A9Q41leLQuQeoJ8Gy0/QfSzns0uYB20hdYABpoH+AINEnDiHHZT4VDdQsEDTwHyCn8sGShADVBvofoJf8gaq82REifTXoBxABaR2gcoRNweKDUQi+QCjKT+X1CVgMJVs6mAmlVigN9ig85/TJCg2QdZjDBm8R+hgIf3XoO9gGw/ArwPzDg7PZ1TS8a9BeYISqYHlApq/BGUDwwmGNi4PIMj+PaiaU/Yj+7iHQKaBngPS29ZGOMHyo727x40bBqIAPAILlToCj8KbhQJSpMyVCOQAOULYpWWqCAjBl3W22NjgDjUz9E8Qv1bGZ0vzRoS3WQfkmKTg9eSot6v0NwjIwe12FF0S6xNwl4HrU9Df/hOt7pcK9Lfj/FG25g4ApANLH4xysFEA3QNLQNOBvgOuf8AqBLdG8QHMHRCueBw6MNwBNxQ5iAcw9cC1rMhSsC73QHcB5R+m+SsY9x74qdAHEoOOBUkJgrpg1oDrT9DSOuCCzwowHOt37K4PflWB25cLWLvgNxXoL+B6dEGowPARaSvUCZBUoEMO88BYokNBngi2BUCaB/6oC4Cd+VpvIYhKAGgieBDQumAAacBCEXUmmCni6IJeByYKyH2wKUGP1AW3qgJ3WkHdrIcKJKJM/RQFGBox0YDHZNCXyeCWJ4NuN4P0CCT6j0DowDIL3N7BDriLQP8vgxHXpNcFA67JLwhmERhfASwiEPfB8Fzgofp2xPSCYJWAjgH9c4FNcwJgvw9CAm4vAvLX+PgzYFK8G0AMmCeBqwaMZ8CiWOXGgYdi8xpX+ipfFB5sikWpHAhBrzlwgbzZ/hyY5DU8GFBSxMiBBHlvwHYX4t4sPBjFvVlPghC3BpkBBWP2PBjYy4o/IUjHvIAHvXTM7gbuPAjpTLAPrifZ4gE0AItsT4BBTVGFj7Ax4Pk32DYCHSBqYhzd0QLRPTtIQOzn9o7fBDA/wv/6MgTHVfQnwPhIHI54PMMAZeaDiXkssvCd2N4OyBxiqjTqx70ZsDLbJA2/p1qw3APjWwEze4zZN8++ezvR3FUhmrsqjT137KC92XUqyB9ohl73E829tjebP3G9ttdzm000t9mNARddDZnoasgk2mto703iQG9vjb03xGU1t8bem0pszEO29ybzoLe2xj5m4uOMQ7aP+aBBjEO2b3MagZtpk+3L12iUxTQT+66UMegtM7FPhcZxhneXvdrlDBj0j9DeRDqTRd1CexMzo6iKQ+eyKErDJ+ru2H7PdDqqVttfEDudj6KE9qdIogTLGvPVsVXGnt8ubwuXPBpAmwAAAABJRU5ErkJggg==");
        background-position: center;
        background-size: contain;
        background-repeat: no-repeat;
        transform: scale(0.5) translateY(-5%);
        opacity: 0.08;
        box-sizing: border-box;
        animation: 0.25s cauldron-logo-appears ease-in; }

/** Material STUBS **/
.cauldron-themeable {
  /** Size resets */
  --mdc-theme-primary: #3741bc;
  --mdc-typography-subtitle1-font-size: 11pt;
  --mdc-typography-subtitle1-line-height: 1.5em;
  --mdc-typography-subtitle2-font-size: 0.875em;
  --mdc-typography-caption-font-size: 0.75em;
  --mdc-typography-caption-line-height: 1.25em;
  --mdc-typography-body1-font-size: 1em;
  --mdc-typography-body2-font-size: 0.875em;
  --mdc-typography-headline6-font-size: 1.25em;
  --mdc-typography-button-font-size: 0.875em;
  font-size: 10pt;
  /** Mixin fixes for mixins that drop live customizability **/ }
  .cauldron-themeable .mdc-list {
    line-height: var(--mdc-typography-subtitle1-line-height, 1.5em); }
  .cauldron-themeable .mdc-menu .mdc-list, .cauldron-themeable .mdc-dialog .mdc-dialog__content, .cauldron-themeable .mdc-menu .mdc-list-item__graphic, .cauldron-themeable .mdc-data-table__header-cell, .cauldron-themeable .mdc-menu .mdc-list-item__meta,
  .cauldron-themeable .mdc-data-table__pagination-total, .cauldron-themeable .mdc-data-table__pagination-rows-per-page-label, .cauldron-themeable .mdc-data-table__cell,
  .cauldron-themeable .mdc-tab:not(.mdc-tab--active) .mdc-tab__icon, .cauldron-themeable .mdc-tab:not(.mdc-tab--active) .mdc-tab__text-label,
  .cauldron-themeable .mdc-dialog .mdc-dialog__title {
    color: var(--mdc-theme-text-primary-on-background); }
  .cauldron-themeable .mdc-radio .mdc-radio__native-control:enabled:not(:checked) + .mdc-radio__background .mdc-radio__outer-circle {
    border-color: var(--mdc-theme-text-secondary-on-background); }
  .cauldron-themeable .mdc-text-field:not(.mdc-text-field--disabled) + .mdc-text-field-helper-line .mdc-text-field-helper-text {
    color: var(--mdc-theme-secondary); }
  .cauldron-themeable .cauldron-editor-component-toolbar .mdc-list-item__graphic {
    margin-right: 0; }
</STYLE><STYLE id="theme_dark-style">
.cauldron-themeable[cauldron-theme="dark"] {
  --mdc-theme-primary: #3ea2ff;
  --mdc-theme-secondary: #0fa5ff;
  --mdc-theme-background: rgb(24, 24, 24);
  --mdc-theme-surface: rgb(38, 40, 56);
  --mdc-theme-error: #b00020;
  --mdc-theme-on-primary: #fff;
  --mdc-theme-on-secondary: #fff;
  --mdc-theme-on-surface: rgb(230, 234, 255);
  --mdc-theme-on-error: #fff;
  --mdc-theme-text-primary-on-background: rgba(255, 255, 255, 0.973);
  --mdc-theme-text-secondary-on-background: rgba(106, 197, 255, 0.54);
  --mdc-theme-text-hint-on-background: rgba(0, 0, 0, 0.38);
  --mdc-theme-text-disabled-on-background: rgba(0, 0, 0, 0.38);
  --mdc-theme-text-icon-on-background: rgba(218, 234, 255, 0.61);
  --mdc-theme-text-primary-on-light: rgba(0, 0, 0, 0.87);
  --mdc-theme-text-secondary-on-light: rgba(0, 0, 0, 0.54);
  --mdc-theme-text-hint-on-light: rgba(0, 0, 0, 0.38);
  --mdc-theme-text-disabled-on-light: rgba(0, 0, 0, 0.38);
  --mdc-theme-text-icon-on-light: rgba(0, 0, 0, 0.38);
  --mdc-theme-text-primary-on-dark: white;
  --mdc-theme-text-secondary-on-dark: rgba(255, 255, 255, 0.7);
  --mdc-theme-text-hint-on-dark: rgba(255, 255, 255, 0.5);
  --mdc-theme-text-disabled-on-dark: rgba(255, 255, 255, 0.5);
  --mdc-theme-text-icon-on-dark: rgba(255, 255, 255, 0.5);
  /** Menu highlights **/
  /** Golden layout **/ }
  .cauldron-themeable[cauldron-theme="dark"] :not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple::before,
  .cauldron-themeable[cauldron-theme="dark"] :not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple::after {
    background-color: #fff; }
  .cauldron-themeable[cauldron-theme="dark"] .cauldron-layout .lm_items:empty::after,
  .cauldron-themeable[cauldron-theme="dark"] .lm_header .lm_tab .lm_close_tab,
  .cauldron-themeable[cauldron-theme="dark"] .lm_controls {
    filter: invert(1); }
  .cauldron-themeable[cauldron-theme="dark"] .lm_content {
    border-color: #3c4347; }
</STYLE></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="NewWebstrateActions" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "New Webstrate",
    "description": "Actions that can create new Webstrates",
    "dependencies": [
        "webstrate-components-repos #MenuSystem",
        "#CauldronBase"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="new-webstrate-actions-script" type="disabled">
/**
 *  Webstrate Actions
 *  Ways of copying and manipulating a webstrate into a new one through the menu
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

if (typeof webstrate !== "undefined"){
    let newMenu = MenuSystem.MenuManager.createMenu("Cauldron.File.NewWebstrate");

    MenuSystem.MenuManager.registerMenuItem("Cauldron.File", {
        label: "New...",
        group: "FileDirect",
        groupOrder: -1,
        order: -1,
        icon: IconRegistry.createIcon("mdc:note_add"),
        submenu: newMenu
    });

    // New empty webstrate
    MenuSystem.MenuManager.registerMenuItem("Cauldron.File.NewWebstrate", {
        label: "Empty",
        icon: IconRegistry.createIcon("mdc:description"),
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Webstrate.New", {
                type: "empty"
            });
        }
    });

    // Download as archive
    MenuSystem.MenuManager.registerMenuItem("Cauldron.File", {
        label: "Download",
        group: "FileDirect",
        icon: IconRegistry.createIcon("mdc:archive"),
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Webstrate.Download");
        }
    });

    // New copy from this one
    MenuSystem.MenuManager.registerMenuItem("Cauldron.File.NewWebstrate", {
        label: "Copy",
        icon: IconRegistry.createIcon("mdc:file_copy"),
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Webstrate.New", {
                type: "copy"
            });
        }
    });

    // New from prototype url
    MenuSystem.MenuManager.registerMenuItem("Cauldron.File.NewWebstrate", {
        label: "From URL...",
        icon: IconRegistry.createIcon("mdc:link"),
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Webstrate.New", {
                type: "url"
            });
        }
    });

    // New from prototype file
    MenuSystem.MenuManager.registerMenuItem("Cauldron.File.NewWebstrate", {
        label: "From File...",
        icon: IconRegistry.createIcon("mdc:unarchive"),
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Webstrate.New", {
                type: "file"
            });
        }
    });

    EventSystem.registerEventCallback("Cauldron.Webstrate.Download", ()=>{
        let iframe = document.createElement("iframe");
        let transient = document.createElement("transient");
        transient.style.display = "none";

        transient.appendChild(iframe);

        iframe.webstrate.on("transcluded", async (webstrate)=>{
            console.log("Webstrate created:", webstrate);

            //Insert WPMv2
            await WPMv2.installWPMInto("/"+webstrate);

            transient.remove();
        });

        iframe.src = location.href + "?dl";

        document.body.appendChild(transient);
    });

    EventSystem.registerEventCallback("Cauldron.Webstrate.New", ({detail: {type: type}})=>{
        let iframe = document.createElement("iframe");
        let transient = document.createElement("transient");
        transient.style.display = "none";

        transient.appendChild(iframe);

        iframe.webstrate.on("transcluded", async (webstrate)=>{
            console.log("Webstrate created:", webstrate);

            //Insert WPMv2
            await WPMv2.installWPMInto("/"+webstrate);

            transient.remove();

            window.open("/"+webstrate);
        });

        switch(type) {
            case "empty":
                iframe.src = "/new";
                break;
            case "copy":
                iframe.src = location.href + "?copy";
                break;
            case "file": {
                let fileInput = document.createElement("input");
                fileInput.setAttribute("type", "file");
                fileInput.setAttribute("name", "file");
                fileInput.setAttribute("accept", ".zip");
                fileInput.click();

                fileInput.addEventListener("input", ()=>{
                    let formElement = document.createElement("form");
                    formElement.appendChild(fileInput);

                    let formData = new FormData(formElement);

                    fetch("/new", {
                        method: "POST",
                        body: formData
                    }).then((response)=>{
                        iframe.src = response.url;
                    });
                });
                break;
            }
            case "url": {
                let url = prompt("Prototype URL:");

                if(url.trim().length > 0) {
                    iframe.src = "/new?prototypeUrl="+url;
                }

                break;
            }
            default:
                console.log("Unknown type:", type);
        }

        document.body.appendChild(transient);
    });
}

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="DocumentActions" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Document Actions",
    "description": "Actions that change document",
    "dependencies": [
        "webstrate-components-repos #MenuSystem",
        "#CauldronBase"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="document-actions-script" type="disabled">
/**
 *  Document Actions
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 **/

MenuSystem.MenuManager.registerMenuItem("Cauldron.File", {
    label: "Title",
    group: "DocumentActions",
    groupOrder: 1,
    order: 0,
    icon: IconRegistry.createIcon("mdc:title"),
    onAction: (menuItem)=>{
        EventSystem.triggerEvent("Document.Edit.Title");
    }
});

EventSystem.registerEventCallback("Document.Edit.Title", ()=>{
    let content = WebstrateComponents.Tools.loadTemplate("#document-title-edit-dialog-tpl");

    content.querySelector("input.title").value = document.title;

    let dialog = new WebstrateComponents.ModalDialog(content);

    content.querySelector("button.save").addEventListener("pointerup", ()=>{
        dialog.close("save");
    });

    content.querySelector("button.cancel").addEventListener("pointerup", ()=>{
        dialog.close("cancel");
    });

    EventSystem.registerEventCallback("ModalDialog.Closed", ({detail: {dialog: closingDialog, action}})=>{
        if(closingDialog === dialog) {
            if(action === "save") {
                document.title = content.querySelector("input.title").value;
            }
        }
    });

    document.querySelector("html").appendChild(dialog.html);

    dialog.open();
});


</SCRIPT><TEMPLATE id="document-title-edit-dialog-tpl">
    <DIV>
        <LABEL>Title: <INPUT type="text" class="title"/></LABEL>
        <BR/>
        <BUTTON class="save">Save</BUTTON><BUTTON class="cancel">Cancel</BUTTON>
    </DIV>
</TEMPLATE></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="CauldronEditorViewActions" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Editor View Actions",
    "description": "Actions that change Cauldron",
    "dependencies": [
        "webstrate-components-repos #MenuSystem",
        "#CauldronBase"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="cauldron-editor-view-actions-script" type="disabled">
/**
 *  View Actions
 *  Control the Cauldron docking mode
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

{
    MenuSystem.MenuManager.registerMenuItem("Cauldron.File", {
        label: "Close",
        group: "Cauldron",
        icon: IconRegistry.createIcon("mdc:close"),
        order: 9000,
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Minimize");
        }
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.Settings", {
        label: "Word-wrap",
        icon: IconRegistry.createIcon("mdc:wrap_text"),
        order: 0,
        checked: ()=>Cauldron.CauldronSettings.getWordwrap(),
        onAction: (menuItem)=>{
            //Toggle word wrap in all open and future editors
            Cauldron.CauldronSettings.setWordwrap(!Cauldron.CauldronSettings.getWordwrap());
        }
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.MainActions", {
        icon: IconRegistry.createIcon("mdc:close"),
        order: 9000,
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Minimize");
        }
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.View.Dock",{
        label: "Left",
        icon: IconRegistry.createIcon("mdc:vertical_split"),
        order: 0,
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Dock", {
                pos: EdgeDocker.MODE.LEFT
            });
        }
    });
    MenuSystem.MenuManager.registerMenuItem("Cauldron.View.Dock",{
        label: "Right",
        icon: IconRegistry.createIcon("mdc:vertical_split"),
        order: 0,
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Dock", {
                pos: EdgeDocker.MODE.RIGHT
            });
        }
    });
    MenuSystem.MenuManager.registerMenuItem("Cauldron.View.Dock",{
        label: "Bottom",
        icon: IconRegistry.createIcon("mdc:horizontal_split"),
        order: 0,
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Dock", {
                pos: EdgeDocker.MODE.BOTTOM
            });
        }
    });
    MenuSystem.MenuManager.registerMenuItem("Cauldron.View.Dock",{
        label: "Float",
        icon: IconRegistry.createIcon("mdc:featured_video"),
        order: 0,
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Dock", {
                pos: EdgeDocker.MODE.FLOAT
            });
        }
    });
    MenuSystem.MenuManager.registerMenuItem("Cauldron.View.Dock",{
        label: "Maximize",
        icon: IconRegistry.createIcon("mdc:aspect_ratio"),
        order: 0,
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Dock", {
                pos: EdgeDocker.MODE.MAXIMIZED
            });
        }
    });

    let dockMenu = MenuSystem.MenuManager.createMenu("Cauldron.View.Dock");
    MenuSystem.MenuManager.registerMenuItem("Cauldron.View", {
        label: "Dock...",
        group: "Positioning",
        groupOrder:0,
        icon: IconRegistry.createIcon("mdc:view_quilt"),
        order: 0,
        submenu: dockMenu
    });

    let themeMenu = MenuSystem.MenuManager.createMenu("Cauldron.View.Theme");
    MenuSystem.MenuManager.registerMenuItem("Cauldron.View", {
        label: "Theme...",
        group: "LayoutCommands",
        groupOrder:0,
        icon: IconRegistry.createIcon("mdc:brush"),
        order: 0,
        submenu: themeMenu
    });

    ["Light", "Dark"].forEach((theme)=>{
        MenuSystem.MenuManager.registerMenuItem("Cauldron.View.Theme",{
            label: theme,
            order: 0,
            checked: ()=>Cauldron.CauldronSettings.getTheme()===theme.toLowerCase(),
            onAction: ()=>{
                Cauldron.CauldronSettings.setTheme(theme.toLowerCase());
                EventSystem.triggerEvent("Cauldron.Theme", {
                    theme: theme.toLowerCase()
                });
            }
        });
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.View", {
        label: "Reset layout",
        group: "LayoutCommands",
        groupOrder:10,


        icon: IconRegistry.createIcon("mdc:settings_backup_restore"),
        order: 1,
        onAction:()=>{
            EventSystem.triggerEvent("Cauldron.ResetLayout");
        }
    });
}

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="CauldronEditorTabActions" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Editor Tabs Actions",
    "description": "Actions that affect editor tabs",
    "dependencies": [
        "webstrate-components-repos #MenuSystem",
        "#CauldronBase"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="cauldron-editor-tabs-actions-script" type="disabled">
/**
 *  Tab Actions
 *  Control the Cauldron tabs
 *
 *  Copyright 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

{
    MenuSystem.MenuManager.registerMenuItem("Cauldron.Tab.ContextMenu", {
        label: "Close",
        group: "Tab",
        icon: IconRegistry.createIcon("mdc:close"),
        order: 100,
        onAction: (e)=>{
            e.menu.context.tab.closeElement.click();
        }
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.Tab.ContextMenu", {
        label: "Close Other",
        group: "Tab",
        icon: IconRegistry.createIcon("mdc:close"),
        order: 110,
        onOpen: (e)=>e.context.tab.header.tabs.length>1,
        onAction: (e)=>{
            let ourContent = e.menu.context.tab.contentItem;

            for (let tab of e.menu.context.tab.header.tabs.slice()){
                if (tab.contentItem != ourContent){
                    tab.closeElement.click();
                }
            };
            return true;
        }
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.Tab.ContextMenu", {
        label: "Close All",
        group: "Tab",
        icon: IconRegistry.createIcon("mdc:close"),
        order: 120,
        onOpen: (e)=>e.context.tab.header.tabs.length>1,
        onAction: (e)=>{
            for (let tab of e.menu.context.tab.header.tabs.slice()){
                tab.closeElement.click();
            };
            return true;
        }
    });

}

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="CauldronEditorDocumentation" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Documentation Help Menu",
    "description": "Documentation for the help menu",
    "dependencies": [
        "webstrate-components-repos #MenuSystem",
        "#CauldronBase"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="documentation-script" type="disabled">
/**
 *  Help Actions
 *  Links to various API and help documentation
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

{
    let documentationMenu = MenuSystem.MenuManager.createMenu("Cauldron.Help.Documentation");

    MenuSystem.MenuManager.registerMenuItem("Cauldron.Help", {
        label: "Documentation",
        icon: IconRegistry.createIcon("mdc:menu_book"),
        submenu: documentationMenu
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.Help.Documentation", {
        label: "Webstrates",
        icon: IconRegistry.createIcon("webstrates:logo"),
        onAction: () => {
            window.open("https://webstrates.github.io/userguide/api.html");
        }
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.Help.Documentation", {
        label: "Codestrates",
        icon: IconRegistry.createIcon("webstrates:codestrates"),
        onAction: () => {
            window.open("https://codestrates.projects.cavi.au.dk/api/codestrates/");
        }
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.Help.Documentation", {
        label: "Cauldron",
        icon: IconRegistry.createIcon("webstrates:cauldron"),
        onAction: () => {
            window.open("https://codestrates.projects.cavi.au.dk/api/cauldron/");
        }
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.Help.Documentation", {
        label: "Webstrate Components",
        icon: IconRegistry.createIcon("webstrates:components"),
        onAction: () => {
            window.open("https://webstrate.projects.cavi.au.dk/docs/webstrate_components/");
        }
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.Help.Documentation", {
        label: "Webstrate Package Manager",
        icon: IconRegistry.createIcon("webstrates:wpm-package-open"),
        onAction: () => {
            window.open("https://webstrate.projects.cavi.au.dk/docs/wpmv2/");
        }
    });
}

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="CauldronEditorCodestratesActions" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Codestrates Actions",
    "description": "Several actions that apply to code fragments",
    "dependencies": [
        "#CauldronBase",
        "webstrate-components-repos #MenuSystem",
        "webstrate-components-repos #wsc-icon-registry"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="fragment-actions-script" type="disabled">
/**
 *  Fragment Actions
 *  Menu entries related to fragments in codestrates
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

MenuSystem.MenuManager.registerMenuItem("Cauldron.Editor.Toolbar", {
    label: "Run",
    icon: IconRegistry.createIcon(["mdc:play_arrow"]),
    tooltip: "Execute the contents of this fragment",
    order: 200,
    class: "runAction",
    onAction: (menuItem)=>{
        EventSystem.triggerEvent("Codestrates.Fragment.Run", {
            fragment: menuItem.menu.context
        });
    },
    onOpen: (menu, menuItem)=>{
        return menu.context.supportsRun();
    }
});
EventSystem.registerEventCallback("Codestrates.Fragment.Run", async ({detail: {fragment: fragment}})=>{
    try {
        let result = await fragment.require();
        console.log("Require result: ", result);
    } catch(e) {
    }
});

MenuSystem.MenuManager.registerMenuItem("Cauldron.Editor.Toolbar", {
    label: "Auto",
    icon: IconRegistry.createIcon(["mdc:play_circle_outline"]),
    tooltip: "Run this fragment automatically",
    order: 100,
    class: "autoAction",
    onAction: (menuItem)=>{
        EventSystem.triggerEvent("Codestrates.Fragment.Auto", {
            fragment: menuItem.menu.context
        });

        menuItem.active = menuItem.menu.context.auto;
    },
    onOpen: (menu, menuItem)=>{
        if(menu.context.supportsAuto()) {
            menuItem.active = menu.context.auto;
            return true;
        }

        return false;
    }
});

// Single-element Autorun On/Off
MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Enable Autorun",
    icon: IconRegistry.createIcon("mdc:play_circle_outline"),
    tooltip: "Execute the contents of this fragment when the page loads",
    group: "EditActions",
    groupOrder: 200,
    order: 200,
    onOpen: (menu)=>{
        if(menu.context.type == "DomTreeNode" && menu.context.context.matches("code-fragment")) {
            let fragment = Fragment.one(menu.context.context);

            return fragment.supportsAuto() && !fragment.auto;
        }
    },
    onAction: (menuItem)=>{
        EventSystem.triggerEvent("Codestrates.Fragment.AutoOn", {
            fragment: Fragment.one(menuItem.menu.context.context)
        });
    }
});
MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Disable Autorun",
    icon: IconRegistry.createIcon("mdc:play_circle_outline"),
    tooltip: "Stop executing the contents of this fragment when the page loads",
    group: "EditActions",
    groupOrder: 200,
    order: 200,
    onOpen: (menu)=>{
        if(menu.context.type == "DomTreeNode" && menu.context.context.matches("code-fragment")) {
            let fragment = Fragment.one(menu.context.context);

            return fragment.supportsAuto() && fragment.auto;
        }
    },
    onAction: (menuItem)=>{
        EventSystem.triggerEvent("Codestrates.Fragment.AutoOff", {
            fragment: Fragment.one(menuItem.menu.context.context)
        });
    }
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Enable Autorun Recursively",
    icon: IconRegistry.createIcon("mdc:play_circle_outline"),
    group: "FragmentActions",
    groupOrder: 9000,
    order: 205,
    onOpen: (menu)=>{
        if(menu.context.type == "DomTreeNode") {
            let childFragments = Fragment.find(menu.context.context.querySelectorAll("code-fragment"));

            let autoFragment = childFragments.find((fragment)=>{
                return fragment.supportsAuto() && !fragment.auto;
            });

            return autoFragment != null;
        }
    },
    onAction: (menuItem)=>{
        let fragments = menuItem.menu.context.context.querySelectorAll("code-fragment");
        fragments.forEach((fragmentHtml)=>{
            let fragment = Fragment.one(fragmentHtml);
            if(fragment.supportsAuto() && !fragment.auto) {
                EventSystem.triggerEvent("Codestrates.Fragment.AutoOn", {
                    fragment: fragment
                });
            }
        });
    }
});
MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Disable Autorun Recursively",
    icon: IconRegistry.createIcon("mdc:play_circle_outline"),
    group: "FragmentActions",
    groupOrder: 9000,
    order: 210,
    onOpen: (menu)=>{
        if(menu.context.type == "DomTreeNode") {
            let childFragments = Fragment.find(menu.context.context.querySelectorAll("code-fragment"));

            let autoFragment = childFragments.find((fragment)=>{
                return fragment.supportsAuto() && fragment.auto;
            });

            return autoFragment != null;
        }
    },
    onAction: (menuItem)=>{
        let fragments = menuItem.menu.context.context.querySelectorAll("code-fragment");
        fragments.forEach((fragmentHtml)=>{
            let fragment = Fragment.one(fragmentHtml);
            if(fragment.supportsAuto() && fragment.auto) {
                EventSystem.triggerEvent("Codestrates.Fragment.AutoOff", {
                    fragment: fragment
                });
            }
        });
    }
});
EventSystem.registerEventCallback("Codestrates.Fragment.Auto", ({detail: {fragment: fragment}})=>{
    fragment.auto = !fragment.auto;
});
EventSystem.registerEventCallback("Codestrates.Fragment.AutoOn", ({detail: {fragment: fragment}})=>{
    fragment.auto = true;
});
EventSystem.registerEventCallback("Codestrates.Fragment.AutoOff", ({detail: {fragment: fragment}})=>{
    fragment.auto = false;
});


EventSystem.registerEventCallback("TreeBrowser.Keyup", ({detail: {evt: evt, treeNode: treeNode}})=>{
    if(evt.key === "Delete") {
        if(treeNode.type === "DomTreeNode") {
            EventSystem.triggerEvent("Codestrates.DomNode.Delete", {
                treeNode: treeNode
            });
        }
    }
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Delete",
    icon: IconRegistry.createIcon("mdc:delete"),
    group: "ViolentActions",
    groupOrder: 9000,
    order: 200,
    onOpen: (menu)=>{
        if(menu.context.type == "DomTreeNode") {
            return true;
        }
    },
    onAction: (menuItem)=>{
        EventSystem.triggerEvent("Codestrates.DomNode.Delete", {
            treeNode: menuItem.menu.context
        });
    }
});
MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Move Up",
    icon: IconRegistry.createIcon("mdc:north"),
    group: "EditActions",
    groupOrder: 9000,
    order: 1000,
    onOpen: (menu)=>{
        if(menu.context.type === "DomTreeNode"){
            let children = Array.from(menu.context.context.parentNode.children);
            return children.indexOf(menu.context.context)>0;
        }
    },
    onAction: (menuItem)=>{
        let children = Array.from(menuItem.menu.context.context.parentNode.children);
        let currentIndex = children.indexOf(menuItem.menu.context.context);
        menuItem.menu.context.context.parentNode.insertBefore(menuItem.menu.context.context, children[currentIndex-1]);
    }
});
MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Move Down",
    icon: IconRegistry.createIcon("mdc:south"),
    group: "EditActions",
    groupOrder: 9000,
    order: 1001,
    onOpen: (menu)=>{
        if(menu.context.type === "DomTreeNode"){
            let children = Array.from(menu.context.context.parentNode.children);
            return children.indexOf(menu.context.context)<children.length-1;
        }
    },
    onAction: (menuItem)=>{
        let children = Array.from(menuItem.menu.context.context.parentNode.children);
        let currentIndex = children.indexOf(menuItem.menu.context.context);
        menuItem.menu.context.context.parentNode.insertBefore(menuItem.menu.context.context, currentIndex===children.length-2?null:children[currentIndex+2]);
    }
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Duplicate",
    icon: IconRegistry.createIcon("mdc:content_copy"),
    group: "EditActions",
    groupOrder: 9000,
    order: 900,
    onOpen: (menu)=>menu.context.type === "DomTreeNode",
    onAction: (menuItem)=>{
        let clone = menuItem.menu.context.context.cloneNode(true);
        WPMv2.stripProtection(clone);
        menuItem.menu.context.context.parentNode.insertBefore(clone, menuItem.menu.context.context);
    }
});

EventSystem.registerEventCallback("Codestrates.DomNode.Delete", ({detail: {treeNode: treeNode}})=>{
    let decision = confirm("Really delete: "+treeNode.getProperty("content"));
    if(decision) {
        treeNode.context.parentNode.removeChild(treeNode.context);
    }
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Insert WPM Package",
    icon: IconRegistry.createIcon("webstrates:wpm-package-open"),
    order: 20,
    group: "inserters",
    groupOrder: -1,
    onOpen: (menu)=>{
        if (!window.DescriptorFragment) return false;
        return menu.context.type == "DomTreeNode" && !menu.context.context.matches("code-fragment, wpm-package");
    },
    onAction: (menuItem)=>{
        EventSystem.triggerEvent("Codestrates.Fragment.CreateWPMPackage", {
            treeNode: menuItem.menu.context
        });
    }
});

EventSystem.registerEventCallback("Codestrates.Fragment.CreateWPMPackage", ({detail: {treeNode: treeNode}})=>{
    let wpmPackage = document.createElement("wpm-package");

    let wpmDescriptor = Fragment.create("wpm/descriptor");
    wpmPackage.appendChild(wpmDescriptor.html[0]);

    WPMv2.stripProtection(wpmPackage);

    treeNode.context.appendChild(wpmPackage);
    setTimeout(()=>{
        let treeBrowser = treeNode.getTreeBrowser();
        let treeNodes = treeBrowser.findTreeNodeForContext(wpmPackage);
        if(treeNodes.length > 0) {
            let treeNode = treeNodes[0];
            treeNode.reveal();
            treeNode.select();
        }
    }, 0);
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Insert DOM Element",
    order: 10,
    icon: IconRegistry.createIcon("mdc:code"),
    group: "inserters",
    groupOrder: -1,
    onOpen: (menu)=>{
        return menu.context.type == "DomTreeNode" && !menu.context.context.matches("code-fragment, wpm-package");
    },
    onAction: (menuItem)=>{
        let elementType = prompt("Which element?");
        if (elementType===null) return;

        try {
            let element = document.createElement(elementType, {approved: true});
            menuItem.menu.context.context.appendChild(element);
            setTimeout(()=>{
                let treeBrowser = menuItem.menu.context.getTreeBrowser();
                let treeNodes = treeBrowser.findTreeNodeForContext(element);
                if(treeNodes.length > 0) {
                    let treeNode = treeNodes[0];
                    treeNode.reveal();
                    treeNode.select();
                }
            }, 0);
        } catch(e) {
            console.error(e);
        }
    }
});

let fragmentMenu = MenuSystem.MenuManager.createMenu("FragmentInsertMenu");

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Insert Fragment",
    icon: IconRegistry.createIcon("mdc:note_add"),
    order: 0,
    group: "inserters",
    groupOrder: -1,
    onOpen: (menu)=>{
        if (Fragment.fragmentTypes.size === 0) return false;

        let canOpen = menu.context.type == "DomTreeNode" && !menu.context.context.matches("code-fragment");

        // Check for new fragments not already registered in the menu
        if (!fragmentMenu.alreadyRegistered){
            fragmentMenu.alreadyRegistered = [];
        }
        Fragment.fragmentTypes.forEach((fragment, fragType)=>{
            if (!fragmentMenu.alreadyRegistered.includes(fragType)){
                MenuSystem.MenuManager.registerMenuItem("FragmentInsertMenu", {
                    label: fragment.name.replace("Fragment",""),
                    icon: IconRegistry.createIcon(["code-fragment:"+fragType, "mdc:insert_drive_file"]),
                    onAction: (menuItem)=>{
                        let fragment = Fragment.create(fragType);
                        WPMv2.stripProtection(fragment.html);
                        menuItem.menu.superMenu.context.context.appendChild(fragment.html[0]);
                        setTimeout(()=>{
                            //Find the newly added treenode and open the editor
                            let treeBrowser = menuItem.menu.superMenu.context.getTreeBrowser();
                            let treeNodes = treeBrowser.findTreeNodeForContext(fragment.html[0]);
                            if(treeNodes.length > 0) {
                                let treeNode = treeNodes[0];
                                treeNode.reveal();
                                treeNode.select();
                                //Is this needed?
                                treeNode.triggerAction();
                            }
                        }, 0);
                    }
                });
                fragmentMenu.alreadyRegistered.push(fragType);
            }
        });

        return canOpen;
    },
    submenu: fragmentMenu
});


MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Open Preview",
    group: "EditActions",
    groupOrder: 0,
    icon: IconRegistry.createIcon("mdc:web"),
    onOpen: (menu)=>{
        if(menu.context.type == "DomTreeNode" && menu.context.context.matches("code-fragment")) {
            let fragment = cQuery(menu.context.context).data("Fragment");

            if(PreviewEditor.types().includes(fragment.type)) {
                return true;
            }
        }
        return false;
    },
    onAction: (menuItem)=>{
        let fragment = cQuery(menuItem.menu.context.context).data("Fragment");

        EventSystem.triggerEvent("Cauldron.Open.Preview", {
            fragment: fragment
        });
    }
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Edit InnerHTML",
    icon: IconRegistry.createIcon("mdc:edit"),
    group: "EditActions",
    groupOrder: 200,
    order: 100,
    onOpen: (menu)=>{
        return menu.context.type === "DomTreeNode" && !menu.context.context.matches("code-fragment");
    },
    onAction: (menuItem)=>{
        let element = menuItem.menu.context.context;

        //Check for any code-fragment inside element
        if(element.querySelector("code-fragment") != null) {
            let decision = confirm("You are about to edit InnerHTML that contains or is itself a code-fragment, are you sure?");

            if(!decision) {
                return;
            }
        }

        EventSystem.triggerEvent("Cauldron.Open.InnerHTMLEditor", {
            element: menuItem.menu.context.context
        });
    }
});

MenuSystem.MenuManager.registerMenuItem("Cauldron.Editor.Toolbar", {
    label: "Save",
    icon: IconRegistry.createIcon(["mdc:save"]),
    onOpen: (menu)=>{
        return menu.context.isInnerHtmlEditor === true;
    },
    onAction: (menuItem)=>{
        menuItem.menu.context.save();
    }
});

</SCRIPT><SCRIPT id="asset-actions-script" type="disabled">
/**
 *  Asset Actions
 *  Menu entries related to assets in wpm packages
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Download",
    group: "TransferActions",
    groupOrder: 0,
    icon: IconRegistry.createIcon("mdc:cloud_download"),
    onOpen: (menu)=>{
        return menu.context.type == "AssetNode" || menu.context.type == "AssetContainer";
    },
    onAction: (menuItem) =>{
        EventSystem.triggerEvent("Cauldron.Asset.Download", {
            asset: menuItem.menu.context.context
        });
    }
});

EventSystem.registerEventCallback("Cauldron.Asset.Download", ({detail: {asset: asset}})=>{
    let a = document.createElement("a");
    a.setAttribute("href", location.href+asset.fileName);
    a.setAttribute("download", asset.fileName);
    a.setAttribute("target", "_blank");
    a.click();
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Delete",
    icon: IconRegistry.createIcon("mdc:delete"),
    group: "ViolentActions",
    groupOrder: 9000,
    onOpen: (menu)=>{
        return (menu.context.type == "AssetNode" || menu.context.type == "AssetContainer");
    },
    onAction: (menuItem)=>{
        if(
            menuItem.menu.context.parentNode != null &&
            menuItem.menu.context.parentNode.parentNode != null &&
            menuItem.menu.context.parentNode.parentNode.type === "DomTreeNode" &&
            menuItem.menu.context.parentNode.parentNode.context.matches("wpm-package")
        ) {
            //Asset inside wpm-package

            let descFrag = cQuery(menuItem.menu.context.parentNode.parentNode.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");
            if(descFrag != null) {
                let decision = confirm("Really delete: "+menuItem.menu.context.getProperty("content"));
                if(decision) {
                    descFrag.require().then((descJson)=>{
                        descJson.assets.splice(descJson.assets.indexOf(menuItem.menu.context.context.fileName), 1);
                        descFrag.raw = JSON.stringify(descJson, null, 2);
                    });
                }
            }
        } else {
            //Asset node not inside a package
            EventSystem.triggerEvent("Codestrates.Asset.Delete", {
                asset: menuItem.menu.context.context,
                success: ()=>{
                    menuItem.menu.context.parentNode.removeNode(menuItem.menu.context);
                },
                fail: (err)=>{
                    console.error(err);
                }
            });
        }
    }
});

EventSystem.registerEventCallback("TreeBrowser.Keyup", ({detail: {evt: evt, treeNode: treeNode}})=>{
    if(evt.key === "Delete") {
        if(treeNode.type === "AssetNode" || treeNode.type === "AssetContainer") {
            EventSystem.triggerEvent("Codestrates.Asset.Delete", {
                asset: treeNode.context,
                success: (err)=>{
                    if(err == null) {
                        treeNode.parentNode.removeNode(treeNode);
                    } else {
                        console.error(err);
                    }
                }
            });
        }
    }
});

EventSystem.registerEventCallback("Codestrates.Asset.Delete", async ({detail: {asset: asset, success: successCallback, fail: failCallback}})=>{
    //Check if asset is used by any wpm-packages.
    let descFragUsingAsset = [];

    for(let wpmPackageElm of Array.from(document.querySelectorAll("wpm-package"))) {
        let descFrag = cQuery(wpmPackageElm).find("code-fragment[data-type='wpm/descriptor']").data("Fragment");

        if(descFrag != null) {
            let descJson = await descFrag.require();

            if(descJson.assets.includes(asset.fileName)) {
                descFragUsingAsset.push(descFrag);
            }
        }
    }

    let msg = "Really delete asset: "+asset.fileName;

    if(descFragUsingAsset.length > 0) {
        msg = "Really delete asset: "+asset.fileName+" (It is currently being used by "+descFragUsingAsset.length+" descriptor fragments, and will be removed from those as well";
    }

    let decision = confirm(msg);
    if(decision) {
        webstrate.deleteAsset(asset.fileName, (err) => {
            if(err == null) {
                for(let descFrag of descFragUsingAsset) {
                    descFrag.require().then((descJson)=>{
                        descJson.assets.splice(descJson.assets.indexOf(asset.fileName), 1);
                        descFrag.raw = JSON.stringify(descJson, null, 2);
                    });
                }
                successCallback();
            } else {
                failCallback(err);
            }
        });
    }
});

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="Cauldron" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
  "friendlyName": "Cauldron Editor",
  "description": "The base core functionality of Cauldron",
  "dependencies": [
    "#CauldronBase",
    "#NewWebstrateActions",
    "#DocumentActions",
    "#CauldronEditorViewActions",
    "#CauldronEditorTabActions",
    "#CauldronEditorCodestratesActions",
    "#CauldronEditorDocumentation",
    "#CauldronCollaboration"
  ],
  "assets": [],
  "version": "0.1",
  "license": "Apache 2.0",
  "changelog": {
    "0.1": "Initial version"
  }
}

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="CauldronLauncher" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron Launcher",
    "description": "Delayed-loads the newest (or included) version of Cauldron and adds it to the window object",
    "dependencies": [
        "#CauldronNamespace"
    ],
    "optionalDependencies": [
        "#Cauldron"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="cauldron-launcher-script" type="disabled">
/**
 *  CauldronLauncher
 *  Launch Cauldron with delayed-load feature or directly if preloaded
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

// Create function on window to install Cauldron editor
window.cauldronEditor = async () => {
    if(typeof Cauldron === "undefined" || typeof Cauldron.Cauldron === "undefined") {
        await WPMv2.require({package: "Cauldron", repository: "cauldron-repos"});
    }
    if(typeof localCauldronEditor === "undefined") {
        window.localCauldronEditor = new Cauldron.Cauldron();
    }
    localCauldronEditor.open();
};

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="CauldronButtonLauncher" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron Edit Button",
    "description": "A floating edit button on your page that launches Cauldron",
    "dependencies": [
        "#CauldronLauncher"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="button-launcher-script" type="disabled">
// Add edit button to page that opens up the Cauldron editor
let button = document.createElement("button");
button.innerHTML="Edit"
button.style.position = "fixed";
button.style.top = "1em";
button.style.right = "1em";
button.id = "cauldron-edit-button";

let transientElement = document.createElement("transient");
transientElement.append(button);
document.body.appendChild(transientElement);

button.addEventListener("click", ()=>{
    cauldronEditor();
});


</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="cauldron-repos" id="CauldronURLLauncher" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron Edit URL",
    "description": "Launches Cauldron when ?edit is added to the URL of the page, also adds the Popup option to the Views menu",
    "dependencies": [
        "#CauldronLauncher",
        "codestrates-repos #EventSystem"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</SCRIPT><SCRIPT id="url-launcher-script" type="disabled">
/**
 *  URL Launcher
 *  Launched Cauldron when a specific URL pattern is detected
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

// Launch Cauldron when ?edit is added to the URL
const urlParams = new URLSearchParams(window.location.search);
const editorMode = urlParams.get('edit');

if(editorMode != null && editorMode !== false) {
    // Be nice to Codestrates if it is running
    window.disableCodestratesFragmentsAutorun = true;

    EventSystem.registerEventCallback("Cauldron.OnInit", ({detail: {cauldron: cauldron}})=>{
        EventSystem.triggerEvent("Cauldron.Dock", {
            pos: EdgeDocker.MODE.MAXIMIZED
        });
    });

    cauldronEditor();
}


//Run when/if Cauldron is initialized
if (typeof webstrate !== "undefined"){
    EventSystem.registerEventCallback("Cauldron.OnInit", ()=>{
        //Insert Cauldron view menu item
        MenuSystem.MenuManager.registerMenuItem("Cauldron.View.Dock", {
            label: "Popout editor",
            icon: IconRegistry.createIcon("mdc:open_in_new"),
            order: 1000, //Order us very low priority, so near the end of the menu
            onAction: ()=>{
                window.open(location.href+"?edit");
            }
        });
    });
}

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="varv-repos" id="varv-engine" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Varv engine",
    "description": "The core of the Varv system",
    "dependencies": [
        "wpm_js_libs #UUIDGenerator",
        "wpm_js_libs #js-yaml",
        "wpm_js_libs #LiveElement",
        "wpm_js_libs #izitoast",
        "wpm_js_libs #Observer",
        "codestrates-repos #EventSystem"
    ],
    "license": "MIT",
    "assets": [],
    "version": "0.1",
    "changelog": {}
}

</SCRIPT><SCRIPT id="VarvPerformance-script" type="disabled">
class VarvPerformance {
    static makeId(length) {
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const charactersLength = characters.length;
        for ( let i = 0; i < length; i++ ) {
            result += characters.charAt(Math.floor(Math.random() *
                charactersLength));
        }
        return result;
    }

    static start() {
        if(!VarvPerformance.enabled) {
            return;
        }

        let mark = this.makeId(32);

        performance.mark(mark);

        return mark;
    }

    static stop(name, mark, details) {
        if(!VarvPerformance.enabled) {
            return;
        }

        let endMark = mark+"end";

        performance.mark(endMark);

        if(VarvPerformance.prefix.length > 0) {
            name = VarvPerformance.prefix+"."+name;
        }

        try {
            performance.measure(name, {
                start: mark,
                end: endMark,
                detail: JSON.stringify(details, (key, value) => {
                    if (typeof value === "object" && value?.hasOwnProperty("constructOptions")) {
                        return value.constructOptions;
                    }

                    return value;
                })
            });
        } catch(e) {
            performance.measure(name, mark, endMark);
        }
    }

    static showInternal(options, callback) {
        let defaultOptions = {
            regex: null,
            minInvocations: 0
        };

        options = Object.assign({}, defaultOptions, options);

        let measureMap = new Map();

        performance.getEntriesByType("measure").forEach((measure)=>{
            let list = measureMap.get(measure.name);
            if(list == null) {
                list = [];
                measureMap.set(measure.name, list);
            }

            list.push(measure);
        });

        let entryArray = Array.from(measureMap.entries());

        entryArray.sort((e1, e2)=>{
            let v1 = e1[1];
            let v2 = e2[1];

            return v2.length - v1.length;
        });

        entryArray.forEach((entry)=>{
            let measures = entry[1];
            let key = entry[0];

            if(measures.length < options.minInvocations) {
                return;
            }

            if(options.regex != null) {
                if(key.match(options.regex) == null) {
                    return;
                }
            }

            measures.sort((m1, m2)=>{
                return m2.duration - m1.duration;
            });

            callback(measures, key);
        });
    }

    static showDetails(options) {
        this.showInternal(options, (measures, key)=>{

            console.groupCollapsed(key+" x"+measures.length);

            measures.forEach((measure)=>{
                if(measure.detail != null) {
                    console.log(measure.duration.toFixed(3) + " ms - ", JSON.parse(measure.detail));
                } else {
                    console.log(measure.duration.toFixed(3) + " ms");
                }
            });

            console.groupEnd();
        });
    }

    static showStats(options) {
        let data = [];

        this.showInternal(options, (measures, key)=> {
            let measureDurations = measures.map((m)=>{
                return m.duration;
            });

            let min = 99999;
            let max = 0;
            let mean = 0;
            let median = -1;
            let sum = 0;

            measureDurations.forEach((d)=>{
                min = Math.min(min, d);
                max = Math.max(max, d);
                sum += d;
            });

            mean = sum / measureDurations.length;

            let middleIndex = Math.floor(measureDurations.length / 2);

            if(measureDurations.length % 2 === 1) {
                //Odd
                median = measureDurations[middleIndex];
            } else {
                //Even
                median = measureDurations[middleIndex-1]/2.0 + measureDurations[middleIndex] / 2.0;
            }

            data.push({
                "name": key,
                "invocations": measureDurations.length,
                "mean": +mean.toFixed(3),
                "min": +min.toFixed(3),
                "max": +max.toFixed(3),
                "median": +median.toFixed(3),
                "sum": +sum.toFixed(3)
            })
        });

        console.table(data);
    }

    static reset() {
        performance.clearMarks();
        performance.clearMeasures();
    }
}

VarvPerformance.enabled = false;
VarvPerformance.prefix = "";
window.VarvPerformance = VarvPerformance;

</SCRIPT><SCRIPT id="YAMLJSONConverter-script" type="disabled">
/**
 *  YAMLJSONConverter - Convert between JSON and YAML program code
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 *
 */
class YAMLJSONConverter {
    /**
     * True/False depending on if the string code can be parsed as YAML
     * @param {string} code
     */
    static isYAML(code) {
        try {
            jsyaml.load(code);
            return true;
        } catch(e) {
            //Ignore
        }

        return false;
    }

    /**
     * True/False depending on if the string code can be parsed as JSON
     * @param {string} code
     */
    static isJSON(code) {
        try {
            JSON.parse(code);
            return true;
        } catch(e) {
            //Ignore
        }

        return false;
    }

    /**
     * Parses the given code string into an object, using either YAML or JSON
     * @param {string} code
     */
    static loadFromString(code) {
        let obj = null;
        let loader = null;

        try {
            obj = JSON.parse(code);
            loader = "JSON";
        } catch(jsonEx) {
            try {
                obj = jsyaml.load(code);
                loader = "YAML";
            } catch(yamlEx) {
                throw new Error("Unable to Parse string as YAML ("+yamlEx+") or JSON ("+jsonEx+")");
            }
        }

        return {
            loader,
            obj
        };
    }

    /**
     * Converts the given code to YAML / JSON, to opposite of what the input was.
     * @param code
     */
    static convert(code) {
        let result = YAMLJSONConverter.loadFromString(code);

        switch(result.loader) {
            case "JSON":
                return jsyaml.dump(result.obj);
                break;
            case "YAML":
                return JSON.stringify(result.obj, null, 2);
                break;
            default:
                console.warn("Unknown obj loader...");
                return code;
        }
    }
}
window.YAMLJSONConverter = YAMLJSONConverter;

</SCRIPT><SCRIPT id="Concept-script" type="disabled">
/**
 *  Concept - The central part of the Varv language
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 *
 */
class Concept {
    constructor(name) {
        this.name = name;
        this.properties = new Map();
        this.actions = new Map();
        this.behaviours = new Map();
        this.triggers = new Map();
        this.mappings = new Map();

        this.otherConcepts = new Set();
        this.appearedCallbacks = [];
        this.disappearedCallbacks = [];
    }

    addTrigger(trigger, removeOld=false) {
        if(removeOld) {
            let oldTrigger = this.triggers.get(trigger.name);

            if (oldTrigger != null) {
                if (Concept.DEBUG) {
                    console.log("Overwriting trigger:", oldTrigger, trigger);
                }

                this.removeTrigger(oldTrigger);
            }
        }

        this.triggers.set(trigger.name, trigger);
    }

    removeTrigger(trigger) {
        this.triggers.delete(trigger.name);
        trigger.disable(this);
    }

    getTrigger(name) {
        return this.triggers.get(name);
    }

    addBehaviour(behaviour, removeOld=false) {
        if(removeOld) {
            let oldBehaviour = this.behaviours.get(behaviour.name);

            if (oldBehaviour != null) {
                if (Concept.DEBUG) {
                    console.log("Overwriting behaviour:", oldBehaviour, behaviour);
                }

                this.removeBehaviour(oldBehaviour);
            }
        }

        this.behaviours.set(behaviour.name, behaviour);

        if(behaviour.callableAction) {
            this.addAction(behaviour.actionChain);
        }
    }

    removeBehaviour(behaviour) {
        this.removeAction(behaviour.actionChain);
        this.behaviours.delete(behaviour.name);
        behaviour.destroy();
    }

    getBehaviour(name) {
        return this.behaviours.get(name);
    }

    addAction(action, removeOld=false) {
        if(removeOld) {
            let oldAction = this.actions.get(action.name);

            if (oldAction != null) {
                if (Concept.DEBUG) {
                    console.log("Overwriting action:", oldAction, action);
                }

                this.removeAction(oldAction);
            }
        }

        this.actions.set(action.name, action);
    }

    removeAction(action) {
        this.actions.delete(action.name);
    }

    getAction(name) {
        return this.actions.get(name);
    }

    addProperty(property, removeOld=false) {
        if(removeOld) {
            let oldProperty = this.properties.get(property.name);

            if (oldProperty != null) {
                if (Concept.DEBUG) {
                    console.log("Overwriting property:", oldProperty, property);
                }

                this.removeProperty(oldProperty);
            }
        }

        this.properties.set(property.name, property);
    }

    removeProperty(property) {
        this.unmapProperty(property);
        this.properties.delete(property.name);
    }

    getProperty(name) {
        const self = this;

        let markStart = VarvPerformance.start();

        let property = null;

        if(name === "uuid") {
            property = {
                name: "uuid",
                type: "string",
                addUpdatedCallback: () => {},
                removeUpdatedCallback: () => {},
                isConceptType: () => false,
                isConceptArrayType: () => false,
                getValue: (uuid) => {
                    return uuid;
                }
            };
        } else if(name === "concept::uuid") {
            property = {
                name: "uuid",
                type: "string",
                addUpdatedCallback: ()=>{},
                removeUpdatedCallback: ()=>{},
                isConceptType: () => false,
                isConceptArrayType: () => false,
                getValue: (uuid) => {
                    return uuid;
                }
            };
        } else if(name === "concept::name") {
            property = {
                name: "name",
                type: "string",
                addUpdatedCallback: ()=>{},
                removeUpdatedCallback: ()=>{},
                isConceptType: () => false,
                isConceptArrayType: () => false,
                getValue: (uuid) => {
                    return self.name;
                }
            };
        } else {
            property = this.properties.get(name);
        }

        if(property != null) {
            VarvPerformance.stop("Concept.getProperty", markStart);
            return property;
        } else {
            VarvPerformance.stop("Concept.getProperty.error", markStart);
            throw new Error("No property ["+name+"] on ["+this.name+"]");
        }
    }

    async setPropertyValue(uuid, name, value, skipStateChangeTrigger=false) {
        await this.getProperty(name).setValue(uuid, value, skipStateChangeTrigger);
    }

    getPropertyValue(uuid, name) {
        return this.getProperty(name).getValue(uuid);
    }

    setupTriggers(debug) {
        const self = this;

        if(debug) {
            console.groupCollapsed("Setting up triggers on concept [" + this.name + "]");
        }

        for(let trigger of this.triggers.values()) {
            if(debug) {
                console.log("Enabling trigger:", trigger);
            }
            trigger.enable(this);
        }

        //We should listen for deleted concepts, and update our property when any we have are deleted...
        this.deletedTriggerDeleter = Trigger.registerTriggerEvent("deleted", async (contexts)=>{
            for(let context of contexts) {
                if(context.target != null) {
                    let concept = await VarvEngine.getConceptFromUUID(context.target);
                    if(concept != null) {
                        //A concept was deleted, check if we have any properties with the given concept
                        for(let property of self.properties.values()) {
                            if(property.holdsConceptOfType(concept)) {
                                await property.removeAllReferences(self.name, context.target);
                            }
                        }
                    }
                }
            }
        });

        if(debug) {
            console.groupEnd();
        }
    }

    destroyTriggers() {
        for(let trigger of this.triggers.values()) {
            if(Concept.DEBUG) {
                console.log("Disabling trigger:", trigger);
            }
            trigger.disable(this);
        }

        this.deletedTriggerDeleter.delete();
    }

    async create(wantedUUID=null, properties=null){
        let mark = VarvPerformance.start();
        if(wantedUUID == null) {
            let uuidMark = VarvPerformance.start();
            wantedUUID = UUIDGenerator.generateUUID("concept");
            VarvPerformance.stop("Concept.create.generateUUID", uuidMark);
        } else {

            // TODO is this correct?

            let oldConcept = await VarvEngine.getConceptFromUUID(wantedUUID);

            //If already present, just return as if it has been created?
            if(oldConcept != null) {
                if(oldConcept !== this) {
                    throw new Error("Trying to create ["+wantedUUID+"] as ["+this.name+"] but it is already registered as a ["+oldConcept.name+"]");
                }

                throw new Error("Trying to create ["+wantedUUID+"] that already existed, as the same concept type..");
            }
        }

        await VarvEngine.registerConceptFromUUID(wantedUUID, this);
        await this.appeared(wantedUUID, true);

        if (properties != null) {
            for (let key of Object.keys(properties)) {
                let value = properties[key];

                await this.setPropertyValue(wantedUUID, key, value, false);
            }
        } else {
            //Now trigger stateChanged for all properties
            for(let [key, prop] of this.properties) {
                let value = prop.getDefaultValue();
                await prop.stateChanged(wantedUUID, value);
            }
        }

        await this.created(wantedUUID);

        for (let callback of this.appearedCallbacks) {
            await callback(wantedUUID, this);
        }

        VarvPerformance.stop("Concept.create", mark);

        return wantedUUID;
    }

    /**
     * Clones the given UUID into a new one
     * @param {type} sourceUUID
     * @returns {@var;wantedUUID}
     */
    async clone(sourceUUID, deep=false, alreadyClonedReferences={}){
        let clonedProperties = {};
        for (const [propertyName, property] of this.properties){
            clonedProperties[propertyName] = await property.getValue(sourceUUID);

            if (deep){
                async function cloneUUID(propertyConcept, uuid){
                    let propertyActualConcept = await VarvEngine.getConceptFromUUID(uuid);
                    if (!propertyActualConcept) {
                        console.warn("Invalid reference to UUID '"+uuid+"' while deep-cloning property "+propertyName+" on "+propertyConcept.name+", the property was left as is (invalid)");
                        return uuid;
                    }
                    if (uuid===sourceUUID) throw new Error("Currently no support for deep cloning of concept instances with properties that contain direct self-references");
                    // TODO: cycles too

                    // Check if we already cloned it, if not do so
                    if (alreadyClonedReferences[uuid]){
                        return alreadyClonedReferences[uuid];
                    } else {
                        let theClone = await propertyConcept.clone(uuid, true);
                        alreadyClonedReferences[uuid] = theClone;
                        return theClone;
                    }
                }

                // Referenced Concepts and Concept reference lists should also be cloned
                if (property.isConceptType()){
                    let propertyConcept = await VarvEngine.getConceptFromType(property.getType());
                    clonedProperties[propertyName] = await cloneUUID(propertyConcept, clonedProperties[propertyName]);
                }
                if (property.isConceptArrayType()){
                    let propertyConcept = await VarvEngine.getConceptFromType(property.getArrayType());
                    let newPropertyValue = [];
                    for(let i = 0; i < clonedProperties[propertyName].length; i++) {
                        newPropertyValue.push(await cloneUUID(propertyConcept, clonedProperties[propertyName][i]));
                    }
                    clonedProperties[propertyName] = newPropertyValue;
                }
            };
        }

        return this.create(null, clonedProperties);
    }

    finishSetup(debug) {
        if(debug) {
            console.groupCollapsed("Finishing concept:", this.name);
        }
        //this.finishProperties(debug);
        this.finishBehaviours(debug);
        this.setupTriggers(debug);
        if(debug) {
            console.groupEnd();
        }
    }

    doAfterSpecLoadSetup(debug) {
        let mark = VarvPerformance.start();
        this.finishProperties(debug);
        VarvPerformance.stop("Concept.doAfterSpecLoadSetup", mark, this.name);
    }

    finishProperties(debug) {
        let self = this;

        if(debug) {
            console.group("Properties:");
        }

        this.properties.forEach((property)=>{
            if(debug) {
                console.log(property)
            }
            property.finishSetup(self);
        });

        if(debug) {
            console.groupEnd();
        }
    }


    finishBehaviours(debug) {
        if(debug) {
            console.group("Behaviours:");
        }
        this.behaviours.forEach((behaviour, key)=>{
            if(debug) {
                console.log(behaviour);
            }
            behaviour.setupEvents();
        });
        if(debug) {
            console.groupEnd();
        }
    }

    omit(omitConfig) {
        let self = this;

        if(omitConfig.schema != null) {
            if(!Array.isArray(omitConfig.schema)) {
                omitConfig.schema = [omitConfig.schema];
            }
            omitConfig.schema.forEach((propertyName)=>{
                let property = self.getProperty(propertyName);
                if(property != null) {
                    self.removeProperty(property);
                }
            });
        }

        if(omitConfig.actions != null) {
            if(!Array.isArray(omitConfig.actions)) {
                omitConfig.actions = [omitConfig.actions];
            }

            omitConfig.actions.forEach((actionName)=>{
                let behaviour = self.getBehaviour(actionName);
                if(behaviour != null) {
                    self.removeBehaviour(behaviour);
                }

                let action = self.getAction(actionName);
                if(action != null) {
                    self.removeAction(action);
                }
            });
        }
    }

    /**
     * Import the otherConcept into this one. This concept will be the combination of both concepts but retains its name.
     * In case of clashes the otherConcept will override existing entries in this concept.
     *
     * @param {Concept} otherConcept Other concept to import into this one
     */
    join(otherConcept){
        if(this === otherConcept) {
            console.warn("Attempting to join concept to itself!");
            return;
        }

        if(Concept.DEBUG) {
            console.group("Joining:", otherConcept.name, " into ", this.name);
        }

        const self = this;

        otherConcept.properties.forEach((property)=>{
            self.addProperty(property.cloneFresh(self), true);
        });

        for (let [propertyName, mappings] of otherConcept.mappings){
            this.mapProperty(this.getProperty(propertyName), mappings);
        }

        otherConcept.behaviours.forEach((behaviour)=>{
            self.addBehaviour(behaviour.cloneFresh(self), true);
        });

        this.otherConcepts.add(otherConcept.name);
        otherConcept.otherConcepts.forEach((otherConceptType)=>{
            self.otherConcepts.add(otherConceptType);
        })

        if(Concept.DEBUG) {
            console.groupEnd();
        }
    }

    unmapProperty(property) {
        this.mappings.get(property.name).forEach((datastoreName)=>{
            let datastore = Datastore.getDatastoreFromName(datastoreName);
            if(datastore != null) {
                datastore.removeBackingStore(this, property);
            } else {
                // TODO: Throw an error here?, We might just be unmapping from a join before datastores are even a thing...
            }
        });
        this.mappings.delete(property.name);
    }

    mapProperty(property, propertyMappings){
        this.mappings.set(property.name, propertyMappings);
    }

    enableMappings(debug = false) {
        const self = this;
        this.mappings.forEach((propertyMappings, propertyName)=>{
            let property = self.getProperty(propertyName);

            if(debug) {
                console.log(propertyName, propertyMappings);
            }

            let sharedDataStores = [];

            propertyMappings.forEach((datastoreName)=>{
                let datastore = Datastore.getDatastoreFromName(datastoreName);

                if(datastore != null) {
                    if(datastore.isShared()) {
                        sharedDataStores.push(datastoreName);
                    }

                    datastore.createBackingStore(this, property);
                } else {
                    console.warn("["+self.name+"] is attempting to map ["+propertyName+"] to a non existing datastore ["+datastoreName+"]");
                }
            });

            if(sharedDataStores.length > 1) {
                console.log("%c Property "+self.name+"."+propertyName+" is mapped to multiple shared datastores ["+sharedDataStores+"], this can create race conditions in multi user use cases.", "background: yellow; color: red;");
            }
        });
    }

    async delete(uuid){
        // Trigger deleted() trigger with target set to uuid
        await this.deleted(uuid);

        await this.disappeared(uuid);
    }

    addAppearedCallback(callback) {
        this.appearedCallbacks.push(callback);
    }

    addDisappearedCallback(callback) {
        this.disappearedCallbacks.push(callback);
    }

    async deleted(uuid) {
        let mark = VarvPerformance.start();
        await Trigger.trigger("deleted", {
            target: uuid
        });
        VarvPerformance.stop("Concept.Event.deleted", mark);
    }

    async created(uuid) {
        let mark = VarvPerformance.start();
        await Trigger.trigger("created", {
            target: uuid
        });
        VarvPerformance.stop("Concept.Event.created", mark);
    }

    async appeared(uuid, skipCallback=false) {
        let mark = VarvPerformance.start();
        // This instance just appeared in at least one datastore
        await VarvEngine.sendEvent("appeared", {
            target: uuid,
            concept: this
        });

        if(!skipCallback) {
            for (let callback of this.appearedCallbacks) {
                await callback(uuid, this);
            }
        }

        VarvPerformance.stop("Concept.Event.appeared", mark);
    }
    async disappeared(uuid) {
        let mark = VarvPerformance.start();

        // This instance just disappeared in at least one datastore
        await VarvEngine.sendEvent("disappeared", {
            target: uuid,
            concept: this
        });

        //Unregister the UUID
        VarvEngine.deregisterConceptFromUUID(uuid, this);

        for(let callback of this.disappearedCallbacks) {
            await callback(uuid, this);
        }

        VarvPerformance.stop("Concept.Event.disappeared", mark);
    }

    async destroy() {
        const self = this;

        if(Concept.DEBUG) {
            console.log("Destroying:", this);
        }

        //Destroy triggers
        this.destroyTriggers();

        //Destroy properties
        for(let property of this.properties.values()) {
            if(Concept.DEBUG) {
                console.log("Derigestering property:", property);
            }
            //Brute force trying to remove from any datastore known to mankind...
            Datastore.datastores.forEach((datastore)=>{
                try {
                    datastore.removeBackingStore(self, property);
                } catch(e) {
                    //Ignore
                }
            })
        }

        //Destroy behaviours
        for(let behaviour of this.behaviours.values()) {
            behaviour.destroy();
        }

        //Destroy actions
        this.actions = null;

        this.triggers = null;
        this.properties = null;
        this.behaviours = null;

        if(Concept.DEBUG) {
            console.log("Deregistering from VarvEngine...");
        }
        VarvEngine.deregisterConceptFromType(this.name);
    }

    isA(conceptType) {
        if(conceptType instanceof Concept) {
            conceptType = conceptType.name;
        }

        return this.name === conceptType || this.otherConcepts.has(conceptType);
    }
}
Concept.DEBUG = false;
window.Concept = Concept;

</SCRIPT><SCRIPT id="Property-script" type="disabled">
/**
 *  Property - A Property on a Concept
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * Defaults:
 *
 * String: "",
 * Boolean: false,
 * Number: 0,
 * Array: [],
 * Concept: null
 */

/**
 * Property options:
 *
 * number - default, min, max
 * boolean - default
 * string - default, enum, matches
 * array - max
 */

class Property {
    constructor(name, options={}) {
        const self = this;

        this.derivedOldValues = new Map();

        this.cloneData = {
            name: name,
            options: options!=null?JSON.parse(JSON.stringify(options)):null
        }

        //Shorthand
        if(typeof options === "string") {
            let type = options;
            options = {};
            options[type] = {};
        }

        if(Object.keys(options).length > 1 && options.type != null) {
            if(Property.DEBUG) {
                console.group("This property was defined with key 'type':", options);
            }

            let temp = options;

            options = {};

            options[temp.type] = temp;

            delete options[temp.type].type;

            if(Property.DEBUG) {
                console.log(options);
                console.groupEnd();
            }
        }

        this.name = name;
        this.type = Object.keys(options)[0];
        this.options = options[this.type];

        if(this.type === "array" && typeof this.options === "string") {
            this.options = {
                items: this.options
            }
        }

        this.setCallbacks = [];
        this.getCallbacks = [];
        this.updatedCallbacks = [];

        if(this.options.derive != null) {
            this.derived = {};

            if(this.options.derive.transform == null) {
                throw new Error("Missing transform option for derive from:"+name);
            }

            if(this.options.derive.properties) {
                this.derived.properties = this.options.derive.properties;
                if(!Array.isArray(this.derived.properties)) {
                    this.derived.properties = [this.derived.properties];
                }
            }

            if(this.options.derive.concepts) {
                this.derived.concepts = this.options.derive.concepts;
                if(!Array.isArray(this.derived.concepts)) {
                    this.derived.concepts = [this.derived.concepts];
                }
            }

            this.derived.transform = this.options.derive.transform;
        }
    }

    cloneFresh() {
        return new Property(this.cloneData.name, this.cloneData.options);
    }

    /**
     * @param {Concept} concept
     */
    finishSetup(concept) {
        const self = this;

        if(this.derived != null) {
            let mark = VarvPerformance.start();
            async function updateFunction(uuid) {
                try {
                    await self.getValue(uuid, true);
                } catch(e) {
                    console.warn("Error while updating derived value for ["+self.name+"]:", e, self);
                }
            }

            async function resetFunction() {
                let uuids = await VarvEngine.getAllUUIDsFromType(concept.name, true);

                for(let uuid of uuids) {
                    try {
                        await self.getValue(uuid, true);
                    } catch(e) {
                        console.warn("Error while updating derived value for ["+self.name+"]:", e, self);
                    }
                }
            }

            if(this.derived.properties != null) {
                try {
                    this.derived.properties.forEach((propertyName) => {
                        VarvEngine.lookupProperty(null, concept, propertyName).then((lookupResult) => {
                            if(lookupResult.property != null) {
                                if(concept.name === lookupResult.concept.name) {
                                    lookupResult.property.addUpdatedCallback(updateFunction);
                                } else {
                                    lookupResult.property.addUpdatedCallback(resetFunction);
                                }
                            }
                        }).catch((e)=>{
                            console.groupCollapsed("Error in derived property ["+this.name+"]");
                            console.log("Unable to setup property update callback for property:", propertyName);
                            console.log("Error:", e);
                            console.log("Derived property:", this);
                            console.log("Concept:", concept);
                            console.groupEnd();
                        });
                    });
                } catch(e) {
                    console.warn(e);
                }
            }

            if(this.derived.concepts != null) {
                try {
                    this.derived.concepts.forEach((conceptName) => {
                        let concept = VarvEngine.getConceptFromType(conceptName);
                        concept.addAppearedCallback(resetFunction);
                        concept.addDisappearedCallback(resetFunction);
                    });
                } catch(e) {
                    console.warn(e);
                }
            }

            VarvPerformance.stop("Property.finishSetup.derived", mark);
        }
    }

    getFullTypeString() {
        let type = this.getType();

        if(typeof type === "string") {
            let possibleConcept = VarvEngine.getConceptFromType(type);
            if(possibleConcept != null) {
                type = ["concept", type];
            }
        }

        if(type === "array") {
            let arrayType = this.getArrayType();
            type = arrayType+"[]";

            if(typeof arrayType === "string") {
                let possibleConcept = VarvEngine.getConceptFromType(arrayType);
                if (possibleConcept != null) {
                    type = ["concept[]", arrayType+"[]"];
                }
            }
        }

        return type;
    }

    getType() {
        return this.type;
    }

    getArrayType() {
        return this.options.items;
    }

    isConceptType() {
        if(typeof this.type === "string") {
            return VarvEngine.getConceptFromType(this.type) != null;
        }

        return false;
    }

    isConceptArrayType() {
        if(this.type === "array" && typeof this.options.items === "string") {
            let concept = VarvEngine.getConceptFromType(this.options.items);

            return concept != null;
        }

        return false;
    }

    isDerived(){
        return this.derived != null;
    }

    async removeAllReferences(propertyConceptType, removeUuid) {
        //Dont remove from derived
        if(this.isDerived()) {
            return;
        }

        if(Property.DEBUG) {
            console.group("["+propertyConceptType+" - "+this.name+"] Removing references to ["+removeUuid+"]");
        }

        for(let propertyConceptUUID of await VarvEngine.getAllUUIDsFromType(propertyConceptType)) {
            let value = await this.getValue(propertyConceptUUID);

            if(this.type === "array") {
                //Concept array property

                let beforeLength = value.length;

                value = value.filter((arrayElm) => {
                    return arrayElm !== removeUuid;
                });

                if(value.length !== beforeLength) {
                    if(Property.DEBUG) {
                        console.log("Found reference in array!");
                    }

                    //We removed something, setValue
                    await this.setValue(propertyConceptUUID, value);
                }
            } else {
                //Concept property
                if(value === removeUuid) {
                    if(Property.DEBUG) {
                        console.log("Found reference!")
                    }
                    await this.setValue(propertyConceptUUID, null);
                }
            }
        }

        if(Property.DEBUG) {
            console.groupEnd();
        }
    }

    holdsConceptOfType(concept) {
        //If not a concept property or array, just skip.
        if(!this.isConceptType() && !this.isConceptArrayType()) {
            return false;
        }

        let types = [concept.name];
        concept.otherConcepts.forEach((otherConcept)=>{
            types.push(otherConcept);
        });

        let handlesType = false;

        for(let type of types) {
            handlesType = handlesType || this.type === type || (this.type === "array" && this.options.items === type);
        }

        return handlesType;
    }

    addUpdatedCallback(callback) {
        this.updatedCallbacks.push(callback);
    }

    removeUpdatedCallback(callback) {
        let index = this.updatedCallbacks.indexOf(callback);
        if (index==-1){
            console.warn("Cannot remove updatedcallback that isn't part of "+this.name+" list of callbacks: "+callback+" list is "+this.updatedCallbacks);
            return;
        }
        this.updatedCallbacks.splice(index, 1);
    }

    addSetCallback(callback) {
        this.setCallbacks.push(callback);
    }

    removeSetCallback(callback) {
        let index = this.setCallbacks.indexOf(callback);
        if (index==-1){
            console.warn("Cannot remove setcallback that isn't part of "+this.name+" list of callbacks: "+callback+" list is "+this.setCallbacks);
            return;
        }
        this.setCallbacks.splice(index, 1);
    }

    addGetCallback(callback) {
        this.getCallbacks.push(callback);
    }

    removeGetCallback(callback) {
        let index = this.getCallbacks.indexOf(callback);
        if (index==-1){
            console.warn("Cannot remove getcallback that isn't part of "+this.name+" list of callbacks: "+callback+" list is "+this.getCallbacks);
            return;
        }
        this.getCallbacks.splice(index, 1);
    }

    async validateInternal(value, type, options) {
        const self = this;

        let validType = false;

        if(value === null) {
            return true;
        }

        switch(type) {
            case "number": {
                validType = typeof value === "number";
                break;
            }
            case "string": {
                validType = typeof value === "string";
                break;
            }
            case "boolean": {
                validType = typeof value === "boolean";
                break;
            }
            case "array": {
                validType = Array.isArray(value);
                break;
            }

            default:
                let typeConcept = VarvEngine.getConceptFromType(type);
                if( typeConcept != null) {
                    if(typeof value === "string") {
                        let valueConcept = await VarvEngine.getConceptFromUUID(value);

                        //If valueconcept is null, we dont know what type it is, pretend its of the correct type.
                        //To fix this, all datastores need to report their known UUID's before they load values

                        validType = valueConcept != null ? (valueConcept.isA(typeConcept.name)) : true;
                    } else {
                        validType = false;
                    }
                } else {
                    console.warn("Unknown type to validate:", type);
                }
        }

        let validValue = true;
        if(type === "array" && options.items != null) {
            for(let arrayValue of value) {
                validValue = validValue && await self.validateInternal(arrayValue, options.items, null);
            }
        }

        // TODO validate value according to options
        let validOptions = true;
        //Validate options
        if(options != null) {
            if (type === "string") {
                if (options.enum != null) {
                    validOptions = options.enum.includes(value);
                }
                if (options.matches != null) {
                    const regexp = new RegExp(options.matches);
                    validOptions = value.match(regexp);
                }
            }

            if (type === "number") {
                if (options.max != null) {
                    validOptions = validOptions && value <= options.max;
                }
                if (options.min != null) {
                    validOptions = validOptions && value >= options.min;
                }
            }

            if (type === "array") {
                if (options.max != null) {
                    validOptions = value.length <= this.options.max;
                }
            }
        }

        return validType && validValue && validOptions;
    }

    async validate(value) {
        return await this.validateInternal(value, this.type, this.options);
    }

    typeCast(inputValue, overrideType = null) {
        let mark = VarvPerformance.start();
        if(inputValue == null) {
            return null;
        }

        try {
            const self = this;

            let castedValue = inputValue;

            let type = this.type;

            if (overrideType !== null) {
                type = overrideType;
            }

            switch (type) {
                case "string": {
                    if(typeof inputValue === "string") {
                        return inputValue;
                    }

                    castedValue = "" + inputValue;
                    break;
                }

                case "number": {
                    if(typeof inputValue === "number") {
                        return inputValue;
                    }

                    castedValue = Number(inputValue);
                    if (isNaN(castedValue)) {
                        throw new Error("Unable to typecast [" + inputValue + "] to [number]");
                    }
                    break;
                }

                case "boolean": {
                    if(typeof inputValue === "boolean") {
                        return inputValue;
                    }

                    if(typeof inputValue === "string") {
                        const inputValueLower = inputValue.toLowerCase();
                        if(inputValue !== "0" && inputValue !== "1" && inputValue !== "true" && inputValue !== "false"){
                            throw new Error("Unable to typecast [" + inputValue + "] to [boolean]");
                        }

                        castedValue = (inputValue === "true" || inputValue === "1");
                    }

                    if(typeof inputValue === "number") {
                        if(inputValue !== 0 && inputValue !== 1){
                            throw new Error("Unable to typecast [" + inputValue + "] to [boolean]");
                        }
                        castedValue = inputValue === 1;
                    }

                    break;
                }

                case "array": {
                    if (Array.isArray(inputValue)) {
                        castedValue = inputValue.map((value) => {
                            return self.typeCast(value, this.options.items);
                        });
                    } else {
                        let parsedArray = JSON.parse(inputValue);

                        if (Array.isArray(parsedArray)) {
                            castedValue = parsedArray.map((value) => {
                                return self.typeCast(value, this.options.items);
                            });
                        } else {
                            throw new Error("Attempted to typecast to an array type, but input value was not an array and could not be parsed as an array: " + inputValue);
                        }
                    }
                    break;
                }

                default:
                    let typeConcept = VarvEngine.getConceptFromType(type);
                    if(typeConcept != null) {
                        return "" + inputValue;
                    }

                    throw new Error("Unknown how to type cast to type: " + type);
            }

            VarvPerformance.stop("Property.typeCast", mark);

            return castedValue;
        } catch(e) {
            throw e;
        }
    }

    async setValue(uuid, value, skipStateChangeTrigger=false) {
        let totalMark = VarvPerformance.start();

        if(this.isDerived()) {
            console.warn("setValue called on a derived property (Might be a left over property in DOMStore from when it was not derived?):", this.name, uuid, value);
            return;
        }

        if(!await this.validate(value)) {
            let type = typeof value;
            if(Array.isArray(value)){
                type = "array";
            }
            throw new Error("Value ["+value+":"+(type)+"] does not validate on property ["+this.name+":"+this.type+"]");
        }

        if(this.setCallbacks.length === 0) {
            throw new Error("No setCallbacks available for property ["+this.name+"]");
        }

        let mark = VarvPerformance.start();

        let promises = [];

        for(let setCallback of this.setCallbacks) {
            let result = setCallback(uuid, value);
            if(result instanceof Promise) {
                promises.push(result);
            }
        }

        if(promises.length > 0) {
            await Promise.all(promises);
        }

        PropertyCache.setCachedProperty(uuid+"."+this.name, value);

        VarvPerformance.stop("Property.setValue.callbacks", mark);

        let markUpdated = VarvPerformance.start();
        await this.updated(uuid, value, skipStateChangeTrigger);
        VarvPerformance.stop("Property.setValue.updated", markUpdated);
        VarvPerformance.stop("Property.setValue", totalMark);
    }

    async updated(uuid, value, skipStateChangeTrigger=false) {
        let mark = VarvPerformance.start();
        let promises = [];
        for(let updateCallback of this.updatedCallbacks.slice()) {
            let result = await updateCallback(uuid, value);

            if(result instanceof Promise) {
                promises.push(result);
            }
        }
        if(promises.length > 0) {
            await Promise.all(promises);
        }
        VarvPerformance.stop("Property.updated.callbacks", mark);

        let stateChangeMark = VarvPerformance.start();
        if(!skipStateChangeTrigger) {
            await this.stateChanged(uuid, value);
        }
        VarvPerformance.stop("Property.updated.stateChanged", stateChangeMark);
        VarvPerformance.stop("Property.updated", mark);
    }

    async deriveValue(uuid) {
        let mark = VarvPerformance.start();
        if(Property.DEBUG) {
            console.group("Deriving property ["+this.name+"] from ["+JSON.stringify(this.derived)+"]");
            console.groupCollapsed("Trace");
            console.trace();
            console.groupEnd();
        }

        //Try to derive property
        let currentFakeContext = [{
            target: uuid
        }];

        let lastTransformOutputVariable = null;

        try {
            for (let transform of this.derived.transform) {

                let transformActionName = null;

                if (Property.DEBUG) {
                    console.log("Applying transform:", transform);
                }

                let transformActionOptions = {};

                if (typeof transform === "string") {
                    transformActionName = transform;
                } else {
                    transformActionName = Object.keys(transform)[0];
                    transformActionOptions = Object.values(transform)[0];
                }

                let transformAction = Action.getPrimitiveAction(transformActionName, transformActionOptions);

                await ActionTrigger.before(transformAction, currentFakeContext);
                let mark = VarvPerformance.start();
                currentFakeContext = await transformAction.apply(currentFakeContext);
                if(transformAction.isPrimitive) {
                    VarvPerformance.stop("PrimitiveAction-"+transformAction.name, mark);
                } else {
                    VarvPerformance.stop("CustomAction-"+transformAction.name, mark);
                }
                await ActionTrigger.after(transformAction, currentFakeContext);

                if(Property.DEBUG) {
                    console.log("CurentContext:", currentFakeContext);
                }

                if(transformActionOptions.as != null) {
                    lastTransformOutputVariable = transformActionOptions.as;
                } else {
                    lastTransformOutputVariable = Action.defaultVariableName(transformAction);
                }
            }
        } catch(e) {
            if(e instanceof StopError) {
                console.log("Transform stopped: "+e.message);
            } else {
                throw e;
            }
        }

        if(lastTransformOutputVariable == null) {
            throw new Error("Unable to extract a variable after transform has run, lastTransformOutputVariable was null!");
        }

        let result = null;

        try {
            result = Action.getVariable(currentFakeContext[0], lastTransformOutputVariable);
        } catch(e) {
            console.debug(e);

            switch(this.type) {
                case "array":
                    result = [];
            }
        }

        if(!await this.validate(result)) {
            throw new Error("Derived value ["+result+"] does not validate against type ["+this.type+"]");
        }

        if(Property.DEBUG) {
            console.log("Resulting value:", result);
            console.groupEnd();
        }

        VarvPerformance.stop("Property.deriveValue", mark);

        return result;
    }

    purgeCache(uuid) {
        PropertyCache.removeCachedProperty(uuid+"."+this.name);
    }

    getValue(uuid, forceDerivedReload) {
        const self = this;

        let mark = VarvPerformance.start();

        if(this.derived != null) {
            return new Promise(async (resolve, reject)=>{
                const derivedOldValue = self.derivedOldValues.get(uuid);

                if(typeof derivedOldValue !== "undefined" && !forceDerivedReload) {
                    resolve(derivedOldValue);
                }

                try {
                    const derivedValue = await self.deriveValue(uuid);
                    self.derivedOldValues.set(uuid, derivedValue);


                    if (typeof derivedOldValue === "undefined" || !self.isSame(derivedValue, derivedOldValue)) {
                        await self.updated(uuid, derivedValue, false);
                    }

                    VarvPerformance.stop("Property.getValue.derived", mark);

                    return resolve(derivedValue);
                } catch(e) {
                    VarvPerformance.stop("Property.getValue.derived", mark);
                    return reject(e);
                }
            });
        }

        if(this.getCallbacks.length === 0) {
            VarvPerformance.stop("Property.getValue.error", mark);
            throw new Error("No getCallbacks available for property ["+this.name+"]");
        }

        let cachedProperty = PropertyCache.getCachedProperty(uuid+"."+this.name);
        if(cachedProperty != null) {
            VarvPerformance.stop("Property.getValue.cached", mark);
            return cachedProperty;
        }

        return new Promise(async (resolve, reject)=>{

            for(let getCallback of this.getCallbacks) {
                try {
                    let value = null;

                    let callbackReturn = getCallback(uuid);

                    if(callbackReturn instanceof Promise) {
                        callbackReturn = await callbackReturn
                    }

                    value = this.typeCast(callbackReturn);

                    PropertyCache.setCachedProperty(uuid+"."+this.name, value);

                    VarvPerformance.stop("Property.getValue.nonCached", mark);

                    resolve(value);

                    return;
                } catch(e) {
                    //console.warn("Something went wrong (Using Default):", e);

                    // Return default value, if no callback returns a value
                }
            }

            VarvPerformance.stop("Property.getValue.defaultValue", mark);

            resolve(this.getDefaultValue());
        });
    }

    getDefaultValue() {
        if(this.options.default != null) {
            return this.options.default;
        }

        switch(this.type) {
            case "string":
                return "";
            case "number":
                return 0;
            case "boolean":
                return false;
            case "array":
                return [];
            default:
                if(VarvEngine.getConceptFromType(this.type) != null) {
                    return null;
                }

                console.warn("Unknown type for default value:", this.type);
        }
    }

    async stateChanged(uuid, value) {
        let mark = VarvPerformance.start();
        await Trigger.trigger("stateChanged", {
            target: uuid,
            property: this.name,
            variables: {
                "currentValue": value,
                "property": this.name
            }
        });
        VarvPerformance.stop("Property.event.stateChanged", mark);
    }

    isSame(value1, value2) {
        switch(this.type) {
            case "number":
            case "string":
            case "boolean":
                return value1 === value2;

            case "array": {
                if(value1 == null) {
                    return value2 == null;
                }

                if(value2 == null) {
                    return value1 == null;
                }

                //Check if values are no match
                if(value1.length !== value2.length) {
                    return false;
                }

                //Check each entry
                for(let i = 0; i<value1.length; i++) {
                    if(value1[i] !== value2[i]) {
                        return false;
                    }
                }

                return true;
            }

            default: {
                if(this.isConceptType()) {
                    return value1 === value2;
                }

                throw new Error("["+this.name+": "+this.type+"] Unable to check isSame of ["+value1+"] and ["+value2+"]");
            }
        }
    }
}
Property.DEBUG = false;
window.Property = Property;

</SCRIPT><SCRIPT id="PropertyCache-script" type="disabled">


class PropertyCache {
    static getCachedProperty(lookupKey) {
        if(PropertyCache.cacheEnabled) {
            let value = PropertyCache.cacheMap.get(lookupKey);

            if(PropertyCache.DEBUG) {
                console.groupCollapsed("PropertyCache getting: ", lookupKey, value);
                console.trace();
                console.groupEnd();
            }

            return value;
        } else {
            return null;
        }
    }

    static removeCachedProperty(lookupKey) {
        if(PropertyCache.DEBUG) {
            console.log("PropertyCache deleting: ", lookupKey);
        }
        PropertyCache.cacheMap.delete(lookupKey);
    }

    static setCachedProperty(lookupKey, value) {
        if(PropertyCache.DEBUG) {
            console.log("PropertyCache setting: ", lookupKey, value);
        }
        PropertyCache.cacheMap.set(lookupKey, value);
    }

    static reset() {
        PropertyCache.cacheMap.clear();
    }
}
PropertyCache.DEBUG = false;
PropertyCache.cacheEnabled = true;
PropertyCache.cacheMap = new Map();
window.PropertyCache = PropertyCache;

</SCRIPT><SCRIPT id="Datastore-script" type="disabled">
/**
 *  DataStore - Superclass for all backing stores
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * Datastores
 * @namespace Datastores
 */

// superclass for all datastores (mostly empty for potential later introspection code)
class Datastore {
    constructor(name, options){
        this.name = name;
        this.options = options;
        this.mappedConcepts = new Map();
    }

    isConceptMapped(concept){
        return this.isConceptTypeMapped(concept.name);
    }
    isConceptTypeMapped(conceptTypeName){
        return this.mappedConcepts.has(conceptTypeName);
    }
    isPropertyMapped(concept, property){
        if (!this.isConceptMapped(concept)) return false;
        return this.mappedConcepts.get(concept.name).has(property.name);
    }
    isPropertyNameMapped(conceptName, propertyName){
        if (!this.isConceptMapped(concept)) return false;
        return this.mappedConcepts.get(conceptName).has(propertyName);
    }
    internalAddConceptMapping(concept){
        if (!this.isConceptMapped(concept))
            this.mappedConcepts.set(concept.name, new Map());
    }
    internalAddPropertyMapping(concept, property, trackingData={}){
        if (this.isPropertyMapped(concept, property)){
            throw new Error('Already has internal mapping for '+concept+"."+property);
        }
        this.internalAddConceptMapping(concept);
        let propertyMap = this.mappedConcepts.get(concept.name);
        propertyMap.set(property.name, trackingData);
    }
    internalRemovePropertyMapping(concept, property){
        if (!this.isConceptMapped(concept)) throw new Error("Concept not mapped when trying to remove "+concept+"."+property);
        let propertyMap = this.mappedConcepts.get(concept.name);
        propertyMap.delete(property.name);
    }

    internalPropertyTrackingData(concept, property){
        return this.mappedConcepts.get(concept.name).get(property.name);
    }

    createBackingStore(concept, property) {
        throw new Error("createBackingStore, should always be overridden in Datastore subclass - "+this.constructor.name);
    }

    removeBackingStore(concept, property) {
        throw new Error("removeBackingStore, should always be overridden in Datastore subclass - "+this.constructor.name);
    }

    isShared() {
        return true;
    }

    async init() {
        throw new Error("init, should always be overridden in Datastore subclass - "+this.constructor.name);
    }

    destroy() {
        throw new Error("destroy, should always be overridden in Datastore subclass - "+this.constructor.name);
    }

    /**
     *
     * @param {String[]} typeNames
     * @param {Filter} query
     * @param {VarvContext} context
     * @param {number} limit
     * @param {Concept} localConcept
     * @returns {Promise<String[]>}
     */
    async lookupInstances(typeNames, query, context, limit = 0, localConcept = null) {
        throw new Error("Implement [lookupInstances] me in sub datastores! - "+this.constructor.name);
    }

    /**
     * @param {String[]} typeNames
     * @param {Filter} query
     * @param {VarvContext} context
     * @param {Concept} localConcept
     * @returns {Promise<number>}
     */
    async countInstances(typeNames, query, context, localConcept) {
        throw new Error("Implement [countInstances] me in sub datastores! - "+this.constructor.name);
    }

    /**
     * @param {String[]} typeNames
     * @param {Filter} query
     * @param {VarvContext} context
     * @param {Concept} localConcept
     * @returns {Promise<boolean>}
     */
    async existsInstance(typeNames, query, context, localConcept) {
        throw new Error("Implement [existsInstance] me in sub datastores! - "+this.constructor.name);
    }

    /**
     *
     * @param {String} uuid
     * @returns {Promise<Concept>}
     */
    async lookupConcept(uuid) {
        throw new Error("Implement [lookupConcept] me in sub datastores! - "+this.constructor.name);
    }

    static getDatastoreFromName(name) {
        return Datastore.datastores.get(name);
    }

    static registerDatastoreType(name, datastoreType) {
        Datastore.datastoreTypes.set(name, datastoreType);
    }

    static getDatastoreType(name) {
        return Datastore.datastoreTypes.get(name);
    }

    static getAllDatastores() {
        return Array.from(Datastore.datastores.values());
    }
}
Datastore.DEBUG = false;
Datastore.datastores = new Map();
Datastore.datastoreTypes = new Map();

window.Datastore = Datastore;

</SCRIPT><SCRIPT id="DirectDatastore-script" type="disabled">
class DirectDatastore extends Datastore {
    constructor(name, options) {
        super(name, options);

        this.conceptUUIDMap = new Map();
        this.conceptTypeUUIDMap = new Map();
    }

    registerConceptFromUUID(uuid, concept) {
        if(this.isConceptMapped(concept)) {
            this.conceptUUIDMap.set(uuid, concept);

            let uuidSet = this.conceptTypeUUIDMap.get(concept.name);
            if (uuidSet == null) {
                uuidSet = new Set();
                this.conceptTypeUUIDMap.set(concept.name, uuidSet);
            }

            uuidSet.add(uuid);
        }
    }

    deregisterConceptFromType(type) {
        const self = this;

        this.getAllUUIDsFromType(type).forEach((uuid)=>{
            self.deregisterConceptFromUUID(uuid);
        });
    }

    deregisterConceptFromUUID(uuid) {
        let concept = this.getConceptFromUUID(uuid);
        this.conceptUUIDMap.delete(uuid);
        if(concept != null) {
            let uuidSet = this.conceptTypeUUIDMap.get(concept.name);
            if (uuidSet != null) {
                uuidSet.delete(uuid);
            }
        }
    }

    getConceptFromUUID(uuid) {
        return this.conceptUUIDMap.get(uuid);
    }

    getAllUUIDsFromType(type, includeOtherConcepts = false) {
        const self = this;

        let uuidSet = null;
        if(!includeOtherConcepts) {
            uuidSet = this.conceptTypeUUIDMap.get(type);
        } else {
            uuidSet = new Set();
            VarvEngine.getAllImplementingConcepts(type).forEach((concept)=>{
                self.getAllUUIDsFromType(concept.name, false).forEach((uuid)=>{
                    uuidSet.add(uuid);
                });
            });
        }
        if (uuidSet == null) {
            return [];
        }
        return Array.from(uuidSet);
    }

    async countInstances(typeNames, query, context, localConcept) {
        let uuids = await this.lookupInstances(typeNames, query, context, 0, localConcept);
        return uuids.length;
    }

    async existsInstance(typeNames, query, context, localConcept) {
        let uuids = await this.lookupInstances(typeNames, query, context, 1, localConcept);
        return uuids.length > 0;
    }

    async lookupInstances(typeNames, query, context, limit, localConcept) {
        const self = this;

        let uuidSet = new Set();

        let markStart = VarvPerformance.start();

        typeNames.forEach((type)=>{
            self.getAllUUIDsFromType(type, false).forEach((uuid)=>{
                uuidSet.add(uuid);
            });
        });

        VarvPerformance.stop("DirectDatastore.lookupInstances.getAll", markStart);

        let result = [];

        if(query != null) {
            let markFilter = VarvPerformance.start();
            let allPromises = [];
            for(let uuid of uuidSet) {
                allPromises.push(query.filter({target: uuid}, localConcept));
            }

            let filterResult = await Promise.all(allPromises);

            let index = 0;
            for(let uuid of uuidSet) {
                if (filterResult[index]) {
                    result.push(uuid);
                }
                index++;
            }

            VarvPerformance.stop("DirectDatastore.lookupInstances.filter", markFilter);
        } else {
            result.push(...uuidSet);
        }

        if(limit > 0 && result.length > limit) {
            result.splice(limit, result.length-limit);
        }

        VarvPerformance.stop("DirectDatastore.lookupInstances", markStart);

        return result;
    }

    async lookupConcept(uuid) {
        let result = this.getConceptFromUUID(uuid);

        if(result == null) {
            throw Error("Unable to find concept from uuid: "+uuid);
        }

        return result;
    }
}
window.DirectDatastore = DirectDatastore;

</SCRIPT><SCRIPT id="Trigger-script" type="disabled">
/**
 *  Trigger - Superclass for all triggers
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * Triggers are used to do something when something happens
 * @namespace Triggers
 */

const VarvEventPrefix = "VarvEvent.";
let triggeringEnabled = true;

class Trigger {
    /**
     * Create a new trigger
     * @param {string} name - The name of this trigger
     * @param {object|string} options - The options of this trigger
     * @param {Concept} concept - The owning concept of this trigger
     */
    constructor(name, options, concept) {
        this.options = options;
        this.name = name;
        this.concept = concept;
    }

    /**
     * Destroy this trigger
     * @param {Concept} concept - The concept this trigger is registered on
     */
    destroy() {
        //Default implementation just disabled the trigger
        this.disable();
    }

    /**
     * Enable this trigger
     */
    enable() {
        console.warn("Always override Trigger.enable in subclass!");
    }

    /**
     * Disable this trigger
     */
    disable() {
        console.warn("Always override Trigger.disable in subclass!");
    }

    /**
     * Register a new type of trigger
     * @param {string} type - The type of trigger to register
     * @param {Trigger} trigger - The trigger to register
     */
    static registerTrigger(type, trigger) {
        Trigger.triggers.set(type, trigger);
    }

    /**
     * Checks if the given type corresponds to a trigger type
     * @param {tring} type the type to check
     * @returns {boolean} true/false depending on if type was a trigger type
     */
    static isTriggerType(type) {
        return Trigger.triggers.has(type);
    }

    /**
     * Create a new named instance of the given trigger type, using the given options
     * @param {string} type - The type of trigger to create
     * @param {string} name - The name to give the trigger
     * @param {object} options - The options to pass along to the trigger
     * @returns {Trigger} - The newly created trigger
     */
    static getTrigger(type, name, options, concept) {
        let triggerClass = Trigger.triggers.get(type);

        if (triggerClass == null) {
            throw new Error("Unknown trigger [" + type + "]");
        }

        return new triggerClass(name, options, concept);
    }

    static registerTriggerEvent(triggerName, callback) {
        return EventSystem.registerEventCallback(VarvEventPrefix+triggerName, async (evt)=>{
            let contexts = Action.clone(evt.detail);

            let callbackReturn = callback(contexts);

            if(callbackReturn instanceof Promise) {
                await callbackReturn;
            }
        });
    }

    static async trigger(triggerName, context) {
        const mark = VarvPerformance.start();
        if(!triggeringEnabled) {
            if(Trigger.DEBUG) {
                console.log("Skipping (Triggering Disabled):", triggerName, context);
            }
            return;
        }

        if(!Array.isArray(context)) {
            context = [context];
        }

        if(Trigger.DEBUG) {
            console.group("Triggering:", triggerName, Action.clone(context));
        }

        try {
            await EventSystem.triggerEventAsync(VarvEventPrefix + triggerName, context);
            VarvPerformance.stop("Trigger-"+triggerName, mark);
        } catch(e) {
            VarvPerformance.stop("Trigger-"+triggerName, mark);
            throw e;
        }

        if(Trigger.DEBUG) {
            console.groupEnd();
        }
    }

    static async runWithoutTriggers(method) {
        triggeringEnabled = false;
        await method();
        triggeringEnabled = true;
    }
}
Trigger.DEBUG = false;
Trigger.triggers = new Map();
window.Trigger = Trigger;

</SCRIPT><SCRIPT id="Filter-script" type="disabled">
/**
 *  Filter - Filtering functionality
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

window.FilterOps = Object.freeze({
    "equals": "equals",
    "unequals": "unequals",
    "greaterThan": "greaterThan",
    "lessThan": "lessThan",
    "greaterOrEquals": "greaterOrEquals",
    "lessOrEquals": "lessOrEquals",
    "startsWith": "startsWith",
    "endsWith": "endsWith",
    "includes": "includes",
    "includesAny": "includesAny",
    "includesAll": "includesAll",
    "matches": "matches",
    "hasProperty": "hasProperty",
    "propertyType": "propertyType"
});

class Filter {
    /**
     * @param {VarvContext} context - The context to filter
     * @param {Concept} localConcept - The local concept
     * @returns {Promise<boolean>} - Returns true if the given context should be kept, false if it should be discarded
     */
    async filter(context, localConcept, assert=false) {
        console.warn("Should override 'filter' in subclass");
        return false;
    }

    /**
     * Filter based on the given values and operator
     * @param {any} value
     * @param {any} compareValue
     * @param {FilterOps} op
     * @returns {boolean}
     */
    static filterValue(value, compareValue, op, assert = false) {
        let pass = false;

        let markStart = VarvPerformance.start();

        if(value == null) {
            switch(op) {
                case FilterOps.equals: {
                    pass = value === compareValue;
                    break;
                }
                case FilterOps.unequals: {
                    pass = value !== compareValue;
                    break;
                }

                default: {
                    console.warn("Filtering with "+op+" on null, is not possible, resulting in false");
                    pass = false;
                }
            }
        } else {
            switch (op) {
                case FilterOps.equals: {
                    if(Array.isArray(value) && Array.isArray(compareValue)) {
                        pass = JSON.stringify(value) === JSON.stringify(compareValue);
                    } else {
                        pass = value === compareValue;
                    }
                    break;
                }
                case FilterOps.unequals: {
                    if(Array.isArray(value) && Array.isArray(compareValue)) {
                        pass = JSON.stringify(value) !== JSON.stringify(compareValue);
                    } else {
                        pass = value !== compareValue;
                    }
                    break;
                }
                case FilterOps.matches: {
                    let regexp = new RegExp(compareValue);
                    pass = value.match(regexp) !== null;
                    break;
                }
                case FilterOps.greaterThan: {
                    pass = value > compareValue;
                    break;
                }
                case FilterOps.lessThan: {
                    pass = value < compareValue;
                    break;
                }
                case FilterOps.greaterOrEquals: {
                    pass = value >= compareValue;
                    break;
                }
                case FilterOps.lessOrEquals: {
                    pass = value <= compareValue;
                    break;
                }
                case FilterOps.startsWith: {
                    pass = value.startsWith(compareValue);
                    break;
                }
                case FilterOps.endsWith: {
                    pass = value.endsWith(compareValue);
                    break;
                }
                case FilterOps.includes: {
                    pass = value.indexOf(compareValue) !== -1;
                    break;
                }
                case FilterOps.includesAny: {
                    if (Array.isArray(compareValue)) {
                        pass = false;
                        for (let arrayValue of compareValue) {
                            if (value.indexOf(arrayValue) !== -1) {
                                pass = true;
                                break;
                            }
                        }
                    } else {
                        pass = value.indexOf(compareValue) !== -1;
                    }
                    break;
                }
                case FilterOps.includesAll: {
                    if (Array.isArray(compareValue)) {
                        pass = true;
                        for (let arrayValue of compareValue) {
                            pass = pass && value.indexOf(arrayValue) !== -1;
                        }
                    } else {
                        pass = value.indexOf(compareValue) !== -1;
                    }
                    break;
                }

                default:
                    VarvPerformance.stop("Filter.filterValue.Error", markStart);
                    throw new Error("Unknown op: " + op);
            }
        }

        if(assert === true || assert > 1) {
            if(assert > 1 && assert % 2 == 0) {
                console.assert(!pass, "NOT: Value: ",value," should not be ",op.toString(),compareValue);
            } else {
                console.assert(pass, "Value: ",value," should be ",op.toString(),compareValue);
            }
        }

        VarvPerformance.stop("Filter.filterValue", markStart);

        return pass;
    }
}

/**
 * Filter based on a property
 *
 * @example
 * //Filter based on property "myProperty" being equal to "someValue"
 * {
 *     "property": "myProperty",
 *     "equals": "someValue"
 * }
 * @example
 * //Filter based on string property "myProperty" starting with "someValue"
 * {
 *     "property": "myProperty",
 *     "startsWith": "someValue"
 * }
 */
class FilterProperty extends Filter {
    /**
     *
     * @param {string} property The property to filter on
     * @param {FilterOps} op The operator to use
     * @param {any} value The value to compare to
     */
    constructor(property, op, value) {
        super();

        this.property = property;
        this.op = op;
        this.value = value;
    }

    /**
     *
     * @param {FilterOps} filterOp - The filter op to get allowed types from
     * @returns {string[]} - An array of allowed types
     */
    allowedTypes() {
        switch(this.op) {
            case FilterOps.equals: {
                return ["boolean", "number", "string", "concept", "array"];
            }
            case FilterOps.matches: {
                return ["string"];
            }
            case FilterOps.unequals: {
                return ["boolean", "number", "string", "concept", "array"];
            }
            case FilterOps.greaterThan: {
                return ["number", "string"];
            }
            case FilterOps.lessThan: {
                return ["number", "string"];
            }
            case FilterOps.greaterOrEquals: {
                return ["number", "string"];
            }
            case FilterOps.lessOrEquals: {
                return ["number", "string"];
            }
            case FilterOps.startsWith: {
                return ["string"];
            }
            case FilterOps.endsWith: {
                return ["string"];
            }
            case FilterOps.includes: {
                return ["string", "array"];
            }
            case FilterOps.includesAny: {
                return ["array"];
            }
            case FilterOps.includesAll: {
                return ["array"];
            }
        }
    }

    prepare(lookup){
        if(lookup === null) {
            throw new Error("No property ["+this.property+"] found!");
        }

        let property = lookup.property;
        let type = property.type;
        if(property.isConceptType()) {
            type = "concept";
        }

        if(!this.allowedTypes().includes(type)) {
            throw new Error("Op ["+this.op+"] does not work on property type ["+property.type+"] from property ["+property.name+"]");
        }

        return {concept:lookup.concept, property:property, target:lookup.target, type:type};
    }

    async filter(context, localConcept, assert) {
        let markStart = VarvPerformance.start();

        let lookupProperty = await VarvEngine.lookupProperty(context.target, localConcept, this.property)

        let lookup = this.prepare(lookupProperty);
        let value = await lookup.property.getValue(lookup.target);

        let typeCastedValue = this.value;
        try {
            //TODO: Not sure if we should typecast here?
            typeCastedValue = lookup.property.typeCast(this.value);
        } catch(e) {
            //Ignore
        }

        let result = Filter.filterValue(value, typeCastedValue, this.op, assert);

        VarvPerformance.stop("FilterProperty.filter", markStart);

        return result;
    }
}
window.FilterProperty = FilterProperty;

/**
 * Filter based on a variable
 *
 * @example
 * //Filter based on variable "myVariable" being equal to "someValue"
 * {
 *     "variable": "myVariable",
 *     "equals": "someValue"
 * }
 * @example
 * //Filter based on string variable "myVariable" starting with "someValue"
 * {
 *     "variable": "myVariable",
 *     "startsWith": "someValue"
 * }
 */
class FilterVariable extends Filter {
    /**
     *
     * @param {string} variable The variable to filter on
     * @param {FilterOps} op The operator to use
     * @param {any} value The value to compare to
     */
    constructor(variable, op, value) {
        super();

        this.variable = variable;
        this.op = op;
        this.value = value;
    }

    /**
     * @returns {string[]} - An array of allowed types
     */
    allowedTypes() {
        switch(this.op) {
            case FilterOps.equals: {
                return ["boolean", "number", "string", "array"];
            }
            case FilterOps.matches: {
                return ["string"];
            }
            case FilterOps.unequals: {
                return ["boolean", "number", "string", "array"];
            }
            case FilterOps.greaterThan: {
                return ["number", "string"];
            }
            case FilterOps.lessThan: {
                return ["number", "string"];
            }
            case FilterOps.greaterOrEquals: {
                return ["number", "string"];
            }
            case FilterOps.lessOrEquals: {
                return ["number", "string"];
            }
            case FilterOps.startsWith: {
                return ["string"];
            }
            case FilterOps.endsWith: {
                return ["string"];
            }
            case FilterOps.includes: {
                return ["string", "array"];
            }
            case FilterOps.includesAny: {
                return ["array"];
            }
            case FilterOps.includesAll: {
                return ["array"];
            }
        }
    }

    async filter(context, localConcept, assert) {
        let markStart = VarvPerformance.start();

        let variableValue = Action.getVariable(context, this.variable);

        let type = typeof variableValue;

        if(Array.isArray(variableValue)) {
            type = "array";
        }

        if(!this.allowedTypes().includes(type)) {
            VarvPerformance.stop("FilterVariable.filter.Error", markStart);
            throw new Error("Op ["+this.op+"] does not work on variable with value type ["+type+"] from variable ["+this.variable+"]");
        }

        let result = Filter.filterValue(variableValue, this.value, this.op, assert);

        VarvPerformance.stop("FilterVariable.filter", markStart);

        return result;
    }
}
window.FilterVariable = FilterVariable;

class FilterValue extends Filter {
    /**
     *
     * @param {FilterOps} op
     * @param {any} value
     */
    constructor(op, value) {
        super();

        this.op = op;
        this.value = value;
    }

    /**
     * @returns {string[]} - An array of allowed types
     */
    allowedTypes() {
        switch(this.op) {
            case FilterOps.equals: {
                return ["boolean", "number", "string", "array"];
            }
            case FilterOps.matches: {
                return ["string"];
            }
            case FilterOps.unequals: {
                return ["boolean", "number", "string", "array"];
            }
            case FilterOps.greaterThan: {
                return ["number", "string"];
            }
            case FilterOps.lessThan: {
                return ["number", "string"];
            }
            case FilterOps.greaterOrEquals: {
                return ["number", "string"];
            }
            case FilterOps.lessOrEquals: {
                return ["number", "string"];
            }
            case FilterOps.startsWith: {
                return ["string"];
            }
            case FilterOps.endsWith: {
                return ["string"];
            }
            case FilterOps.includes: {
                return ["string", "array"];
            }
            case FilterOps.includesAny: {
                return ["array"];
            }
            case FilterOps.includesAll: {
                return ["array"];
            }
        }
    }

    async filter(value, localConcept, assert) {
        let markStart = VarvPerformance.start();

        let type = typeof value;

        if(Array.isArray(value)) {
            type = "array";
        }

        if(!this.allowedTypes().includes(type)) {
            VarvPerformance.stop("FilterValue.filter.Error", markStart);
            throw new Error("This operator ["+this.op+"] does not allow value type ["+type+"]");
        }

        let result = Filter.filterValue(value, this.value, this.op, assert);

        VarvPerformance.stop("FilterValue.filter", markStart);

        return result;
    }
}
window.FilterValue = FilterValue;

/**
 * Filters based on concept
 *
 * @example
 * //Filter concepts that are not of type "myConceptType", including inherited concepts
 * {
 *     "concept": "myConceptType",
 *     "includeOthers": true
 * }
 *
 * //Filter concepts that are not of type "myConceptType", excluding inherited concepts
 * {
 *     "concept": "myConceptType",
 *     "includeOthers": false
 * }
 */
class FilterConcept extends Filter {
    constructor(conceptName, includeOthers=true) {
        super();

        this.includeOthers = includeOthers;
        this.conceptName = conceptName;
    }

    async filter(context, localConcept, assert) {
        let markStart = VarvPerformance.start();

        let concept = await VarvEngine.getConceptFromUUID(context.target);

        if(concept == null) {
            return false;
        }

        let pass = false;

        if (this.includeOthers){
            // Check if concept.name or any otherConcept is correct
            pass = concept.isA(this.conceptName);
        } else {
            pass = concept.name === this.conceptName;
        }

        if(assert === true || assert > 1) {
            if(assert > 1 && assert % 2 == 0) {
                //Negated assert?
                console.assert(!pass, "NOT: Concept: "+concept.name+" is a "+this.conceptName+" when it should not be!");
            } else {
                //Normal assert
                console.assert(pass, "Concept: "+concept.name+" is not a "+this.conceptName+" when it should have been!");
            }
        }

        VarvPerformance.stop("FilterConcept.filter", markStart);

        return pass;
    }
}
window.FilterConcept = FilterConcept;

/**
 * Filter based on multiple other filters, if any filter passes, this passes
 *
 * @example
 * {
 *     "or": [
 *         {"property": "myProperty", "equals": "someValue"},
 *         {"property": "myProperty", "equals": "someOtherValue"},
 *     ]
 * }
 */
class FilterOr extends Filter {
    constructor(filters) {
        super();

        this.filters = filters;
    }

    async filter(context, localConcept, assert) {
        let markStart = VarvPerformance.start();

        let pass = false;

        let promises = [];

        for(let filter of this.filters) {
            promises.push(filter.filter(context, localConcept, assert));
        }

        let filterResult = await Promise.all(promises);
        for(let result of filterResult) {
            pass = pass || result;
        }

        VarvPerformance.stop("FilterOr.filter", markStart);

        return pass;
    }
}
window.FilterOr = FilterOr;

/**
 * Filter based on multiple other filters, if all filter passes, this passes
 *
 * @example
 * {
 *     "and": [
 *         {"property": "myProperty", "equals": "someValue"},
 *         {"property": "myProperty", "equals": "someOtherValue"},
 *     ]
 * }
 */
class FilterAnd extends Filter {
    constructor(filters) {
        super();

        this.filters = filters;
    }

    async filter(context, localConcept, assert) {
        let markStart = VarvPerformance.start();

        let pass = true;

        let promises = [];

        for(let filter of this.filters) {
            promises.push(filter.filter(context, localConcept, assert));
        }

        let filterResult = await Promise.all(promises);
        for(let result of filterResult) {
            pass = pass && result;
        }

        VarvPerformance.stop("FilterAnd.filter", markStart);

        return pass;
    }
}
window.FilterAnd = FilterAnd;

/**
 * Filter based on other filter, if the other filter passes, this does not, and vice versa
 *
 * @example
 * {
 *     "not": {"property": "myProperty", "equals": "someValue"}
 * }
 */
class FilterNot extends Filter {
    constructor(filter) {
        super();

        this.notFilter = filter;
    }

    async filter(context, localConcept, assert) {

        let markStart = VarvPerformance.start();

        if(assert === true) {
            assert = 1;
        }

        let pass = ! (await this.notFilter.filter(context, localConcept, assert?(assert+1):false));

        VarvPerformance.stop("FilterNot.filter", markStart);

        return pass;
    }
}
window.FilterNot = FilterNot;

/**
 * Filter based on some calculation
 *
 * @example
 * {
 *     "calculation": "10 + $someVariable$ + $someProperty$",
 *     "equals": 1010
 * }
 */
class FilterCalc extends Filter {
    constructor(calculation, operator, value) {
        super();

        this.valueFilter = new FilterValue(operator, value);
        this.calculation = calculation;
    }

    async filter(context, localConcept, assert) {
        let markStart = VarvPerformance.start();

        let result = math.evaluate(this.calculation);

        let pass = await this.valueFilter.filter(result, localConcept, assert);

        VarvPerformance.stop("FilterCalc.filter", markStart);

        return pass;
    }
}

window.FilterCalc = FilterCalc;

/**
 * Filters based on if concept has a property or not
 *
 * @example
 * {
 *     "hasProperty": "somePropertyName"
 * }
 */
class FilterPropertyExists extends Filter {
    constructor(property) {
        super();

        this.property = property;
    }

    async filter(context, localConcept, assert) {
        let markStart = VarvPerformance.start();

        let pass = true;

        try {
            let concept = await VarvEngine.getConceptFromUUID(context.target);
            concept.getProperty(this.property);
        } catch(e) {
            //Silent fail, but mark that we saw no property
            pass = false;
        }

        VarvPerformance.stop("FilterPropertyExists.filter", markStart);

        return pass;
    }
}
window.FilterPropertyExists = FilterPropertyExists;

/**
 * Filters based on property type
 *
 * @example
 * //Filter all where property "myProperty" is not of type "string" or "number"
 * {
 *     "property": "myProperty",
 *     "propertyType": ["number", "string"]
 * }
 *
 * @example
 * //Filter all where property "myProperty" is not of type "concept" or "concept[]"
 * {
 *     "property": "myProperty",
 *     "propertyType": ["array[concept]", "concept"]
 * }
 */

class FilterPropertyType extends Filter {
    constructor(property, types) {
        super();

        this.property = property;
        this.types = types;

        if(!Array.isArray(this.types)) {
            this.types = [this.types];
        }
    }

    async filter(context, localConcept, assert) {
        let markStart = VarvPerformance.start();

        let pass = false;

        try {
            let concept = await VarvEngine.getConceptFromUUID(context.target);
            let property = concept.getProperty(this.property);

            let type = property.getFullTypeString();

            if(Array.isArray(type)) {
                for(let t of type) {
                    if(this.types.includes(t)) {
                        pass = true;
                        break;
                    }
                }
            } else {
                pass = this.types.includes(type);
            }
        } catch(e) {
            //Silent ignore
        }

        VarvPerformance.stop("FilterPropertyType.filter", markStart);

        return pass;
    }
}
window.FilterPropertyType = FilterPropertyType;

</SCRIPT><SCRIPT id="Action-script" type="disabled">
/**
 *  Action - The super class for all Actions
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * A context in Varv
 * @typedef {object} VarvContext
 * @property {string} [target] - The UUID of the target this context refers to
 * @property {object} [variables] - The variables currently set to any value
 */

/**
 * Base class for all actions
 */
class Action {
    /**
     * Crate a new Action
     * @param {string} name - The name of the action
     * @param {object} options - The options of the action
     * @param {Concept} concept - The owning concept
     */
    constructor(name, options, concept) {
        this.name = name;
        this.options = options;
        this.concept = concept;

        if(this.options == null) {
            this.options = {};
        }
    }

    /**
     * Applies this Action to the given contexts, returning some resulting contexts
     * @param {VarvContext[]} contexts
     * @param {object} arguments
     * @returns {Promise<VarvContext[]>}
     */
    async apply(contexts, actionArguments = {}) {
        console.warn("Always override Action.apply in subclass!");
        return contexts;
    }

    /**
     * @callback forEachCallback
     * @param {VarvContext} context - The context currently being looked at
     * @param {object} options - The current options with variables and arguments substituted
     * @param {number} index - The index of the current context in the context array
     * @returns {VarvContext|VarvContext[]}
     */

    /**
     * Loops through the given contexts, and calls the given callback for each, complete with substituted options and the index of the context
     * @param {VarvContext[]} contexts - The contexts to handle
     * @param {object} actionArguments - The arguments to use for this action
     * @param {forEachCallback} callback - The callback to call for each context
     * @returns {Promise<VarvContext[]>}
     */
    async forEachContext(contexts, actionArguments={}, callback) {
        if(arguments.length < 2) {
            throw new Error("forEachContext can be called either as (contexts, actionArguments, callback) or (contexts, callback)");
        }

        //If called with 2 arguments options is the callback
        if(arguments.length === 2) {
            if(typeof actionArguments !== "function") {
                throw new Error("forEachContext can be called either as (contexts, actionArguments, callback) or (contexts, callback)");
            }

            // noinspection JSValidateTypes
            callback = actionArguments;
            actionArguments = {};
        }

        let results = [];

        let index = 0;

        let options = await Action.lookupArguments(this.options, actionArguments);

        for (let context of contexts) {
            //Make sure to clone context, since we change it directly, thus variables might be a shared object if not.
            let clonedContext = Action.cloneContext(context);

            let optionsWithVariables = await Action.lookupVariables(options, clonedContext);

            let result = await callback(clonedContext, optionsWithVariables, index);

            if (result != null) {
                if (Array.isArray(result)) {
                    result.forEach((entry) => {
                        results.push(entry);
                    });
                } else {
                    results.push(result);
                }
            }

            index++;
        }

        return results;
    }

    /**
     * Get the default variable name, for when no variable name is supplied
     * @param {Action} - The action asking, the name of the action is used.
     * @returns {string} - The default variable name
     */
    static defaultVariableName(action) {
        if(action == null) {
            return "result";
        }

        return action.name;
    }

    /**
     * Sets the given variable to the given value, in the given context
     * @param {VarvContext} context - The context to set the variable inside
     * @param {string} name - The name of the variable to set
     * @param {any} value - The value to set
     */
    static setVariable(context, name, value) {
        if(context.variables == null) {
            context.variables = {}
        }

        if(name === "target") {
            console.warn("Unable to set variable target!");
            return;
        }

        context.variables[name] = value;
    }

    /**
     * Retrieve the value of the given variable from the given context
     * @param {VarvContext} context
     * @param {string} name
     * @returns {any}
     */
    static getVariable(context, name) {
        if(name === "target" && context.target != null) {
            //If context.target exists use that, if not, check variables as getCommonVariables might have saved a common target
            return context.target;
        }

        if(name === "lastTarget" && context.lastTarget != null) {
            //If context.lastTarget exists use that
            return context.lastTarget;
        }

        if(context.variables == null) {
            context.variables = {}
        }

        if(!context.variables.hasOwnProperty(name)) {
            if(name === "target") {
                throw new Error("Context did not contain target, and no variable target existed either!");
            }

            throw new Error("No named variable ["+name+"]");
        }

        return context.variables[name];
    }

    /**
     * Extract all the variables that have the same value across all contexts
     * @param contexts
     * @returns {{}}
     */
    static getCommonVariables(contexts) {
        let common = {};

        let mark = VarvPerformance.start();

        if(contexts.length > 0) {
            let testContext = contexts[0];

            if(testContext.variables != null) {
                Object.keys(testContext.variables).forEach((variableName)=>{
                    let variableValue = testContext.variables[variableName];
                    let keep = true;

                    for(let otherContext of contexts) {
                        if(otherContext.variables != null) {
                            let otherValue = otherContext.variables[variableName];

                            if(otherValue != null && otherValue === variableValue) {
                                continue;
                            }

                            if(Array.isArray(otherValue) && Array.isArray(variableValue)) {
                                if(otherValue.length === variableValue.length) {
                                    let arrayEqual = true;
                                    for(let i = 0; i<otherValue.length; i++) {
                                        arrayEqual = arrayEqual && otherValue[i] === variableValue[i];
                                    }

                                    if(arrayEqual) {
                                        continue;
                                    }
                                }
                            }
                        }

                        keep = false;
                        break;
                    }

                    if(keep) {
                        common[variableName] = variableValue;
                    }
                });
            }

            if(testContext.target != null) {
                let keep = true;
                for(let otherContext of contexts) {
                    if (otherContext.target != testContext.target) {
                        keep = false;
                        break;
                    }
                }

                if(keep) {
                    common["target"] = testContext.target;
                }
            }
        } else {
            if(contexts.savedVariables) {
                return contexts.savedVariables;
            }
        }

        VarvPerformance.stop("Action.getCommonVariables", mark, "#contexts "+contexts.length);

        return common;
    }

    static getCommonTarget(contexts) {
        let commonTarget = -1;
        contexts.forEach((context)=>{
            if(commonTarget === -1) {
                commonTarget = context.target;
            } else {
                if(commonTarget !== context.target) {
                    commonTarget = null;
                }
            }
        });
        return commonTarget;
    }

    /**
     * Looks up any options that are set to an argument replacement value "@myArgumentName" and replaces it with that arguments value
     * @param {object} options - The options to do the replacement on
     * @param {object} actionArguments - The arguments to replace into the options
     * @returns {object} A clone of the options argument, with all replacement values replaced
     */
    static async lookupArguments(options, actionArguments) {
        let mark = VarvPerformance.start();

        const optionsClone = Action.clone(options);

        let regex = /@(\S+?)(?:@|\s|$)/gm;

        for(let parameter in optionsClone) {
            if(!Object.hasOwn(optionsClone, parameter)) {
                continue;
            }

            let value = optionsClone[parameter];

            optionsClone[parameter] = await Action.subParam(value, (value)=>{
                if(!value.includes("@")) {
                    return value;
                }

                //Substitute any @argumentName with the value of the argument
                for(let match of value.matchAll(regex)) {
                    let search = match[0].trim();
                    let variableName = match[1];

                    let variableValue = actionArguments[variableName];

                    if(Action.DEBUG) {
                        console.log("Replaced argument:", search, variableValue, actionArguments, variableName);
                    }

                    if(value === search) {
                        //Single value, set it directly
                        value = variableValue;
                    } else {
                        //Replace into value
                        value = value.replace(search, variableValue);
                    }
                }

                return value;
            });

        }

        VarvPerformance.stop("Action.lookupArguments", mark, {options});

        return optionsClone;
    }

    static async subParam(value, lookupCallback) {
        if (Array.isArray(value)) {
            for (let i = 0; i < value.length; i++) {
                value[i] = await Action.subParam(value[i], lookupCallback);
            }
            return value;
        } else if (typeof value === "object" && value != null && Object.getPrototypeOf(value) === Object.prototype) {
            for(let key in value) {
                if(Object.hasOwn(value, key)) {
                    value[key] = await Action.subParam(value[key], lookupCallback);
                }
            }
            return value;
        } else if (typeof value === "string") {
            return lookupCallback(value);
        } else {
            return value;
        }
    }

    static clone(obj) {
        if(Array.isArray(obj)) {
            return obj.map((arrayValue)=>{
                return Action.clone(arrayValue);
            });
        } else if(typeof obj === "object" && obj != null && Object.getPrototypeOf(obj) === Object.prototype) {

            let clone = {};

            for (let key in obj) {
                if (!Object.hasOwn(obj, key)) {
                    continue;
                }

                clone[key] = Action.clone(obj[key]);
            }

            return clone;
        }

        return obj;
    }


    /**
     * Look up any options that have a variable replacement value "$myVariable" and replaces it with the value of that variable.
     * @param {object} options
     * @param {VarvContext} context
     * @returns {object} - Returns a clone of the given options, with all replacement values replaced.
     */
    static async lookupVariables(options, context) {
        if(Action.DEBUG) {
            console.group("Looking up variables from context:", options, context);
        }

        let mark = VarvPerformance.start();

        const optionsClone = Action.clone(options);

        async function doLookup(context, variableName) {
            let variableValue = null;

            if(variableName.indexOf(".") !== -1) {
                let split = variableName.split(".");

                //concept.property lookup, not really variable
                let conceptName = split[0];
                let propertyName = split[1];

                let result = null;

                if(conceptName === "lastTarget") {
                    result = await VarvEngine.lookupProperty(context.lastTarget, null, propertyName);
                } else if(conceptName === "target") {
                    result = await VarvEngine.lookupProperty(context.target, null, propertyName);
                } else {
                    result = await VarvEngine.lookupProperty(context.target, null, variableName);
                }

                if (result != null && result.target != null) {
                    variableValue = await result.property.getValue(result.target);
                }
            } else {
                variableValue = Action.getVariable(context, variableName);
            }

            return variableValue;
        }

        let regex = /\$(\S+?)(?:\$|\s|$)/gm;

        for(let key of Object.keys(optionsClone)) {
            optionsClone[key] = await Action.subParam(optionsClone[key], async (value)=>{
                if(!value.includes("$")) {
                    return value;
                }

                //Substitute any $VariableName with the value of the variable
                for(let match of value.matchAll(regex)) {
                    let search = match[0].trim();
                    let variableName = match[1];

                    let variableValue = await doLookup(context, variableName);

                    if(Action.DEBUG) {
                        console.log("Replaced variable:", search, variableValue);
                    }

                    if(value === search) {
                        //Single value, set it directly
                        value = variableValue;
                    } else {
                        //Replace into value
                        value = value.replace(search, variableValue);
                    }
                }

                return value;
            });
        }

        if(Action.DEBUG) {
            console.groupEnd();
        }

        VarvPerformance.stop("Action.lookupVariables", mark, {context, options});

        //Handle special stuff here
        Action.substituteEvery(optionsClone, "calculate", (value)=>{
            return CalculateAction.evaluate(value);
        });

        return optionsClone;
    }

    static substituteEvery(input, nameToSubstitute, callback) {
        if(Array.isArray(input)) {
            for(let i = 0; i< input.length; i++) {
                input[i] = Action.substituteEvery(input[i], nameToSubstitute, callback);
            }
        } else if(typeof input === "object") {
            for(let key in input) {
                if(input.hasOwnProperty(key)) {
                    if(key === nameToSubstitute) {
                        if(Object.keys(input).length > 1) {
                            console.warn("Substituting on something with more than 1 entry (Stuff will be lost):", input, nameToSubstitute);
                        }

                        let origValue = input[key];
                        return callback(origValue);
                    } else {
                        input[key] = Action.substituteEvery(input[key], nameToSubstitute, callback);
                    }
                }
            }
        }

        return input;
    }

    /**
     * Registers the given action as a primitive action with the given name
     * @param {string} name
     * @param {Action} action
     */
    static registerPrimitiveAction(name, action) {
        if(Action.DEBUG) {
            console.log("Registering primitive action:", name, action);
        }

        if (Action.primitiveActions.has(name)) {
            console.warn("Overriding primitive action: ", name);
        }

        Action.primitiveActions.set(name, action);
    }

    /**
     * Gets an instance of the primitive action with the given name, using the given options
     * @param {string} name
     * @param {object} options
     * @returns {Action}
     */
    static getPrimitiveAction(name, options, concept) {
        let actionClass = Action.primitiveActions.get(name);

        if (actionClass == null) {
            throw new Error("Unknown primitive action [" + name + "]");
        }

        let action = new actionClass(name, options, concept);

        action.isPrimitive = true;

        return action;
    }

    /**
     * Checks if a primitive action with the given name exists
     * @param {string} name
     * @returns {boolean}
     */
    static hasPrimitiveAction(name) {
        return Action.primitiveActions.has(name);
    }

    /**
     * Clones the given context. (Any non JSON serializable values in the context, will be lost)
     * @param {VarvContext} context
     * @returns {VarvContext} - The cloned context
     */
    static cloneContext(context) {
        let mark = VarvPerformance.start();

        let result = null;
        if(Array.isArray(context)) {
            result = context.map(Action.cloneContextInternal);
        } else {
            result = Action.cloneContextInternal(context);
        }

        VarvPerformance.stop("Action.cloneContext", mark);

        return result;
    }

    static cloneContextInternal(context) {
        //Move over allowed properties
        let preCloneObject = {};
        preCloneObject.variables = context.variables;
        preCloneObject.target = context.target;

        if(Action.DEBUG) {
            console.log("Cloning context:", context, preCloneObject);
        }
        return Action.clone(preCloneObject);
    }
}
Action.DEBUG = false;
Action.primitiveActions = new Map();
window.Action = Action;

class ActionChain extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);

        this.actions = [];
    }

    addAction(action) {
        const self = this;

        if(Array.isArray(action)) {
            action.forEach((actionElm)=>{
                self.actions.push(actionElm);
            })
        } else {
            this.actions.push(action);
        }
    }

    async apply(contexts, actionArguments = {}) {
        let currentContexts = contexts;

        for (let action of this.actions) {
            let commonVariablesBefore = Action.getCommonVariables(currentContexts);

            await ActionTrigger.before(action, currentContexts);
            let mark = VarvPerformance.start();
            currentContexts = await action.apply(currentContexts, actionArguments);
            if(action.isPrimitive) {
                VarvPerformance.stop("PrimitiveAction-"+action.name, mark);
            } else {
                VarvPerformance.stop("CustomAction-"+action.name, mark);
            }
            await ActionTrigger.after(action, currentContexts);

            if(currentContexts == null) {
                currentContexts = [];
            }

            if(currentContexts.length === 0) {
                currentContexts.savedVariables = commonVariablesBefore;
            }
        }

        return currentContexts;
    }
}

window.ActionChain = ActionChain;

class LookupActionAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments = {}) {
        const self = this;

        let optionsWithArguments = await Action.lookupArguments(this.options, actionArguments);

        if(optionsWithArguments.lookupActionName == null) {
            throw new Error("[LookupActionAction] Missing option 'lookupActionName'");
        }

        //TODO: We assume that all concepts are of the same type, when/if polymorphism is introduced this breaks
        let contextConcept = null;
        if(contexts.length > 0) {
            contextConcept = await VarvEngine.getConceptFromUUID(contexts[0].target);
        }

        let action = VarvEngine.lookupAction(optionsWithArguments.lookupActionName, [contextConcept, self.concept], optionsWithArguments.lookupActionArguments);

        if(action != null) {
            await ActionTrigger.before(action, contexts);
            let mark = VarvPerformance.start();
            let lookupActionResult = await action.apply(contexts, action.isPrimitive?{}:optionsWithArguments.lookupActionArguments);
            if(action.isPrimitive) {
                VarvPerformance.stop("PrimitiveAction-"+action.name, mark);
            } else {
                VarvPerformance.stop("CustomAction-"+action.name, mark);
            }
            await ActionTrigger.after(action, lookupActionResult);
            return lookupActionResult;
        }

        return null;
    }
}

window.LookupActionAction = LookupActionAction;

class StopError extends Error {
    constructor(msg) {
        super(msg);
    }
}
window.StopError = StopError;

</SCRIPT><SCRIPT id="Behaviour-script" type="disabled">
/**
 *  Behaviour - Concept behaviours
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 *
 */
class Behaviour {
    constructor(name, triggers, actions, concept, overrideActionName=null) {
        const self = this;

        this.concept = concept;

        if(triggers == null) {
            triggers = [];
        }

        if(actions == null) {
            actions = [];
        }

        if(!Array.isArray(triggers)) {
            triggers = [triggers];
        }

        if(!Array.isArray(actions)) {
            actions = [actions];
        }

        this.cloneData = {
            name: name,
            triggers: triggers!=null?JSON.parse(JSON.stringify(triggers)):null,
            actions: actions!=null?JSON.parse(JSON.stringify(actions)):null,
            overrideActionName: overrideActionName
        }

        this.name = name;

        this.triggers = triggers.map((triggerJson)=>{
            if(typeof triggerJson === "string") {
                if(!Trigger.isTriggerType(triggerJson)) {
                    console.log("Unknown trigger, guessing it is an action trigger:", triggerJson);
                    triggerJson = {"action": triggerJson};
                }
            }

            let originalStringTrigger = null;

            if(typeof triggerJson === "string") {
                originalStringTrigger = triggerJson;

                triggerJson = {};
                triggerJson[originalStringTrigger] = {};
            }

            if(typeof triggerJson !== "string") {

                let triggerName = UUIDGenerator.generateUUID("trigger-");
                let trigger = ConceptLoader.parseTrigger(triggerName, triggerJson, concept);

                if(trigger != null) {
                    self.concept.addTrigger(trigger);

                    return triggerName;
                } else {
                    if(originalStringTrigger == null) {
                        console.warn("Unable to parse anonymous trigger:", triggerJson);
                    } else {
                        return originalStringTrigger;
                    }
                }

                return null;
            }

            return triggerJson;
        }).filter((trigger)=>{
            return typeof trigger === "string";
        });

        this.deleteCallbacks = [];

        let actionName = name+".actions";

        if(overrideActionName != null) {
            actionName = overrideActionName;
            this.callableAction = true;
        }

        this.actionChain = new ActionChain(actionName, {}, this.concept);

        actions.forEach((actionJson)=>{
            if(typeof actionJson !== "string") {
                let actionName = UUIDGenerator.generateUUID("action-");

                if(!Array.isArray(actionJson)) {
                    actionJson = [actionJson];
                }

                let action = ConceptLoader.parseAction(actionName, actionJson, self.concept);

                if(action != null) {
                    self.actionChain.addAction(action);
                } else {
                    console.warn("Unable to parse anonymous action:", actionJson);
                }
            } else {
                let action = null;

                //Check for primitive action first.
                if(Action.hasPrimitiveAction(actionJson)) {
                    action = Action.getPrimitiveAction(actionJson, {}, concept);
                } else {
                    action = new LookupActionAction("", {
                        lookupActionName: actionJson
                    }, concept);
                }

                self.actionChain.addAction(action);
            }
        });
    }

    cloneFresh(concept) {
        return new Behaviour(this.cloneData.name, this.cloneData.triggers, this.cloneData.actions, concept,  this.cloneData.overrideActionName);
    }

    setupEvents() {
        const self = this;

        this.triggers.forEach((trigger)=>{
            self.deleteCallbacks.push(Trigger.registerTriggerEvent(trigger, async (context) => {
                try {
                    await self.onTrigger(trigger, context);
                } catch(e) {
                    console.error(e);
                }
            }));
        });
    }

    async onTrigger(triggerName, context) {
        try {
            await ActionTrigger.before(this.actionChain, context);
            let mark = VarvPerformance.start();
            let resultContext = await this.actionChain.apply(context);
            if(this.actionChain.isPrimitive) {
                VarvPerformance.stop("PrimitiveAction-"+this.actionChain.name, mark);
            } else {
                VarvPerformance.stop("CustomAction-"+this.actionChain.name, mark);
            }
            await ActionTrigger.after(this.actionChain, resultContext);
        } catch(e) {
            if(e instanceof StopError) {
                //console.log("We stopped the chain: "+e.message);
            } else {
                throw e;
            }
        }
    }

    destroy() {
        const self = this;


        this.deleteCallbacks.forEach((deleteCallback)=>{
            deleteCallback.delete();
        });
        this.triggers.forEach((triggerName)=>{
            let trigger = self.concept.getTrigger(triggerName);
            if(trigger != null) {
                self.concept.removeTrigger(trigger);
            }
        });
        this.deleteCallbacks = null;
        this.triggers = null;
        this.actionChain = null;
    }
}

window.Behaviour = Behaviour;

</SCRIPT><SCRIPT id="ConceptLoader-script" type="disabled">
/**
 *  Concept Loader - Convert JSON to program structure
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/*
 * Loads all concepts from the given json spec.
 *
 * ConceptLoader.SystemDefaultMappings can be set to an array of datastores, that will be used for any property that does not define a datastore mapping.
 * It defaults to ["dom", "cauldron"]
 */

class ConceptLoader {
    static get SystemDefaultMappings() {
        let defaultMappings = ["dom"];

        if(Datastore.getDatastoreType("cauldron") != null) {
            defaultMappings.push("cauldron");
        }

        return this.hasOwnProperty('_SystemDefaultMappings') ? this._SystemDefaultMappings : defaultMappings;
    }
    static set SystemDefaultMappings(mappings) {
        this._SystemDefaultMappings = mappings;
    }

    static parseSpec(json) {
        let mark = VarvPerformance.start();

        let parsedSpec = {
            "concepts":[],
            "dataStores": []
        }

        function getConceptFromName(name) {
            return parsedSpec.concepts.find((concept)=>{
                return concept.name === name;
            });
        }

        //Start parse group
        if(ConceptLoader.DEBUG) {
            console.groupCollapsed("Parsing: ", json);
        }

        //Start datastore group
        if(ConceptLoader.DEBUG) {
            console.groupCollapsed("Parsing dataStores...");
        }

        const dataStores = {
            "dom": {
                "type": "dom",
                "options": {default: true}
            },
            "memory": {
                "type": "memory",
                "options": {default: true}
            },
            "localStorage": {
                "type": "localStorage",
                "options": {default: true}
            }
        };

        if(Datastore.getDatastoreType("cauldron") != null) {
            dataStores.cauldron = {
                "type": "cauldron",
                "options": {default: true}
            };
        }

        if(ConceptLoader.DEBUG) {
            console.log("Default dataStores:", Object.assign({},dataStores));
        }

        if(json.dataStores != null) {
            Object.keys(json.dataStores).forEach((dataStoreKey)=>{
                let dataStoreConfig = json.dataStores[dataStoreKey];
                dataStores[dataStoreKey] = dataStoreConfig;
            });
        }

        for(let dataStoreKey of Object.keys(dataStores)) {
            const dataStoreConfig = dataStores[dataStoreKey];
            if(ConceptLoader.DEBUG) {
                console.log("Creating dataStore instance:", dataStoreKey, dataStoreConfig);
            }
            let dataStoreClass = Datastore.getDatastoreType(dataStoreConfig.type);

            let dataStoreInstance = new dataStoreClass(dataStoreKey, dataStoreConfig.options);
            parsedSpec.dataStores.push(dataStoreInstance);
        }

        //End datastore group
        if(ConceptLoader.DEBUG) {
            console.groupEnd();
        }

        if(json.concepts != null) {
            // Go through every concept in this JSON
            Object.keys(json.concepts).forEach((conceptName) => {
                let conceptJson = json.concepts[conceptName];

                if (ConceptLoader.DEBUG) {
                    console.groupCollapsed("Concept:", conceptName);
                }

                let concept = new Concept(conceptName);
                //VarvEngine.registerConceptFromType(conceptName, concept);

                let structure = conceptJson.structure || conceptJson.schema;

                // Find the properties of this Concept
                if (structure != null) {
                    Object.keys(structure).forEach((propertyName) => {
                        let propertyJson = structure[propertyName];

                        let property = new Property(propertyName, propertyJson);

                        if (ConceptLoader.DEBUG) {
                            console.log("Property:", property);
                        }

                        concept.addProperty(property);
                    });
                }

                // Find the mappings
                concept.properties.forEach((property) => {
                    //Dont map derived properties
                    if(property.isDerived()) {
                        return;
                    }

                    let propertyName = property.name;

                    let propertyMappings = ConceptLoader.getMappingsForProperty(conceptJson, propertyName);

                    if (ConceptLoader.DEBUG) {
                        console.log("Mapping:", propertyName, propertyMappings);
                    }

                    concept.mapProperty(property, propertyMappings);
                });

                // Find the actions
                if (conceptJson.actions != null) {
                    Object.keys(conceptJson.actions).forEach((actionName) => {
                        let actionSetup = conceptJson.actions[actionName];

                        if (Array.isArray(actionSetup)) {
                            //This is a behaviour action, with only then part
                            let behaviour = new Behaviour(actionName, [], actionSetup, concept, actionName);

                            if (ConceptLoader.DEBUG) {
                                console.log("Behaviour:", behaviour);
                            }

                            concept.addBehaviour(behaviour);
                        } else {
                            //This is a behaviour action, with either then or when or both...
                            let behaviour = new Behaviour(actionName, actionSetup.when, actionSetup.then, concept, actionName);

                            if (ConceptLoader.DEBUG) {
                                console.log("Behaviour:", behaviour);
                            }

                            concept.addBehaviour(behaviour);
                        }
                    });
                }

                if(conceptJson.extensions != null) {
                    if(json.extensions == null) {
                        json.extensions = [];
                    }

                    let sugarExtensions = [];

                    if (ConceptLoader.DEBUG) {
                        console.log("Sugar extensions...");
                    }
                    Object.keys(conceptJson.extensions).forEach((extensionType) => {
                        let extensionSetup = conceptJson.extensions[extensionType];

                        if(!Array.isArray(extensionSetup)) {
                            extensionSetup = [extensionSetup];
                        }

                        switch(extensionType) {
                            case "inject": {
                                if (ConceptLoader.DEBUG) {
                                    console.log("Inject:", extensionSetup);
                                }
                                let extension = {
                                    "concept": concept.name,
                                    "inject": extensionSetup
                                }
                                sugarExtensions.unshift(extension);
                                break;
                            }

                            case "pick": {
                                if (ConceptLoader.DEBUG) {
                                    console.log("Pick:", extensionSetup);
                                }

                                extensionSetup.forEach((extensionSetupElm)=>{
                                    let extension = {
                                        "concept": extensionSetupElm.concept,
                                        "into": concept.name,
                                        "pick": {}
                                    }

                                    if(extensionSetupElm.schema != null) {
                                        extension.pick.schema = extensionSetupElm.schema;
                                    }
                                    if(extensionSetupElm.actions != null) {
                                        extension.pick.actions = extensionSetupElm.actions;
                                    }
                                    sugarExtensions.unshift(extension);
                                });

                                break;
                            }

                            case "omit": {
                                if (ConceptLoader.DEBUG) {
                                    console.log("Omit:", extensionSetup);
                                }

                                extensionSetup.forEach((extensionSetupElm)=>{
                                    let extension = {
                                        "concept": concept.name,
                                        "omit": {}
                                    }

                                    if(extensionSetupElm.schema != null) {
                                        extension.omit.schema = extensionSetupElm.schema;
                                    }
                                    if(extensionSetupElm.actions != null) {
                                        extension.omit.actions = extensionSetupElm.actions;
                                    }
                                    sugarExtensions.unshift(extension);
                                });

                                break;
                            }

                            default:
                                console.log("Unknown extension type:", extensionType, extensionSetup);
                        }
                    });

                    sugarExtensions.forEach((extension)=>{
                        json.extensions.unshift(extension);
                    })
                }

                if (ConceptLoader.DEBUG) {
                    console.groupEnd();
                }

                parsedSpec.concepts.push(concept);
            });
        }

        if(ConceptLoader.DEBUG) {
            console.groupCollapsed("Extensions");
        }

        // Now modify the environment with the concept extensions (join, inject ...) in order of definition
        if (json.extensions){
            json.extensions.forEach((extension)=>{
                try {
                    if (extension.inject != null) {
                        // Join two or more concepts together into a new concept
                        if (!extension.concept) throw new Error("Inject extension without target 'concept' name: " + JSON.stringify(extension));

                        let target = getConceptFromName(extension.concept);
                        if (!target) throw new Error("Inject extension with target 'concept' set to '" + extension.concept + "' that does not exist: " + JSON.stringify(extension));

                        if (ConceptLoader.DEBUG) {
                            console.log("Injecting into " + extension.concept + ":");
                        }

                        if (!Array.isArray(extension.inject)) extension.inject = [extension.inject];
                        for (let joinee of extension.inject) {
                            let otherConcept = getConceptFromName(joinee);
                            if (!otherConcept) throw new Error("Inject extension with unknown concept '" + joinee + "' in 'inject' list: " + JSON.stringify(extension));
                            target.join(otherConcept);
                        }
                    } else if (extension.join != null) {
                        // Join two or more concepts together into a new concept
                        if (!extension.as) throw new Error("Join extension without 'as' target concept name: " + JSON.stringify(extension));

                        let potentialClash = getConceptFromName(extension.as);
                        if (potentialClash) throw new Error("Join extension with 'as' target concept name '" + extension.as + "' that already exists: " + JSON.stringify(extension));

                        let concept = new Concept(extension.as);
                        parsedSpec.concepts.push(concept);

                        if (ConceptLoader.DEBUG) {
                            console.groupCollapsed("Joining into " + extension.as + ":");
                        }
                        for (let joinee of extension.join) {
                            let otherConcept = getConceptFromName(joinee);
                            if (!otherConcept) throw new Error("Join extension with unknown concept '" + joinee + "' in 'join' list: " + JSON.stringify(extension));
                            if (ConceptLoader.DEBUG) {
                                console.log(otherConcept.name);
                            }
                            concept.join(otherConcept);
                        }
                        if (ConceptLoader.DEBUG) {
                            console.groupEnd();
                        }
                    } else if (extension.omit != null) {
                        if(!extension.concept) throw new Error("Omit extension without 'concept' option: "+JSON.stringify(extension));

                        let concept = getConceptFromName(extension.concept);

                        if(concept != null) {
                            if (ConceptLoader.DEBUG) {
                                console.log("Omitting from " + extension.concept + ":", extension.omit);
                            }

                            concept.omit(extension.omit);
                        }
                    } else if (extension.pick != null) {
                        if(!extension.concept) throw new Error("Pick extension without 'concept' option: "+JSON.stringify(extension));
                        if(!extension.as && !extension.into) throw new Error("Pick extension without 'as' or 'into' option: "+JSON.stringify(extension));

                        let toConcept = null;

                        let fromConcept = getConceptFromName(extension.concept);

                        if(fromConcept == null) {
                            throw new Error("Pick extension with unknown concept '"+extension.concept+"': "+JSON.stringify(extension));
                        }

                        if(extension.as != null) {
                            if(getConceptFromName(extension.as) != null) {
                                throw new Error("Pick extension option 'as' another concept with that name already exists: "+JSON.stringify(extension));
                            }
                            toConcept = new Concept(extension.as);
                            parsedSpec.concepts.push(toConcept);
                        } else if(extension.into != null) {
                            toConcept = getConceptFromName(extension.into);
                        }

                        if (ConceptLoader.DEBUG) {
                            console.log("Picking from " + extension.concept + " as "+extension.as+":", extension.pick);
                        }

                        if(extension.pick.schema != null) {
                            if(!Array.isArray(extension.pick.schema)) {
                                extension.pick.schema = [extension.pick.schema];
                            }

                            extension.pick.schema.forEach((propertyName)=>{
                                let property = fromConcept.getProperty(propertyName);
                                toConcept.addProperty(property.cloneFresh(toConcept), true);

                                let mappings = fromConcept.mappings.get(propertyName);
                                toConcept.mapProperty(toConcept.getProperty(propertyName), mappings);
                            });
                        }

                        if(extension.pick.actions != null) {
                            if (!Array.isArray(extension.pick.actions)) {
                                extension.pick.actions = [extension.pick.actions];
                            }

                            extension.pick.actions.forEach((behaviourName)=>{
                                let behaviour = fromConcept.getBehaviour(behaviourName);
                                toConcept.addBehaviour(behaviour.cloneFresh(toConcept), true);
                            });
                        }
                    } else {
                        throw new Error("Unsupported extension: " + JSON.stringify(extension));
                    }
                } catch(e) {
                    console.warn(e);
                }
            });
        }
        if(ConceptLoader.DEBUG) {
            console.groupEnd();
        }

        //End Parse group
        if(ConceptLoader.DEBUG) {
            console.groupEnd();
        }

        VarvPerformance.stop("ConceptLoader.parseSpec", mark);

        return parsedSpec;
    }

    /**
     *
     * @param {object} json
     * @returns {Promise<any[]>}
     */
    static async loadSpec(spec) {
        let mark = VarvPerformance.start();

        if(ConceptLoader.DEBUG) {
            console.groupCollapsed("Loading: ", spec);
        }

        if(ConceptLoader.DEBUG) {
            console.groupCollapsed("Mapping concepts...");
        }

        spec.concepts.forEach((concept)=>{
            if(ConceptLoader.DEBUG) {
                console.log(concept);
            }
            VarvEngine.registerConceptFromType(concept.name, concept);
        });

        if(ConceptLoader.DEBUG) {
            console.groupEnd();
        }

        if(ConceptLoader.DEBUG) {
            console.groupCollapsed("Loading dataStores...");
        }

        for(let dataStore of spec.dataStores) {
            if(ConceptLoader.DEBUG) {
                console.log("Initializing datastore:", dataStore);
            }
            await dataStore.init();

            Datastore.datastores.set(dataStore.name, dataStore);
        }

        if(ConceptLoader.DEBUG) {
            console.groupEnd();
        }

        if(ConceptLoader.DEBUG) {
            console.groupCollapsed("Enabling mappings");
        }

        spec.concepts.forEach((concept)=>{
            concept.enableMappings(ConceptLoader.DEBUG);
        });

        if(ConceptLoader.DEBUG) {
            console.groupEnd();
        }

        if(ConceptLoader.DEBUG) {
            console.groupCollapsed("Loading backing store...");
        }

        // Run all datastore load methods
        for(let datastore of Array.from(Datastore.datastores.values())) {
            await Trigger.runWithoutTriggers(async ()=>{
                await datastore.loadBackingStore();
            });
        }

        if(ConceptLoader.DEBUG) {
            console.groupEnd();
        }

        if(ConceptLoader.DEBUG) {
            console.groupCollapsed("Finishing concepts");
        }

        spec.concepts.forEach((concept)=>{
            concept.finishSetup(ConceptLoader.DEBUG);
        });

        if(ConceptLoader.DEBUG) {
            console.groupEnd();
        }

        if(ConceptLoader.DEBUG) {
            console.groupEnd();
        }

        VarvPerformance.stop("ConceptLoader.loadSpec", mark);

        return spec.concepts;
    }

    static getMappingsForProperty(conceptJson, propertyName){
        // System-level default
        let propertyMappings = ConceptLoader.SystemDefaultMappings;

        // If concept has defaultMappings, use those
        if(conceptJson.defaultMappings != null) {
            if(!Array.isArray(conceptJson.defaultMappings)) {
                console.warn("concept defaultMappings must be an array");
            } else {
                propertyMappings = conceptJson.defaultMappings;
            }
        }

        // If property has mappings use those
        if (conceptJson.mappings && conceptJson.mappings[propertyName]) {
            propertyMappings = conceptJson.mappings[propertyName];
        }

        return propertyMappings;
    }


    static parseTrigger(triggerName, triggerJson, concept) {
        let mark = VarvPerformance.start();

        let trigger = null;

        if(ConceptLoader.DEBUG) {
            console.log("Parsing trigger:", triggerName, triggerJson);
        }

        let triggerType = Object.keys(triggerJson)[0];
        let triggerOptions = triggerJson[triggerType];

        try {
            trigger = Trigger.getTrigger(triggerType, triggerName, triggerOptions, concept);
        } catch (e) {
            console.warn(e);
        }

        VarvPerformance.stop("ConceptLoader.parseTrigger", mark);

        return trigger;
    }

    static parseAction(actionName, actionSetup, concept) {
        let mark = VarvPerformance.start();

        let chain = new ActionChain(actionName, {}, concept);

        actionSetup.forEach((actionPart) => {
            if(typeof actionPart === "string") {
                if(Action.hasPrimitiveAction(actionPart)) {
                    chain.addAction(Action.getPrimitiveAction(actionPart, {}, concept));
                } else {
                    let lookupAction = new LookupActionAction("", {
                        "lookupActionName": actionPart
                    }, concept);

                    chain.addAction(lookupAction);
                }
            } else {
                let keys = Object.keys(actionPart);

                if(keys.length > 1) {
                    console.warn("You have an action with more than one key as action name: ", actionPart);
                }

                let actionName = keys[0];
                let actionOptions = actionPart[actionName];

                let action = null;

                try {
                    // Check for primitive action
                    action = Action.getPrimitiveAction(actionName, actionOptions, concept);
                } catch(e) {
                    // No primitive action, reference with arguments?
                    action = new LookupActionAction("", {
                        "lookupActionName": actionName,
                        "lookupActionArguments": actionOptions
                    }, concept);
                }

                chain.addAction(action);
            }
        });

        VarvPerformance.stop("ConceptLoader.parseAction", mark);

        return chain;
    }
}

ConceptLoader.DEBUG = false;
window.ConceptLoader = ConceptLoader;

</SCRIPT><SCRIPT id="VarvEngine-script" type="disabled">
/**
 *  VarvEngine - The core of the Varv system
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */

/**
 * @private
 */

const RELOAD_TIMEOUT = 1000;

class VarvEngine {
    static getConceptFromUUID(uuid) {
        let mark = VarvPerformance.start();

        let cachedConcept = VarvEngine.conceptUUIDCache.get(uuid);
        if(cachedConcept != null) {
            VarvPerformance.stop("VarvEngine.getConceptFromUUID.cached", mark);
            return cachedConcept;
        }

        return new Promise(async (resolve, reject)=>{
            let promises = [];

            try {
                for(let ds of Datastore.getAllDatastores()) {
                    promises.push(ds.lookupConcept(uuid));
                }

                let result = await Promise.any(promises);

                if(result != null) {
                    VarvEngine.conceptUUIDCache.set(uuid, result);
                }

                VarvPerformance.stop("VarvEngine.getConceptFromUUID.nonCached", mark);

                resolve(result);
            } catch(e) {
                VarvPerformance.stop("VarvEngine.getConceptFromUUID.nonCached.error", mark);

                resolve(null);
            }
        });
    }

    static async switchConceptType(uuid, newConcept, oldConcept) {
        console.groupCollapsed("%c EXPERIMENTAL: Switching "+uuid+" from "+oldConcept.name+" to "+newConcept.name, "background: red; color: yellow");

        //Find and save all properties of the concept
        let oldProperties = {};

        for(let property of oldConcept.properties) {
            property = property[1];
            oldProperties[property.name] = {
                "type": property.type,
                "value": await property.getValue(uuid)
            }

            property.purgeCache(uuid);
        }

        console.log("Old properties:", oldProperties);

        //Dissapear the instance
        await oldConcept.disappeared(uuid);

        console.log("Creating instance as new concept!");
        VarvEngine.registerConceptFromUUID(uuid, newConcept);

        //Appear new instance
        await newConcept.appeared(uuid);

        //Set all properties that match
        for(let property of newConcept.properties) {
            property = property[1];

            if(oldProperties[property.name] != null) {
                let oldProperty = oldProperties[property.name];
                console.log("Matching property name:", oldProperty);
                try {
                    await property.setValue(uuid, oldProperty.value);
                } catch(e) {
                    console.warn("Unable to set property on new concept type:", e);
                }
            }
        }

        console.log("Cleaning references:");

        //Clean all references that no longer match
        for(let concept of VarvEngine.concepts) {
            for(let [key, property] of concept.properties) {
                //If property could hold old concept type, but not new, remove if our reference exists
                if(property.holdsConceptOfType(oldConcept) && !property.holdsConceptOfType(newConcept)) {
                    console.log("Found property that can no longer hold our reference:", property.name);
                    await property.removeAllReferences(concept.name, uuid);
                }
            }
        }

        console.groupEnd();
    }


    static getConceptFromType(type) {
        return VarvEngine.conceptTypeMap.get(type);
    }

    static async countInstances(typeNames, query, context, localConcept) {
        //TODO: What is correct here?

        let maxCount = 0;

        for(let datastore of Datastore.getAllDatastores()) {
            let count = await datastore.countInstances(typeNames, query, context, localConcept);
            maxCount = Math.max(count, maxCount);
        }

        return maxCount;
    }

    static async existsInstance(typeNames, query, context, localConcept) {
        //TODO: What is correct here?

        let exists = false;
        for(let datastore of Datastore.getAllDatastores()) {
            let result = await datastore.existsInstance(typeNames, query, context, localConcept);
            if(result) {
                exists = true;
                break;
            }
        }

        return exists;
    }

    /**
     *
     * @param {String|String[]}typeNames
     * @param {Filter} query
     * @param {VarvContext} context
     * @param {number}limit
     * @param {Concept} localConcept
     * @returns {Promise<any[]>}
     */
    static async lookupInstances(typeNames, query, context, limit = 0, localConcept = null) {
        if(!Array.isArray(typeNames)) {
            typeNames = [typeNames];
        }

        const mark = VarvPerformance.start();

        let result = new Set();
        let promises = [];
        for(let ds of Datastore.getAllDatastores()) {
            promises.push(ds.lookupInstances(typeNames, query, context, limit, localConcept));
        }

        let promiseResults = await Promise.all(promises);

        promiseResults.forEach((uuids)=>{
            if(uuids != null) {
                uuids.forEach((uuid)=>{
                    result.add(uuid);
                });
            }
        });
        VarvPerformance.stop("VarvEngine.lookupInstances", mark, {typeNames, query, limit});

        return Array.from(result);
    }

    static async getAllUUIDsFromType(type, includeOtherConcepts=false) {
        if(VarvEngine.getAllUUIDsFromTypeWarningShowed !== true) {
            console.groupCollapsed("%c DEPRECATED: [getAllUUIDsFromType] - consider rewriting ", "background: yellow; color: red;");
            console.trace();
            console.groupEnd();
            VarvEngine.getAllUUIDsFromTypeWarningShowed = true;
        }

        const mark = VarvPerformance.start()

        let uuidSet = new Set();

        let lookupTypes = [type];

        if(includeOtherConcepts) {
            lookupTypes = VarvEngine.getAllImplementingConceptNames(type);
        }

        for(let ds of Datastore.getAllDatastores()) {
            if(lookupTypes.find((type)=>{
                return ds.isConceptTypeMapped(type);
            }) != null) {
                if(! (ds instanceof DirectDatastore)) {
                    console.warn("getAllUUIDsFromType called on concept stored inside non DirectDatastore, potentially risky!");
                }

                //Pretend filtering is not a thing atm
                let uuids = await ds.lookupInstances(lookupTypes, null, null, 0, null);
                uuids.forEach((uuid) => {
                    uuidSet.add(uuid);
                });
            }
        }

        VarvPerformance.stop("VarvEngine.getAllUUIDsFromType", mark, {conceptType: type});

        return Array.from(uuidSet);
    }

    static getAllImplementingConceptNames(primaryType) {
        return VarvEngine.getAllImplementingConcepts(primaryType).map((concept)=>{
            return concept.name;
        });
    }

    /**
     * Returns an array of Concept that implement the given type, starting with
     * the primary type itself
     * @param {type} primaryTypeName
     * @returns {Array}
     */
    static getAllImplementingConcepts(primaryTypeName){

        // Find all concepts with type, including other concepts
        let primaryConcept = null;
        let otherConcepts = VarvEngine.concepts.filter((concept)=>{
            if(concept.name === primaryTypeName) {
                primaryConcept = concept;
                return false; // This is prepended later
            }

            if(concept.otherConcepts.has(primaryTypeName)) {
                return true;
            }

            return false;
        });

        if(primaryConcept != null) {
            otherConcepts.unshift(primaryConcept);
        }

        return otherConcepts;
    }

    static lookupAction(actionName, lookupConcepts = [], primitiveOptions = {}) {
        let mark = VarvPerformance.start();

        //Filter null and undefined
        lookupConcepts = lookupConcepts.filter((concept)=>{
            return concept != null;
        });

        //Make unique
        lookupConcepts = new Set(lookupConcepts);

        //Add other concepts
        for(let concept of VarvEngine.conceptTypeMap.values()) {
            lookupConcepts.add(concept);
        }

        if(VarvEngine.DEBUG) {
            console.groupCollapsed("Looking up:", actionName, [...lookupConcepts].map((concept)=>{return concept.name}));
        }

        let action = VarvEngine.lookupActionInternal(actionName, lookupConcepts, primitiveOptions);

        if(VarvEngine.DEBUG) {
            if(action != null) {
                console.log("Found action:", action);
            }
            console.groupEnd();
        }

        VarvPerformance.stop("VarvEngine.lookupAction", mark, {actionName});

        return action;
    }

    /**
     * @private
     * @param {string} actionName
     * @param {Set<Concept>} lookupConcepts
     * @returns {Action|null}
     */
    static lookupActionInternal(actionName, lookupConcepts, primitiveOptions = {}) {

        let conceptName = null;

        let split = actionName.split(".");

        if(split.length === 1) {
            actionName = split[0];
        } else if(split.length === 2) {
            conceptName = split[0];
            actionName = split[1];
        } else {
            throw new Error("Only able to lookup actions of the form 'actionname' or 'concept.actionname'");
        }

        if(VarvEngine.DEBUG) {
            console.log("Checking if lookup was on the form 'concept.actionname'");
        }

        if(conceptName != null) {
            if(VarvEngine.DEBUG) {
                console.log("Lookup was 'concept.actionname', forcing lookup to specific concept: ", conceptName);
            }

            let concept = this.conceptTypeMap.get(conceptName);

            if (concept != null) {
                if(VarvEngine.DEBUG) {
                    console.log("Trying to lookup action [" + actionName + "] on concept [" + concept.name + "]");
                }
                return concept.getAction(actionName);
            } else {
                throw new Error("Attempted lookup on form 'concept.actionname' where concept did not exist!");
            }
        }

        //Lookup action directly from name, trying default concept first
        if(lookupConcepts!=null && lookupConcepts.size > 0) {
            if(VarvEngine.DEBUG) {
                console.group("Trying to lookup on lookupConcepts in order");
            }
            for(let lookupConcept of lookupConcepts) {
                if(VarvEngine.DEBUG) {
                    console.log("Trying lookup on concept:", lookupConcept.name);
                }

                let action = lookupConcept.getAction(actionName);

                if(action != null) {
                    if(VarvEngine.DEBUG) {
                        console.groupEnd();
                    }
                    return action;
                }
            }
            if(VarvEngine.DEBUG) {
                console.groupEnd();
            }
        }

        if(VarvEngine.DEBUG) {
            console.log("Trying lookup on primitive actions...")
        }

        //Try primitive actions?
        try {
            if (Action.hasPrimitiveAction(actionName)) {
                return Action.getPrimitiveAction(actionName, primitiveOptions, null);
            }
        } catch(e) {}

        if(VarvEngine.DEBUG) {
            console.log("Action not found!");
        }

        return null;
    }

    static isKnownConceptType(type) {
        return VarvEngine.conceptTypeMap.has(type);
    }

    static registerConceptFromUUID(uuid, concept) {
        let mark = VarvPerformance.start();
        //Legacy register of all direct datastores
        for(let ds of Datastore.getAllDatastores()) {
            if(ds instanceof DirectDatastore) {
                ds.registerConceptFromUUID(uuid, concept);
            }
        }

        //Precache ourselves aswell
        VarvEngine.conceptUUIDCache.set(uuid, concept);

        VarvPerformance.stop("VarvEngine.registerConceptFromUUID", mark);
    }

    static deregisterConceptFromUUID(uuid, concept) {
        this.conceptUUIDCache.delete(uuid);

        //Also clear lookupTarget cache for this concept, if the concept was the target
        let possibleCache = VarvEngine.lookupTargetCache.get(concept.name);
        if(possibleCache?.data === uuid) {
            VarvEngine.lookupTargetCache.delete(concept.name);
        }

        //Legacy register of all direct datastores
        for(let ds of Datastore.getAllDatastores()) {
            if(ds instanceof DirectDatastore) {
                ds.deregisterConceptFromUUID(uuid);
            }
        }
    }

    static registerConceptFromType(type, concept) {
        let oldConcept = this.conceptTypeMap.get(type);

        if(oldConcept != null && oldConcept != concept) {
            console.warn("Registering ["+type+"] already registered", oldConcept, concept);
        }

        VarvEngine.conceptTypeMap.set(type, concept);
    }

    static deregisterConceptFromType(type) {
        for(let ds of Datastore.getAllDatastores()) {
            if(ds instanceof DirectDatastore) {
                ds.deregisterConceptFromType(type);
            }
        }

        VarvEngine.conceptTypeMap.delete(type);
    }

    /**
     * Legacy start, no longer used, Varv starts by itself
     */
    static async start() {
        console.log("await VarvEngine.start() legacy function no longer does anything, Varv is always started - you can remove this call from your code");
    }

    static async init(){
        let reloading = false;
        let reloadQueueId = null;

        let foundDefinitionFragments = [];

        const live = new LiveElement("code-fragment[data-type='text/varv'],code-fragment[data-type='text/varvscript']");

        let firstRun = true;

        let fragmentChangedHandler = (fragment)=>{
            if(fragment.fragment != null) {
                fragment = fragment.fragment;
            }
            if(fragment.auto) {
                queueReload();
            }
        }

        let fragmentAutoChangedHandler = ()=>{
            queueReload();
        }

        live.forEach((elm)=>{
            let fragment = Fragment.one(elm);
            elm.fragmentLink = fragment;

            foundDefinitionFragments.push(fragment);

            fragment.registerOnFragmentChangedHandler(fragmentChangedHandler);
            fragment.registerOnAutoChangedHandler(fragmentAutoChangedHandler);

            if(!firstRun) {
                if(fragment.auto) {
                    queueReload();
                }
            }
        });

        live.removed((elm)=>{
            let fragment = elm.fragmentLink;
            foundDefinitionFragments.splice(foundDefinitionFragments.indexOf(fragment), 1);
            fragment.unRegisterOnFragmentChangedHandler(fragmentChangedHandler);
            fragment.unRegisterOnAutoChangedHandler(fragmentAutoChangedHandler);
            if(elm.hasAttribute("auto")) {
                queueReload();
            }
        });

        firstRun = false;
        await queueReload(true);

        async function reload() {
            let mark = VarvPerformance.start();
            reloading = true;
            if (VarvEngine.DEBUG) {
                console.group("Reloading VarvEngine....");
            }

            if (VarvEngine.DEBUG) {
                console.log("Destroying old engine...");
            }
            for (let concept of VarvEngine.concepts) {
                await concept.destroy();
            }

            VarvEngine.concepts = [];

            for (let datastore of Datastore.datastores.values()) {
                if (VarvEngine.DEBUG) {
                    console.log("Destroying datastore:", datastore);
                }
                datastore.destroy();
            }
            Datastore.datastores.clear();

            VarvEngine.conceptUUIDCache.clear();
            VarvEngine.conceptTypeMap.clear();
            VarvEngine.lookupPropertyCache.clear();
            VarvEngine.lookupTargetCache.clear();
            PropertyCache.reset();

            if (VarvEngine.DEBUG) {
                console.log("Merging definition fragments...");
            }

            let combinedObj = {};

            for (let fragment of foundDefinitionFragments) {
                if (fragment.auto) {
                    let varvJson = await fragment.require();

                    combinedObj = VarvEngine.merge(combinedObj, varvJson);

                    //Attempt to merge conflicts we know how to handle:
                    VarvEngine.resolveMergeConflicts(combinedObj);
                } else {
                    if (VarvEngine.DEBUG) {
                        console.log("Skipping disabled fragment:", fragment);
                    }
                }
            }

            if (VarvEngine.DEBUG) {
                console.log("Combined Spec:", combinedObj);
            }

            if (VarvEngine.DEBUG) {
                console.log("Loading new engine...");
            }

            let spec = ConceptLoader.parseSpec(combinedObj);

            VarvEngine.concepts = await ConceptLoader.loadSpec(spec);

            VarvEngine.concepts.forEach((concept)=>{
                concept.doAfterSpecLoadSetup(ConceptLoader.DEBUG);
            });

            await VarvEngine.sendEvent("engineReloaded", VarvEngine.concepts);

            if (VarvEngine.DEBUG) {
                console.log("Reload complete...", VarvEngine.concepts);
                console.groupEnd();
            }
            reloading = false;
            VarvPerformance.stop("VarvEngine.reload", mark);
        }

        function queueReload(initial=false) {
            return new Promise((resolve)=>{
                if(VarvEngine.DEBUG) {
                    console.log("Queuing reload...");
                }

                if(reloadQueueId != null) {
                    window.clearTimeout(reloadQueueId);
                }

                reloadQueueId = setTimeout(()=>{
                    reloadQueueId = null;
                    if(!reloading) {
                        reloading = true;
                        reload().then(()=>{
                            if (!initial){
                                iziToast.success({
                                    title: '',
                                    message: 'Successfully loaded Varv!',
                                    transitionIn: "fadeIn",
                                    transitionOut: 'fadeOut',
                                    position: "topCenter",
                                    timeout: 2000,
                                    close: false,
                                    closeOnClick: true
                                });
                            }
                            reloading = false;
                            resolve();
                        }).catch((e)=>{
                            iziToast.error({
                                title: '',
                                message: 'Error reloading Varv: '+e.message,
                                transitionIn: "fadeIn",
                                transitionOut: 'fadeOut',
                                position: "topCenter",
                                timeout: 2000,
                                close: false,
                                closeOnClick: true
                            });
                            console.groupEnd();
                            console.error(e);
                            reloading = false;
                            resolve();
                        });
                    } else {
                        queueReload().then(()=>{
                            resolve();
                        });
                    }
                }, initial?0:RELOAD_TIMEOUT);
            });
        }

        EventSystem.registerEventCallback("Varv.Restart", ()=>{
            queueReload();
        });
    }

    static async lookupTarget(concept, useOtherConcepts=true) {
        let target = null;

        let mark = VarvPerformance.start();

        let cache = VarvEngine.lookupTargetCache.get(concept.name);
        if(cache != null) {
            VarvPerformance.stop("VarvEngine.lookupTarget.cached", mark);
            cache.hit++;
            return cache.data;
        }

        let instanceTypes = [];
        instanceTypes.push(concept.name);

        if(useOtherConcepts) {
            instanceTypes.push(...VarvEngine.getAllImplementingConceptNames(concept.name));
        }

        let uuids = await VarvEngine.lookupInstances(instanceTypes, null, null,2, null);
        if(uuids.length > 0) {
            target = uuids[0];
            if(uuids.length > 1) {
                console.warn("[lookupTarget] Multiple uuid's exist for concept ["+concept.name+"]", uuids);
            }

            VarvPerformance.stop("VarvEngine.lookupTarget", mark);

            VarvEngine.lookupTargetCache.set(concept.name, {
                data: target,
                hit: 0
            });

            return target;
        }

        throw new Error("No instance of concept found: "+concept.name);
    }

    /**
     * The object returned from lookupProperty
     * @typedef {object} lookupPropertyObject
     * @property {Concept} concept The concept the property was found on
     * @property {Property} property The property itself
     * @property {string} target The target to look up the property on
     */

    /**
     *
     * @param {string|Concept} contextTarget
     * @param {Concept} localConcept
     * @param {string} propertyName
     * @returns {null|lookupPropertyObject}
     */
    static async lookupProperty(contextTarget, localConcept, propertyName) {
        const DEBUG_LOOKUP_PROPERTY = false;

        const mark = VarvPerformance.start();

        const lookupPropertyCacheKey = "CTX:"+(contextTarget?.target!=null?contextTarget.target:"NULL")+"CPT:"+(localConcept!=null?localConcept.name:"NULL")+"PN:"+propertyName;

        let cache = VarvEngine.lookupPropertyCache.get(lookupPropertyCacheKey);

        if(cache != null) {
            if(cache.isValid()) {
                cache.hit++;
                VarvPerformance.stop("VarvEngine.lookupProperty.cached", mark);
                return cache.data;
            } else {
                VarvEngine.lookupPropertyCache.delete(lookupPropertyCacheKey);
            }
        }

        if(VarvEngine.DEBUG || DEBUG_LOOKUP_PROPERTY) {
            console.groupCollapsed("Looking up property:", propertyName, contextTarget, localConcept);
            console.trace();
        }

        //Lookup of form concept.property, overrides all the other lookup types
        let conceptName = null;

        let split = propertyName.split(".");

        if(split.length === 1) {
            propertyName = split[0];
        } else if(split.length === 2) {
            conceptName = split[0];
            propertyName = split[1];
        } else {
            throw new Error("Only able to lookup actions of the form 'actionname' or 'concept.actionname'");
        }

        if (conceptName != null) {
            if (VarvEngine.DEBUG || DEBUG_LOOKUP_PROPERTY) {
                console.log("Lookup of form concept.property...", conceptName, propertyName);
            }

            let lookupConcept = VarvEngine.getConceptFromType(conceptName);

            if (conceptName === "lastTarget") {
                console.warn("Should never see this (conceptName === 'lastTarget') ?????");
            }

            if (lookupConcept != null) {
                let lookupProperty = lookupConcept.getProperty(propertyName);

                if (lookupProperty != null) {

                    let lookupTarget = null;

                    try {
                        if (contextTarget != null && (await VarvEngine.getConceptFromUUID(contextTarget)).isA(conceptName)) {
                            //The current target was of this concept, lets assume that is the wanted target?
                            lookupTarget = contextTarget;
                        } else {
                            lookupTarget = await VarvEngine.lookupTarget(lookupConcept);
                        }
                    } catch(e) {
                        //Ignore for now?
                    }

                    if (VarvEngine.DEBUG || DEBUG_LOOKUP_PROPERTY) {
                        console.log("Found concept.property, ", lookupProperty, lookupConcept, lookupTarget);
                        console.groupEnd();
                    }

                    VarvPerformance.stop("VarvEngine.lookupProperty.concept.property", mark);

                    let result = {
                        property: lookupProperty,
                        concept: lookupConcept,
                        target: lookupTarget,
                        type: "specificConcept"
                    }

                    VarvEngine.lookupPropertyCache.set(lookupPropertyCacheKey, {
                        isValid: () => {
                            return VarvEngine.lookupTargetCache.get(lookupConcept.name) != null;
                        },
                        hit: 0,
                        data: result
                    });

                    return result;
                } else {
                    throw new Error("Lookup property on [" + split.join(".") + "], property does not exist: " + propertyName);
                }
            } else {
                throw new Error("Lookup property on [" + split.join(".") + "], concept does not exist: " + conceptName);
            }
        }

        //Lookup on contextConcept
        try {
            let contextConcept = null;

            if(contextTarget instanceof Concept) {
                contextConcept = contextTarget;
                contextTarget = null;
            } else {
                let promiseOrValue = VarvEngine.getConceptFromUUID(contextTarget);
                if(promiseOrValue instanceof Promise) {
                    promiseOrValue = await promiseOrValue;
                }
                contextConcept = promiseOrValue;
            }

            let property = contextConcept.getProperty(propertyName);

            if (VarvEngine.DEBUG || DEBUG_LOOKUP_PROPERTY) {
                console.log("Found on contextConcept", contextConcept.name);
                console.groupEnd();
            }

            VarvPerformance.stop("VarvEngine.lookupProperty.contextConcept", mark);

            return {
                property: property,
                concept: contextConcept,
                target: contextTarget,
                type: "contextConcept"
            }
        } catch(e) {
            //Ignore
        }

        //Lookup on localConcept
        try {
            let property = localConcept.getProperty(propertyName);

            if(VarvEngine.DEBUG || DEBUG_LOOKUP_PROPERTY) {
                console.log("Found on localConcept", localConcept.name);
                console.groupEnd();
            }

            VarvPerformance.stop("VarvEngine.lookupProperty.localConcept", mark);

            let target = null;
            try {
                target = await VarvEngine.lookupTarget(localConcept)
            } catch(e) {
                //Ignore
            }

            return {
                property: property,
                concept: localConcept,
                target: target,
                type: "localConcept"
            }
        } catch(e) {
            //Ignore
        }

        //Lookup on globalConcept
        for(let globalConcept of VarvEngine.concepts) {
            try {
                let property = globalConcept.getProperty(propertyName);

                if(VarvEngine.DEBUG || DEBUG_LOOKUP_PROPERTY) {
                    console.log("Found on globalConcept", globalConcept.name);
                    console.groupEnd();
                }

                VarvPerformance.stop("VarvEngine.lookupProperty.globalConcept", mark);

                let target = null;
                try {
                    target = await VarvEngine.lookupTarget(globalConcept)
                } catch(e) {
                    //Ignore
                }

                return {
                    property: property,
                    concept: globalConcept,
                    target: target,
                    type: "globalConcept"
                }
            } catch(e) {
                //Ignore
            }
        }

        VarvPerformance.stop("VarvEngine.lookupProperty.notFound", mark);

        if(VarvEngine.DEBUG || DEBUG_LOOKUP_PROPERTY) {
            console.log("Not found...");
            console.groupEnd();
        }

        return null;
    }

    /**
     * Lookup an unknown reference
     * @param {string} reference - The reference to lookup
     * @param {Concept} localConcept=null - The concept to lookup properties on first, before trying globally
     * @param {boolean} executeAtOnce - If true, the value of the function is returned, and not the function.
     * @returns {function|object|string} - An object containing the type of reference if known, or just the reference if still unknown
     */
    static lookupReference(reference, lookupConcepts = []) {
        const mark = VarvPerformance.start();

        let allConcepts = new Set();
        if(lookupConcepts != null) {
            if(!Array.isArray(lookupConcepts)) {
                lookupConcepts = [lookupConcepts];
            }

            lookupConcepts.forEach((concept)=>{
                allConcepts.add(concept);
            });
        }

        VarvEngine.concepts.forEach((concept)=>{
            allConcepts.add(concept);
        });

        let lookup = VarvEngine.lookupReferenceInternal(reference, allConcepts);

        VarvPerformance.stop("VarvEngine.lookupReference", mark, {reference});

        return lookup;
    }

    static lookupReferenceInternal(reference, lookupConcepts) {
        if(VarvEngine.DEBUG) {
            console.groupCollapsed("Looking up unknown reference:", reference);
        }

        //Check for concept type
        if (VarvEngine.getConceptFromType(reference) != null) {
            if(VarvEngine.DEBUG) {
                console.log("Was concept!");
                console.groupEnd();
            }
            return {
                "concept": reference
            }
        }

        //Check for view
        if (DOMView?.singleton.existsAsViewElement(reference)) {
            if(VarvEngine.DEBUG) {
                console.log("Was view!");
                console.groupEnd();
            }
            return {
                "view": reference
            }
        }

        //Check for global property
        for(let concept of lookupConcepts) {
            try {
                concept.getProperty(reference);

                if(VarvEngine.DEBUG) {
                    console.log("Was property on concept: [" + concept.name + "]");
                    console.groupEnd();
                }

                return {
                    "concept": concept.name,
                    "property": reference
                }
            } catch(e) {
                //Ignore, just means we had no property of given name
            }
        }

        if(VarvEngine.DEBUG) {
            console.log("Was unknown!");
            console.groupEnd();
        }

        return {
            "unknown": reference
        };
    }

    static resolveMergeConflicts(spec) {
        const DEBUG_MERGE = VarvEngine.DEBUG || false;

        function replaceInSpec(prefix, newValue) {
            if(prefix.startsWith("spec.")) {
                prefix = prefix.substring(5);
            }

            let currentPath = spec;
            let lastPath = null;
            let lastPrefixPart = null;
            prefix.split(".").forEach((prefixPart)=>{
                lastPath = currentPath;
                lastPrefixPart = prefixPart;

                if(prefixPart.indexOf("[") !== -1) {
                    let key = prefixPart.substring(0, prefixPart.indexOf("["));
                    let index = prefixPart.substring(prefixPart.indexOf("[")+1, prefixPart.indexOf("]"));
                    //Array entry
                    currentPath = currentPath[key][index];
                } else {
                    //Object entry
                    currentPath = currentPath[prefixPart];
                }
            });

            if(lastPath != null) {
                if(lastPrefixPart.indexOf("[") !== -1) {
                    let key = lastPrefixPart.substring(0, lastPrefixPart.indexOf("["));
                    let index = lastPrefixPart.substring(lastPrefixPart.indexOf("[")+1, lastPrefixPart.indexOf("]"));
                    //Array entry
                    lastPath[key][index] = newValue;
                } else {
                    //Object entry
                    lastPath[lastPrefixPart] = newValue;
                }

                return true;
            }

            return false;
        }

        function handleMergeConflict(prefix, json) {
            let merged = false;
            if(DEBUG_MERGE) {
                console.group("Attempting to merge: ", prefix, json.mergeConflict);
            }

            if(json.mergeConflict.type === "arrayMerge") {
                if(DEBUG_MERGE) {
                    console.log("ArrayMerge");
                }

                if(prefix.endsWith(".enum")) {
                    if(DEBUG_MERGE) {
                        console.log("Enum merge!")
                    }

                    merged = replaceInSpec(prefix, json.mergeConflict.part2);
                } else if(prefix.endsWith(".then")) {
                    if(DEBUG_MERGE) {
                        console.log("Action then merge!");
                    }

                    merged = replaceInSpec(prefix, json.mergeConflict.part2);
                } else if(prefix.endsWith(".when")) {
                    if(DEBUG_MERGE) {
                        console.log("Action when merge!");
                    }

                    merged = replaceInSpec(prefix, json.mergeConflict.part2);
                } else if(prefix.match(/actions\.\S+$/)) {
                    if(DEBUG_MERGE) {
                        console.log("Action array merge!");
                    }

                    merged = replaceInSpec(prefix, {"then": json.mergeConflict.part2});
                } else if(prefix.endsWith(".extensions")) {
                    let result = [];
                    json.mergeConflict.part1.forEach((ext)=>{
                        result.push(ext);
                    });
                    json.mergeConflict.part2.forEach((ext)=>{
                        result.push(ext);
                    });

                    merged = replaceInSpec(prefix, result);
                }
            } else if(json.mergeConflict.type == null) {
                if(DEBUG_MERGE) {
                    console.log("Unknown merge type!");
                }

                if(prefix.match(/actions\.\S+$/)) {
                    let then = null;
                    let when = null;

                    if(Array.isArray(json.mergeConflict.part1)) {
                        then = json.mergeConflict.part1;
                        when = json.mergeConflict.part2.when;
                    } else if(Array.isArray(json.mergeConflict.part2)) {
                        then = json.mergeConflict.part2;
                        when = json.mergeConflict.part1.when;
                    } else {
                        //Unknown action merge
                    }

                    merged = replaceInSpec(prefix, {then, when});
                }
            }

            if(DEBUG_MERGE) {
                console.groupEnd();
            }
            return merged;
        }

        //Check for any mergeconflicts left...
        function findMergeConflict(json, prefix="") {
            if(typeof json === "object") {
                if(Array.isArray(json)) {
                    json.forEach((elm, index)=>{
                        findMergeConflict(elm, prefix+"["+index+"]");
                    });
                } else if(json != null) {
                    if(json.mergeConflict != null) {
                        let handled = handleMergeConflict(prefix, json);
                        if(!handled) {
                            console.warn("Found unhandled mergeConflict:", prefix, json);
                        }
                    }

                    Object.keys(json).forEach((objKey)=>{
                        let objValue = json[objKey];
                        findMergeConflict(objValue, prefix+"."+objKey);
                    });
                }
            }
        }

        findMergeConflict(spec, "spec");
    }

    static merge(json1, json2) {
        if(VarvEngine.DEBUG) {
            console.groupCollapsed("Merging:", json1, json2);
        }

        if(json1 == null && json2 != null) {
            if(VarvEngine.DEBUG) {
                console.log("Shortcut json2:", json2);
                console.groupEnd();
            }
            return json2;
        } else if(json2 == null && json1 != null) {
            if(VarvEngine.DEBUG) {
                console.log("Shortcut json1:", json1);
                console.groupEnd();
            }
            return json1;
        }

        if(json1 == null && json2 == null) {
            if(VarvEngine.DEBUG) {
                console.log("Null shortcut...");
                console.groupEnd();
            }
            return null;
        }

        //Neither json is null, as that would have resulted in a shortcut...

        let type1 = typeof json1;
        let type2 = typeof json2;

        if(type1 !== type2) {
            //Types were different, but none of the json was null, this should be an error of some sort?
            if(VarvEngine.DEBUG) {
                console.warn("Unable to merge different types:", json1, json2);
                console.groupEnd();
            }
            return {
                "mergeConflict": {
                    "part1": json1,
                    "part2": json2
                }
            };
        }

        let isArray1 = Array.isArray(json1);
        let isArray2 = Array.isArray(json2);

        if(isArray1 != isArray2) {
            if(VarvEngine.DEBUG) {
                console.warn("One was array, other was not!");
                console.groupEnd();
            }
            return {
                "mergeConflict": {
                    "part1": json1,
                    "part2": json2
                }
            };
        }

        if(isArray1) {
            if(VarvEngine.DEBUG) {
                console.log("Array merge...");
            }

            if(VarvEngine.DEBUG) {
                console.groupEnd();
            }

            return {
                "mergeConflict": {
                    "type": "arrayMerge",
                    "part1": json1,
                    "part2": json2
                }
            };
        } else if(type1 === "object") {
            if(VarvEngine.DEBUG) {
                console.log("Object merge...");
            }

            let result = {};

            for(let key of Object.keys(json1)) {
                result[key] = VarvEngine.merge(json1[key], json2[key]);
            }

            for(let key of Object.keys(json2)) {
                if(!result.hasOwnProperty(key)) {
                    //This was not handled already from json1 keys
                    result[key] = VarvEngine.merge(json1[key], json2[key]);
                }
            }

            if(VarvEngine.DEBUG) {
                console.groupEnd();
            }
            return result;
        } else {
            if(VarvEngine.DEBUG) {
                console.log("Value merge...");
            }
            if(json1 !== json2) {
                if(VarvEngine.DEBUG) {
                    console.warn("Non equal values! (Overriding from json2)");
                }
            }

            if(VarvEngine.DEBUG) {
                console.groupEnd();
            }
            return json2;
        }
    }

    static async sendEvent(eventName, detail) {
        if(Datastore.DEBUG) {
            console.group("Sending varv engine event:", eventName, detail);
        }
        let mark = VarvPerformance.start();
        await EventSystem.triggerEventAsync(VarvEngine.VarvEngineEventPrefix+eventName, detail);
        VarvPerformance.stop("VarvEngine.sendEvent."+eventName, mark, detail);
        if(Datastore.DEBUG) {
            console.groupEnd();
        }
    }

    static registerEventCallback(eventName, callback) {
        return EventSystem.registerEventCallback(VarvEngine.VarvEngineEventPrefix+eventName, async (evt)=>{
            await callback(evt.detail);
        });
    }

    static handlePossibleAsync(possiblePromise, callback) {
        if(possiblePromise instanceof Promise) {
            //Was promise, so wait for actual value
            possiblePromise.then((actualValue)=>{
                callback(actualValue);
            });
        } else {
            //No promise, so was actual value
            callback(possiblePromise);
        }
    }
}

VarvEngine.concepts = [];
VarvEngine.DEBUG = false;
VarvEngine.VarvEngineEventPrefix = "VarvEngineEvent.";
VarvEngine.conceptTypeMap = new Map();
VarvEngine.conceptUUIDCache = new Map();
VarvEngine.lookupPropertyCache = new Map();
VarvEngine.lookupTargetCache = new Map();

window.VarvEngine = VarvEngine;

const urlParams = new URLSearchParams(location.search);
window.VarvEngine.disabled = (urlParams.get("varv") === "false");

if(!window.VarvEngine.disabled) {
    wpm.onAllInstalled(async ()=>{
        if(typeof Fragment !== "undefined") {
            Fragment.addAllFragmentsLoadedCallback(async ()=>{
                console.log("Starting VarvEngine with Codestrates");
                await VarvEngine.init();
            });
        } else {
            console.log("Starting VarvEngine");
            await VarvEngine.init();
        };
    });
} else {
    console.log("Varv disabled!");
}


</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="varv-repos" id="varv-codestrates-extensions" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Varv codestrates extension",
    "description": "Extend Codestrates with Varv fragments",
    "dependencies": [
        "codestrates-repos #fragment_core",
        "codestrates-repos #js-eval-engine"
    ],
    "assets": [],
    "license": "MIT",
    "version": "0.1",
    "changelog": {}
}

</SCRIPT><SCRIPT id="ConceptDefinitionFragment-script" type="disabled">
/**
 *  ConceptDefinitionFragment - A Codestrate Fragment type for Concept Definitions
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

wpm.onRemoved(()=>{
    Fragment.unRegisterFragmentType(ConceptDefinitionFragment);
});
/**
 * A fragment that contains Varv code
 *
 * Supports auto - executes require() on load
 * @extends Fragments.Fragment
 * @hideconstructor
 * @memberof Fragments
 */
class ConceptDefinitionFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    async require(options = {}) {
        return YAMLJSONConverter.loadFromString(this.raw).obj;
    }

    supportsAuto() {
        return true;
    }

    static type() {
        return "text/varv";
    }
};
window.ConceptDefinitionFragment = ConceptDefinitionFragment;
Fragment.registerFragmentType(ConceptDefinitionFragment);

function detectYAMLJSON(editor) {
    let code = editor.getModel().getValue().trim();
    let numCurlyBrackets = (code.match(/{/g)||[]).length;

    let YAML = 0;
    let JSON = 0

    if(code.length === 0) {
        //If fragment is empty, set it up as JSON
        JSON += 4;
    }

    if(numCurlyBrackets > 10) {
        //Many curly brackets, probably JSON
        JSON++;
    } else {
        YAML++;
    }

    if(code.startsWith("{")) {
        //Code starts with a curly bracket, probably JSON
        JSON++;
    } else {
        YAML++;
    }

    if(code.endsWith("}")) {
        //Code ends with a curly bracket, probably JSON
        JSON++;
    } else {
        YAML++;
    }

    if(YAML > JSON) {
        monaco.editor.setModelLanguage(editor.getModel(), "yaml");
    } else {
        monaco.editor.setModelLanguage(editor.getModel(), "json");
    }
}

EventSystem.registerEventCallback("Codestrates.Editor.Opened", (evt)=>{
    let editor = evt.detail.editor;

    if(editor.fragment instanceof ConceptDefinitionFragment) {
        editor.fragment.registerOnFragmentChangedHandler(() => {
            detectYAMLJSON(editor.editor);
        });
        detectYAMLJSON(editor.editor);
    }
});

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="varv-repos" id="varv-inspector" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><STYLE id="inspector-style">
.mdc-menu .varv-inspector-preview {
    background: rgba(100,100,100,0.2);
    max-width: 30rem;
    width: 100%;
    overflow: auto;
    max-height: 20rem;
    padding: 0;
    margin: 0;
    font-size: 0.8em;
}
</STYLE><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Varv engine inspector",
    "description": "Inspect DOMView rendering elements using ctrl+rclick",
    "dependencies": [

    ],
    "optionalDependencies": [
        "webstrate-components-repos #MaterialDesignOutlinedIcons",
        "webstrate-components-repos #MaterialMenu"
    ],
    "assets": [],
    "license": "MIT",
    "version": "0.1",
    "changelog": {}
}

</SCRIPT><SCRIPT id="Inspector-script" type="disabled">
/**
 *  Inspector - Allow inspection of rendered DOMView elements
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 *
 */
class Inspector {
    constructor() {
        const self = this;

        document.addEventListener("contextmenu", (evt)=>{
            if(evt.ctrlKey) {
                evt.preventDefault();
            }
        });

        document.addEventListener("mouseup", async (evt)=>{
            if(evt.button !== 2 || !evt.ctrlKey) {
                return;
            }
            await wpm.require(["MaterialDesignOutlinedIcons", "MaterialMenu"]);
            self.handleContextMenu(evt);
        });
    }

    async handleContextMenu(evt) {
        let conceptBindings = DOMView.singleton.getConceptPath(evt.target);
        let properties = DOMView.singleton.getPropertyPath(evt.target);
        let templates = DOMView.singleton.getTemplatePath(evt.target);

        //console.group("Inspecting:", evt.target);

        if(window.MenuSystem != null) {
            console.log("Adding menu ");

            //Setup context menus
            let contextMenu = MenuSystem.MenuManager.createMenu("Varv.Inspector.ContextMenu", {
                context: evt.target,
                groupDividers: true
            });
            document.body.appendChild(contextMenu.html);

            contextMenu.registerOnCloseCallback(()=>{
                document.body.removeChild(contextMenu.html);
            });

            // Concept path
            for(let conceptBinding of conceptBindings.reverse()) {
                let concept = conceptBinding.concept;
                let conceptMenu = MenuSystem.MenuManager.createMenu("ConceptInspectMenu");

                if (typeof TreeBrowser !== "undefined"){
                    let treeBrowsers = TreeBrowser.findAllTreeBrowsers();
                    if (treeBrowsers){
                        conceptMenu.addItem({
                            label: "Inspect in Cauldron",
                            icon: IconRegistry.createIcon("mdc:gps_fixed"),
                            onAction: (menuItem) => {
                                for (let browser of treeBrowsers){
                                    let treeNodes = browser.findTreeNode(conceptBinding.uuid);
                                    if(treeNodes.length > 0) {
                                        let treeNode = treeNodes[0];
                                        treeNode.reveal();
                                        treeNode.select();
                                    }
                                }
                            }
                        });
                    }
                    contextMenu.addItem({
                        label: concept.name,
                        group: "Concepts",
                        groupOrder: 0,
                        icon: IconRegistry.createIcon("mdc:api"),
                        submenu: conceptMenu
                    });
                } else {
                    contextMenu.addItem({
                        label: concept.name,
                        group: "Concepts",
                        groupOrder: 0,
                        icon: IconRegistry.createIcon("mdc:api")
                    });
                }
            };

            // Template path
            let currentTemplateTop = null;
            for (let templateNode of templates.reverse()){
                let templateMenu = MenuSystem.MenuManager.createMenu("TemplateInspectMenu");
                let fragment = null;

                let parentAutoDom = cQuery(templateNode).closest(".autoDom")[0];
                if (parentAutoDom){
                    let id = parentAutoDom.getAttribute("id");
                    if (id){
                        fragment = Fragment.one("[transient-fragment-uuid='"+id+"']");
                    }
                }

                // Filter som levels
                let parentTemplate = cQuery(templateNode).closest("varv-template")[0];
                if (!parentTemplate){
                    parentTemplate = parentAutoDom; // Not a template, use main fragment as top
                }
                if (currentTemplateTop === parentTemplate){
                    // Only show one level from each template, skip the rest
                    continue;
                }
                currentTemplateTop = parentTemplate;

                if (typeof TreeBrowser !== "undefined"){
                    let treeBrowsers = TreeBrowser.findAllTreeBrowsers();
                    if (treeBrowsers){
                        templateMenu.addItem({
                            label: "Edit in Cauldron",
                            icon: IconRegistry.createIcon("mdc:mode_edit"),
                            onAction: (menuItem) => {
                                // If this is inside an autoDom fragment, use the fragment
                                if (fragment){
                                    EventSystem.triggerEvent("Cauldron.Open.FragmentEditor", {
                                        fragment: fragment
                                    });
                                } else {
                                }
                                // TODO: If this was not autoDom, edit plain HTML template instead
                            }
                        });
                    }
                }  else {
                    templateMenu.addItem({
                        label: "Dump to console",
                        icon: IconRegistry.createIcon("mdc:mode_edit"),
                        onAction: (menuItem) => {
                            console.log(fragment);
                        }
                    });
                }

                // Text
                let textView = document.createElement("pre");
                textView.classList.add("varv-inspector-preview");
                textView.innerText = templateNode.outerHTML;
                let source = textView.innerHTML;
                let replacement = "<b style='background:rgba(255,0,0,0.2)'>"+textView.innerHTML+"</b>";
                textView.innerText = currentTemplateTop.outerHTML;
                templateMenu.registerOnOpenCallback(()=>{
                    textView.innerHTML = textView.innerHTML.replace(source,replacement);
                    templateMenu.html.appendChild(textView);
                });

                let content = templateNode.tagName;
                if (fragment){
                    console.log(fragment);
                    let name = fragment.html[0].getAttribute("name");
                    if (name != null && name != ""){
                        content = name+" ";
                    }
                    if(fragment.html[0].id != null && fragment.html[0].id!="") {
                        content += "#"+fragment.html[0].id;
                    }
                }

                contextMenu.addItem({
                    label: content,
                    group: "Templates",
                    groupOrder: 1,
                    icon: IconRegistry.createIcon("code-fragment:text/html"),
                    submenu: templateMenu
                });

            }

            contextMenu.open({
                x: evt.x,
                y: evt.y
            });
        };



        console.groupCollapsed("Concepts - Closest concept is last");
        for(let conceptBinding of conceptBindings) {
            let concept = conceptBinding.concept;
            let uuid = conceptBinding.uuid;

            console.group("Concept:", concept.name, uuid);

            console.groupCollapsed("Properties");
            for(let property of concept.properties.values()) {
                let value = await property.getValue(uuid);
                console.log(property.name+": ", value);
            }
            console.groupEnd();

            function debugAction(action) {
                if(action instanceof ActionChain) {
                    if(action.actions.length === 1) {
                        debugAction(action.actions[0]);
                    } else {
                        console.groupCollapsed(action.name+":", action.constructor.name);
                        for(let actionChainElement of action.actions) {
                            debugAction(actionChainElement);
                        }
                        console.groupEnd();
                    }
                } else {
                    let actionName = action.name;
                    if(actionName.length > 0) {
                        actionName += ":";
                    }
                    console.log(actionName, action.constructor.name, action.options);
                }
            }

            console.groupCollapsed("Actions");
            for(let action of concept.actions.values()) {
                debugAction(action);
            }
            console.groupEnd();

            console.groupCollapsed("Behaviours");
            for(let behaviour of concept.behaviours.values()) {
                console.groupCollapsed(behaviour.name+":", behaviour.constructor.name);
                console.group("When:");
                for(let triggerName of behaviour.triggers) {
                    let trigger = concept.getTrigger(triggerName);
                    console.log(trigger.name+":", trigger.constructor.name, trigger.options);
                }
                console.groupEnd();
                console.group("Then:");
                for(let action of behaviour.actionChain.actions) {
                    debugAction(action);
                }
                console.groupEnd();
                console.groupEnd();
            }
            console.groupEnd();

            console.groupEnd();
        }

        console.groupEnd();

        console.groupCollapsed("Views - Closest view is first");

        let parent = evt.target;

        while(parent != null && parent.parentNode != null) {
            if(parent.matches("[view]")) {
                let viewName = parent.getAttribute("view");
                console.log("View:", viewName, parent);
            }

            parent = parent.parentNode;
        }

        console.groupEnd();

        console.groupCollapsed("Properties - ");
        for(let property of properties) {
            let type = property.property.type;

            if(type === "array") {
                type = property.property.options.items+"[]";
            }

            console.log(property.property.name+":", type);
        }
        console.groupEnd();

        console.groupEnd();
    }
}
window.Inspector = Inspector;
Inspector.instance = new Inspector();

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="varv-repos" id="mirrorverse-audio-router" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "MirrorVerse Audio Router",
    "description": "GUI for routing audio in MirrorVerse",
    "dependencies": [
        "codestrates-repos #editor_monaco",
        "webstrate-components-repos #MaterialMenu",
        "webstrate-components-repos #MaterialDesignOutlinedIcons",
        "webstrate-components-repos #WebstrateComponents_Tools"
    ],
    "optionalDependencies": [
    ],
    "assets": [],
    "license": "MIT",
    "version": "0.1",
    "changelog": {}
}

</SCRIPT><SCRIPT id="audio-router-script" type="disabled">
class MirrorVerseAudioRouter {
    static toVarv(json) {
        let outputVarv = {"concepts": {"audioManager":{"actions":{}}}};

        let usedNames = new Set();
        let uniqueIdMap = new Map();
        let alreadySetup = new Set();

        function getUniqueId(nodeId, nodeData) {
            if(uniqueIdMap.has(nodeId)) {
                return uniqueIdMap.get(nodeId);
            }

            let uniqueId = nodeId;

            if(nodeData.name != null && nodeData.name.length > 0) {
                uniqueId = nodeData.name;

                if(usedNames.has(uniqueId)) {
                    let i = 1;
                    while(usedNames.has(uniqueId+""+i)) {
                        i++;
                    }
                    uniqueId = uniqueId+""+i;
                }
            }

            usedNames.add(uniqueId);
            uniqueIdMap.set(nodeId, uniqueId);

            return uniqueId;
        }

        function createConnectionNode(uniqueId, index, nodeId, rootName) {
            let connectionActions = [];
            outputVarv.concepts.audioManager.actions[uniqueId+"NodeConnection"+index] = connectionActions;

            if(typeof nodeId === "string") {
                let nodeData = json.nodes[nodeId];
                let uniqueId = getUniqueId(nodeId, nodeData);

                if(nodeData.nodeType === "DecisionNode") {
                    connectionActions.push(uniqueId+"NodeIn");

                    if(alreadySetup.has(nodeId)) {
                        return;
                    }
                    alreadySetup.add(nodeId);

                    createDecisionNode(nodeData, uniqueId, rootName);
                } else {
                    //Value node
                    connectionActions.push("selectOriginalAudioStream");
                    let setAction = {"set":{}};

                    let value = nodeData.value;

                    if(rootName === "volume") {
                        value = parseFloat(value);
                    }

                    setAction.set[rootName] = nodeData.value;
                    connectionActions.push(setAction);
                }
            }
        }

        function createDecisionNode(nodeData, uniqueId, rootName) {
            let nodeInActions = [];
            outputVarv.concepts.audioManager.actions[uniqueId+"NodeIn"] = nodeInActions;

            //Select correct node
            switch(nodeData.concept) {
                case "client":
                    nodeInActions.push("selectClient")
                    break;
                case "currentRoom":
                    nodeInActions.push("selectCurrentRoom")
                    break;
                case "toolManager":
                    nodeInActions.push("selectToolManager")
                    break;
                default:
                    console.warn("Unknown concept:", nodeData.concept);
            }

            //Push decisions
            for(let decisionIndex = 1; decisionIndex<nodeData.decisions.length+1; decisionIndex++) {
                let decision = nodeData.decisions[decisionIndex-1];

                let decisionActions = [];
                outputVarv.concepts.audioManager.actions[uniqueId+"NodeDecision"+decisionIndex] = decisionActions;
                nodeInActions.push({"run": uniqueId+"NodeDecision"+decisionIndex});

                let where = {
                    "where": {
                        "property": nodeData.property,
                        "stopIfEmpty": true
                    }
                };

                where.where[decision.comparator] = decision.value;

                decisionActions.push(where);

                if(decision.connection != null) {
                    createConnectionNode(uniqueId, decisionIndex, decision.connection, rootName);
                    decisionActions.push(uniqueId + "NodeConnection" + decisionIndex);
                }
            }
        }

        if(json.rootConnections != null) {
            for(let rootName of Object.keys(json.rootConnections)) {
                let nodeId = json.rootConnections[rootName].connection;

                if(nodeId != null) {

                    if(json.nodes != null) {
                        let nodeData = json.nodes[nodeId];
                        let uniqueId = getUniqueId(nodeId, nodeData);

                        let actionKey = rootName + "RootConnection";
                        outputVarv.concepts.audioManager.actions[actionKey] = [
                            uniqueId + "NodeIn"
                        ];

                        try {
                            createDecisionNode(nodeData, uniqueId, rootName);
                        } catch (e) {
                            console.error(e);
                        }
                    }
                }
            }
        }

        console.log("Compiled varv:", outputVarv);

        return outputVarv;
    }

    static concepts() {
        return Object.assign({}, MirrorVerseAudioRouter.conceptPropertyList);
    }
}

MirrorVerseAudioRouter.conceptPropertyList = {
    "client": [
        "name",
        "local",
        "muted",
        "logicalDistance",
        "logicalVolume",
        "analyserVolume",
        "inHoveredRoom",
        "distance",
        "onPedestal",
        "whisperTarget",
        "broadcasting"
    ],
    "currentRoom": [
        "name",
        "audioFilter"
    ],
    "toolManager": [
        "listeningInActive",
        "listeningInHoveredExists",
        "gatherActive",
        "whisperActive",
        "whisperTargeted",
        "whisperTargetedBy"
    ]
};

window.MirrorVerseAudioRouter = MirrorVerseAudioRouter;

</SCRIPT><SCRIPT id="AudioRouterFragment-script" type="disabled">
class AudioRouterFragment extends Fragment {
    constructor(html) {
        super(html);

        //Setup raw on start
        this.oldRaw = this.raw;
    }

    async require(options = {}) {
        let defaultOptions = {
            pretty: false,
            auto: true
        }

        options = Object.assign({}, defaultOptions, options);

        let fragment = Fragment.create(ConceptDefinitionFragment.type());

        let json = null;

        try {
            json = JSON.parse(this.raw);
        } catch(e) {
            console.warn("Unable to parse json:", this.raw);
            json = {};
        }

        if(options.pretty) {
            fragment.raw = JSON.stringify(MirrorVerseAudioRouter.toVarv(json), null, 2);
        } else {
            fragment.raw = JSON.stringify(MirrorVerseAudioRouter.toVarv(json));
        }
        fragment.auto = options.auto;

        return fragment.html[0];
    }

    setupAutoDomHandling() {
        if(!this.supportsAutoDom()) {
            return;
        }

        let self = this;

        function sanitize(jsonRaw) {
            let json = JSON.parse(jsonRaw);

            if(json.unused != null) {
                json.unused.forEach((unused) => {
                    if (unused.type === "DecisionNode") {
                        delete json.nodes[unused.id];
                    }
                });
            }

            return JSON.stringify(json, (key, value)=>{
                if(key === "position") {
                    return null;
                }
                if(key === "unused") {
                    return null;
                }
                return value;
            }, 0);
        }

        this.registerOnFragmentChangedHandler((context) => {
            //Check if really updated, or just a position change
            let sanitizedNew = null;
            try {
                sanitizedNew = sanitize(self.raw);
            } catch(e) {
                console.warn(e);
            }

            let sanitizedOld = null;

            try {
                sanitizedOld = sanitize(this.oldRaw);
            } catch(e) {
                console.warn(e);
            }

            if(sanitizedOld !== sanitizedNew) {
                //Save new raw
                this.oldRaw = this.raw;
                self.autoDomDirty = true;
                if (self.auto && !Fragment.disableAutorun) {
                    self.insertAutoDom();
                }
            }
        });
    }

    supportsAutoDom() {
        return true;
    }

    static type() {
        return "text/mirrorverse-audio-router";
    }
}
window.AudioRouterFragment = AudioRouterFragment;
MonacoEditor.registerExtraType(AudioRouterFragment.type(), "json");
Fragment.registerFragmentType(AudioRouterFragment);

</SCRIPT><SCRIPT id="AudioRouterGUIEditor-script" type="disabled">
class AudioRouterGUIEditor extends Editor {
    constructor(fragment, options = {}) {
        super("mirrorverse-audio-router", fragment, options);

        this.setupEditor();
    }

    updatedCallback() {
        const self = this;
        if(this.updateCallbackTimeout == null) {
            this.updateCallbackTimeout = setTimeout(()=>{
                self.handleModelChanged();
                self.updateCallbackTimeout = null;
            }, 0);
        }
    }

    setupEditor() {
        const self = this;

        this.playArea = document.createElement("div");
        this.playArea.classList.add("mirrorverse-audio-router-maximized");
        //this.playArea.classList.add("mirrorverse-audio-router");
        this.svgArea = document.createElementNS('http://www.w3.org/2000/svg', "svg");
        this.svgArea.classList.add("mirrorverse-audio-router-maximized");
        this.editorDiv[0].appendChild(this.playArea);
        this.editorDiv[0].appendChild(this.svgArea);

        let lastDragPosition = null;

        this.playArea.addEventListener("pointerdown", (evt)=>{
            if(evt.button === 0) {
                evt.stopPropagation();
                lastDragPosition = {
                    x: evt.clientX,
                    y: evt.clientY
                }
            }
        });

        document.addEventListener("pointermove", (evt)=>{
            if(lastDragPosition != null) {
                evt.stopPropagation();

                let offsetX = evt.clientX - lastDragPosition.x;
                let offsetY = evt.clientY - lastDragPosition.y;

                let x = parseFloat(self.playArea.getAttribute("data-x"));
                let y = parseFloat(self.playArea.getAttribute("data-y"));

                if (isNaN(x)) {
                    x = 0;
                }

                if (isNaN(y)) {
                    y = 0;
                }

                x += offsetX;
                y += offsetY;

                if(x > 2500) {
                    x = 2500;
                }

                if(x < -2500) {
                    x = -2500;
                }

                if(y > 2500) {
                    y = 2500;
                }

                if(y < -2500) {
                    y = -2500;
                }

                self.playArea.setAttribute("data-x", x);
                self.playArea.setAttribute("data-y", y);

                self.playArea.style.left = x + "px";
                self.playArea.style.top = y + "px";

                lastDragPosition = {
                    x: evt.clientX,
                    y: evt.clientY
                }
            }
        });

        document.addEventListener("pointerup", (evt)=>{
            if(evt.button === 0) {
                lastDragPosition = null;
            }
        });

        function makeId(length) {
            let result = '';
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            const charactersLength = characters.length;
            let counter = 0;
            while (counter < length) {
                result += characters.charAt(Math.floor(Math.random() * charactersLength));
                counter += 1;
            }
            return result;
        }

        let menuId = makeId(10);

        this.playAreaContextMenu = MenuSystem.MenuManager.createMenu("mirrorverse-audio-router-playAreaContext"+menuId,{
            groupDividers: true
        });
        this.audioRouterNodeContextMenu = MenuSystem.MenuManager.createMenu("mirrorverse-audio-router-audioRouterNodeContext"+menuId);

        this.editorDiv[0].appendChild(this.playAreaContextMenu.html);
        this.editorDiv[0].appendChild(this.audioRouterNodeContextMenu.html);

        this.playArea.addEventListener("contextmenu", (evt)=>{
            evt.preventDefault();
            if(self.audioRouterNodeContextMenu.isOpen){
                self.audioRouterNodeContextMenu.close();
            }

            if(self.playAreaContextMenu.isOpen){
                self.playAreaContextMenu.close();
            }

            if(evt.target == this.playArea) {
                self.playAreaContextMenu.openPosition = {x:evt.clientX, y:evt.clientY};
                self.playAreaContextMenu.open({
                    x: evt.clientX,
                    y: evt.clientY
                });
            } else {
                self.audioRouterNodeContextMenu.context = evt.target;

                //Open node context
                self.audioRouterNodeContextMenu.open({
                    x: evt.clientX,
                    y: evt.clientY
                });
            }
        });

        function getRelativePos(menuPos) {

            let playAreaBounds = self.playArea.getBoundingClientRect();

            return {
                x: menuPos.x - playAreaBounds.x,
                y: menuPos.y - playAreaBounds.y
            }
        }

        this.menuItems = [];

        this.menuItems.push(MenuSystem.MenuManager.registerMenuItem("mirrorverse-audio-router-playAreaContext"+menuId, {
            label: "Recenter View",
            icon: IconRegistry.createIcon("mdc:zoom_in_map"),
            group: "View",
            groupOrder: 0,
            order: 0,
            onAction: (evt)=>{
                self.playArea.setAttribute("data-x", 0);
                self.playArea.setAttribute("data-y", 0);

                self.playArea.style.left = "0px";
                self.playArea.style.top = "0px";
            }
        }));
        this.menuItems.push(MenuSystem.MenuManager.registerMenuItem("mirrorverse-audio-router-playAreaContext"+menuId, {
            label: "Recenter Nodes",
            icon: IconRegistry.createIcon("mdc:shuffle"),
            group: "View",
            groupOrder: 0,
            order: 0,
            onAction: (evt)=>{
                let audioNodes = self.playArea.querySelectorAll(".mirrorVerseAudioRouterNode");

                let minX = 9999999999999;
                let minY = 9999999999999;

                let maxX = -9999999999999;
                let maxY = -9999999999999;

                audioNodes.forEach((elm)=>{
                    if(elm.hasAttribute("data-x")) {
                        let x = parseFloat(elm.getAttribute("data-x")) + elm.offsetWidth / 2.0;
                        let y = parseFloat(elm.getAttribute("data-y")) + elm.offsetHeight / 2.0;
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                });

                let centerX = minX + (maxX - minX) / 2.0;
                let centerY = minY + (maxY - minY) / 2.0;

                let editorCoreDiv = self.playArea.closest(".codestrates-editor-core");

                let centerViewX = Math.floor(2500 + editorCoreDiv.offsetWidth / 2.0);
                let centerViewY = Math.floor(2500 + editorCoreDiv.offsetHeight / 2.0);

                let offsetX = centerViewX - centerX;
                let offsetY = centerViewY - centerY;

                console.log("Center view:", centerViewX, centerViewY, centerX, centerY, offsetX, offsetY);

                audioNodes.forEach((elm)=>{
                    if(elm.hasAttribute("data-x")) {
                        let x = parseFloat(elm.getAttribute("data-x"));
                        let y = parseFloat(elm.getAttribute("data-y"));
                        x += offsetX;
                        y += offsetY;

                        elm.setAttribute("data-x", x);
                        elm.setAttribute("data-y", y);

                        elm.style.left = x+"px";
                        elm.style.top = y+"px";
                    }
                });
            }
        }));

        this.menuItems.push(MenuSystem.MenuManager.registerMenuItem("mirrorverse-audio-router-playAreaContext"+menuId, {
            label: "Insert Decision Node",
            icon: IconRegistry.createIcon("mdc:schema"),
            group: "DecisionNode",
            groupOrder: 10,
            order: 0,
            onAction: (evt)=>{
                let id = makeId(10);
                let fakeJson = {
                    "nodes": {}
                }

                fakeJson.nodes[id] = {
                    name: "",
                    concept: "client",
                    property: "name",
                    decisions: [],
                    position: getRelativePos(evt.menu.openPosition)
                }
                let node = new DecisionNode(id, fakeJson, self, ()=>{self.updatedCallback()});
                node.render(self.playArea);
                self.updatedCallback();
            }
        }));

        ["muted", "volume", "audioFilter"].forEach((rootName)=>{
            let icon = "";

            if(rootName == "volume") {
                icon = "mdc:volume_up";
            }

            if(rootName == "muted") {
                icon = "mdc:volume_mute";
            }

            if(rootName == "audioFilter") {
                icon = "mdc:filter_alt";
            }

            self.menuItems.push(MenuSystem.MenuManager.registerMenuItem("mirrorverse-audio-router-playAreaContext"+menuId, {
                label: "Insert "+rootName+" root node",
                icon: IconRegistry.createIcon(icon),
                group: "RootNode",
                groupOrder: 5,
                order: 0,
                onAction: (evt)=>{
                    let fakeJson = {
                        "rootConnections": {}
                    }

                    fakeJson.rootConnections[rootName] = {
                        position: getRelativePos(evt.menu.openPosition),
                        connection: null
                    }

                    let node = new RootNode(rootName, fakeJson, self, ()=>{self.updatedCallback()});
                    node.render(self.playArea);
                    self.updatedCallback();
                },
                onOpen: (evt)=>{
                    let found = false;
                    for(let node of self.playArea.querySelectorAll(".mirrorVerseAudioRouterRootNode")) {
                        if(node.audioRoutingNode.rootName === rootName) {
                            found = true;
                            break;
                        }
                    }

                    return !found;
                }
            }));

            self.menuItems.push(MenuSystem.MenuManager.registerMenuItem("mirrorverse-audio-router-playAreaContext"+menuId, {
                label: "Insert "+rootName+" value node",
                icon: IconRegistry.createIcon(icon),
                group: "ValueNode",
                groupOrder: 20,
                order: 0,
                onAction: (evt)=>{
                    let value = true;

                    if(rootName === "volume") {
                        value = 0.0;
                    } else if(rootName === "audioFilter") {
                        value = "none";
                    }

                    let id = makeId(10);

                    let fakeJson = {
                        type: rootName,
                        value: value,
                        position: getRelativePos(evt.menu.openPosition)
                    }

                    let node = new ValueNode(id, fakeJson, self, ()=>{self.updatedCallback()});
                    node.render(self.playArea);

                    self.updatedCallback();
                }
            }));
        })

        self.menuItems.push(MenuSystem.MenuManager.registerMenuItem("mirrorverse-audio-router-audioRouterNodeContext"+menuId, {
            label: "Delete",
            icon: IconRegistry.createIcon("mdc:extension"),
            order: 0,
            onAction: (evt)=>{
                let audioRouterElm = evt.menu.context.closest(".mirrorVerseAudioRouterNode");

                if(audioRouterElm != null) {
                    audioRouterElm.audioRoutingNode.delete();
                }
            }
        }));

        self.menuItems.push(MenuSystem.MenuManager.registerMenuItem("mirrorverse-audio-router-audioRouterNodeContext"+menuId, {
            label: "Disconnect",
            icon: IconRegistry.createIcon("mdc:extension"),
            order: 0,
            onAction: (evt)=>{
                let audioRouterElm = evt.menu.context.closest(".mirrorVerseAudioRouterNode");

                if(audioRouterElm != null) {
                    audioRouterElm.audioRoutingNode.disconnectFromParent();
                    self.updatedCallback();
                }
            },
            onOpen: (evt)=>{
                return false;

                let audioRouterElm = evt.context.closest(".mirrorVerseAudioRouterNode");

                if(audioRouterElm != null) {
                    if(audioRouterElm.audioRoutingNode instanceof DecisionNode || audioRouterElm.audioRoutingNode instanceof ValueNode) {
                        return true;
                    }
                }

                return false;
            }
        }));

        if(VarvEngine.concepts.length > 0) {
            this.load(this.fragment.raw);
        } else {
            let first = true;
            VarvEngine.registerEventCallback("engineReloaded", ()=>{
                if(first) {
                    first = false;
                    self.load(this.fragment.raw);
                }
            });
        }

        let mutationObserver = new MutationObserver((mutations)=>{
            self.redrawSvgLines();
        });
        mutationObserver.observe(this.playArea, {
            attributes: true,
            childList: true,
            attributeFilter: ["data-x", "data-y"],
            subtree: true
        });

        let svgMutationObserver = new MutationObserver((mutations)=>{
            self.checkTypes();
        });
        svgMutationObserver.observe(this.svgArea, {
            childList: true,
            subtree: true
        });
    }

    redrawSvgLines() {
        this.svgArea.querySelectorAll("line").forEach((line)=>{
            line.svgLine.redraw();
        });
    }

    checkTypes() {
        this.playArea.querySelectorAll(".mirrorVerseAudioRouterNode").forEach((elm)=>{
            elm.audioRoutingNode.checkUnused();
            elm.audioRoutingNode.checkType();
        });
    }

    load(jsonRaw) {
        console.groupCollapsed("Load");
        console.trace();
        console.groupEnd();

        const self = this;

        self.handleModelChanges = false;

        let json = {};

        try {
            json = JSON.parse(jsonRaw);
        } catch(e) {

        }

        //Clear editor
        while(this.playArea.lastChild != null) {
            this.playArea.lastChild.remove();
        }

        if(json.rootConnections != null) {
            Array.from(Object.keys(json.rootConnections)).forEach((rootName) => {
                let rootNode = new RootNode(rootName, json, self, ()=>{self.updatedCallback()});
                rootNode.render(self.playArea);
            });
        }

        if(json.unused != null) {
            json.unused.forEach((unused)=>{
                let nodeData = json.nodes[unused.id];
                switch(nodeData.nodeType) {
                    case "ValueNode": {
                        let node = new ValueNode(unused.id,nodeData, self, ()=>{self.updatedCallback()});
                        node.render(self.playArea);
                        break;
                    }

                    case "DecisionNode": {
                        //Check if decision node already was loaded?
                        let found = false;
                        for(let decisionElm of self.playArea.querySelectorAll(".mirrorVerseAudioRouterDecisionNode")) {
                            if(decisionElm.audioRoutingNode.id === unused.id) {
                                found = true;
                                break;
                            }
                        }

                        if(!found) {
                            let node = new DecisionNode(unused.id, json, self, () => {
                                self.updatedCallback()
                            });
                            node.render(self.playArea);
                        }
                        break;
                    }

                    default:
                        console.warn("Unknown unused type:", unused);
                }
            });
        }

        setTimeout(()=>{
            this.redrawSvgLines();
            this.checkTypes();
        }, 0);

        self.handleModelChanges = true;
    }

    setValue(value) {
        if(this.loadAnimationId == null) {
            this.loadAnimationId = requestAnimationFrame(()=>{
                this.load(value);
                this.loadAnimationId = null;
            });
        }
    }

    getValue() {
        let result = {
            "rootConnections": {},
            "nodes": {},
            "unused": []
        };

        function handleValueNode(valueNode) {
            valueNode.html.classList.remove("unused");

            let valueNodeResult = {
                "nodeType": "ValueNode",
                value: valueNode.value,
                position: valueNode.getPosition(),
                type: valueNode.type
            };

            return valueNodeResult;
        }

        function handleDecision(decision) {
            let decisionResult = {
                "comparator": decision.decision.comparator,
                "value": decision.decision.value
            };

            if(decision.children.length === 1) {
                let connectionNode = decision.children[0];

                decisionResult.connection = connectionNode.id;

                if(connectionNode instanceof DecisionNode) {
                    let decisionNodeResult = handleDecisionNode(connectionNode);
                    result.nodes[connectionNode.id] = decisionNodeResult;
                } else if(connectionNode instanceof ValueNode) {
                    let valueNodeResult = handleValueNode(connectionNode);
                    result.nodes[connectionNode.id] = valueNodeResult;
                } else {
                    throw new Error("Unknown decision connection:"+JSON.stringify(connectionNode, null, 2));
                }
            } else if(decision.children.length > 1) {
                throw new Error("Weird setup, root node has more than 1 decision node beneath it?");
            }

            return decisionResult;
        }

        function handleDecisionNode(decisionNode) {
            decisionNode.html.classList.remove("unused");

            let decisionNodeResult = {
                "nodeType": "DecisionNode",
                "name": decisionNode.data.name,
                "concept": decisionNode.data.concept,
                "property": decisionNode.data.property,
                "decisionCount": decisionNode.children.length,
                "decisions": []
            }

            decisionNode.children.forEach((decision) =>{
                let decisionResult = handleDecision(decision);

                decisionNodeResult.decisions.push(decisionResult);
            });

            decisionNodeResult.position = decisionNode.getPosition();

            return decisionNodeResult;
        }

        //Mark all as unused
        this.playArea.querySelectorAll(".mirrorVerseAudioRouterNode").forEach((elm)=>{
            elm.classList.add("unused");
        });

        this.playArea.querySelectorAll(".mirrorVerseAudioRouterRootNode").forEach((rootElm)=>{
            //Handle root node
            rootElm.classList.remove("unused");
            let rootNode = rootElm.audioRoutingNode;

            let rootResult = {
                "position": rootNode.getPosition()
            };

            result.rootConnections[rootNode.rootName] = rootResult;

            if(rootNode.children.length === 1) {
                let decisionNode = rootNode.children[0];
                rootResult.connection = decisionNode.id;

                let decisionNodeResult = handleDecisionNode(decisionNode);

                result.nodes[decisionNode.id] = decisionNodeResult;

            } else if(rootNode.children.length > 1) {
                throw new Error("Weird setup, root node has more than 1 decision node beneath it?");
            }
        });

        function handleUnused(elm) {
            elm.classList.remove("unused");

            let node = elm.audioRoutingNode;

            if(node instanceof ValueNode) {
                let valueResult = handleValueNode(node);
                result.nodes[node.id] = valueResult;
                result.unused.push({
                    "id": node.id
                });
            }
            if(node instanceof DecisionNode) {
                let decisionResult = handleDecisionNode(node);
                result.nodes[node.id] = decisionResult;
                result.unused.push({
                    "id": node.id
                });
            }
        }

        this.playArea.querySelectorAll(".mirrorVerseAudioRouterDecisionNode.unused").forEach((elm)=>{
            handleUnused(elm);
        });

        this.playArea.querySelectorAll(".mirrorVerseAudioRouterValueNode.unused").forEach((elm)=>{
            handleUnused(elm);
        });

        return JSON.stringify(result, null, 2);
    }

    unload() {
        if(this.audioRouterNodeContextMenu != null) {
            this.audioRouterNodeContextMenu.destroy();
            this.audioRouterNodeContextMenu = null;
        }

        if(this.playAreaContextMenu != null) {
            this.playAreaContextMenu.destroy();
            this.playAreaContextMenu = null;
        }

        this.menuItems.forEach((menuItem)=>{
            menuItem.delete();
        });

        super.unload();
    }

    static types() {
        return [
            AudioRouterFragment.type()
        ]
    }
}
window.AudioRouterGUIEditor = AudioRouterGUIEditor;
EditorManager.registerEditor(AudioRouterGUIEditor);

class Node {
    constructor(editor, updateCallback) {
        this.children = [];
        this.editor = editor;
        this.svg = this.editor.svgArea;
        this.updateCallback = updateCallback;
        this.connectionLine = null;
        this.connectionPoint = null;
    }

    checkType() {
        console.warn("Override in subclass [checkType]:", this);
    }

    findRootNodes() {
        let rootNodes = [];

        let parents = this.findParentNodes();

        parents.forEach((parent)=>{
            if(parent instanceof RootNode) {
                rootNodes.push(parent);
            } else {
                rootNodes.push(...parent.findRootNodes());
            }
        });



        return Array.from(new Set(rootNodes));
    }

    findParentNodes() {
        let parents = [];

        for(let line of this.svg.querySelectorAll("line")) {
            if(line.svgLine.endElement === this.html) {
                let audioNodeElm = line.svgLine.startElement.closest(".mirrorVerseAudioRouterNode");
                if(audioNodeElm != null) {
                    let audioRouterNode = audioNodeElm.audioRoutingNode;
                    parents.push(audioRouterNode);
                }
            }
        }

        return parents;
    }

    checkUnused() {
        this.html.classList.remove("error");
        this.html.classList.remove("mirrorVerseUnused");

        if(this.findRootNodes().length === 0) {
            this.html.classList.add("mirrorVerseUnused");
        } else if(this.findRootNodes().length > 1) {
            this.html.classList.add("error");
        }
    }

    delete() {
        this.html.remove();

        this.disconnectAll();

        this.disconnectFromParents();

        this.updated();
    }

    disconnectFromParents() {
        const self = this;

        this.svg.querySelectorAll("line").forEach((line) => {
            if (line.svgLine.endElement === self.html) {
                let audioRoutingNode = line.svgLine.startElement.closest(".mirrorVerseAudioRouterNode").audioRoutingNode;
                if(audioRoutingNode != null) {
                    audioRoutingNode.disconnect(self);
                }
            }
        });
    }

    onConnection(parentNode) {
        this.checkType();
    }

    getPosition() {
        if(this.html != null) {
            let x = parseFloat(this.html.getAttribute("data-x"));
            if(isNaN(x)) {
                x = 0;
            }
            let y = parseFloat(this.html.getAttribute("data-y"));
            if(isNaN(y)) {
                y = 0;
            }
            return {
                x, y
            }
        }

        return null;
    }

    setPosition(pos) {
        if(pos != null && pos.x != null && pos.y != null) {
            this.html.setAttribute("data-x", pos.x);
            this.html.setAttribute("data-y", pos.y);
            this.html.style.left = pos.x + "px";
            this.html.style.top = pos.y + "px";
        }
    }

    updated() {
        this.updateCallback();
    }

    renderSelf(container) {
        console.warn("Override in subclass [renderSelf]:", this);
    }

    render(container) {
        const self = this;

        this.renderSelf(container);

        if(this.html.classList.contains("draggable")) {
            this.setupDrag(this.html, (offsetX, offsetY) => {
                let x = parseFloat(self.html.getAttribute("data-x"));
                let y = parseFloat(self.html.getAttribute("data-y"));

                if (isNaN(x)) {
                    x = 0;
                }

                if (isNaN(y)) {
                    y = 0;
                }

                x += offsetX;
                y += offsetY;

                self.html.setAttribute("data-x", x);
                self.html.setAttribute("data-y", y);

                self.html.style.left = x + "px";
                self.html.style.top = y + "px";

                self.updated();
            }, (dropTarget) => {
                //Ignore drop
            });
        }

        this.children.forEach((child) => {
            child.render(container);
        });
    }

    setupDrag(element, dragCallback, dropCallback) {
        const self = this;

        let lastDragPosition = null;

        if(element.draggingEnabled === true) {
            //Dragging already setup on this element, skip
            return;
        }

        element.draggingEnabled = true;

        element.addEventListener("pointerdown", (evt)=>{
            if(evt.target.matches("input, select, option, button")) {
                return;
            }

            if(evt.button === 0) {
                evt.stopPropagation();
                lastDragPosition = {
                    x: evt.clientX,
                    y: evt.clientY
                };
            }
        });

        document.addEventListener("pointermove", (evt)=>{
            if(lastDragPosition != null) {
                evt.stopPropagation();

                let offsetX = evt.clientX - lastDragPosition.x;
                let offsetY = evt.clientY - lastDragPosition.y;

                dragCallback(offsetX, offsetY, evt);

                lastDragPosition = {
                    x: evt.clientX,
                    y: evt.clientY
                }
            }
        })

        document.addEventListener("pointerup", (evt)=>{
            if(lastDragPosition != null) {
                lastDragPosition = null;
                dropCallback(evt);
            }
        });
    }

    setupConnectionDragging(connectionOut) {
        const self = this;

        let lineDragElement = null;
        let svgLine = null;

        this.setupDrag(connectionOut, (offsetX, offsetY, evt)=>{
            if(lineDragElement == null) {
                lineDragElement = document.createElement("div");
                lineDragElement.style.position = "absolute";
                lineDragElement.style.display = "inline-block";
                lineDragElement.style.height = "1em";
                lineDragElement.style.width = "1em";
                lineDragElement.style.backgroundColor = "lime";

                let elementX = parseFloat(self.html.getAttribute("data-x"));
                let elementY = parseFloat(self.html.getAttribute("data-y"));

                if(isNaN(elementX)) {
                    elementX = 0;
                }

                if(isNaN(elementY)) {
                    elementY = 0;
                }

                lineDragElement.setAttribute("data-x", (elementX+evt.target.offsetLeft));
                lineDragElement.setAttribute("data-y", (elementY+evt.target.offsetTop));

                svgLine = new SVGLine(connectionOut, lineDragElement, self.svg);

                self.html.parentNode.appendChild(lineDragElement);
            }

            let x = parseFloat(lineDragElement.getAttribute("data-x"));
            let y = parseFloat(lineDragElement.getAttribute("data-y"));

            if(isNaN(x)) {
                x = 0;
            }

            if(isNaN(y)) {
                y = 0;
            }

            x += offsetX;
            y += offsetY;

            lineDragElement.setAttribute("data-x", x);
            lineDragElement.setAttribute("data-y", y);

            lineDragElement.style.left = x + "px";
            lineDragElement.style.top = y + "px";

            //svgLine.redraw();
        }, (evt)=>{
            if(lineDragElement != null) {
                lineDragElement.remove();
                lineDragElement = null;
            }

            if(svgLine != null) {
                svgLine.remove();
                svgLine = null;
            }

            let possibleConnection = document.elementFromPoint(evt.clientX, evt.clientY);

            if(possibleConnection != null) {
                possibleConnection = possibleConnection.closest(".connectionTarget");
                if(possibleConnection != null) {
                    let source = possibleConnection.audioRoutingNode;
                    self.connect(source);
                }
            }
        });
    }

    connect(node) {
        if(node instanceof DecisionNode) {
            //Check if node is our own parent
            let ourNode = this.html.closest(".mirrorVerseAudioRouterNode")?.audioRoutingNode;

            //Check if we would create a loop
            let foundLoop = false;
            function findLoop(testNode) {
                if(testNode === ourNode) {
                    foundLoop = true;
                    return;
                }

                testNode.children.forEach((child)=>{
                    //Decisions inside here, as we are children of a DecisionNode
                    if(child.children.length > 0) {
                        if(child.children[0] instanceof DecisionNode) {
                            findLoop(child.children[0]);
                        }
                    }
                })
            }

            findLoop(node);

            if(foundLoop) {
                console.log("Found loop, unable to connect:", node);
                return;
            }
        }

        //No loop continue

        //Remove old connection out from us
        if(this.connectionLine != null) {
            this.connectionLine.remove();
        }

        let connectPoint = this.html;

        if(this.connectionPoint != null) {
            connectPoint = this.connectionPoint;
        }

        this.connectionLine = new SVGLine(connectPoint, node.html, this.svg, true);

        this.updated();

        this.onConnected(node);

        node.onConnection(this);
    }

    onConnected(childNode) {
        console.warn("Override in subclass [onConnected]:", this);
    }

    disconnect(child) {
        const self = this;

        if(this.connectionLine != null) {
            this.connectionLine.remove();
        }

        this.onDisconnected(child);
    }

    onDisconnected(child) {
        console.warn("Override in subclass [onDisconnected]", this);
    }

    disconnectAll() {
        console.warn("Override in subclass [disconnectAll]:", this);
    }

    getNodeFromId(id) {
        let foundNode = null;

        for(let nodeElm of this.editor.playArea.querySelectorAll(".mirrorVerseAudioRouterNode")) {
            if(nodeElm?.audioRoutingNode?.id === id) {
                foundNode = nodeElm.audioRoutingNode;
                break;
            }
        }

        return foundNode;
    }
}

class ValueNode extends Node {
    constructor(nodeId, data, editor, updateCallback) {
        super(editor, updateCallback);

        this.id = nodeId;
        this.type = data.type;
        this.value = data.value;
        this.position = data.position;

        this.setup();
        this.checkUnused();
    }

    checkType() {
        const self = this;

        let roots = this.findRootNodes();

        this.html.classList.remove("error");

        roots.forEach((root)=>{
            if(root != null && root.rootName !== self.type) {
                self.html.classList.add("error");
            }
        });
    }

    setup() {
        const self = this;

        this.html = WebstrateComponents.Tools.loadTemplate("#mirrorverse-audio-router-ValueNode");
        this.html.audioRoutingNode = this;
        this.html.querySelectorAll(".type").forEach((elm)=>{
            elm.classList.add("hidden");
        });

        this.setPosition(this.position);

        this.renderSelf(this.editor.playArea);

        switch(this.type) {
            case "muted":
                this.html.querySelector(".type.muted").classList.remove("hidden");
                this.html.querySelector(".type.muted input").checked = this.value;

                this.html.querySelector(".type.muted input").addEventListener("change", ()=>{
                    self.value = this.html.querySelector(".type.muted input").checked;
                    self.updated();
                });

                break;
            case "volume":
                this.html.querySelector(".type.volume").classList.remove("hidden");
                this.html.querySelector(".type.volume input").value = this.value;

                this.html.querySelector(".type.volume input").addEventListener("change", ()=>{
                    self.value = parseFloat(this.html.querySelector(".type.volume input").value);

                    if(self.value > 1) {
                        self.value = 1;
                    }

                    if(self.value < 0) {
                        self.value = 0;
                    }

                    self.updated();
                });

                break;
            case "audioFilter":
                this.html.querySelector(".type.audioFilter").classList.remove("hidden");
                this.html.querySelector(".type.audioFilter select").value = this.value;

                this.html.querySelector(".type.audioFilter select").addEventListener("change", ()=>{
                    self.value = this.html.querySelector(".type.audioFilter select").value;
                    self.updated();
                });

                break;
            default:
                console.warn("Unknown ValueNode type:", this);
        }
    }

    renderSelf(container) {
        if(this.html.closest("html") == null) {
            container.appendChild(this.html);
        }
    }

    disconnectAll() {
        //Do nothing
    }
}

class RootNode extends Node {
    constructor(rootName, json, editor, updateCallback) {
        super(editor, updateCallback);

        this.rootName = rootName;

        this.connectionLine = null;

        this.setup(json);
    }

    disconnectAll() {
        if(this.children.length > 0) {
            this.disconnect(this.children[0]);
        }
    }

    onDisconnected() {
        this.children = [];
    }

    checkUnused() {
        //Do nothing
    }

    checkType() {
        //Do nothing
    }

    setup(json) {
        const self = this;

        this.html = WebstrateComponents.Tools.loadTemplate("#mirrorverse-audio-router-rootNode");
        this.html.audioRoutingNode = this;

        this.setPosition(json.rootConnections[this.rootName].position);

        this.connectionPoint = this.html.querySelector(".connectionOut");

        let nodeId = json.rootConnections[this.rootName].connection;
        if(nodeId != null) {
            let decisionNode = this.getNodeFromId(nodeId);
            if(decisionNode == null) {
                decisionNode = new DecisionNode(nodeId, json, this.editor, this.updateCallback);
            }

            this.connect(decisionNode);
        }

        this.setupConnectionDragging(this.connectionPoint);
    }

    renderSelf(container) {
        if(this.html.closest("html") == null) {
            container.appendChild(this.html);
        }

        this.html.querySelector(".title").textContent = this.rootName;
    }

    onConnected(childNode) {
        if(! (childNode instanceof DecisionNode)) {
            this.disconnect(childNode);
            return;
        }
        this.children = [childNode];
    }
}

class Decision extends Node {
    constructor(decision, node, json, editor, updateCallback) {
        super(editor, updateCallback);

        this.decision = decision;
        this.node = node;

        this.setup(json);
    }

    checkType() {
        let conceptType = this.node.data.concept;

        if(conceptType === "currentRoom") {
            conceptType = "containerMirror";
        }

        let concept = VarvEngine.getConceptFromType(conceptType);
        let property = concept.getProperty(this.node.data.property);

        let type = property.type;
        let arrayType = null;

        if(property.isConceptType()) {
            type = "concept";
        }

        if(type === "array") {
            arrayType = property.getArrayType();

            if(property.isConceptArrayType()) {
                arrayType = "concept";
            }
        }

        let oldType = this.html.getAttribute("data-type");

        if(oldType !== type) {
            console.log("Setting property type:", type, arrayType, this.html.querySelector("."+type+" .value"));

            this.html.setAttribute("data-type", type);

            this.html.querySelectorAll(".type, .arrayType").forEach((elm)=>{
                elm.classList.add("hidden");
            });

            this.html.querySelectorAll(".type."+type).forEach((elm)=>{
                elm.classList.remove("hidden");
            });

            switch (type) {
                case "boolean": {
                    this.decision.comparator = "equals";
                    this.html.querySelector(".boolean:not(.hidden) .value").value = this.decision.value;
                    let value = this.html.querySelector(".boolean:not(.hidden) .value").value === "true";

                    //If we dont have a correct value, default to true
                    this.html.querySelector(".boolean:not(.hidden) .value").value = value;

                    this.decision.value = value;

                    break;
                }

                case "number": {
                    this.html.querySelector(".number:not(.hidden) .value").value = this.decision.value;
                    this.html.querySelector(".number:not(.hidden) .comparator").value = this.decision.comparator;

                    let value = parseFloat(this.html.querySelector(".number:not(.hidden) .value").value);

                    if(isNaN(value) || value == null) {
                        value = 1.0;
                        this.html.querySelector(".number:not(.hidden) .value").value = 1.0;
                    }

                    this.decision.value = value;

                    break;
                }

                case "string": {
                    console.log("String!");
                    this.html.querySelector(".string:not(.hidden) .value").value = this.decision.value;
                    this.html.querySelector(".string:not(.hidden) .comparator").value = this.decision.comparator;
                    break;
                }

                case "concept": {
                    this.html.querySelector(".concept:not(.hidden) .value").value = this.decision.value;
                    this.html.querySelector(".concept:not(.hidden) .comparator").value = this.decision.comparator;
                    break;
                }

                case "array": {
                    this.html.querySelectorAll(".arrayType."+arrayType).forEach((elm)=>{
                        elm.classList.remove("hidden");
                    });

                    this.decision.comparator = "includes";

                    switch(arrayType) {
                        case "boolean": {
                            this.html.querySelector(".array .boolean .value").value = this.decision.value;
                            let value = this.html.querySelector(".array .boolean .value").value === "true";

                            //If we dont have a correct value, default to true
                            this.html.querySelector(".array .boolean .value").value = value;

                            this.decision.value = value;

                            break;
                        }

                        case "number": {
                            this.html.querySelector(".array .number .value").value = this.decision.value;

                            let value = parseFloat(this.html.querySelector(".array .number .value").value);

                            if(isNaN(value) || value == null) {
                                value = 1.0;
                                this.html.querySelector(".array .number .value").value = 1.0;
                            }

                            this.decision.value = value;

                            break;
                        }

                        case "string": {
                            this.html.querySelector(".array .string .value").value = this.decision.value;
                            break;
                        }

                        case "concept": {
                            this.html.querySelector(".array .concept .value").value = this.decision.value;
                            break;
                        }

                        default:
                            console.warn("Unknown array type:", arrayType);
                    }

                    break;
                }

                default:
                    console.warn("Unknown proprety type:", type);
            }

            let currentComparator = this.html.querySelector(".type:not(.hidden) .comparator");

            if(currentComparator?.value === "") {
                currentComparator.selectedIndex = 0;
                this.decision.comparator = currentComparator.value;
                console.log("Reset comparator to:", this.decision.comparator);
            }

            this.updated();
        }
    }

    setup(json) {
        const self = this;

        this.html = WebstrateComponents.Tools.loadTemplate("#mirrorverse-audio-router-decision");
        this.html.audioRoutingNode = this;

        this.checkType();

        this.html.querySelectorAll(".boolean .value, .string .value, .concept .value").forEach((elm)=>{
            elm.addEventListener("change", ()=>{
                console.log("Value changed:", elm, elm.value);
                self.decision.value = elm.value;
                self.updated();
            });
        });

        this.html.querySelectorAll(".number .value").forEach((elm)=>{
            elm.addEventListener("change", ()=>{
                let value = parseFloat(elm.value);

                console.log("Value changed:", elm, value);

                self.decision.value = value;
                self.updated();
            });
        });

        this.html.querySelectorAll(".comparator").forEach((comparatorElm)=>{
            comparatorElm.addEventListener("change", (evt)=>{
                console.log("Comparator changed:", evt);
                self.decision.comparator = evt.target.value;
                self.updated();
            });
        });

        this.connectionPoint = this.html.querySelector(".connectionOut");

        if(this.decision.connection != null) {
            let data = json.nodes[this.decision.connection];

            let connectionNode = this.getNodeFromId(this.decision.connection);

            if(connectionNode == null) {
                if (data?.nodeType === "DecisionNode") {
                    connectionNode = new DecisionNode(this.decision.connection, json, this.editor, this.updateCallback);
                } else if (data?.nodeType === "ValueNode") {
                    connectionNode = new ValueNode(this.decision.connection, data, this.editor, this.updateCallback);
                }
            }

            if(connectionNode != null) {
                this.connect(connectionNode);
            }
        }

        this.setupConnectionDragging(this.connectionPoint);
    }

    isConnected(child) {
        if(this.children.length > 0) {
            return this.children[0] === child;
        }

        return false;
    }

    disconnectAll() {
        if(this.children.length > 0) {
            this.disconnect(this.children[0]);
        }
    }

    onConnected(childNode) {
        this.children = [childNode];
    }

    onDisconnected() {
        this.children = [];
    }

    renderSelf(container) {

    }
}

class DecisionNode extends Node {
    constructor(nodeId, json, editor, updateCallback) {
        super(editor, updateCallback);

        this.id = nodeId;
        this.data = json.nodes[this.id];

        this.setup(json);

        this.checkUnused();
    }

    disconnectAll() {
        const self = this;

        this.children.forEach((decision)=>{
            decision.disconnectAll();
        });
    }

    disconnect(child) {
        this.children.forEach((decision)=>{
            if(decision.isConnected(child)) {
                decision.disconnect(child);
            }
        });
    }

    checkType() {
        //Do nothing
    }

    setup(json) {
        const self = this;

        this.html = WebstrateComponents.Tools.loadTemplate("#mirrorverse-audio-router-decisionNode");
        this.html.audioRoutingNode = this;

        this.setPosition(this.data.position);

        this.renderSelf(this.editor.playArea);

        let conceptSelect = this.html.querySelector(".concept select");

        conceptSelect.addEventListener("change", ()=>{
            self.data.concept = conceptSelect.value;
            self.updatePropertyDropdown();
            self.updated();
        });

        let propertySelect = this.html.querySelector(".property select");
        propertySelect.addEventListener("change", ()=>{
            self.data.property = propertySelect.value;
            self.updateDecisions();
            self.updated();
        });

        this.data.decisions.forEach((decision)=>{
            self.children.push(new Decision(decision, self, json, self.editor, self.updateCallback));
        })

        this.html.querySelector(".addDecision").addEventListener("click", ()=>{
            let fakeJson = {value: "", comparator: "equals"};
            let decision = new Decision(fakeJson, self, json, self.editor, self.updateCallback);
            self.children.push(decision);
            self.render(self.html.parentNode);
            self.updated();
        });
        this.html.querySelector(".removeDecision").addEventListener("click", ()=>{
            if(self.children.length > 0) {
                let lastDecision = self.children.pop();

                lastDecision.delete();
            }
        });
    }

    updateDecisions() {
        this.children.forEach((decision)=>{
            decision.checkType();
        });
    }

    renderSelf(container) {
        const self = this;

        if(this.html.closest("html") == null) {
            container.appendChild(this.html);
        }

        this.html.querySelector(".name input").value = this.data.name;
        this.html.querySelector(".id").textContent = this.id;
        this.html.querySelector(".concept select").value = this.data.concept;

        this.updatePropertyDropdown(true);

        this.html.querySelector(".property select").value = this.data.property;

        let decisionsDiv = this.html.querySelector(".decisions");

        decisionsDiv.innerHTML = "";
        this.children.forEach((decision)=>{
            decisionsDiv.appendChild(decision.html);
        });

        this.html.querySelector(".name input").addEventListener("change", ()=>{
            self.data.name = self.html.querySelector(".name input").value;
            self.updated();
        })
    }

    updatePropertyDropdown(skipSelect = false) {
        let propertySelect = this.html.querySelector(".property select");
        propertySelect.innerHTML = "";

        MirrorVerseAudioRouter.concepts()[this.data.concept].forEach((property)=>{
            let option = document.createElement("option");
            option.value = property;
            option.textContent = property;

            propertySelect.appendChild(option);
        });

        if(!skipSelect) {
            this.data.property = propertySelect.value;
            this.updateDecisions();
        }
    }
}

class SVGLine {
    constructor(startElement, endElement, svg, connectTopMiddle=false) {
        this.lineElement = document.createElementNS('http://www.w3.org/2000/svg', "line");
        this.lineElement.classList.add("mirrorverse-audio-routing-connection");
        this.startElement = startElement;
        this.endElement = endElement;
        this.svg = svg;
        this.connectTopMiddle = connectTopMiddle;

        this.lineElement.svgLine = this;

        this.svg.appendChild(this.lineElement);

        this.redraw();
    }

    redraw() {
        const self = this;

        function getPosition(elm, connectTopMiddle) {
            const bounds = elm.getBoundingClientRect();

            const svgBounds = self.svg.getBoundingClientRect();

            if(connectTopMiddle) {
                return {
                    x: (bounds.x - svgBounds.x) + bounds.width / 2.0,
                    y: (bounds.y - svgBounds.y)
                }
            } else {
                return {
                    x: (bounds.x - svgBounds.x) + bounds.width / 2.0,
                    y: (bounds.y - svgBounds.y) + bounds.height / 2.0
                }
            }
        }

        let start = getPosition(this.startElement);
        let end = getPosition(this.endElement, this.connectTopMiddle);

        this.lineElement.setAttribute("x1", start.x);
        this.lineElement.setAttribute("y1", start.y);
        this.lineElement.setAttribute("x2", end.x);
        this.lineElement.setAttribute("y2", end.y);
    }

    remove() {
        this.lineElement.remove();
    }
}

//Setup cauldron menu item
MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Edit with AudioRouter GUI",
    icon: IconRegistry.createIcon("mdc:account_tree"),
    group: "EditActions",
    groupOrder: 0,
    order: 200,
    onOpen: (menu) => {
        if (menu.context.type == "DomTreeNode" && menu.context.context.matches("code-fragment[data-type='"+AudioRouterFragment.type()+"']")) {
            return true;
        }
    },
    onAction: (menuItem) => {
        EventSystem.triggerEvent("Varv.Open.AudioRouterGUI", {
            fragment: Fragment.one(menuItem.menu.context.context)
        });
    }
});

EventSystem.registerEventCallback("Varv.Open.AudioRouterGUI", (evt)=>{
    const detail = {
        fragment: evt.detail.fragment,
        editorClass: AudioRouterGUIEditor,
        titleWrapper: (t) => {
            return t + " - AudioRouter"
        }
    };

    if(evt.detail.line != null) {
        detail.line = evt.detail.line;
    }

    EventSystem.triggerEvent("Cauldron.Open.FragmentEditor", detail);
});

MenuSystem.MenuManager.registerMenuItem("Cauldron.Editor.Toolbar", {
    label: "Export",
    icon: IconRegistry.createIcon("mdc:ios_share"),
    group: "EditActions",
    groupOrder: 0,
    order: 200,
    onOpen: (menu) => {
        return menu.context instanceof AudioRouterFragment;
    },
    onAction: (menuItem) => {
        let fragment = menuItem.menu.context;

        fragment.require({pretty: true, auto: false}).then((codeFragment)=>{
            codeFragment.auto = false;
            WPMv2.stripProtection(codeFragment);
            fragment.html[0].parentNode.insertBefore(codeFragment, fragment.html[0].nextElementSibling);
        }).catch((e)=>{
            console.warn("Unable to export AudioRouter to varv:")
        });
    }
});

</SCRIPT><STYLE id="main-style">
.mirrorverse-audio-router {
  position: relative;
  margin-left: -2500px;
  margin-top: -2500px;
  width: 5000px;
  height: 5000px; }

.mirrorverse-audio-router-maximized {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%; }

div.mirrorverse-audio-router-maximized {
  background-image: linear-gradient(45deg, #F0F0F0 25%, transparent 25%), linear-gradient(-45deg, #F0F0F0 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #F0F0F0 75%), linear-gradient(-45deg, transparent 75%, #F0F0F0 75%);
  background-size: 5px 5px;
  background-position: 0 0, 2px 0, 2px -2px, 0px 2px; }

.codestrates-editor-core.component {
  overflow: hidden; }

svg.mirrorverse-audio-router-maximized {
  pointer-events: none; }

.mirrorVerseAudioRouterNode {
  display: inline-flex;
  justify-content: center;
  border: 1px solid black;
  border-radius: 10px;
  padding: 1em;
  user-select: none;
  flex-direction: column;
  align-items: center;
  position: absolute;
  gap: 0.25em; }
  .mirrorVerseAudioRouterNode.mirrorVerseUnused {
    opacity: 0.5; }
  .mirrorVerseAudioRouterNode.error {
    border-color: orangered; }

.mirrorVerseAudioRouterValueNode .type.hidden {
  display: none; }

.mirrorVerseAudioRouterValueNode.error {
  border-color: orangered; }

.mirrorVerseAudioRouterValueNode input {
  width: 3.5em; }

.mirrorVerseAudioRouterDecisionNode .decisions {
  display: flex;
  align-items: center;
  gap: 0.25em; }
  .mirrorVerseAudioRouterDecisionNode .decisions .decision {
    border: 1px solid black;
    display: flex;
    flex-direction: column;
    align-items: center; }
    .mirrorVerseAudioRouterDecisionNode .decisions .decision .connectionOut {
      display: inline-block;
      width: 1em;
      height: 1em;
      background-color: #4D7A97; }
    .mirrorVerseAudioRouterDecisionNode .decisions .decision .type.array:not(.hidden) {
      display: flex; }
    .mirrorVerseAudioRouterDecisionNode .decisions .decision .type input {
      width: 3.5em; }

.mirrorVerseAudioRouterRootNode {
  border-radius: 50%;
  width: 5em;
  height: 5em; }
  .mirrorVerseAudioRouterRootNode .title {
    color: red; }
  .mirrorVerseAudioRouterRootNode .connectionOut {
    display: inline-block;
    width: 1em;
    height: 1em;
    background-color: green; }

.mirrorverse-audio-routing-connection {
  stroke: #1f389c;
  stroke-width: 2px; }

.hidden {
  display: none; }
</STYLE><TEMPLATE id="mirrorverse-audio-router-decisionNode">
  <DIV class="mirrorVerseAudioRouterDecisionNode mirrorVerseAudioRouterNode connectionTarget draggable">
    <DIV class="name">Name: <INPUT type="text"/></DIV>
    <DIV class="hidden">Id: <SPAN class="id"></SPAN></DIV>
    <DIV class="concept">Concept: <SELECT>
        <OPTION value="client">client</OPTION>
        <OPTION value="currentRoom">currentRoom</OPTION>
        <OPTION value="toolManager">toolManager</OPTION>
      </SELECT>
    </DIV>
    <DIV class="property">Property: <SELECT>
      </SELECT>
    </DIV>
    <DIV>Decisions: <BUTTON type="button" class="addDecision">+</BUTTON><BUTTON type="button" class="removeDecision">-</BUTTON></DIV>
    <DIV class="decisions"></DIV>
  </DIV>
</TEMPLATE><TEMPLATE id="mirrorverse-audio-router-rootNode">
  <DIV class="mirrorVerseAudioRouterRootNode mirrorVerseAudioRouterNode draggable">
    <DIV class="title"></DIV>
    <DIV class="connectionOut"></DIV>
  </DIV>
</TEMPLATE><TEMPLATE id="mirrorverse-audio-router-ValueNode">
  <DIV class="mirrorVerseAudioRouterValueNode mirrorVerseAudioRouterNode connectionTarget draggable">
    <DIV class="muted type">Muted: <INPUT type="checkbox" value="on"/></DIV>
    <DIV class="volume type">Volume: <INPUT type="number" min="0" max="1" step="0.01"/></DIV>
    <DIV class="audioFilter type">Filter: <SELECT><OPTION value="none">none</OPTION><OPTION value="muffled">muffled</OPTION><OPTION value="overdrive">overdrive</OPTION></SELECT></DIV>
  </DIV>
</TEMPLATE><TEMPLATE id="mirrorverse-audio-router-decision">
  <DIV class="decision">
    <DIV class="array type">
      <SELECT class="comparator">
        <OPTION value="equals">includes</OPTION>
      </SELECT>
      <DIV class="concept string arrayType">
        <INPUT type="text" class="value"/>
      </DIV>
      <DIV class="number arrayType">
        <INPUT type="number" class="value"/>
      </DIV>
      <DIV class="boolean arrayType">
        <SELECT class="value">
          <OPTION value="true">true</OPTION>
          <OPTION value="false">false</OPTION>
        </SELECT>
      </DIV>
    </DIV>
    <DIV class="concept type">
      <SELECT class="comparator">
        <OPTION value="equals">==</OPTION>
        <OPTION value="unequals">!=</OPTION>
      </SELECT>
      <INPUT type="text" class="value"/>
    </DIV>
    <DIV class="string type">
      <SELECT class="comparator">
        <OPTION value="equals">==</OPTION>
        <OPTION value="unequals">!=</OPTION>
        <OPTION value="greaterThan">></OPTION>
        <OPTION value="lessThan">&lt;</OPTION>
        <OPTION value="greaterOrEquals">>=</OPTION>
        <OPTION value="lessOrEquals">&lt;=</OPTION>
        <OPTION value="startsWith">startsWith</OPTION>
        <OPTION value="endsWith">endsWith</OPTION>
        <OPTION value="includes">includes</OPTION>
        <OPTION value="matches">matches</OPTION>
      </SELECT>
      <INPUT type="text" class="value"/>
    </DIV>
    <DIV class="number type">
      <SELECT class="comparator">
        <OPTION value="equals">==</OPTION>
        <OPTION value="unequals">!=</OPTION>
        <OPTION value="greaterThan">></OPTION>
        <OPTION value="lessThan">&lt;</OPTION>
        <OPTION value="greaterOrEquals">>=</OPTION>
        <OPTION value="lessOrEquals">&lt;=</OPTION>
      </SELECT>
      <INPUT type="number" class="value"/>
    </DIV>
    <DIV class="boolean type">
      <SELECT class="value">
        <OPTION value="true">true</OPTION>
        <OPTION value="false">false</OPTION>
      </SELECT>
    </DIV>
    <DIV class="connectionOut"></DIV>
  </DIV>
</TEMPLATE></WPM-PACKAGE><WPM-PACKAGE data-repository="varv-repos" id="varv-builtin-actions" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Varv Standard Actions",
    "description": "Simple built-in actions for varv",
    "dependencies": [
        "#varv-engine",
        "wpm_js_libs #mathjs"
    ],
    "assets": [],
    "license": "MIT",
    "version": "0.1",
    "changelog": {}
}

</SCRIPT><SCRIPT id="ArrayActions-script" type="disabled">
/**
 *  ArrayActions - Actions related to array functionallity
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * Actions that deal with arrays
 * @namespace ArrayActions
 */

/**
 * Action "length" that can put the length of an array or string into a variable
 * @memberOf ArrayActions
 * @example
 * // Find the length of a property (array or string)
 * {
 *     "length": {
 *         "of": {"property": "myArrayOrStringProperty"},
 *         "as": "myResultVariableName"
 *     }
 * }
 *
 * @example
 * // Find the length of a property (array or string), on a non selected property
 * {
 *     "length": {
 *         "of": {"property": "myConcept.myArrayOrStringProperty"},
 *         "as": "myResultVariableName"
 *     }
 * }
 *
 * @example
 * // Find the length of a variable (array or string)
 * {
 *     "length": {
 *         "of": {"variable": "myArrayOrStringVariable"},
 *         "as": "myResultVariableName"
 *     }
 * }
 *
 * @example
 * // Shorthand, set the variable "length" to the length of the property "myProperty"
 * {
 *     "length": "myProperty"
 * }
 *
 * @example
 * // Shorthand, set the variable "length" to the length of the variable "myVariable"
 * {
 *     "length": "$myVariable"
 * }
 */
class LengthAction extends Action {
    static options() {
        return {
            "of": "enumValue[property,variable]",
            "as": "@string"
        }
    }

    constructor(name, options, concept) {
        //Shorthand
        if(typeof options === "string") {

            if(options.trim().startsWith("$")) {
                //Shorthand lookup variable
                options = {
                    of: {
                        variable: options.trim().substring(1)
                    }
                }
            } else {
                options = {
                    of: {
                        property: options
                    }
                }
            }
        }

        super(name, options, concept);

        if(this.options.of == null) {
            if(this.options.property != null) {
                this.options.of = {
                    property: this.options.property
                }

                delete this.options.property;
            } else if(this.options.variable != null) {
                this.options.of = {
                    variable: this.options.variable
                }

                delete this.options.variable;
            }
        }
    }

    async apply(contexts, actionArguments) {
        const self = this;

        if(this.options.of == null) {
            throw new Error("Missing option 'of' on length action");
        }

        if(this.options.of.property == null && this.options.of.variable == null) {
            throw new Error("Missing option 'of.property' or 'of.variable' on length action");
        }

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            let variableName = Action.defaultVariableName(self);

            if(options.as != null) {
                variableName = options.as;
            }

            if(options.of.property != null) {
                // Length of property

                const lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.of.property);

                if(lookup == null) {
                    throw new Error("No property ["+options.of.property+"] found");
                }

                const concept = lookup.concept;
                const property = lookup.property;
                const target = lookup.target;

                if(property.type !== "array" && property.type !== "string") {
                    throw new Error("Unable to get length of non array|string type property ["+property.name+"] on ["+concept.name+"]");
                }

                let value = await property.getValue(target);

                Action.setVariable(context, variableName, value.length);
            } else if(options.of.variable != null) {
                // Length of variable
                const variableValue = Action.getVariable(context, options.of.variable);

                if(!Array.isArray(variableValue) && typeof variableValue !== "string") {
                    throw new Error("Variable ["+options.of.variable+"] was not of type array or string!");
                }

                Action.setVariable(context, variableName, variableValue.length);
            }

            return context;
        });
    }
}
Action.registerPrimitiveAction("length", LengthAction);
window.LengthAction = LengthAction;

class AppendPrependAction extends Action {
    constructor(name, options, concept, prepend = false) {
        super(name, options, concept);

        if(this.options.to == null) {
            if(this.options.property != null) {
                this.options.to = {
                    property: this.options.property
                }

                delete this.options.property;
            } else if(this.options.variable != null) {
                this.options.to = {
                    variable: this.options.variable
                }

                delete this.options.variable;
            }
        }

        this.prepend = prepend;
    }

    async apply(contexts, actionArguments) {
        const self = this;

        if(this.options.to == null) {
            throw new Error("Missing option 'to' on "+(this.prepend?"prepend":"append")+" action");
        }

        if(this.options.to.property == null && this.options.to.variable == null) {
            throw new Error("Missing option 'to.property' or 'to.variable' on "+(this.prepend?"prepend":"append")+" action");
        }

        return this.forEachContext(contexts, actionArguments, async (context, options) =>{
            let items = [];

            if(options.item != null) {
                items.push(options.item);
            } else if(options.items != null) {
                items.push(...options.items);
            } else {
                throw new Error("Missing 'item' or 'items' option on Append/Prepend action.");
            }

            if(options.to.property != null) {
                // Append to property array

                const lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.to.property);

                if(lookup == null) {
                    throw new Error("No property ["+options.of.property+"] found");
                }

                const concept = lookup.concept;
                const property = lookup.property;
                const target = lookup.target;

                if(property.type !== "array") {
                    throw new Error("Unable to "+(this.prepend?"prepend":"append")+" to non array type property ["+property.name+"] on ["+concept.name+"]");
                }

                let value = await property.getValue(target);

                if(self.prepend) {
                    items.reverse().forEach((item)=>{
                        value.unshift(item);
                    });
                } else {
                    items.forEach((item)=>{
                        value.push(item);
                    });
                }

                await property.setValue(target, value);
            } else if(options.to.variable != null) {
                // Append to variable array
                let array = Action.getVariable(context, options.to.variable);

                if(self.prepend) {
                    items.reverse().forEach((item)=>{
                        array.unshift(item);
                    });
                } else {
                    items.forEach((item)=>{
                        array.push(item);
                    });
                }
            }

            return context;
        });
    }
}

/**
 * An action "append" that can append an 'item' or a number of 'items' to an array, the array can be from either a property or a variable
 * @memberOf ArrayActions
 * @example
 * // Append a string item to an array inside a property
 * {
 *     "append": {
 *         "to": {"property": "myStringArrayProperty"},
 *         "item": "myStringItem"
 *     }
 * }
 *
 * @example
 * // Append a string item to an array inside a property, on a non selected concept
 * {
 *     "append": {
 *         "to": {"property": "myConcept.myStringArrayProperty"},
 *         "item": "myStringItem"
 *     }
 * }
 *
 * @example
 * // Append a string item to an array inside a variable
 * {
 *     "append": {
 *         "to": {"variable": "myStringArrayVariable"},
 *         "item": "myStringItem"
 *     }
 * }
 *
 * @example
 * // Append a number of string items to an array inside a variable
 * {
 *     "append": {
 *         "to": {"variable": "myStringArrayVariable"},
 *         "items": ["myStringItem1", "myStringItem2"]
 *     }
 * }
 */
class AppendAction extends AppendPrependAction {
    static options() {
        return {
            "to": "enumValue[property,variable]",
            "item": "raw"
        }
    }
    constructor(name, options, concept) {
        super(name, options, concept, false);
    }
}
Action.registerPrimitiveAction("append", AppendAction)
window.AppendAction = AppendAction;

/**
 * An action "prepend" that can prepend an 'item' or a number of 'items' to an array, the array can be from either a property or a variable
 * @memberOf ArrayActions
 * @example
 * // Prepend a string item to an array inside a property
 * {
 *     "prepend": {
 *         "to": {"property": "myStringArrayProperty"},
 *         "item": "myStringItem"
 *     }
 * }
 *
 * @example
 * // Prepend a string item to an array inside a property, on a non selected concept
 * {
 *     "prepend": {
 *         "to": {"property": "myConcept.myStringArrayProperty"},
 *         "item": "myStringItem"
 *     }
 * }
 *
 * @example
 * // Prepend a string item to an array inside a variable
 * {
 *     "prepend": {
 *         "to": {"variable": "myStringArrayVariable"},
 *         "item": "myStringItem"
 *     }
 * }
 *
 * @example
 * // Prepend a number of string items to an array inside a variable
 * {
 *     "prepend": {
 *         "to": {"variable": "myStringArrayVariable"},
 *         "items": ["myStringItem1", "myStringItem2"]
 *     }
 * }
 */
class PrependAction extends AppendPrependAction {
    static options() {
        return {
            "to": "enumValue[property,variable]",
            "item": "raw"
        }
    }
    constructor(name, options, concept) {
        super(name, options, concept, true);
    }
}
Action.registerPrimitiveAction("prepend", PrependAction)
window.PrependAction = PrependAction;

/**
 * An action "insert" that inserts an 'item' or 'items' into an array property or variable, at a given index.
 * @memberOf ArrayActions
 * @example
 * {
 *      /Insert "myNewItem" at index 2, in the array at myArrayProperty
 *     "insert": {
 *         "to": {"property": "myArrayProperty"},
 *         "index": 2,
 *         "item": "myNewItem"
 *     }
 * }
 *
 * @example
 * {
 *      /Insert "myNewItem" at index 2, in the array at myVariableArray
 *     "insert": {
 *         "to": {"variable": "myVariableArray"},
 *         "index": 2,
 *         "item": "myNewItem"
 *     }
 * }
 *
 * @example
 * {
 *      /Insert multiple items at index 3, in the array at myVariableArray
 *     "insert": {
 *         "to": {"variable": "myVariableArray"},
 *         "index": 3,
 *         "items": ["myNewItem", "mySecondNewItem"]
 *     }
 * }
 */
class InsertAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);

        if(this.options.to == null) {
            if(this.options.property != null) {
                this.options.to = {
                    property: this.options.property
                }

                delete this.options.property;
            } else if(this.options.variable != null) {
                this.options.to = {
                    variable: this.options.variable
                }

                delete this.options.variable;
            }
        }
    }

    async apply(contexts, actionArguments = {}) {
        if(this.options.to == null) {
            throw new Error("Missing option 'to' on "+(this.prepend?"prepend":"append")+" action");
        }

        if(this.options.index == null) {
            throw new Error("Missing option 'index' on insert action");
        }

        if(this.options.to.property == null && this.options.to.variable == null) {
            throw new Error("Missing option 'to.property' or 'to.variable' on "+(this.prepend?"prepend":"append")+" action");
        }

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            if(options.index < 0) {
                throw new Error("Option 'index' can not be less than 0: "+options.index);
            }

            let array = null;
            let arrayPropertyTarget = null;
            let arrayProperty = null;

            if(options.to.property != null) {
                // Append to property array

                const lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.to.property);

                if (lookup == null) {
                    throw new Error("No property [" + options.of.property + "] found");
                }

                const concept = lookup.concept;
                const property = lookup.property;
                const target = lookup.target;

                if (property.type !== "array") {
                    throw new Error("Unable to " + (this.prepend ? "prepend" : "append") + " to non array type property [" + property.name + "] on [" + concept.name + "]");
                }

                arrayPropertyTarget = target;
                arrayProperty = property;

                array = await property.getValue(target);
            } else if(options.to.variable != null) {
                array = Action.getVariable(context, options.to.variable);
            }

            if(array == null) {
                throw new Error("Unable to find array: "+JSON.stringify(options, null, 2)+" in 'insert'");
            }

            if(options.index > array.length) {
                throw new Error("Option 'index' can not be more than array length: "+array.length);
            }

            let items = [];

            if(options.item != null) {
                items.push(options.item);
            } else if(options.items != null) {
                items.push(...options.items);
            } else {
                throw new Error("Missing option either 'item' or 'items' on insert action");
            }

            items.reverse().forEach((item)=>{
                array.splice(options.index, 0, item);
            });

            if(arrayProperty != null) {
                //If property, remember to set it
                await arrayProperty.setValue(arrayPropertyTarget, array);
            }

            return context;
        });
    }
}
Action.registerPrimitiveAction("insert", InsertAction)
window.InsertAction = InsertAction;

class RemoveFirstLastAction extends Action {
    constructor(name, options, concept, removeFirst = false) {

        //Shorthand { "remove-first": "propertyName" }
        if(typeof options === "string") {
            if(options.trim().startsWith("$")) {
                options = {
                    "of": {
                        "variable": options.trim().substring(1)
                    }
                }
            } else {
                options = {
                    "of": {
                        "property": options
                    }
                }
            }
        }

        super(name, options, concept);

        if(this.options.of == null) {
            if(this.options.property != null) {
                this.options.of = {
                    property: this.options.property
                }

                delete this.options.property;
            } else if(this.options.variable != null) {
                this.options.of = {
                    variable: this.options.variable
                }

                delete this.options.variable;
            }
        }

        this.removeFirst = removeFirst;
    }

    async apply(contexts, actionArguments) {
        const self = this;

        if(this.options.of == null) {
            throw new Error("Missing option 'of' on "+(this.removeFirst?"remove-first":"remove-last")+" action");
        }

        if(this.options.of.property == null && this.options.of.variable == null) {
            throw new Error("Missing option 'of.property' or 'of.variable' on "+(this.removeFirst?"remove-first":"remove-last")+" action");
        }

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            let variableName = Action.defaultVariableName(self);

            if(options.as != null) {
                variableName = options.as;
            }

            if(options.of.property != null) {
                // remove of property

                const lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.of.property);

                if(lookup == null) {
                    throw new Error("No property ["+options.of.property+"] found");
                }

                const concept = lookup.concept;
                const property = lookup.property;
                const target = lookup.target;

                if(property.type !== "array") {
                    throw new Error("Unable to "+(this.removeFirst?"remove-first":"remove-last")+" of non array type property ["+property.name+"] on ["+concept.name+"]");
                }

                let value = await property.getValue(target);

                let result = null;

                if(self.removeFirst) {
                    result = value.shift();
                } else {
                    result = value.pop();
                }

                // Set back the changed array
                await property.setValue(target, value);

                // Set result variable
                Action.setVariable(context, variableName, result);
            } else if(options.of.variable != null) {
                // remove of variable
                const variableValue = Action.getVariable(context, options.of.variable);

                if(!Array.isArray(variableValue)) {
                    throw new Error("Variable ["+options.of.variable+"] was not of type array!");
                }

                let result = null;

                if(self.removeFirst) {
                    result = variableValue.shift();
                } else {
                    result = variableValue.pop();
                }

                // Set back the changed array
                Action.setVariable(context, options.of.variable, variableValue);

                // Set the result variable
                Action.setVariable(context, variableName, result);
            }

            return context;
        });
    }
}

/**
 * An action "removeFirst" that can remove the first item of an array, and set a variable to the removed item
 * @memberOf ArrayActions
 * @example
 * // Remove the first item from an array property
 * {
 *     "removeFirst": {
 *         "of": {"property": "myArrayProperty"},
 *         "as": "myResultVariableName"
 *     }
 * }
 *
 * @example
 * // Remove the first item from an array property, on a non selected concept
 * {
 *     "removeFirst": {
 *         "of": {"property": "myConcept.myArrayProperty"},
 *         "as": "myResultVariableName"
 *     }
 * }
 *
 * @example
 * // Remove the first item from an array property, shorthand notation, result will be in variable named "removeFirst"
 * {
 *     "removeFirst": "myArrayProperty"
 * }
 *
 * @example
 * // Remove the first item from an array variable
 * {
 *     "removeFirst": {
 *         "of": {"variable": "myArrayVariable"},
 *         "as": "myResultVariableName"
 *     }
 * }
 */
class RemoveFirstAction extends RemoveFirstLastAction {
    static options() {
        return {
            "of": "enumValue[property,variable]",
            "as": "@string"
        }
    }
    constructor(name, options, concept) {
        super(name, options, concept, true);
    }
}
Action.registerPrimitiveAction("removeFirst", RemoveFirstAction);
window.RemoveFirstAction = RemoveFirstAction;

/**
 * An action "removeLast" that can remove the last item of an array, and set a variable to the removed item
 * @memberOf ArrayActions
 * @example
 * // Remove the last item from an array property
 * {
 *     "removeLast": {
 *         "of": {"property": "myArrayProperty"},
 *         "as": "myResultVariableName"
 *     }
 * }
 *
 * @example
 * // Remove the last item from an array property, on a non selected concept
 * {
 *     "removeLast": {
 *         "of": {"property": "myConcept.myArrayProperty"},
 *         "as": "myResultVariableName"
 *     }
 * }
 *
 * @example
 * // Remove the last item from an array property, shorthand notation, result will be in variable named "removeLast"
 * {
 *     "removeLast": "myArrayProperty"
 * }
 *
 * @example
 * // Remove the last item from an array variable
 * {
 *     "removeLast": {
 *         "of": {"variable": "myArrayVariable"},
 *         "as": "myResultVariableName"
 *     }
 * }
 */
class RemoveLastAction extends RemoveFirstLastAction {
    static options() {
        return {
            "of": "enumValue[property,variable]",
            "as": "@string"
        }
    }
    constructor(name, options, concept) {
        super(name, options, concept, false);
    }
}
Action.registerPrimitiveAction("removeLast", RemoveLastAction);
window.RemoveLastAction = RemoveLastAction;

/**
 * An action "removeItem" that can remove 1 or X items from a given index in an array, the array can be in either a property or a variable
 *
 * If removeCount is 1, then the result will be just the item removed, if its > 1, then the result will be an array of the removed items
 * @memberOf ArrayActions
 * @example
 * //Remove 1 items starting from index 1 of an array property
 * {
 *     "removeItem": {
 *         "of": { "property": "myArrayProperty" },
 *         "index": 1,
 *         "as": "myResultVariableName"
 *     }
 * }
 *
 * @example
 * //Remove 2 items starting from index 1 of an array property
 * {
 *     "removeItem": {
 *         "of": { "property": "myArrayProperty" },
 *         "index": 1,
 *         "removeCount": 2,
 *         "as": "myResultVariableName"
 *     }
 * }
 *
 * @example
 * //Remove 2 items starting from index 1 af an array variable
 * {
 *     "removeItem": {
 *         "of": { "variable": "myArrayVariable" },
 *         "index": 1,
 *         "removeCount": 2,
 *         "as": "myResultVariableName"
 *     }
 * }
 */
class RemoveItemAction extends Action {
    static options() {
        return {
            "of": "enumValue[property,variable]",
            "index": "number",
            "removeCount": "@number",
            "as": "@string"
        }
    }
    constructor(name, options, concept) {
        super(name, options, concept);

        if(this.options.of == null) {
            if(this.options.property != null) {
                this.options.of = {
                    property: this.options.property
                }

                delete this.options.property;
            } else if(this.options.variable != null) {
                this.options.of = {
                    variable: this.options.variable
                }

                delete this.options.variable;
            }
        }
    }

    async apply(contexts, actionArguments) {
        const self = this;

        if(this.options.of == null) {
            throw new Error("Missing option 'of' on removeItem action");
        }

        if(this.options.of.property == null && this.options.of.variable == null) {
            throw new Error("Missing option 'of.property' or 'of.variable' on removeItem action");
        }

        if(this.options.index == null && this.options.item == null) {
            throw new Error("Missing option either 'index' or 'item' on removeItem action");
        }

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            let variableName = Action.defaultVariableName(self);

            if(options.as != null) {
                variableName = options.as;
            }

            let removeCount = 1;

            if(options.removeCount != null) {
                removeCount = options.removeCount;
            }

            if(options.of.property != null) {
                const lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.of.property);

                if(lookup == null) {
                    throw new Error("No property ["+options.of.property+"] found");
                }

                const concept = lookup.concept;
                const property = lookup.property;
                const target = lookup.target;

                if(property.type !== "array") {
                    throw new Error("Unable to removeItem of non array type property ["+property.name+"] on ["+concept.name+"]");
                }

                let value = await property.getValue(target);

                let index = 0;

                if(options.index != null) {
                    index = options.index;
                } else if(options.item != null) {
                    index = value.indexOf(options.item);
                }

                let result = value.splice(index, removeCount);

                if(result.length === 1) {
                    result = result[0];
                }

                await property.setValue(target, value);

                Action.setVariable(context, variableName, result);
            } else if(options.of.variable != null) {
                let value = Action.getVariable(context, options.of.variable);

                let index = 0;

                if(options.index != null) {
                    index = options.index;
                } else if(options.item != null) {
                    index = value.indexOf(options.item);
                }

                let result = value.splice(index, removeCount);

                if(result.length === 1) {
                    result = result[0];
                }

                Action.setVariable(context, variableName, result);
            }

            return context;
        });
    }
}
Action.registerPrimitiveAction("removeItem", RemoveItemAction);
window.RemoveItemAction = RemoveItemAction;

/**
 * An action 'items' that extracts an array property or variable into another variable, optionally applying filtering
 * @memberOf ArrayActions
 * @example
 * //Shorthand, returns result into variable 'items' and applies no filtering
 * {
 *     "items": "myArrayProperty"
 * }
 *
 * @example
 * //Shorthand, returns result into variable 'items' and applies no filtering
 * {
 *     "items": "$myArrayVariable"
 * }
 *
 * @example
 * //Property example
 * {
 *     "items:" {
 *         "property": "myArrayProperty",
 *         "as": "myResultVariableName",
 *         "where": {
 *             "equals": "my-specific-value"
 *         }
 *     }
 * }
 *
 * //Property example, on non selected concept
 * {
 *     "items:" {
 *         "property": "myConcept.myArrayProperty",
 *         "as": "myResultVariableName",
 *         "where": {
 *             "equals": "my-specific-value"
 *         }
 *     }
 * }
 *
 * @example
 * //Variable example
 * {
 *     "items:" {
 *         "variable": "myArrayVariableName",
 *         "as": "myResultVariableName",
 *         "where": {
 *             "equals": "my-specific-value"
 *         }
 *     }
 * }
 */
class ItemsAction extends Action {
    static options() {
        return {
            "$items": "enumValue[property,variable]",
            "as": "@string",
            "where": "filter"
        }
    }

    constructor(name, options, concept) {
        //Shorthand
        if(typeof options === "string") {
            if(options.trim().startsWith("$")) {
                options = {
                    variable: options.trim().substring(1)
                }
            } else {
                options = {
                    property: options
                }
            }
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            if(options.property == null && options.variable == null) {
                throw new Error("Action 'items' must have either option 'property' or 'variable'");
            }

            let resultName = Action.defaultVariableName(self);

            if(options.as != null) {
                resultName = options.as;
            }

            let result = null;

            if(options.property != null) {
                const lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.property);

                if(lookup == null) {
                    throw new Error("No property ["+options.of.property+"] found");
                }

                const concept = lookup.concept;
                const property = lookup.property;
                const target = lookup.target;

                if(property.type !== "array") {
                    throw new Error("Property ["+options.property+"] of ["+concept.name+"] is not an array");
                }

                result = await property.getValue(target);
            } else if(options.variable != null) {
                result = Action.getVariable(context, options.variable);

                if(!Array.isArray(result)) {
                    throw new Error("Variable ["+options.variable+"] did not contain an array!");
                }
            }

            if(options.where != null) {
                let filteredResult = [];

                let filter = FilterAction.constructFilter(options.where, true);

                for(let v of result) {
                    //TODO: Might backfire if an array of strings contains the string equal to a concept?
                    let concept = await VarvEngine.getConceptFromUUID(v);
                    if(concept != null) {
                        v = {
                            target: v
                        }
                    }

                    if(await filter.filter(v)) {
                        if(v.target != null) {
                            v = v.target;
                        }
                        filteredResult.push(v);
                    }
                }

                result = filteredResult;
            }

            Action.setVariable(context, resultName, result);

            return context;
        });
    }
}
Action.registerPrimitiveAction("items", ItemsAction);
window.ItemsAction = ItemsAction;

/**
 * An action 'join' that joins an array into a string and saves it in a variable, default separator: ","
 * @memberOf ArrayActions
 * @example
 * {
 *     "join": {
 *         "property": "myProperty",
 *         "separator": ","
 *     }
 * }
 *
 * @example
 * {
 *     "join": {
 *         "variable": "myProperty",
 *         "separator": ","
 *     }
 * }
 *
 * @example
 * //Shorthand, joins the array in property "myArrayProperty" into a string
 * {
 *     "join": "myArrayProperty"
 * }
 *
 * @example
 * //Shorthand, joins the array in variable "myArrayVariable" into a string
 * {
 *     "join": "$myArrayVariable"
 * }
 */
class JoinAction extends Action {
    constructor(name, options, concept) {
        if(typeof options === "string") {
            if(options.trim().startsWith("$")) {
                options = {
                    of: {
                        variable: options.trim().substring(1)
                    }
                }
            } else {
                options = {
                    of: {
                        property: options
                    }
                }
            }
        }

        if(options.property != null) {
            options.of = {
                property: options.property
            }

            delete options.property;
        }

        if(options.variable != null) {
            options.of = {
                variable: options.variable
            }

            delete options.variable;
        }

        const defaultOptions = {
            "separator": ","
        }

        super(name, Object.assign({}, defaultOptions, options), concept);
    }

    async apply(contexts, actionArguments = {}) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{

            let result = null;

            let inputArray = null;

            if(options?.of.property != null) {
                let lookup = VarvEngine.lookupProperty(context.target, self.concept, options.of.property);

                const concept = lookup.concept;
                const property = lookup.property;
                const target = lookup.target;

                if(property.type !== "array") {
                    throw new Error("Property ["+options.of.property+"] of ["+concept.name+"] is not an array");
                }

                inputArray = property.getValue(target);

            } else if(options?.of.variable != null) {
                inputArray = Action.getVariable(context, options.of.variable);
            } else {
                throw new Error("'join' requires either option 'of.property' or option 'of.variable' to be present:"+JSON.stringify(options));
            }

            if(!Array.isArray(inputArray)) {
                throw new Error("Targeted variable or property, did not result in an array: "+JSON.stringify(options));
            }

            if(inputArray != null) {
                result = inputArray.join(options.separator);
            }

            let variableName = Action.defaultVariableName(self);
            if(options.as != null) {
                variableName = options.as;
            }

            Action.setVariable(context, variableName, result);

            return context;
        });
    }
}
window.JoinAction = JoinAction;
Action.registerPrimitiveAction("join", JoinAction);

/**
 * An action 'slice' that slices a string or an array.
 *
 * @memberOf ArrayActions
 *
 * @example
 * //Slices mySliceableProperty starting from 0, ending with 10, saving the result in "myResultVariable"
 * {
 *     "slice": {
 *         "of": {
 *             "property": "mySliceableProperty"
 *         },
 *         "start": 0,
 *         "end": 10,
 *         "as": "myResultVariable"
 *     }
 * }
 *
 * @example
 * //Shorthand: Slices the variable "mySliceableVariable", from 0 to end, which in practice, means its a copy of the whole thing
 * {
 *     "slice: "mySliceableVariable"
 * }
 */
class SliceAction extends Action {
    constructor(name, options, concept) {
        if(typeof options === "string") {
            if(options.startsWith("$")) {
                options = {
                    "of": {
                        "variable": options.trim().substring(1)
                    }
                }
            } else {
                options = {
                    "of": {
                        "property": options
                    }
                }
            }
        }

        if(options.property != null) {
            options.of = {
                property: options.property
            }

            delete options.property;
        }

        if(options.variable != null) {
            options.of = {
                variable: options.variable
            }

            delete options.variable;
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments = {}) {
        const self = this;
        return this.forEachContext(contexts, actionArguments, async (context, options)=> {
            let theThingToSlice = null;

            if(options.of == null) {
                throw new Error("'slice' requires option 'of' to be present:"+JSON.stringify(options));
            }

            if(options.of.variable != null) {
                //Handle variable
                theThingToSlice = Action.getVariable(context, options.of.variable);
            } else if(options.of.property != null) {
                //Handle property
                let lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.of.property);

                const concept = lookup.concept;
                const property = lookup.property;
                const target = lookup.target;

                if(property.type !== "array") {
                    throw new Error("Property ["+options.property+"] of ["+concept.name+"] is not an array");
                }

                theThingToSlice = await property.getValue(target);
            } else {
                throw new Error("'slice' requires option 'of.variable' or 'of.property' to be present:"+JSON.stringify(options));
            }

            if(theThingToSlice == null) {
                throw new Error("'slice' the chosen array was null: "+JSON.stringify(options));
            }

            if(theThingToSlice.slice == null) {
                throw new Error("'slice' unable to slice on type: "+(typeof theThingToSlice));
            }

            let start = 0;
            let end = theThingToSlice.length;

            if(options.start != null) {
                start = options.start;
            }

            if(options.end != null) {
                end = options.end;
            }

            let result = theThingToSlice.slice(start, end);

            let variableName = Action.defaultVariableName(self);
            if(options.as != null) {
                variableName = options.as;
            }

            Action.setVariable(context, variableName, result);

            return context;
        });
    }
}
window.SliceAction = SliceAction;
Action.registerPrimitiveAction("slice", SliceAction);

/**
 * An action 'index' that finds the index of a given item in an array
 *
 * @example
 * //Lookup the item "myLookupItem" inside the array property "myArrayProperty", and save the resulting index in the variable "myResultVariableName"
 * {"index": {
 *     "of": {
 *         "property": "myArrayProperty"
 *     },
 *     "item": "myLookupItem",
 *     "as": "myResultVariableName"
 * }}
 *
 * @example
 * //Shorthand, lookup the "myLookupItem" inside the property array "myArrayProperty", and saves the index in the variable "index"
 * {"index": {"myArrayProperty": "myLookupItem"}}
 */
class IndexAction extends Action {
    constructor(name, options, concept) {
        //Handle {"index": {"$myVariable": "myItem"}} shorthand
        //Handle {"index": {"myProperty": "myItem"}} shorthand

        if(Object.keys(options).length === 1) {
            let key = Object.keys(options)[0];
            let value = options[key];

            if(key.startsWith("$")) {
                options = {
                    "of": {
                        "variable": key.substring(1)
                    },
                    "item": value
                }
            } else {
                options = {
                    "of": {
                        "property": key
                    },
                    "item": value
                }
            }
        }

        if(options.property != null) {
            options.of = {
                property: options.property
            }

            delete options.property;
        }

        if(options.variable != null) {
            options.of = {
                variable: options.variable
            }

            delete options.variable;
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments = {}) {
        const self = this;
        return this.forEachContext(contexts, actionArguments, async (context, options) => {

            let theArray = null;

            if(options.of == null) {
                throw new Error("'index' requires option 'of' to be present:"+JSON.stringify(options));
            }

            if(options.item == null) {

            }

            if(options.of.variable != null) {
                //Handle variable
                theArray = Action.getVariable(context, options.of.variable);
            } else if(options.of.property != null) {
                //Handle property
                let lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.of.property);

                const concept = lookup.concept;
                const property = lookup.property;
                const target = lookup.target;

                if(property.type !== "array") {
                    throw new Error("Property ["+options.property+"] of ["+concept.name+"] is not an array");
                }

                theArray = await property.getValue(target);
            } else {
                throw new Error("'index' requires option 'of.variable' or 'of.property' to be present:"+JSON.stringify(options));
            }

            if(theArray == null) {
                throw new Error("'index' the chosen array was null: "+JSON.stringify(options));
            }

            if(theArray.indexOf == null) {
                throw new Error("'index' unable to find index on type: "+(typeof theArray));
            }

            let index = theArray.indexOf(options.item);

            let variableName = Action.defaultVariableName(self);

            if(options.as != null) {
                variableName = options.as;
            }

            Action.setVariable(context, variableName, index);

            return context;
        });
    }
}
Action.registerPrimitiveAction("index", IndexAction);
window.IndexAction = IndexAction;

</SCRIPT><SCRIPT id="ContextActions-script" type="disabled">
/**
 *  ContextActions - Actions that manipulate the context
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * Actions that change the current context
 * @namespace ContextActions
 */

// gate(filter) // filter context
// gate(filter... or=[])

/**
 * An action "select" that selects a number of concepts of the given type, optionally filtered by a where condition
 * <br />
 * Options:
 * <ul>
 * <li>concept: The concept to select</li>
 * <li>property: Select the concepts this property holds</li>
 * <li>target: The specific uuid to select</li>
 * <li>as: The variable name to save the selection as</li>
 * <li>where: A filter spec for filtering on the selection</li>
 * <li>forEach (false): If true the select action is run 1 time for each currently selected concept</li>
 * <li>stopIfEmpty (false): If true, the action chain stops if nothing is selected</li>
 * </ul>
 * @memberOf ContextActions
 * @example
 * //Select all concepts of a type
 * {
 *     "select": {
 *         "concept": "myConceptType"
 *     }
 * }
 *
 * @example
 * //Select all concepts of a type, and save the selected uuids in the variable $mySelection
 * {
 *     "select": {
 *         "concept": "myConceptType",
 *         "as": "mySelection"
 *     }
 * }
 *
 * @example
 * //Select all concepts of a type (Shorthand version)
 * {
 *     "select": "myConceptType"
 * }
 *
 * @example
 * //Select concept with given uuid
 * {
 *     "select": {
 *         "target": "someuuid"  //Can also be an array: "target": ["uuid1", "uuid2"]
 *     }
 * }
 *
 * @example
 * //Select concept saved in variable, shorthand
 * {
 *     "select": "$myConceptVariable"
 * }
 *
 * @example
 * //Select all concepts of a type, filtering for some property. (Also supports "or", "and" and "not" inside the where clause)
 * {
 *     "select": {
 *         "concept": "myConceptType",
 *         "where": {
 *             "property": "color",
 *             "equals": "yellow"
 *         }
 *     }
 * }
 *
 * @example
 * //Select all concepts of a type, filtering using a calculation
 * {
 *     "select": {
 *         "concept": "myConceptType",
 *         "where": {
 *             "calculate": "$myConceptType.myProperty$ + 10",
 *             "equals": "15"
 *         }
 *     }
 * }
 *
 * @example
 * //Select all concepts of a type, filtering using lastTarget (only available in forEach)
 * {
 *     "select": {
 *         "concept": "myConceptType",
 *         "where": {
 *             "property": "myConceptType.uuid",
 *             "equals": "lastTarget.uuid$"
 *         },
 *         "forEach": true
 *     }
 * }
 */
class SelectAction extends Action {
    static options() {
        return {
            "$selectType": "enumValue[concept,property,variable]",
            "where": "filter",
            "as": "@string",
            "forEach": "boolean%false",
            "stopIfEmpty": "boolean%false"
        };
    }

    constructor(name, options, concept) {
        //Handle shorthand
        if(typeof options === "string") {
            if(options.trim().startsWith("$")) {
                options = {
                    target: options
                }
            } else {
                options = {
                    concept: options
                }
            }
        }

        const defaultOptions = {
            forEach: false,
            stopIfEmpty: false
        };

        options = Object.assign({}, defaultOptions, options);

        let wherePart = options.where;
        delete options.where;

        super(name, options, concept);

        this.wherePart = wherePart;
    }

    async apply(contexts, actionArguments) {
        const self = this;

        const DEBUG_SELECT = false;

        async function doSelect(context, options, originalOptions) {
            let mark = VarvPerformance.start();

            if(DEBUG_SELECT) {
                console.group("doSelect");
                console.log("Context:", context);
                console.log("Options:", options);
                console.log("Where:", self.wherePart);
            }

            let conceptUUIDs = [];
            let doFilter = true;

            if(options.concept != null) {
                //Select concept from type
                if(DEBUG_SELECT) {
                    console.log("Concept selection...");
                }

                doFilter = false;

                let filter = null;

                if(self.wherePart) {
                    let clonedVariables = Object.assign({}, context.variables);

                    let filterContext = {target: null, lastTarget: context.target, variables: clonedVariables};

                    let lookupWhereWithArguments = await Action.lookupArguments(self.wherePart, actionArguments);

                    let lookupWhereOptions = await Action.lookupVariables(lookupWhereWithArguments, filterContext);

                    filter = await FilterAction.constructFilter(lookupWhereOptions);
                }

                let limit = 0;

                if(options.limit != null) {
                    limit = options.limit;
                }

                conceptUUIDs = await VarvEngine.lookupInstances(VarvEngine.getAllImplementingConceptNames(options.concept), filter, context, limit, self.concept);

            } else if(options.target != null) {
                if(DEBUG_SELECT) console.log("Selecting target:", options.target);

                //Select concept from target
                if (Array.isArray(options.target)) {
                    conceptUUIDs.push(...options.target);
                } else {
                    conceptUUIDs.push(options.target);
                }

                //Filter
                let filterResults = conceptUUIDs.map((uuid)=>{
                    return VarvEngine.getConceptFromUUID(uuid);
                });

                filterResults = await Promise.all(filterResults);

                conceptUUIDs = conceptUUIDs.filter((uuid, index)=>{
                    let shouldKeep = filterResults[index] != null;

                    if(!shouldKeep) {
                        console.warn("Could not find any concept with uuid: ["+uuid+"], ignoring!");
                    }

                    return shouldKeep;
                });
            } else if(options.property != null) {
                //Select concept from property of type concept or concept[]
                let lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.property);

                if(lookup == null) {
                    if(DEBUG_SELECT) {
                        console.groupEnd();
                    }
                    throw new Error("No property ["+options.property+"] found!");
                }

                if(lookup.property.isConceptType()) {
                    let value = await lookup.property.getValue(lookup.target)
                    conceptUUIDs.push(value);
                } else if(lookup.property.isConceptArrayType()) {
                    let value = await lookup.property.getValue(lookup.target)
                    conceptUUIDs.push(...value);
                } else {
                    if(DEBUG_SELECT) {
                        console.groupEnd();
                    }
                    throw new Error("Only able to select properties that are of concept or concept array type: ["+options.property+":"+lookup.property.type+"]");
                }

            } else {
                if(DEBUG_SELECT) {
                    console.groupEnd();
                }
                throw new Error("Missing option 'concept' or 'target' on select action");
            }

            //Filtering already done?

            if(doFilter) {
                let filterMark= VarvPerformance.start();
                let filteredUUIDs = [];

                if (self.wherePart != null) {
                    let lookupWhereWithArguments = await Action.lookupArguments(self.wherePart, actionArguments);

                    let allPromises = [];

                    for (let uuid of conceptUUIDs) {
                        let clonedVariables = Object.assign({}, context.variables);

                        let filterContext = {target: uuid, lastTarget: context.target, variables: clonedVariables};

                        let lookupWhereOptions = await Action.lookupVariables(lookupWhereWithArguments, filterContext);

                        let filter = await FilterAction.constructFilter(lookupWhereOptions);

                        allPromises.push(filter.filter(filterContext, self.concept));
                    }

                    let filterResult = await Promise.all(allPromises);

                    let index = 0;
                    for (let uuid of conceptUUIDs) {
                        if(filterResult[index]) {
                            filteredUUIDs.push(uuid);
                        }
                        index++;
                    }

                } else {
                    filteredUUIDs.push(...conceptUUIDs);
                }
                VarvPerformance.stop("SelectAction.doSelect.filtering", filterMark, {filter: self.wherePart, numConcepts: conceptUUIDs.length});

                conceptUUIDs = filteredUUIDs;
            }

            let result = conceptUUIDs.map((uuid)=>{
                // Turn into context
                let newContext = Object.assign({}, context, {target: uuid});
                //Make sure the target variable from commonVariables, does not bleed out, since we just set a correct target.
                delete newContext.variables["target"];
                return newContext;
            });

            if(options.as) {
                result.forEach((resultContext)=>{
                    Action.setVariable(resultContext, options.as, conceptUUIDs);
                });
            }

            VarvPerformance.stop("SelectAction.doSelect", mark);

            if(DEBUG_SELECT) {
                console.groupEnd();
            }

            return result;
        }

        let result = [];

        let optionsWithArguments = await Action.lookupArguments(this.options, actionArguments);

        if(optionsWithArguments.forEach) {
            //Individual mode
            result = await this.forEachContext(contexts, actionArguments,async (context, options)=>{
                return await doSelect(context, options, optionsWithArguments);
            });
        } else {
            //Bulk mode

            //Find any common variables and keep
            let commonVariables = Action.getCommonVariables(contexts);

            let commonTarget = -1;

            contexts.forEach((context)=>{
                if(commonTarget === -1) {
                    commonTarget = context.target;
                } else {
                    if(commonTarget !== context.target) {
                        commonTarget = null;
                    }
                }
            });

            let optionsWithVariablesAndArguments = await Action.lookupVariables(optionsWithArguments, {target: commonTarget, variables: commonVariables});

            result = await doSelect({target: null, variables: commonVariables}, optionsWithVariablesAndArguments, optionsWithArguments);
        }

        if(optionsWithArguments.stopIfEmpty && result.length === 0) {
            throw new StopError("Action '"+self.name+"' had no output, and 'stopIfEmpty' was set!");
        }

        return result;
    }
}
Action.registerPrimitiveAction("select", SelectAction);
window.SelectAction = SelectAction;

/**
 * An action 'storeSelection' that stores the current concept selection as a variable
 * @memberOf ContextActions
 * @example
 * {
 *     "storeSelection": {
 *         "as": "mySelectionVariableName"
 *     }
 * }
 *
 * @example
 * //Shorthand
 * {
 *     "storeSelection": "mySelectionVariableName"
 * }
 */
class StoreSelectionAction extends Action {
    static options() {
        return {
            "as": "@string"
        };
    }

    constructor(name, options, concept) {

        if(typeof options === "string") {
            options = {
                "as": options
            };
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        let uuids = contexts.filter((context)=>{
            return context.target != null;
        }).map((context)=>{
            return context.target;
        });

        let variableName = Action.defaultVariableName(this);

        let optionsWithArguments = await Action.lookupArguments(this.options, actionArguments);

        let commonVariables = Action.getCommonVariables(contexts);
        let optionsWithVariablesAndArguments = await Action.lookupVariables(optionsWithArguments, {variables: commonVariables});

        if(optionsWithVariablesAndArguments.as) {
            variableName = optionsWithVariablesAndArguments.as;
        }

        contexts.forEach((context)=>{
            Action.setVariable(context, variableName, uuids.slice());
        })

        return contexts;
    }
}
Action.registerPrimitiveAction("storeSelection", StoreSelectionAction);
window.StoreSelectionAction = StoreSelectionAction;

/**
 * An action "limit" that limits the current selected concepts to a given count, starting from first or last
 * @memberOf ContextActions
 * @example
 * //Limit concepts to 1, starting from first
 * {
 *     "limit": {
 *         "count": 1,
 *         "last": false
 *     }
 * }
 *
 * @example
 * //Limit concepts to 1, starting from first (shorthand version)
 * {
 *     "limit": 1
 * }
 *
 * @example
 * //Limit concepts to 2, starting from last
 * {
 *     "limit": {
 *         "count": 2,
 *         "last": true
 *     }
 * }
 */
class LimitAction extends Action {
    static options() {
        return {
            "count": "number",
            "last": "boolean%false"
        };
    }

    constructor(name, options, concept) {
        //Shorthand
        if(typeof options === "number") {
            options = {
                count: options
            }
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        return this.forEachContext(contexts, actionArguments, (context, options, index)=>{
            if(options.count == null) {
                throw new Error("Missing option 'count' on action 'limit'");
            }

            if(options.last === true) {
                //Allow the last "count" elements through
                if(index >= contexts.length - options.count) {
                    return context;
                }
            } else {
                //Allow the first "count" elements through
                if(index <= options.count-1) {
                    return context;
                }
            }
        });
    }
}
Action.registerPrimitiveAction("limit", LimitAction);
window.LimitAction = LimitAction;

/**
 * An action "where" that filters on the currently selected concepts
 *
 * If the option "stopIfEmpty" is set to true, the action chain will terminate after the where action, if no concepts
 * survived the filtering.
 * <p>
 * Available operators for property/variable/value filter:
 * </p>
 *
 * <ul>
 * <li>"equals" - "number", "boolean", "string", "concept", "array"</li>
 * <li>"unequals" - "number", "boolean", "string", "concept", "array"</li>
 * <li>"greaterThan" - "number", "string"</li>
 * <li>"lessThan" - "number", "string"</li>
 * <li>"greaterOrEquals" - "number", "string"</li>
 * <li>"lessOrEquals" - "number", "string"</li>
 * <li>"startsWith" - "string"</li>
 * <li>"endsWith" - "string"</li>
 * <li>"includes" - "string", "array"</li>
 * <li>"includesAny" - "array"</li>
 * <li>"includesAll" - "array"</li>
 * <li>"matches" - "string"</li>
 * </ul>
 * @memberOf ContextActions
 * @example
 * {
 *     "where": {
 *         "or": [
 *             {
 *                 "calculate": "10 + $myVariable$",
 *                 "equals": 15
 *             },
 *             {
 *                 "not": {
 *                     "variable": "myVariableName",
 *                     "equals": "myVariableValue"
 *                 }
 *             },
 *             {
 *                 "not": {
 *                     "property": "myProperty",
 *                     "equals": "myPropertyValue"
 *                 }
 *             },
 *             {
 *                 "and": [
 *                     {
 *                         "property": "myOtherProperty",
 *                         "unequals": "somethingelse"
 *                     },
 *                     {
 *                         "property": "myThirdProperty",
 *                         "lowerThan": 10
 *                     }
 *                 ]
 *             }
 *         ]
 *     }
 * }
 */
class FilterAction extends Action {
    static options() {
        return {
            "$where": "filter",
            "stopIfEmpty": "boolean%false"
        };
    }
    constructor(name, options, concept) {
        const defaultOptions = {
            stopIfEmpty: false
        };

        options = Object.assign({}, defaultOptions, options);

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        let result = await this.forEachContext(contexts, actionArguments, async (context, options)=>{
            let mark = VarvPerformance.start();

            try {
                let filter = FilterAction.constructFilter(options);

                let shouldKeep = await filter.filter(context, this.concept);

                VarvPerformance.stop("FilterAction.forEachContext.loop", mark);

                if (shouldKeep) {
                    return context;
                }
            } catch(e) {
                console.error(e);
            }

            return null;
        });

        let optionsWithArguments = await Action.lookupArguments(this.options, actionArguments);

        if(optionsWithArguments.stopIfEmpty && result.length === 0) {
            throw new StopError("Action '"+self.name+"' had no output, and 'stopIfEmpty' was set!");
        }

        return result;
    }

    static constructFilter(options) {
        let filter = FilterAction.constructFilterInternal(options);
        filter.constructOptions = options;
        return filter;
    }

    static constructFilterInternal(options) {
        try {
            let operator = null;

            for(let op in FilterOps) {
                if(typeof options[op] !== "undefined") {
                    operator = op;
                    break;
                }
            }

            if (operator !== null) {
                let value = options[operator];

                if(operator === "hasProperty") {
                    return new FilterPropertyExists(value);
                }
                if(operator === "propertyType") {
                    return new FilterPropertyType(options.property, value);
                }

                if(options.calculation != null) {
                    //Property defined, this is a property filter
                    return new FilterCalc(options.calculation, operator, value);
                }

                if(options.property != null) {
                    //Property defined, this is a property filter
                    return new FilterProperty(options.property, operator, value);
                }

                if(options.variable != null) {
                    //Variable defined, this is a variable filter
                    return new FilterVariable(options.variable, operator, value);
                }

                return new FilterValue(operator, value);
            } else {
                //This should be an "and", "or", "not" or concept filter

                if(options.concept != null) {
                    if(options.includeOthers != null) {
                        return new FilterConcept(options.concept, options.includeOthers);
                    }

                    //Concept defined, this is a concept filter
                    return new FilterConcept(options.concept);
                }

                if (options.or != null) {
                    let orFilters = [];

                    options.or.forEach((filterOptions) => {
                        orFilters.push(FilterAction.constructFilter(filterOptions));
                    });

                    return new FilterOr(orFilters);
                } else if (options.and != null) {
                    let andFilters = [];

                    options.and.forEach((filterOptions) => {
                        andFilters.push(FilterAction.constructFilter(filterOptions));
                    });

                    return new FilterAnd(andFilters);
                } else if (options.not != null) {
                    return new FilterNot(FilterAction.constructFilter(options.not));
                }
            }
        } catch(e) {
            console.error(e);
        }

        console.warn("No filter constructed using:", options);

        return null;
    }
}
Action.registerPrimitiveAction("where", FilterAction);
window.FilterAction = FilterAction;

/**
 * An action "new" that creates a new concept, optionally setting properties on it as well.
 * Runs in bulk mode unless 'forEach: true' is set. In bulk mode only 1 new concept is created, else 1 new would be created for every currently selected concept.
 * 'select: false' is not supported in bulk mode ('forEach: false')
 *
 *
 * @memberOf ContextActions
 * @example
 * {
 *      "new": {
 *          "concept": "myConcept",
 *          "with": {
 *              "myFirstProperty": "someValue",
 *              "mySecondProperty": false
 *              "myThirdProperty": "$myVariableName"
 *          }
 *      }
 * }
 *
 * @example
 * //Run in non-bulk mode, creates 1 "myConcept" for each currently selected concept
 * {
 *      "new": {
 *          "concept": "myConcept",
 *          "forEach": true
 *      }
 * }
 *
 * @example
 * //Same as other example, but don't change the current selection, which means that the newly created concept is only passed along as a variable
 * {
 *      "new": {
 *          "concept": "myConcept",
 *          "with": {
 *              "myFirstProperty": "someValue",
 *              "mySecondProperty": false
 *              "myThirdProperty": "$myVariableName"
 *          },
 *          "as": "myVariableName",
 *          "select": false
 *      }
 * }
 */
class NewAction extends Action {
    static options() {
        return {
            "concept": "string",
            "with": "propertyList",
            "as": "@string",
            "select": "boolean%true"
        }
    }
    constructor(name, options, concept) {
        //Shorthand
        if(typeof options === "string") {
            options = {
                concept: options
            }
        }

        const defaultOptions = {
            select: true,
            forEach: false
        };

        super(name, Object.assign({}, defaultOptions, options), concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        async function doNew(context, options) {
            let concept = VarvEngine.getConceptFromType(options.concept);

            let uuid = await concept.create(null, options.with);

            let variableName = Action.defaultVariableName(self);

            if (options.as != null) {
                variableName = options.as;
            }

            Action.setVariable(context, variableName, uuid);

            let select = options.select;

            if(options.forEach == false) {
                if(!select) {
                    console.warn("Uncompatible options for 'new' action - select: false and forEach: false. Bulk mode always selects the newly created instance")
                }

                select = true;
            }

            if(select) {
                context.target = uuid;
            }

            return context;
        }

        let optionsWithArguments = await Action.lookupArguments(this.options, actionArguments);

        let result = [];

        if(optionsWithArguments.forEach) {
            result = await this.forEachContext(contexts, actionArguments, async (context, options) => {
                return await doNew(context, options);
            });
        } else {
            //Bulk mode

            //Find any common variables and keep
            let commonVariables = Action.getCommonVariables(contexts);

            let optionsWithVariablesAndArguments = await Action.lookupVariables(optionsWithArguments, {variables: commonVariables});

            result = [await doNew({variables: commonVariables}, optionsWithVariablesAndArguments)];
        }

        return result;
    }
}
Action.registerPrimitiveAction("new", NewAction);
window.NewAction = NewAction;

/**
 * An action "remove" that removes instances of concepts
 * @memberOf ContextActions
 * @example
 * //Remove the current context target
 * {
 *     "remove"
 * }
 *
 * @example
 * // Remove the concept or concepts (if variable points to an array) that the variable holds
 * {
 *     "remove": "$someVariable"
 * }
 */
class RemoveAction extends Action {
    static options() {
        return {
            "target": "@string"
        };
    }

    constructor(name, options, concept) {
        if(typeof options === "string") {
            options = {
                target: options
            }
        }
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        return this.forEachContext(contexts, actionArguments, async (context, options)=>{

            let removeUuids = options.target;

            if(removeUuids == null) {
                if(context.target == null) {
                    throw new Error("No uuid's supplied to be removed, and context.target is non existant");
                }

                //No remove option specified, remove current target
                removeUuids = context.target;

                context.target = null;
            }

            if(!Array.isArray(removeUuids)) {
                removeUuids = [removeUuids];
            }

            for(let uuid of removeUuids) {
                let concept = await VarvEngine.getConceptFromUUID(uuid);
                await concept.delete(uuid);
            }

            //Return null, to signal that this target/context is now invalid.
            return null;
        });
    }
}
Action.registerPrimitiveAction("remove", RemoveAction);
window.RemoveAction = RemoveAction;

/**
 * An action "eval" that takes a filter, and sets a variable to true/false, depending on if the filter matched or not
 * @memberOf ContextActions
 * @example
 * {
 *     "eval": {
 *         "and": [
 *             { "property": "myFirstProperty", "equals": false },
 *             { "property": "mySecondProperty", "equals": false }
 *         ]
 *     }
 * }
 */
class EvalAction extends Action {
    static options() {
        return {
            "$eval": "filter",
            "as": "@string"
        };
    }
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;
        return this.forEachContext(contexts, actionArguments, async (context, options)=>{

            let filter = FilterAction.constructFilter(options);

            let shouldFilter = await filter.filter(context);

            let variableName = Action.defaultVariableName(self);

            if(options.as != null) {
                variableName = options.as;
            }

            Action.setVariable(context, variableName, shouldFilter);

            return context;
        });
    }
}
Action.registerPrimitiveAction("eval", EvalAction);
window.EvalAction = EvalAction;

/**
 * An action "count" that counts how many concepts exists with the given where filter. Sets a variable to the count
 * @memberOf ContextActions
 * @example
 * // Counts how many "myConcept" that matches the given "where" filter, and saves the result as "myResultVariableName"
 * {
 *     "count": {
 *         "concept": "myConcept",
 *         "where": {
 *             "property": "myProperty",
 *             "equals": "myTestValue"
 *         },
 *         "as": "myResultVariableName"
 *     }
 * }
 *
 * @example
 * // Counts how many "myConcept" there is, and saves the result as "count"
 * {
 *     "count": "myConcept
 * }
 */
class CountAction extends SelectAction {
    static options() {
        return {
            "$selectType": "enumValue[concept]",
            "where": "filter",
            "as": "@string",
            "forEach": "boolean%false"
        };
    }

    constructor(name, options, concept) {
        if(typeof options === "string") {
            options = {
                concept: options
            }
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        let optionsWithArguments = await Action.lookupArguments(this.options, actionArguments);

        async function doCount(context, options) {
            if(options.concept == null) {
                throw new Error("Count requires an option 'concept'");
            }

            let filter = null;

            if(self.wherePart) {
                let clonedVariables = Object.assign({}, context.variables);

                let filterContext = {target: null, lastTarget: context.target, variables: clonedVariables};

                let lookupWhereWithArguments = await Action.lookupArguments(self.wherePart, actionArguments);

                let lookupWhereOptions = await Action.lookupVariables(lookupWhereWithArguments, filterContext);

                filter = await FilterAction.constructFilter(lookupWhereOptions);
            }

            return await VarvEngine.countInstances(VarvEngine.getAllImplementingConceptNames(options.concept), filter, context, 0, self.concept);
        }

        if(optionsWithArguments.forEach) {
            return this.forEachContext(contexts, actionArguments, async (context, options)=>{
                let clonedContext = Action.cloneContext(context);

                let count = await doCount(clonedContext, options);

                let variableName = Action.defaultVariableName(self);

                if(options.as != null) {
                    variableName = options.as;
                }

                Action.setVariable(context, variableName, count);

                return context;
            });
        } else {
            //Bulk mode
            //Find any common variables and keep
            let commonVariables = Action.getCommonVariables(contexts);

            let commonTarget = -1;

            contexts.forEach((context)=>{
                if(commonTarget === -1) {
                    commonTarget = context.target;
                } else {
                    if(commonTarget !== context.target) {
                        commonTarget = null;
                    }
                }
            });

            let optionsWithVariablesAndArguments = await Action.lookupVariables(optionsWithArguments, {target: commonTarget, variables: commonVariables});

            let count = await doCount({target: commonTarget, variables: commonVariables}, optionsWithVariablesAndArguments);

            return this.forEachContext(contexts, actionArguments, async (context, options)=>{
                let variableName = Action.defaultVariableName(self);

                if(options.as != null) {
                    variableName = options.as;
                }

                Action.setVariable(context, variableName, count);

                return context;
            });
        }
    }
}
Action.registerPrimitiveAction("count", CountAction);
window.CountAction = CountAction;

/**
 * An action "exists" that checks if any concepts exists with the given where filter. Sets a variable to true/false depending.
 * @memberOf ContextActions
 * @example
 * // Sets a variable "myResultVariableName" to true/false depending on if any "myConcept" that matches the where filter exists
 * {
 *     "exists": {
 *         "concept": "myConcept",
 *         "where": {
 *             "property": "myProperty",
 *             "equals": "myTestValue"
 *         },
 *         "as": "myResultVariableName"
 *     }
 * }
 *
 * @example
 * // Sets a variable "exists" to true/false depending on if any "myConcept" exists
 * {
 *     "exists": "myConcept"
 * }
 */
class ExistsAction extends SelectAction {
    static options() {
        return {
            "$selectType": "enumValue[concept]",
            "where": "filter",
            "as": "@string",
            "forEach": "boolean%false"
        };
    }

    constructor(name, options, concept) {
        if(typeof options === "string") {
            options = {
                concept: options
            }
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        let optionsWithArguments = await Action.lookupArguments(this.options, actionArguments);

        async function doExists(context, options) {
            if(options.concept == null) {
                throw new Error("Exists requires an option 'concept'")
            }

            let filter = null;

            if(self.wherePart) {
                let clonedVariables = Object.assign({}, context.variables);

                let filterContext = {target: null, lastTarget: context.target, variables: clonedVariables};

                let lookupWhereWithArguments = await Action.lookupArguments(self.wherePart, actionArguments);

                let lookupWhereOptions = await Action.lookupVariables(lookupWhereWithArguments, filterContext);

                filter = await FilterAction.constructFilter(lookupWhereOptions);
            }

            return await VarvEngine.existsInstance(VarvEngine.getAllImplementingConceptNames(options.concept), filter, context, 1, self.concept);
        }

        if(optionsWithArguments.forEach) {
            return this.forEachContext(contexts, actionArguments, async (context, options)=>{
                let clonedContext = Action.cloneContext(context);

                let exists = await doExists(clonedContext, options);

                let variableName = Action.defaultVariableName(self);

                if(options.as != null) {
                    variableName = options.as;
                }

                Action.setVariable(context, variableName, exists);

                return context;
            });
        } else {
            //Bulk mode
            //Find any common variables and keep
            let commonVariables = Action.getCommonVariables(contexts);

            let commonTarget = -1;

            contexts.forEach((context)=>{
                if(commonTarget === -1) {
                    commonTarget = context.target;
                } else {
                    if(commonTarget !== context.target) {
                        commonTarget = null;
                    }
                }
            });

            let optionsWithVariablesAndArguments = await Action.lookupVariables(optionsWithArguments, {target: commonTarget, variables: commonVariables});

            let exists = await doExists({target: commonTarget, variables: commonVariables}, optionsWithVariablesAndArguments);

            return this.forEachContext(contexts, actionArguments, async (context, options)=>{
                let variableName = Action.defaultVariableName(self);

                if(options.as != null) {
                    variableName = options.as;
                }

                Action.setVariable(context, variableName, exists);

                return context;
            });
        }
    }
}
Action.registerPrimitiveAction("exists", ExistsAction);
window.ExistsAction = ExistsAction;

/**
 * An action 'sort' that sorts the selected concepts naturally based on a property/variable, can be sorted either ascending or descending.
 *
 * Always sorts "naturally", and only supports string, number and boolean types.
 * @memberOf ContextActions
 * @example
 * {"sort": {
 *     "property": "myProperty",
 *     "order": "asc"
 * }}
 *
 * @example
 * {"sort": {
 *     "variable": "myVariable",
 *     "order": "desc"
 * }}
 *
 * @example
 * //Shorthand sorts ascending on property
 * {"sort": "myProperty"}
 */
class SortAction extends Action {
    constructor(name, options, concept) {
        if(typeof options === "string") {
            options = {
                "property": options
            }
        }

        if(options.order == null) {
            options.order = "asc"
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        let optionsWithArguments = await Action.lookupArguments(this.options, actionArguments);

        if(optionsWithArguments.property == null && optionsWithArguments.variable == null) {
            throw new Error("Missing option property or variable on sort action");
        }

        const sortedContexts = await Promise.all(contexts.map(async (context)=> {
            let obj = {
                c: context,
                t: await VarvEngine.getConceptFromUUID(context.target),
            };

            if(optionsWithArguments.property) {
                //We have an invariant that says that all selected concepts are of same type
                console.warn("TODO: Implement some fix for polymorphism enabled sort");
                const concept = obj.t;
                if(concept == null) {
                    throw new Error("Unable to find concept for uuid ["+obj.c.target+"]");
                }

                const property = concept.getProperty(optionsWithArguments.property);
                if(property == null) {
                    throw new Error("Unable to find property ["+optionsWithArguments.property+"] on ["+concept.name+"]");
                }

                let value = await property.getValue(obj.c.target);
                obj.v = value;
            } else {
                //Variable
                let value = Action.getVariable(obj.c, optionsWithArguments.variable);
                obj.v = value;
            }

            return obj;
        }));

        sortedContexts.sort((c1, c2)=>{
            let s1 = c1.v;
            let s2 = c2.v;

            if(typeof s1 !== typeof s2) {
                throw new Error("Unable to sort when not the same type: ("+s1+") - ("+s2+")");
            }

            if(typeof s1 === "number") {
                return s1 - s2;
            } else if(typeof s1 === "string") {
                return s1.localeCompare(s2);
            } else if(typeof s1 === "boolean") {
                return s1 - s2;
            } else {
                console.warn("Unable to sort "+(typeof s1));
            }
        });

        return sortedContexts.map((o)=>{
            return o.c;
        });
    }
}
Action.registerPrimitiveAction("sort", SortAction);
window.SortAction = SortAction;


/**
 * An action "clone" that copies instances of concepts
 * @memberOf ContextActions
 * @example
 * // Clone the current context target
 * {
 *     "clone"
 * }
 *
 * @example
 * // Clone the concepts referenced in $myUuidArray
 * {"clone": {
 *  "of": "$myUuidArray"
 * }}
 *
 * @example
 * //Do a deep clone of current context target, setting the variable "myVariable" to the result, not selecting the new clone
 * {"clone: {
 *     "deep": true,
 *     "select": false,
 *     "as": "myVariable"
 * }}
 *
 */
class CloneAction extends Action {
    static options() {
        return {
            "target": "@string"
        };
    }

    constructor(name, options, concept) {
        if(typeof options === "string") {
            options = {
                of: options
            }
        }
        const defaultOptions = {
            select: true,
            deep: false
        };

        super(name, Object.assign({}, defaultOptions, options), concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            let cloneUUIDs = options.of;

            if(cloneUUIDs == null) {
                if(context.target == null) {
                    throw new Error("No uuid's in 'of' option supplied to be cloned, and context.target is non existant");
                }

                // No clone option specified, clone current target
                cloneUUIDs = context.target;
            }

            if(!Array.isArray(cloneUUIDs)) {
                cloneUUIDs = [cloneUUIDs];
            }

            let resultingContexts = [];

            let newUUIDs = [];
            for(let uuid of cloneUUIDs) {
                let concept = await VarvEngine.getConceptFromUUID(uuid);
                let clone = await concept.clone(uuid, options.deep);
                newUUIDs.push(clone);
            }

            // Handle "as" before creating result contexts as it needs to be on all of them.
            let variableName = Action.defaultVariableName(self);

            if (options.as != null) {
                variableName = options.as;
            }

            if(options.select) {
                //Select the new clones
                for(let uuid of newUUIDs) {
                    let resultContext = Action.cloneContext(context);
                    resultContext.target = uuid;

                    let variableValue = newUUIDs;
                    if(newUUIDs.length === 1) {
                        variableValue = uuid;
                    }

                    Action.setVariable(resultContext, variableName, variableValue);
                    resultingContexts.push(resultContext);
                }

                return resultingContexts;
            } else {
                //Keep our old context selected
                if(newUUIDs.length === 1) {
                    newUUIDs = newUUIDs[0];
                }

                Action.setVariable(context, variableName, newUUIDs);
                return context;
            }
        });
    }
}
Action.registerPrimitiveAction("clone", CloneAction);
window.CloneAction = CloneAction;

/**
 * An action 'setType' that can change the type of a concept instance, highly experimental
 *
 * @memberOf ContextActions
 *
 * @example
 * //Changes the type of all currently selected concept instances to "myNewConcept"
 * {
 *     "setType": {"concept": "myNewConcept"}
 * }
 *
 * @example
 * //Shorthand
 * {"setType": "myNewConcept"}
 */
class SetTypeAction extends Action {
    constructor(name, options, concept) {
        if(typeof options === "string") {
            options = {
                concept: options
            }
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            if(options.concept == null) {
                throw new Error("Missing concept in action 'setType'");
            }

            let targetConcept = VarvEngine.getConceptFromType(options.concept);

            if(targetConcept == null) {
                throw new Error("Unknown concept \""+options.concept+"\" in action 'setType'");
            }

            if(context.target != null) {
                let concept = await VarvEngine.getConceptFromUUID(context.target);

                if(concept != null) {
                    await VarvEngine.switchConceptType(context.target, targetConcept, concept);
                }
            } else {
                throw new Error("Missing context.target in action 'setType'");
            }

            return context;
        });
    }
}
Action.registerPrimitiveAction("setType", SetTypeAction);
window.SetTypeAction = SetTypeAction;

</SCRIPT><SCRIPT id="MathActions-script" type="disabled">
/**
 *  MathActions - Actions that calculate math
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * Actions that do math
 * @namespace MathActions
 */

class IncrementDecrementAction extends Action {
    constructor(name, decrement, options, concept) {
        // Handle string shorthand
        if(typeof options === "string"){
            options = {
                property: options
            }
        }

        const defaultOptions = {
            by: 1
        }

        super(name, Object.assign({}, defaultOptions, options), concept);

        this.decrement = decrement;
    }

    /**
     * @param {VarvContext[]} context
     * @returns {Promise<VarvContext[]>}
     */
    async apply(contexts, actionArguments = {}) {
        const self = this;

        if(this.options.property == null && this.options.variable == null) {
            throw new Error("Either 'property' or 'variable' needs to be set for action 'increment'");
        }

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            if(options.property != null) {
                const lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.property);

                if(lookup == null) {
                    throw new Error("No property ["+options.of.property+"] found");
                }

                const concept = lookup.concept;
                const property = lookup.property;
                const target = lookup.target;

                let currentValue = await property.getValue(target);

                if (this.decrement) {
                    currentValue -= options.by;
                } else {
                    currentValue += options.by;
                }

                await property.setValue(target, currentValue);
            } else if(options.variable != null) {
                let currentValue = Action.getVariable(context, options.variable);

                if (this.decrement) {
                    currentValue -= options.by;
                } else {
                    currentValue += options.by;
                }

                Action.setVariable(context, options.variable, currentValue);
            }

            return context;
        });
    }
}

/**
 * An action "increment" that increments a number property or variable
 * @memberOf MathActions
 * @example
 * // Increment the property by 1
 * {
 *     "increment": {
 *         "property": "myNumberProperty"
 *     }
 * }
 *
 * @example
 * // Increment the property by 2
 * {
 *     "increment": {
 *         "property": "myNumberProperty",
 *         "by": 2
 *     }
 * }
 *
 * @example
 * // Increment the property by 1, (Shorthand version)
 * {
 *     "increment": "myNumberProperty"
 * }
 *
 * @example
 * // Increment the variable by 2
 * {
 *     "increment": {
 *         "variable": "myNumberVariable",
 *         "by": 2
 *     }
 * }
 */
class IncrementAction extends IncrementDecrementAction {
    static options() {
        return {
            "$inc": "enumValue[property,variable]",
            "by": "number%1"
        }
    }

    constructor(name, options, concept) {
        super(name, false, options, concept);
    }
}
Action.registerPrimitiveAction("increment", IncrementAction);
window.IncrementAction = IncrementAction;

/**
 * An action "decrement" that decrements a number property or variable
 * @memberOf MathActions
 * @example
 * // Decrement the property by 1
 * {
 *     "decrement": {
 *         "property": "myNumberProperty"
 *     }
 * }
 *
 * @example
 * // Decrement the property by 2
 * {
 *     "decrement": {
 *         "property": "myNumberProperty",
 *         "by": 2
 *     }
 * }
 *
 * @example
 * // Decrement the property by 1, (Shorthand version)
 * {
 *     "decrement": "myNumberProperty"
 * }
 *
 * @example
 * // Decrement the variable by 2
 * {
 *     "decrement": {
 *         "variable": "myNumberVariable",
 *         "by": 2
 *     }
 * }
 */
class DecrementAction extends IncrementDecrementAction {
    static options() {
        return {
            "$dec": "enumValue[property,variable]",
            "by": "number%1"
        }
    }

    constructor(name, options, concept) {
        super(name, true, options, concept);
    }
}
Action.registerPrimitiveAction("decrement", DecrementAction);
window.DecrementAction = DecrementAction;

/**
 * An action 'calculate' that calculates a given math expression and sets a variable with the result
 * @memberOf MathActions
 * @example
 * //Shorthand, calculates and sets result in variable 'calculate'
 * {
 *     "calculate": "42 + 60 + $myVariableName$
 * }
 *
 * @example
 * {
 *     "calculate": {
 *         "expression": "sqrt(2) * sqrt(2)",
 *         "as": "myResultVariableName"
 *     }
 * }
 */
class CalculateAction extends Action {
    static options() {
        return {
            "expression": "string",
            "as": "@string"
        }
    }

    constructor(name, options, concept) {
        //Shorthand
        if(typeof options === "string") {
            options = {
                expression: options
            }
        }

        if(Array.isArray((options))) {
            options = {
                expression: options.join(";")
            }
        }

        super(name, options, concept);
    }

    static evaluate(expression) {
        let result = math.evaluate(expression);
        if (typeof result === "object" && Array.isArray(result.entries) && result.entries.length>0){
            // Collapse to single value if parser switched to multi-expression evaluation mode
            result = result.entries[0];
        }

        return result;
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{

            let resultName = Action.defaultVariableName(self);

            if(options.as != null) {
                resultName = options.as;
            }

            let result = CalculateAction.evaluate(options.expression);

            Action.setVariable(context, resultName, result);

            return context;
        });
    }
}
Action.registerPrimitiveAction("calculate", CalculateAction);
window.CalculateAction = CalculateAction;

/**
 * An action 'random' that generates a random number from within a range. Both minimum and maximum are inclusive
 *
 * If no range is specified. 0 - Number.MAX_SAFE_INTEGER (2^53 -1) is used as range.
 * @memberOf MathActions
 * @example
 * //Shorthand, generates a random number between 0 and 10, saves the result in the variable named "random"
 * {
 *     "random": [0, 10]
 * }
 *
 * @example
 * //Generate a random integer between 0 and 10, and save the result in the variable "myResultVariableName"
 * {
 *     "random": {
 *         "range": [0, 10],
 *         "as": "myResultVariableName"
 *     }
 * }
 *
 * @example
 * //Generate a random float number between 0 and 10, and save the result in the variable "myResultVariableName"
 * {
 *     "random": {
 *         "range": [0, 10],
 *         "float": true,
 *         "as": "myResultVariableName"
 *     }
 * }
 */
class RandomAction extends Action {
    static options() {
        return {
            "range": "range",
            "float": "boolean%false",
            "as": "@string"
        }
    }

    constructor(name, options, concept) {
        //Shorthand
        if(Array.isArray(options)) {
            options = {
                range: options
            }
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1) + min);
        }

        function getRandomArbitrary(min, max) {
            if(max < Number.MAX_VALUE) {
                //Upper bound is off by the smallest possible value
                //make it inclusive by incrementing by the smallest value
                max += Number.MIN_VALUE;
            }
            return Math.random() * (max - min) + min;
        }

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            let range = options.range;

            if(range == null) {
                range = [0, Number.MAX_SAFE_INTEGER]
            }

            let randomNumber = Number.NaN;

            if(options.float) {
                randomNumber = getRandomArbitrary(range[0], range[1]);
            } else {
                randomNumber = getRandomInt(range[0], range[1]);
            }

            let variableName = Action.defaultVariableName(this);

            if(options.as != null) {
                variableName = options.as;
            }

            Action.setVariable(context, variableName, randomNumber);

            return context;
        });
    }
}
Action.registerPrimitiveAction("random", RandomAction);
window.RandomAction = RandomAction;

</SCRIPT><SCRIPT id="PropertyActions-script" type="disabled">
/**
 *  PropertyActions - Actions that manipulate properties on concept instances
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * Actions that operate on properties
 * @namespace PropertyActions
 */

/**
 * An action "set" that sets a property or variable to a given value
 * @memberOf PropertyActions
 * @example
 * //Set property to a given value
 * {
 *     "set": {
 *         "property": "myProperty",
 *         "value": "myValueToSet"
 *     }
 * }
 *
 * @example
 * //Set property to a given value (shorthand version)
 * {
 *     "set": {
 *         "myProperty": "myValueToSet"
 *     }
 * }
 *
 * @example
 * //Set variable to a given value (shorthand version)
 * {
 *     "set": {
 *         "$myVariableName": "myValueToSet"
 *     }
 * }
 *
 * @example
 * //Set a variable to a given value
 * {
 *     "set": {
 *         "variable": "myVariableName",
 *         "value": "myValueToSet"
 *     }
 * }
 *
 * @example
 * //Set a property on a currently non selected concept to a given value
 * {
 *     "set": {
 *         "property": "myConcept.myProperty",
 *         "value": "myValueToSet"
 *     }
 * }
 */
class SetAction extends Action {
    static options() {
        return {
            "$setType": "enumValue[property,variable]",
            "value": "raw"
        }
    }

    constructor(name, options, concept) {
        // Shorthand { "property-name": "value-to-set" }
        if(Object.keys(options).length === 1) {
            const key = Object.keys(options)[0];
            const value = options[key];

            if(key.trim().startsWith("$")) {
                options = {
                    variable: key.trim().substring(1),
                    value: value
                }
            } else {
                options = {
                    property: key,
                    value: value
                }
            }
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        const mark = "action-set-start-"+performance.now();

        if(this.options.property == null && this.options.variable == null) {
            throw new Error("Missing option 'property' or 'variable' on 'set' action: "+JSON.stringify(this.options, null, 2));
        }

        if(this.options.value == null) {
            throw new Error("Missing option 'value' on 'set' action: "+JSON.stringify(this.options, null, 2));
        }

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            let mark = VarvPerformance.start();

            if(options.property) {
                let lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.property);

                if(lookup == null) {
                    throw new Error("No property [" + options.property + "] found on any concept");
                }

                await lookup.property.setValue(lookup.target, options.value);
            } else if(options.variable) {
                Action.setVariable(context, options.variable, options.value);
            }

            VarvPerformance.stop("SetAction.forEachContext.loop", mark);

            return context;
        });
    }
}
Action.registerPrimitiveAction("set", SetAction);
window.SetAction = SetAction;

/**
 * An action 'get' that extracts a property and saves it in a variable
 * @memberOf PropertyActions
 * @example
 * {
 *     "get": {
 *         "property": "myProperty",
 *         "as": "myVariableName"
 *     }
 * }
 *
 * @example
 * //Get a property on a currently non selected concept
 * {
 *     "get": {
 *         "property": "myConcept.myProperty",
 *         "as": "myVariableName"
 *     }
 * }
 *
 * @example
 * //Shorthand example that gets the given property and sets it into variable 'get'
 * {
 *     "get": "myProperty"
 * }
 */
class GetAction extends Action {
    static options() {
        return {
            "property": "string",
            "as": "@string"
        }
    }
    constructor(name, options, concept) {
        //Shorthand
        if(typeof options === "string") {
            options = {
                property: options
            }
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            if(options.property == null) {
                throw new Error("Missing option 'property' on 'get' action");
            }

            let lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.property);

            if(lookup == null) {
                throw new Error("Unable to find property: "+options.property);
            }

            let value = await lookup.property.getValue(lookup.target);

            let resultName = Action.defaultVariableName(self);
            if(options.as != null) {
                resultName = options.as;
            }

            Action.setVariable(context, resultName, value);

            return context;
        });
    }
}
Action.registerPrimitiveAction("get", GetAction);
window.GetAction = GetAction;

/**
 * An action "toggle" that toggles a boolean property or variable
 * @memberOf PropertyActions
 * @example
 * //Toggle a boolean property
 * {
 *     "toggle": {
 *         "property": "myBooleanProperty"
 *     }
 * }
 *
 * @example
 * //Toggle a boolean property on a non selected concept
 * {
 *     "toggle": {
 *         "property": "myConcept.myBooleanProperty"
 *     }
 * }
 *
 * @example
 * //Toggle a boolean property (shorthand version)
 * {
 *     "toggle": "myBooleanProperty"
 * }
 *
 * @example
 * //Toggle a boolean variable (shorthand version)
 * {
 *     "toggle": "$myBooleanVariable"
 * }
 *
 * @example
 * //Toggle a boolean variable
 * {
 *     "toggle": {
 *         "variable": "myBooleanVariable"
 *     }
 * }
 */
class ToggleAction extends Action {
    static options() {
        return {
            "$setType": "enumValue[property,variable]"
        }
    }
    constructor(name, options, concept) {
        // Shorthand "toggle": "property-to-toggle"
        if(typeof options === "string") {
            if(options.trim().startsWith("$")) {
                options = {
                    variable: options.trim().substring(1),
                }
            } else {
                options = {
                    property: options,
                }
            }
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        if(this.options.property == null && this.options.variable == null) {
            throw new Error("Either 'property' or 'variable' must be set for 'toggle' action");
        }

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            if(options.property != null) {
                const lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.property);

                if(lookup == null) {
                    throw new Error("No property ["+options.of.property+"] found");
                }

                const concept = lookup.concept;
                const property = lookup.property;
                const target = lookup.target;

                if (property.type !== "boolean") {
                    throw new Error("Unable to toggle non boolean property [" + options.property + "] on [" + concept.name + "]");
                }

                let currentValue = await property.getValue(target);

                await property.setValue(target, !currentValue);
            } else if(options.variable != null) {
                let currentValue = Action.getVariable(context, options.variable);

                if(typeof currentValue !== "boolean") {
                    throw new Error("Unable to toggle non boolean variable ["+options.variable+"]");
                }

                Action.setVariable(context, options.variable, !currentValue);
            }

            return context;
        });
    }
}
Action.registerPrimitiveAction("toggle", ToggleAction);
window.ToggleAction = ToggleAction;

/**
 * An action 'enums' that sets a variable to all possible values of an enum string type.
 * @memberOf PropertyActions
 * @example
 * //Fetch all enum values for myEnumProperty and save in variable $enum
 * {
 *     "enums": {
 *         "property": "myEnumProperty"
 *     }
 * }
 *
 * @example
 * //Fetch all enum values for myEnumProperty and save in variable $myVariableName
 * {
 *     "enums": {
 *         "property": "myEnumProperty",
 *         "as": "myVariableName"
 *     }
 * }
 *
 * @example
 * //Non selected concept version
 * {
 *     "enums": {
 *         "property": "myConcept.myEnumProperty"
 *     }
 * }
 *
 * @example
 * //Shorthand version
 * {
 *     "enums": "myEnumProperty"
 * }
 */
class EnumsAction extends Action {
    static options() {
        return {
            "property": "string",
            "as": "@string"
        }
    }
    constructor(name, options, concept) {
        //Shorthand
        if(typeof options === "string") {
            options = {
                property: options
            }
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            if(options.property == null) {
                throw new Error("Missing required option 'property' for 'enums' action");
            }

            if(context.target == null) {
                throw new Error("Missing 'target' option for 'enums' action")
            }

            const lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.property);

            if(lookup == null) {
                throw new Error("No property ["+options.of.property+"] found");
            }

            const property = lookup.property;

            if(property.options.enum == null || property.type !== "string") {
                throw new Error("["+options.property+"] is not an enumerable string type");
            }

            let resultName = Action.defaultVariableName(self);

            if(options.as != null) {
                resultName = options.as;
            }

            Action.setVariable(context, resultName, property.options.enum.slice());

            return context;
        });
    }
}
Action.registerPrimitiveAction("enums", EnumsAction);
window.EnumsAction = EnumsAction;

/**
 * An action 'getType' that sets a variable to the type of the looked up property/variable/target. If the lookup finds nothing, the variable is set to undefined.
 *
 * @memberOf PropertyActions
 *
 * @example
 * {
 *     "getType": {
 *         "property": "myProperty",
 *         "as": "myPropertyType"
 *     }
 * }
 *
 * @example
 * {
 *     "getType": {
 *         "variable": "myVariableName",
 *         "as": "myVariableType"
 *     }
 * }
 *
 * @example
 * {
 *     "getType": {
 *         "target": "someConceptUUID",
 *         "as": "myConceptType"
 *     }
 * }
 *
 * @example
 * //Shorthand retrieves the type of myProperty and puts it in the variable 'getType'
 * //Looks up in the following order:
 * //ContextConcept, LocalConcept, GlobalConcept, Variable, UUID
 * {
 *     "getType": "somePropertyNameVariableNameOrConceptUUID"
 * }
 *
 * @example
 * //Shorthand that looks up the current target's concept type
 * "getType"
 */
class GetTypeAction extends Action {
    constructor(name, options, concept) {
        if(typeof options === "string") {
            options = {
                runtimeLookup: options
            }
        }

        if(typeof options === "object" && Object.keys(options).length === 0) {
            options.target = "$target$";
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments = {}) {
        let self = this;
        return this.forEachContext(contexts, actionArguments, async (context, options)=>{

            if(options.runtimeLookup != null) {
                //Figure out what we are dealing with
                let found = false;

                //Check for property on specificConcept, contextConcept, localConcept or globalConcept
                let propertyLookupResult = await VarvEngine.lookupProperty(context.target, self.concept, options.runtimeLookup);
                if(propertyLookupResult != null) {
                    options.property = propertyLookupResult.property;

                    found = true;
                }

                //Check for variable
                if(!found) {
                    //Not a property, try variable?
                    try {
                        Action.getVariable(context, options.runtimeLookup);

                        options.variable = options.runtimeLookup;

                        found = true;
                    } catch(e) {
                        //Do nothing
                    }
                }

                //Check for concept type
                if(!found) {
                    let concept = await VarvEngine.getConceptFromUUID(options.runtimeLookup);

                    if(concept != null) {
                        options.target = concept;
                        found = true;
                    }
                }

                if(!found) {
                    throw new Error("Unable to lookup ["+options.runtimeLookup+"] to anything meaningfull for action 'getType'");
                }
            }

            if(options.property == null && options.variable == null && options.target == null) {
                throw new Error("Missing option, either 'property', 'variable' or 'target' should be present on action 'getType'");
            }

            let result = undefined;

            if(options.property != null) {
                let foundProperty = null;

                if(options.property instanceof Property) {
                    foundProperty = options.property;
                } else {
                    let lookupResult = await VarvEngine.lookupProperty(context.target, self.concept, options.property);
                    if(lookupResult != null) {
                        foundProperty = lookupResult.property;
                    }
                }

                if(foundProperty != null) {
                    result = foundProperty.getType();

                    if(result === "array") {
                        result += ":"+foundProperty.getArrayType();
                    }
                }
            }

            if(options.variable != null) {
                try {
                    //Find type of variable?
                    let value = Action.getVariable(context, options.variable);

                    if (value != null) {
                        if (Array.isArray(value)) {
                            result = "array";
                        } else if (typeof value === "number") {
                            result = "number";
                        } else if (typeof value === "boolean") {
                            result = "boolean";
                        } else if (typeof value === "string") {
                            let concept = await VarvEngine.getConceptFromUUID(value);

                            if (concept != null) {
                                result = concept.name;
                            } else {
                                result = "string";
                            }
                        }
                    } else {
                        //Variable existed, but was null. Set type to "null" ?
                        result = "null";
                    }
                } catch(e) {
                    //Do nothing
                }
            }

            if(options.target != null) {
                //Find type of concept
                let foundConcept = null;

                if(options.target instanceof Concept) {
                    foundConcept = options.target;
                } else {
                    foundConcept = await VarvEngine.getConceptFromUUID(options.target);
                }

                if(foundConcept != null) {
                    result = foundConcept.name;
                }
            }

            let variableName = Action.defaultVariableName(self);

            if(options.as != null) {
                variableName = options.as;
            }

            Action.setVariable(context, variableName, result);

            return context;
        });
    }
}
Action.registerPrimitiveAction("getType", GetTypeAction);
window.GetTypeAction = GetTypeAction;

/**
 * An action 'conceptTypes' that returns the currently defined concept types, optionally filtered for injected/joined concepts
 * @memberOf PropertyActions
 *
 * @example
 * //Retrieve all concept types into the variable "myConceptTypes"
 * {"conceptTypes": {"as": "myConceptTypes"}}
 *
 * @example
 * //Retrieve all concept types, that have "myConcept" and "myOtherConcept" injected/joined. Saved into the variable "conceptTypes"
 * {"conceptTypes": {
 *     "isType": ["myConcept", "myOtherConcept"]
 * }}
 */
class ConceptTypesAction extends Action {
    constructor(name, options, concept) {

        super(name, options, concept);
    }

    async apply(contexts, actionArguments = {}) {
        let self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            let testTypes = options.isType;
            if(testTypes == null) {
                testTypes = [];
            }
            if(!Array.isArray(testTypes)) {
                testTypes = [testTypes];
            }

            let result = VarvEngine.concepts.filter((concept)=>{
                for(let testType of testTypes) {
                    if(!concept.isA(testType)) {
                        return false;
                    }
                }
                return true;
            }).map((concept)=>{
                return concept.name;
            });

            let variableName = Action.defaultVariableName(self);

            if(options.as != null) {
                variableName = options.as;
            }

            Action.setVariable(context, variableName, result);

            return context;
        });
    }
}
Action.registerPrimitiveAction("conceptTypes", ConceptTypesAction);
window.ConceptTypesAction = ConceptTypesAction;

</SCRIPT><SCRIPT id="TextActions-script" type="disabled">
/**
 *  TextActions - Actions related to string manipulation
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * Actions that operate on strings
 * @namespace TextActions
 */

/**
 * An action "textTransform" that can transform a string to either "uppercase", "lowercase", "capitalize"
 * @memberOf TextActions
 * @example
 * // Uppercase a string in a property
 * {
 *     "textTransform": {
 *         "property": "myStringProperty",
 *         "mode": "uppercase"
 *     }
 * }
 *
 * // Capitalize a string in a variable
 * {
 *     "textTransform": {
 *         "variable": "myStringVariable",
 *         "mode": "capitalize"
 *     }
 * }
 */
class TextTransformAction extends Action {
    static options() {
        return {
            "$transform": "enumValue[property,variable]",
            "mode": "enum[uppercase,lowercase,capitalize]"
        }
    }
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        if(this.options.property == null && this.options.variable == null) {
            throw new Error("Either 'property' or 'variable' must be set for action 'textTransform'");
        }

        if(this.options.mode == null) {
            throw new Error("Missing option 'mode' for action 'textTransform'");
        }

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            if(options.property != null) {
                const lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.property);

                if(lookup == null) {
                    throw new Error("No property ["+options.of.property+"] found");
                }

                const concept = lookup.concept;
                const property = lookup.property;
                const target = lookup.target;

                if (property.type !== "string") {
                    throw new Error("Unable to apply textTransform on non string property [" + options.property + "] on [" + concept.name + "]");
                }

                let currentValue = await property.getValue(target);

                currentValue = self.transform(currentValue, options.mode.toLowerCase());

                await property.setValue(target, currentValue);
            } else if(options.variable != null) {
                let value = Action.getVariable(context, options.variable);

                if (typeof value !== "string") {
                    throw new Error("Unable to apply textTransform on non string variable [" + options.variable + "]");
                }

                value = self.transform(value, options.mode.toLowerCase());

                Action.setVariable(context, options.variable, value);
            }

            return context;
        });
    }

    transform(value, mode) {
        switch (mode) {
            case "uppercase": {
                value = value.toUpperCase();
                break;
            }
            case "lowercase": {
                value = value.toLowerCase();
                break;
            }
            case "capitalize": {
                const words = value.toLowerCase().split(" ");
                for (let i = 0; i < words.length; i++) {
                    words[i] = words[i].charAt(0).toUpperCase() + words[i].substring(1);
                }
                value = words.join(" ");
                break;
            }

            default:
                throw new Error("Unknown text transform mode: " + mode);
        }

        return value;
    }
}
Action.registerPrimitiveAction("textTransform", TextTransformAction);
window.TextTransformAction = TextTransformAction;

/**
 * An action "concat" that concatenates an array of strings and saves the result in a variable
 * @memberOf TextActions
 * @example
 * {
 *     "concat": [
 *         "Hello",
 *         " ",
 *         "World!"
 *     ]
 * }
 *
 * @example
 * {
 *     "concat": {
 *          "strings": [
 *              "How",
 *              "dy!"
 *          ],
 *          "as": "myResultVariable"
 *     }
 * }
 *
 * @example
 * {
 *     "concat": {
 *          "strings": [
 *              "Hello, ",
 *              "$myStringVariable",
 *              " doing?"
 *          ],
 *          "as": "myResultVariable"
 *     }
 * }
 *
 * @example
 * {
 *     "concat": {
 *          "strings": "$myStringArrayVariable",
 *          "as": "myResultVariable"
 *     }
 * }
 *
 * @example
 * {
 *     "concat": {
 *          "strings": [
 *              "Variable: "
 *              {"variable": "myStringVariable"},
 *              " Property: ",
 *              {"property": "myStringProperty"}
 *          ],
 *          "as": "myResultVariable"
 *     }
 * }
 */
class ConcatAction extends Action {
    constructor(name, options, concept) {
        //Shorthand
        if(Array.isArray(options) || typeof options === "string") {
            options = {
                strings: options
            }
        }

        if(typeof options.strings === "string") {
            options.strings = [options.strings];
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            let resultName = Action.defaultVariableName(self);

            if(options.as != null) {
                resultName = options.as;
            }

            if(!Array.isArray(options.strings)) {
                throw new Error("Option 'strings' must be an array of strings");
            }

            let result = "";

            for(let s of options.strings) {
                if(typeof s === "object") {
                    if(s.variable != null) {
                        s = Action.getVariable(context, s.variable);
                    } else if(s.property != null) {
                        const lookup = await VarvEngine.lookupProperty(context.target, self.concept, s.property);

                        if(lookup == null) {
                            throw new Error("No property ["+options.of.property+"] found");
                        }

                        const concept = lookup.concept;
                        const property = lookup.property;
                        const target = lookup.target;

                        s = await property.getValue(target);
                    } else {
                        throw new Error("Unknown object type in concat strings array: "+JSON.stringify(s, null ,2));
                    }
                }

                result += s;
            }

            Action.setVariable(context, resultName, result);

            return context;
        });
    }
}
Action.registerPrimitiveAction("concat", ConcatAction);
window.ConcatAction = ConcatAction;

/**
 * An action 'split' that splits a String into an array, based on the given delimiter. Default delimiter is ","
 * @memberOf TextActions
 * @example
 * //Split the string in "myStringProperty" at the delimiter ";" and save the result in the variable "myArrayVariable", keeping any empty values. ex. "test;;test2" would not return the empty between ;;
 * {
 *     "split": {
 *         "property": "myStringProperty",
 *         "delimiter": ";",
 *         "removeEmptyValues": false,
 *         "as": "myArrayVariable"
 *     }
 * }
 *
 * @example
 * //Split the string in "myStringVariable" at the delimiter ";" and save the result in the variable "myArrayVariable"
 * {
 *     "split": {
 *         "variable": "myStringVariable",
 *         "delimiter": ";",
 *         "as": "myArrayVariable"
 *     }
 * }
 *
 * @example
 * //Shorthand example, splitting property using delimiter "," and saving result in variable "split"
 * {
 *     "split": "myStringProperty"
 * }
 *
 * @example
 * //Shorthand example, splitting variable using delimiter "," and saving result in variable "split"
 * {
 *     "split": "$myStringVariable"
 * }
 */
class TextSplitAction extends Action {
    constructor(name, options, concept) {
        if(typeof options === "string") {
            if(options.startsWith("$")) {
                options = {
                    "variable": options
                }
            } else {
                options = {
                    "property": options
                }
            }
        }

        const defaultOptions = {
            delimiter: ",",
            removeEmptyValues: true
        }

        super(name, Object.assign({}, defaultOptions, options), concept);
    }

    async apply(contexts, actionArguments = {}) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            let result = null;

            if(options.property != null) {
                const lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.property);

                if(lookup == null) {
                    throw new Error("No property ["+options.of.property+"] found");
                }

                const concept = lookup.concept;
                const property = lookup.property;
                const target = lookup.target;

                if (property.type !== "string") {
                    throw new Error("Unable to apply split on non string property [" + options.property + "] on [" + concept.name + "]");
                }

                let currentValue = await property.getValue(target);

                result = currentValue.split(options.delimiter);

            } else if(options.variable != null) {
                let value = Action.getVariable(context, options.variable);

                if (typeof value !== "string") {
                    throw new Error("Unable to apply textTransform on non string variable [" + options.variable + "]");
                }

                result = value.split(options.delimiter);
            }

            if(options.removeEmptyValues) {
                result = result.filter((v)=>{
                    return v.trim().length > 0;
                });
            }

            if(result != null) {
                let resultName = Action.defaultVariableName(self);

                if (options.as != null) {
                    resultName = options.as;
                }

                Action.setVariable(context, resultName, result);
            }

            return context;
        });
    }
}
window.TextSplitAction = TextSplitAction;
Action.registerPrimitiveAction("split", TextSplitAction);

</SCRIPT><SCRIPT id="TimingActions-script" type="disabled">
/**
 *  TimingActions - Actions related to time
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * Actions that deal with time
 * @namespace TimingActions
 */

/**
 * An action "wait" that waits for a given duration before continuing
 * @memberOf TimingActions
 * @example
 * //Wait for 100ms
 * {
 *     "wait": {
 *         "duration": 100
 *     }
 * }
 *
 * //Wait for 100ms (shorthand version)
 * {
 *     "wait": 100
 * }
 */
class WaitAction extends Action {
    static options() {
        return {
            "duration": "number"
        }
    }

    constructor(name, options, concept) {
        //shorthand
        if(typeof options === "number") {
            options = {
                "duration": options
            }
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        if(this.options.duration == null) {
            throw new Error("Option 'duration' must be present on 'wait' action");
        }
        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            await new Promise((resolve)=>{
                setTimeout(()=>{
                    resolve();
                }, options.duration);
            })

            return context;
        });
    }
}
Action.registerPrimitiveAction("wait", WaitAction);
window.WaitAction = WaitAction;

</SCRIPT><SCRIPT id="FlowActions-script" type="disabled">
/**
 *  FlowActions - Actions that create control flow
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * Actions that control the flow of the program
 * @namespace FlowActions
 */

/**
 * An action 'run' that runs another action, and continuing no matter the outcome of the other action.
 * @memberOf FlowActions
 * @example
 * {
 *     "run": {
 *         "action": "myActionName"
 *     }
 * }
 *
 * @example
 * //Shorthand example
 * {
 *     "run": "myActionName"
 * }
 */
class RunAction extends Action {
    static options() {
        return {
            "run": "string"
        }
    }

    constructor(name, options, concept) {
        //Shorthand
        if(typeof options === "string") {
            options = {
                action: options
            }
        }

        const defaultOptions = {
            lookupActionArguments: {},
            stopOnError: true
        };

        super(name, Object.assign({}, defaultOptions, options), concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        let optionsWithArguments = await Action.lookupArguments(this.options, actionArguments);

        if(optionsWithArguments.action == null) {
            throw new Error("Missing option 'action' for 'run' action");
        }

        //TODO: We assume that all concepts are of the same type, this is probabely wrong with otherConcepts being in play...
        let contextConcept = null;
        if(contexts.length > 0) {
            contextConcept = await VarvEngine.getConceptFromUUID(contexts[0].target);
        }

        let commonVariables = Action.getCommonVariables(contexts);
        let commonTarget = Action.getCommonTarget(contexts);

        let optionsWithVariablesAndArguments = await Action.lookupVariables(optionsWithArguments, {target: commonTarget, variables: commonVariables});

        let action = VarvEngine.lookupAction(optionsWithVariablesAndArguments.action, [contextConcept, self.concept]);

        if(action == null) {
            throw new Error("Unable to find action ["+optionsWithVariablesAndArguments.action+"]");
        }

        let clonedContexts = contexts.map((context)=> {
            return Action.cloneContext(context);
        });
        if(contexts.savedVariables) {
            clonedContexts.savedVariables = JSON.parse(JSON.stringify(contexts.savedVariables));
        }

        try {
            await ActionTrigger.before(action, clonedContexts);
            let mark = VarvPerformance.start();
            let runContextsResult = await action.apply(clonedContexts, optionsWithVariablesAndArguments.lookupActionArguments);
            if(action.isPrimitive) {
                VarvPerformance.stop("PrimitiveAction-"+action.name, mark);
            } else {
                VarvPerformance.stop("CustomAction-"+action.name, mark);
            }
            await ActionTrigger.after(action, runContextsResult);
        } catch(e) {
            if(e instanceof StopError) {
                //console.log("Run Action was stopped: " + e.message);
            } else {
                if(this.options.stopOnError === true) {
                    throw e;
                }
            }
        }

        return contexts;
    }
}
Action.registerPrimitiveAction("run", RunAction);
window.RunAction = RunAction;
RunAction.DEBUG = false;

/**
 * An action 'exit' that stops the action chain as soon as it is encountered
 * @memberOf FlowActions
 *
 * @example
 * "exit"
 */
class ExitAction extends Action {
    static options() {
        return {};
    }

    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        throw new StopError("Action '"+this.name+"' encountered!");
    }
}
Action.registerPrimitiveAction("exit", ExitAction);
window.ExitAction = ExitAction;

/**
 * An action 'switch' that can test several branches, and execute an array of actions if the branch matches
 *
 * Each branch is tested in the order they are present in the array.
 *
 * The where option is used as a filter, and if the filter matches the actions in then is applied
 *
 * Default is to break after a branch matches, but if "break": false is added as an option, it will continue to next branch
 *
 * If a branch has no where option, it is always executed if no branch has breaked until it is reached.
 * @memberOf FlowActions
 * @example
 * {
 *     "switch": [
 *         {
 *             "where": {"property": "myProperty", "equals": "myValue"},
 *             "then": ["myAction", "myOtherAction"],
 *             "break": true
 *         },
 *         {
 *             "where": {"property": "myProperty", "equals": "myOtherValue"},
 *             "then": ["myAction", "myOtherAction"],
 *             "break": true
 *         },
 *         {
 *             "then": ["myDefaultAction"]
 *         }
 *     ]
 * }
 */
class SwitchAction extends Action {
    static options() {
        return {
            "$switch": "switch"
        }
    }

    constructor(name, options, concept) {
        if(options == null) {
            options = [];
        }

        if(!Array.isArray(options)) {
            options = [options];
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        let options = await Action.lookupArguments(this.options, actionArguments);

        let results = [];

        for (let context of contexts) {
            //Make sure to clone context, since we change it directly, thus variables might be a shared object if not.
            let clonedContext = Action.cloneContext(context);

            let lookedUpOptions = [];

            if(Array.isArray(options)) {
                //Lookup variables for each case
                for(let option of options) {
                    let clonedOption = {};

                    if(option.where != null) {
                        clonedOption.where = await Action.lookupVariables(option.where, clonedContext);
                    }
                    if(option.break != null) {
                        clonedOption.break = await Action.lookupVariables(option.break, clonedContext);
                    }
                    if(option.then) {
                        clonedOption.then =  Action.clone(option.then);
                    }

                    lookedUpOptions.push(clonedOption);
                }
            }

            //Do switch
            for(let caseOption of lookedUpOptions) {
                if(caseOption.where != null) {
                    let filter = FilterAction.constructFilter(caseOption.where);

                    let matches = await filter.filter(clonedContext);

                    if(!matches) {
                        //Did not match, skip to next branch
                        continue;
                    }
                }

                let actions = caseOption.then;
                if(!Array.isArray(actions)) {
                    actions = [actions];
                }

                let action = ConceptLoader.parseAction(UUIDGenerator.generateUUID("SwitchCaseAction"), actions, this.concept);

                await ActionTrigger.before(action,  [clonedContext]);
                let mark = VarvPerformance.start();
                clonedContext = await action.apply([clonedContext]);
                if(action.isPrimitive) {
                    VarvPerformance.stop("PrimitiveAction-"+action.name, mark);
                } else {
                    VarvPerformance.stop("CustomAction-"+action.name, mark);
                }
                await ActionTrigger.after(action, [clonedContext]);

                let doBreak = true;

                if(caseOption.break != null) {
                    doBreak = caseOption.break;
                }

                if(doBreak) {
                    break;
                }
            }

            if (clonedContext != null) {
                if (Array.isArray(clonedContext)) {
                    clonedContext.forEach((entry) => {
                        results.push(entry);
                    });
                } else {
                    results.push(clonedContext);
                }
            }
        }

        return results;
    }
}
Action.registerPrimitiveAction("switch", SwitchAction);
window.SwitchAction = SwitchAction;


</SCRIPT><SCRIPT id="CustomActions-script" type="disabled">
/**
 *  CustomActions - Actions that allow custom code
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * Actions that handle custom code
 * @namespace CustomActions
 */

/**
 * An action 'customJS' that can run a custom piece of javascript code on the current context, the function must be a function on the window object
 * @memberOf CustomActions
 * @example
 * //Runs window.myFunction
 * {
 *     "customJS": {
 *          "functionName": "myFunction"
*      }
 * }
 *
 * //Shorthand, runs window.myFunction
 * {
 *     "customJS": "myFunction"
 * }
 */
class CustomJSAction extends Action {
    constructor(name, options, concept) {
        if(typeof options === "string") {
            options = {
                "functionName": options
            }
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        return this.forEachContext(contexts, actionArguments, async (context, options)=> {
            if(this.options.functionName == null) {
                throw new Error("'functionName' must be set for action 'customJS'");
            }

            let f = window[options.functionName];

            if(f == null) {
                throw new Error("'window."+options.functionName+"' is not defined");
            }

            if(typeof f !== "function") {
                throw new Error("'window."+options.functionName+"' is not a function");
            }

            return await f(context, options);
        });
    }
}
Action.registerPrimitiveAction("customJS", CustomJSAction);
window.CustomJSAction = CustomJSAction;

</SCRIPT><SCRIPT id="DebugActions-script" type="disabled">
/**
 *  DebugActions - Actions that make debugging easier
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * Actions related to debugging or benchmarking
 * @namespace DebugActions
 */

/**
 * An action "debugConcept" that prints the currently selected concepts to the console.
 * @memberOf DebugActions
 *
 * @example
 * {
 *     "debugConcept"
 * }
 */
class DebugConceptAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            let concept = await VarvEngine.getConceptFromUUID(context.target);

            console.groupCollapsed("ConceptDebug:", concept.name, context.target);

            for(let key of concept.properties.keys()) {
                let property = concept.properties.get(key);
                let value = await property.getValue(context.target);
                console.log(key, "->", value);
            }

            console.groupEnd();

            return context;
        });
    }

    static options() {
        return {
        };
    }
}
Action.registerPrimitiveAction("debugConcept", DebugConceptAction);
window.DebugConceptAction = DebugConceptAction;

/**
 * An action "debugContext" that prints the current context to the console
 * @memberOf DebugActions
 * @example
 * {
 *     "debugContext"
 * }
 */
class DebugContextAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        console.groupCollapsed("ContextDebug");
        console.log("Contexts:", contexts.map((context)=>{return Action.cloneContext(context)}));
        console.log("ActionArguments:",actionArguments);
        console.log("SavedVariables:", contexts.savedVariables);

        console.group("forEachContext:")
        const result = await this.forEachContext(contexts, actionArguments, async (context, options)=>{

            console.log(JSON.parse(JSON.stringify(context)));

            return context;
        });
        console.groupEnd();

        console.groupEnd();

        return result;
    }

    static options() {
        return {
        };
    }
}
Action.registerPrimitiveAction("debugContext", DebugContextAction);
window.DebugContextAction = DebugContextAction;

/**
 * An action "debugMessage" that can debug a message to the console
 * @memberOf DebugActions
 * @example
 * {
 *     "debugMessage": {
 *         "message": "The message to debug"
 *     }
 * }
 *
 * @example
 * //Shorthand version
 * {
 *     "debugMessage": "The message to debug"
 * }
 */
class DebugMessageAction extends Action {
    constructor(name, options, concept) {
        //Shorthand
        if(typeof options === "string"){
            options = {
                message: options
            }
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        if(this.options.bulk) {
            console.log(this.options.message);
            return contexts;
        }

        return this.forEachContext(contexts, actionArguments, async (context, options)=>{
            let message = options.msg;

            if(options.message != null) {
                message = options.message;
            }
            console.log(message);

            return context;
        });
    }

    static options() {
        return {
            "message": "string"
        };
    }
}
Action.registerPrimitiveAction("debugMessage", DebugMessageAction);
window.DebugMessageAction = DebugMessageAction;

/**
 * An action 'varvPrefix' that sets the current prefix to VarvPerformance logging.
 * @memberOf DebugActions
 * @example
 * // Set the VarvPerformance prefix to "myPrefix"
 *
 * {
 *     "varvPrefix": "myPrefix"
 * }
 *
 * @example
 * // Remove the current VarvPerformance prefix
 *
 * {
*       "varvPrefix": ""
 * }
 */
class VarvPerformancePrefix extends Action {
    constructor(name, options, concept) {
        if(typeof options === "string") {
            options = {
                prefix: options
            }
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments = {}) {
        let options = await Action.lookupArguments(this.options, actionArguments);

        let common = Action.getCommonVariables(contexts);
        options = await Action.lookupVariables(options, {variables: common, target: null});

        VarvPerformance.prefix = options.prefix

        return contexts;
    }
}
Action.registerPrimitiveAction("perfPrefix", VarvPerformancePrefix);
window.VarvPerformancePrefix = VarvPerformancePrefix;

/**
 * An action 'repeat' that can run a set of actions a number of times
 * @memberOf DebugActions
 * @example
 * // Runs the action "someAction" 10 times
 * {
 *     "repeat": {
 *         iterations: 10,
 *         actions: [
 *             "someAction"
 *         ]
 *     }
 * }
 */
class RepeatAction extends Action {
    constructor(name, options, concept) {
        const defaultOptions = {
            iterations: 1,
            actions: []
        };

        super(name, Object.assign({}, defaultOptions, options), concept);
    }

    async apply(contexts, actionArguments = {}) {
        let options = await Action.lookupArguments(this.options, actionArguments);

        let actionOptions = options.actions;

        delete options.actions;

        let common = Action.getCommonVariables(contexts);
        options = await Action.lookupVariables(options, {variables: common, target: null});

        if(typeof options.iterations !== "number" || options.iterations <= 0) {
            throw new Error("RepeatAction is missing options iterations, must be a number larger than 0");
        }

        if(!Array.isArray(options.actions)) {
            options.actions = [options.actions];
        }

        let action = ConceptLoader.parseAction(UUIDGenerator.generateUUID("RepeatActions"), actionOptions, this.concept);

        let clonedContext = Action.cloneContext(contexts);

        for(let i = 0; i<options.iterations; i++) {

            await ActionTrigger.before(action, clonedContext);
            let mark = VarvPerformance.start();
            clonedContext = await action.apply(clonedContext);
            if (action.isPrimitive) {
                VarvPerformance.stop("PrimitiveAction-" + action.name, mark);
            } else {
                VarvPerformance.stop("CustomAction-" + action.name, mark);
            }
            await ActionTrigger.after(action, clonedContext);
        }

        return clonedContext;
    }
}
Action.registerPrimitiveAction("repeat", RepeatAction);
window.RepeatAction = RepeatAction;

/**
 * An action 'profile' that starts or stops the javascript profiler, supports only 1 profile running at a time
 * if another profile is running, that is stopped first before starting a new.
 * @memberOf DebugActions
 * @example
 * // Starts the profiler, and gives it the given name
 * {
 *     "profile": {
 *         "name": "A name for your profile"
 *     }
 * }
 *
 * @example
 * // Starts the profiler, and gives it the given name, shorthand version
 * {
 *     "profile": "A name for your profile"
 * }
 *
 * @example
 * // Stops the currently running profile
 * {
 *     "profile": null
 * }
 */
class ProfileAction extends Action {
    constructor(name, options, concept) {
        if(typeof options === "string") {
            options = {
                "name": options
            }
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments = {}) {
        let options = await Action.lookupArguments(this.options, actionArguments);

        let common = Action.getCommonVariables(contexts);
        options = await Action.lookupVariables(options, {variables: common, target: null});

        if(console.profile == null) {
            console.warn("console.profile not supported");
        } else {
            //Stop any current profile
            if (ProfileAction.currentProfile != null) {
                console.profileEnd(ProfileAction.currentProfile);
                ProfileAction.currentProfile = null;
            }

            //Start new profile if requested
            if(options.name != null) {
                console.profile(options.name);
                ProfileAction.currentProfile = options.name;
            }
        }

        return contexts;
    }
}
ProfileAction.currentProfile = null;
Action.registerPrimitiveAction("profile", ProfileAction);
window.ProfileAction = ProfileAction;

/**
 * An action 'timer' that is used to record time between 2 points, only 1 timer is supported at a time
 * If another timer is running when a new one is to be started, the old timer is stopped first.
 * When the timer is stopped, the duration is debugged into the console
 * @memberOf DebugActions
 * @example
 * // Stats a timer, and names it "myTimerName"
 * {
 *     "timer": {
 *         "name": "myTimerName"
 *     }
 * }
 *
 * @example
 * // Stats a timer, and names it "myTimerName", shorthand
 * {
 *     "timer": "myTimerName"
 * }
 */
class TimerAction extends Action {
    constructor(name, options, concept) {
        if(typeof options === "string") {
            options = {
                name: options
            }
        }

        super(name, options, concept);
    }

    async apply(contexts, actionArguments = {}) {
        let options = await Action.lookupArguments(this.options, actionArguments);

        let common = Action.getCommonVariables(contexts);
        options = await Action.lookupVariables(options, {variables: common, target: null});

        //Stop any current timer
        if (TimerAction.currentTimer != null) {
            console.timeEnd(TimerAction.currentTimer);
            TimerAction.currentTimer = null;
        }

        //Start new timer if requested
        if(options.name != null) {
            console.time(options.name);
            TimerAction.currentTimer = options.name;
        }

        return contexts;
    }
}
TimerAction.currentTimer = null;
Action.registerPrimitiveAction("timer", TimerAction);
window.TimerAction = TimerAction;

/**
 * An action 'group' that can start/stop console groups. Only supports one group at a time, if another group is open, this will be closed first.
 * @memberOf DebugActions
 *
 * @example
 * // Starts a new console group "myGroupName" non collapsed
 * {
 *     "group": {
 *         "name": "myGroupName",
 *         "collapse": false
 *     }
 * }
 *
 * @example
 * // Starts a new console group "myGroupName" non collapsed, shorthand
 * {
 *     "group": "myGroupName"
 * }
 *
 * @example
 * // Closes the current group
 * {
 *     "group": null
 * }
 */
class GroupAction extends Action {
    constructor(name, options, concept) {
        if(typeof options === "string") {
            options = {
                name: options
            }
        }

        let defaultOptions =  {
            collapse: false
        };

        super(name, Object.assign({}, defaultOptions, options), concept);
    }

    async apply(contexts, actionArguments = {}) {
        let options = await Action.lookupArguments(this.options, actionArguments);

        let common = Action.getCommonVariables(contexts);
        options = await Action.lookupVariables(options, {variables: common, target: null});

        //Stop any current profile
        if (GroupAction.currentGroup != null) {
            console.groupEnd();
            GroupAction.currentGroup = null;
        }

        //Start new profile if requested
        if(options.name != null) {
            if(options.collapse) {
                console.groupCollapsed(options.name);
            } else {
                console.group(options.name);
            }
            GroupAction.currentGroup = options.name;
        }

        return contexts;
    }
}
GroupAction.currentGroup = null;
Action.registerPrimitiveAction("group", GroupAction);
window.GroupAction = GroupAction;

/**
 * An action 'assert' that can be used to check that some state is as expected, uses filters
 * @memberOf DebugActions
 *
 * @example
 * // Assert that the property "myProperty" is less than 10
 * {
 *     "assert": {
 *         "where": {
 *             "property": "myProperty",
 *             "lessThan": 10
 *         }
 *     }
 * }
 */
class AssertAction extends Action {
    constructor(name, options, concept) {
        if(options.where == null) {
            //Lets assume we got the filter directly
            options = {
                where: options
            }

            if(options.where.showAndReset != null) {
                options.showAndReset = options.where.showAndReset;
                delete options.where.showAndReset;
            }
        }

        let defaultOptions = {
            where: null,
            showAndReset: false
        };

        super(name, Object.assign({}, defaultOptions, options), concept);
    }

    async apply(contexts, actionArguments = {}) {
        let self = this;

        if (this.options.showAndReset === true) {
            let color = "background: green; color: white;";

            if (AssertAction.failed > 0) {
                color = "background: red; color: white;";
            }

            console.log("%c Successfull asserts: " + (AssertAction.total - AssertAction.failed) + "/" + AssertAction.total, color);
            AssertAction.total = 0;
            AssertAction.failed = 0;

            return contexts;
        } else {
            return this.forEachContext(contexts, actionArguments, async (context, options, index)=>{
                AssertAction.total++;

                if(options.where == null) {
                    throw new Error("Missing option 'where' on action 'assert'")
                }

                let filter = FilterAction.constructFilter(options.where);

                let pass = await filter.filter(context, self.concept, true);
                if(!pass) {
                    AssertAction.failed++;
                }

                return context;
            });
        }
    }
}
Action.registerPrimitiveAction("assert", AssertAction);
window.AssertAction = AssertAction;
AssertAction.failed = 0;
AssertAction.total = 0;

/**
 * An action 'assertException' that works like 'run' but asserts that the action chain called by run, should throw an exception.
 *
 * @example
 * {
 *     "assertException": {
 *         "action": "myExceptionThrowingAction"
 *     }
 * }
 */
class AssertExceptionAction extends RunAction {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments = {}) {
        let exception = false;

        try {
            await super.apply(contexts, actionArguments);
        } catch(e) {
            //Exception
            exception = true;
        }

        if(!exception) {
            console.assert(false, "No error, when one was expected!");
            AssertAction.failed++;
        }

        AssertAction.total++;

        return contexts;
    }
}
Action.registerPrimitiveAction("assertException", AssertExceptionAction);
window.AssertExceptionAction = AssertExceptionAction;

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="varv-repos" id="varv-builtin-triggers" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Varv Standard Triggers",
    "description": "Simple built-in triggers for varv",
    "dependencies": [
        "#varv-engine"
    ],
    "assets": [],
    "license": "MIT",
    "version": "0.1",
    "changelog": {}
}

</SCRIPT><SCRIPT id="TimingTriggers-script" type="disabled">
/**
 *  Timing Triggers - triggers based on time
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * A trigger 'interval' that triggers at a given interval, this trigger event has no target.
 * @memberOf Triggers
 * @example
 * //Trigger every 10 seconds
 * {
 *     "interval": 10
 * }
 */
class IntervalTrigger extends Trigger {
    static options() {
        return {
            "interval": "number"
        }
    }

    constructor(name, options, concept) {
        //Shorthand
        if(typeof options === "number") {
            options = {
                interval: options
            }
        }

        super(name, options, concept);

        this.intervalId = null;
    }

    enable() {
        const self = this;

        let interval = this.options.interval;

        let currentRepetition = 0;

        this.intervalId = setInterval(async ()=>{
            await Trigger.trigger(self.name, {
                target: null,
                variables:{
                    repetition: currentRepetition
                }
            });

            currentRepetition++;
        }, interval);
    }

    disable() {
        if(this.intervalId != null) {
            clearInterval(this.intervalId);
        }
        this.intervalId = null;
    }
}
Trigger.registerTrigger("interval", IntervalTrigger);
window.IntervalTrigger = IntervalTrigger;

</SCRIPT><SCRIPT id="PropertyTriggers-script" type="disabled">
/**
 *  PropertyTriggers - triggers on property changes
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * A trigger "stateChanged" that listens for property state changes
 * @memberOf Triggers
 * @example
 * //Triggers the stateChanged event when myProperty has changed, only the first concept that has the property is checked.
 * {
 *     "stateChanged": "myProperty"
 * }
 *
 * @example
 * //Triggers the stateChanged event when any property on myConcept changes
 * {
 *     "stateChanged": "myConcept"
 * }
 *
 * @example
 * //Triggers the stateChanged event when any property on myConcept changes, or if myProperty changes, on the first concept it was found on
 * {
 *     "stateChanged": ["myConcept", "myProperty"]
 * }
 *
 * @example
 * //Triggers the stateChanged event when property myProperty changes on myConcept
 * {
 *     "stateChanged": {"myConcept": "myProperty"}
 * }
 *
 * @example
 * //Triggers the stateChanged event when property myProperty changes on myConcept
 * {
 *     "stateChanged": {
 *         "concept": "myConcept",
 *         "property": "myProperty"
 *     }
 * }
 *
 * @example
 * //Triggers the stateChanged event when property myProperty changes
 * {
 *     "stateChanged": {
 *         "property": "myProperty"
 *     }
 * }
 *
 * @example
 * //Triggers the stateChanged event when a property on myConcept changes
 * {
 *     "stateChanged": {
 *         "concept": "myConcept"
 *     }
 * }
 */
class StateChangedTrigger extends Trigger {
    constructor(name, options, concept) {
        if(typeof options === "string") {
            //Shorthand options string
            options = {
                runtimeLookup: [options]
            };
        } else if(Array.isArray(options)) {
            //Shorthand options concept array
            options = {
                runtimeLookup: []
            }
            for(let i = 0; i<options.length; i++) {
                options.runtimeLookup.push(options[i]);
            }
        } else if(Object.keys(options).length === 1) {
            //Shorthand options {"concept": "property"}
            let possibleConceptType = Object.keys(options)[0];
            let concept = VarvEngine.getConceptFromType(possibleConceptType);

            if(concept != null) {
                try {
                    let property = concept.getProperty(options[possibleConceptType]);

                    //We have both concept and property, so shorthand was correct
                    options = {
                        "concept": concept.name,
                        "property": property.name
                    }
                } catch(e) {
                    //Ignore
                }
            }
        }

        super(name, options, concept);
        this.triggerDelete = null;
    }

    enable() {
        const self = this;

        this.triggerDelete = Trigger.registerTriggerEvent("stateChanged", async (context)=>{
            //Always only 1 entry in array
            context = context[0];

            let options = Object.assign({}, self.options);

            if(options.runtimeLookup != null) {
                let lookedUpReferences = [];
                options.runtimeLookup.forEach((reference)=>{
                    let lookup = VarvEngine.lookupReference(reference, self.concept);
                    lookedUpReferences.push(lookup);
                });

                //Set options to the looked up references
                options = Object.assign(options, lookedUpReferences);
            }

            //Check if options array shorthand
            if(Array.isArray(options)) {
                let temp = options;
                options = {
                    concept: [],
                    property: []
                }

                temp.forEach((entry)=>{
                    if(entry.concept != null) {
                        options.concept.push(entry.concept);
                    }

                    if(entry.property != null) {
                        options.property.push(entry.property);
                    }
                })
            }

            let clonedContext = Action.cloneContext(context);

            if(Trigger.DEBUG) {
                console.log("StateChangedTrigger:", self.name, options, ""+context.target);
            }

            let triggeringConcept = await VarvEngine.getConceptFromUUID(context.target);

            if(triggeringConcept == null) {
                throw new Error("Unknown concept for UUID: "+context.target);
            }

            if(options.exactConceptMatch && options.concept == null) {
                //We are matching excact on concept, but have no concept, use owning concept
                options.concept = self.concept.name;
            }

            if(options.concept != null) {
                let filterConcepts = options.concept;
                if(!Array.isArray(filterConcepts)) {
                    filterConcepts = [filterConcepts];
                }

                let found = filterConcepts.length === 0;

                for(let filterConcept of filterConcepts) {
                    if(options.exactConceptMatch) {
                        if (triggeringConcept.name === filterConcept) {
                            found = true;
                            break;
                        }
                    } else {
                        if (triggeringConcept.isA(filterConcept)) {
                            found = true;
                            break;
                        }
                    }
                }

                if(!found) {
                    //Skip based on wrong concept
                    if(Trigger.DEBUG) {
                        console.log("Skipping based on wrong concept");
                    }
                    return;
                }
            }

            if(options.property != null) {
                let filterProperties = options.property;
                if(!Array.isArray(filterProperties)) {
                    filterProperties = [filterProperties];
                }

                let found = filterProperties.length === 0;

                for(let filterProperty of filterProperties) {
                    if(context.property === filterProperty) {
                        found = true;
                        break;
                    }
                }

                if(!found) {
                    //Skip based on wrong property
                    if (Trigger.DEBUG) {
                        console.log("Skipping based on wrong property")
                    }
                    return;
                }
            }

            await Trigger.trigger(self.name, clonedContext);
        });
    }

    disable() {
        if(this.triggerDelete != null) {
            this.triggerDelete.delete();
        }
        this.triggerDelete = null;
    }
}
Trigger.registerTrigger("stateChanged", StateChangedTrigger);
window.StateChangedTrigger = StateChangedTrigger;

</SCRIPT><SCRIPT id="FlowTriggers-script" type="disabled">
/**
 *  FlowTriggers - Triggers based on control flow and calls
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * A trigger 'action' that triggers when an action is run
 * @memberOf Triggers
 * @example
 * //Trigger before action 'myActionName' is run
 * {
 *     "action": {
 *         "action": "myActionName",
 *         "hook": "before"
 *     }
 * }
 *
 * //Trigger after action 'myActionName' is run
 * {
 *     "action": {
 *         "action": "myActionName",
 *         "hook": "after"
 *     }
 * }
 *
 * //Trigger after any of multiple actions are run
 * {
 *     "action": {
 *         "action": ["myActionName", "mySecondActionName", "myThirdActionName"],
 *         "hook": "after"
 *     }
 * }
 * //Shorthand, trigger after 'myActionName' is run
 * {
 *     "action": "myActionName"
 * }
 *
 * //Shorthand, trigger after 'myConcept.myActionName' is run
 * {
 *     "action": "myConcept.myActionName"
 * }
 *
 * //Super shorthand, triggers after myActionName
 * "myActionName"
 */
class ActionTrigger extends Trigger {
    static options() {
        return {
            "action": "string",
            "hook": "enum[before,after]%after"
        }
    }

    constructor(name, options, concept) {
        if (typeof options === "string") {
            options = {
                action: options
            }
        }

        let defaultOptions = {
            "hook": "after"
        };

        options = Object.assign({}, defaultOptions, options);

        super(name, options, concept);
    }

    enable() {
        const self = this;

        this.deleteTrigger = Trigger.registerTriggerEvent("action", async (contexts)=>{
            //Only 1 context
            let context = contexts[0];

            let actions = self.options.action;

            if(!Array.isArray(actions)) {
                actions = [actions];
            }

            for(let actionEntry of actions) {
                let actionPart = actionEntry;
                let conceptPart = null;

                let split = actionEntry.split(".");
                if(split.length === 2) {
                    //Action was on the form, concept.action
                    actionPart = split[1];
                    conceptPart = split[0];
                }

                if(conceptPart != null && context.actionConcept !== conceptPart) {
                    //Not the concept we are looking for, skip
                    continue;
                }

                if(context.actionName !== actionPart) {
                    //Not the action we are looking for, skip
                    continue;
                }

                if(context.hook !== self.options.hook) {
                    //Not the hook we are looking at, skip
                    continue;
                }

                let clonedContexts = Action.cloneContext(context.actionContext);

                await Trigger.trigger(self.name, clonedContexts);
            }
        });
    }

    disable() {
        if(this.deleteTrigger != null) {
            this.deleteTrigger.delete();
        }
    }

    static async before(action, contexts) {
        await ActionTrigger.doTrigger(action, contexts, false);
    }

    static async after(action, contexts) {
        await ActionTrigger.doTrigger(action, contexts, true);
    }

    static async doTrigger(action, contexts, after) {
        await Trigger.trigger("action", {
            target: null,
            actionContext: contexts,
            actionName: action.name,
            actionConcept: action.concept?.name,
            hook: after?"after":"before"
        });
    }
}
Trigger.registerTrigger("action", ActionTrigger);
window.ActionTrigger = ActionTrigger;

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="varv-repos" id="varv-dom" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Varv DOM Data Store",
    "description": "Allow data to be stored in the browser DOM",
    "dependencies": [
        "#varv-engine"
    ],
    "assets": [],
    "license": "MIT",
    "version": "0.1",
    "changelog": {}
}

</SCRIPT><SCRIPT id="DOMDataStore-script" type="disabled">
/**
 *  DOMDataStore - Store as DOM elements
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * A storage that provides a DOM-element&attribute-based serialization of Concept properties
 *
 * <pre>
 * options:
 * storageName - The name of the element to store that data below (Default: "varv-data")
 * storageWebstrate - The name of the webstrate to store the data at (Default: current webstrate)
 * </pre>
 *
 * @memberOf Datastores
 */
class DOMDataStore extends DirectDatastore {
    constructor(name, options = {}) {
        super(name, options);

        this.deleteCallbacks = [];
    }

    destroy() {
        if(this.iframeTransient != null) {
            this.iframeTransient.remove();
        }

        this.stopObserver();

        this.deleteCallbacks.forEach((deleteCallback)=>{
            deleteCallback.delete();
        });
    }

    async init() {
        const self = this;

        let storageName = "varv-data";
        if(this.options.storageName != null) {
            storageName = this.options.storageName;
        }

        let topElement = document;

        //If webstrate is specified, find topElement inside iframe
        if(this.options.storageWebstrate != null) {
            if(DOMDataStore.DEBUG) {
                console.log("Opening storage webstrate:", this.options.storageWebstrate);
            }
            let transient = document.createElement("transient");
            transient.style.display = "none";
            transient.setAttribute("name", "storageWebstrate-"+this.options.storageWebstrate);
            let iframe = document.createElement("iframe");

            transient.appendChild(iframe);
            document.body.appendChild(transient);

            iframe.src = "/"+this.options.storageWebstrate;
            await Observer.waitForTransclude(iframe);

            if(DOMDataStore.DEBUG) {
                console.log("Storage webstrate ready:", this.options.storageWebstrate);
            }

            topElement = iframe.contentDocument;

            this.iframeTransient = transient;
        }

        // Try to find an existing one
        this.backingElement = topElement.querySelector(storageName);

        this.queryCache = new QuerySelectorCache(this.backingElement);

        // None exists, create one
        if (!this.backingElement) {
            this.backingElement = topElement.createElement(storageName, {approved: true});
            topElement.body.appendChild(this.backingElement);

            // TODO: Check if webstrates race condition happened here and remedy it
        }

        // Add an observer to data backing element
        this.observer = new MutationObserver((mutations)=>{
            self.mutationCallback(mutations);
        });
        self.startObserver();

        //Setup disappeared listener?
        this.deleteCallbacks.push(VarvEngine.registerEventCallback("disappeared", async (context)=>{
            if(DOMDataStore.DEBUG) {
                console.log("Saw disappeared UUID (DOMDataStore):", context.target);
            }
            let conceptDom = this.backingElement.querySelector("concept[uuid='"+context.target+"']");
            if(conceptDom !== null) {
                self.executeObserverless(()=>{
                    conceptDom.remove();
                });
            }
        }));

        this.deleteCallbacks.push(VarvEngine.registerEventCallback("appeared", async (context)=>{
            if(DOMDataStore.DEBUG) {
                console.log("Saw appeared UUID (DOMDataStore):", context.target);
            }

            let mark = VarvPerformance.start();
            if (self.isConceptMapped(context.concept)) {
                this.executeObserverless(() => {
                    self.getConceptElementOrCreate(context.target, context.concept);
                });
            }
            VarvPerformance.stop("DOMDataStore.registerEventCallback.appeared", mark);
        }));
    }

    async addConcept(node, uuid) {
        let propertyChangedNodes = [];

        let self = this;

        // Check if already exists (this would be a bit weird but could happen in multi-backed concepts where the other backing already registered their part)
        let conceptByUUID = await VarvEngine.getConceptFromUUID(uuid);

        // Check if a duplicate already exists in the DOM marshalled data, since that is definitely a mistake
        let foundConcepts = self.backingElement.querySelectorAll('concept[uuid="'+uuid+'"]');
        if (foundConcepts.length > 1){
            console.warn("Warning: More than one DOM concept node found for "+conceptByUUID.name +" - only one element is allowed per uuid, this is bad, deleting extra");

            self.executeObserverless(()=>{
                //Clean everything but the first occurrence?
                Array.from(foundConcepts).slice(1).forEach((conceptElement)=>{
                    conceptElement.remove();
                });
            });

            return;
        }

        // Check if the concept type is available and mapped
        let conceptType = node.getAttribute("type");
        if (conceptType===null) {
            console.warn("DOM concept node added without type, ignoring for now - not sure how to handle it");
            return;
        }

        let concept = VarvEngine.getConceptFromType(conceptType);
        if (!concept){
            console.warn("Warning: DOM concept node added for concept of unknown type '"+conceptType+"', ignoring");
            return;
        }

        if (conceptByUUID && concept.name !== conceptByUUID.name){
            console.warn("Warning: DOM concept node added which specified different type than the one registered in the current mapping, ignoring it");
            return;
        }

        if (!self.isConceptMapped(concept)){
            console.warn("Warning: DOM concept node added for concept for which there are no DOM-mapped properties in the current mapping, ignoring it");
            return;
        }

        // Everything checks out, let's add it then'
        if(DOMDataStore.DEBUG) {
            console.log("DOM saw " + uuid + " of type "+conceptType);
        }
        self.registerConceptFromUUID(uuid, concept);

        // Concepts can only exist as top-level but when added they can already carry properties as children nodes
        Array.from(node.children).forEach((childNode)=>{
            if (childNode.tagName==="PROPERTY"){
                // Make sure to import those property values if they exist
                propertyChangedNodes.push(childNode);
            }
        });

        // Signal that someone made a new concept instance appear for the first time
        if(conceptByUUID == null) {
            await concept.appeared(uuid);
        }

        return propertyChangedNodes;
    }

    async removeConcept(node, uuid) {
        let self = this;

        let concept =  self.getConceptFromUUID(uuid);
        if (!concept ){
            console.warn("Notice: DOM concept node removed for concept with uuid "+uuid+" that we didn't know about, this inconsistency is odd");
            return;
        }

        let foundConcepts = self.backingElement.querySelectorAll('concept[uuid="'+uuid+'"]');
        if(foundConcepts.length > 0) {
            console.warn("Notice: Node with uuid "+uuid+" still exists in DOM, not calling disappear");
            return;
        }

        // Someone deleted this concept instance, let's tell everyone to delete it here too
        await concept.disappeared(uuid);
    }

    async mutationCallback(mutationList) {
        const self = this;

        if(DOMDataStore.DEBUG) {
            console.log("Got remote mutation", mutationList);
        }

        let addedConcepts = new Map();
        let removedConcepts = new Map();
        let propertyChangedNodes = [];

        for(let mutation of mutationList) {
            switch (mutation.type) {
                case 'childList':
                    // Look for newly added concept instances first
                    for(let node of mutation.addedNodes) {
                        try {
                            if (node.tagName==="CONCEPT"){
                                let uuid = node.getAttribute("uuid");
                                if (uuid===null) {
                                    console.warn("DOM concept node added without uuid, ignored for now - not sure what to do about it");
                                    continue;
                                }

                                addedConcepts.set(uuid, node);
                                //Since we saw this node added, it is no longer in queue to be removed
                                removedConcepts.delete(uuid);
                            }

                            // A property could also be added (set) directly by someone for the first time
                            if (node.tagName==="PROPERTY"){
                                propertyChangedNodes.push(node);
                            }
                        } catch (ex){
                            console.error("Unhandled exception in DOM node adding handler", ex);
                        }
                    }

                    // Removals
                    for(let node of mutation.removedNodes) {
                        try {
                            // Concepts can be removed (deleted) and they appear only as top-level nodes here
                            if (node.tagName==="CONCEPT"){
                                let uuid = node.getAttribute("uuid");
                                if (uuid===null) {
                                    console.warn("DOM concept node removed without uuid, ignored for now - not sure what to do about it");
                                    return;
                                }

                                removedConcepts.set(uuid, node);
                                //Since we just removed this concept, it is no longer added
                                addedConcepts.delete(uuid);
                            }
                        } catch (ex){
                            console.error("Unhandled exception in DOM node remove handler", ex);
                        }
                    }

                    // Array property had one or more new child nodes added to it
                    if (mutation.target.tagName==="PROPERTY"){
                        propertyChangedNodes.push(mutation.target);
                    }

                    break;
                case 'attributes':
                    // - Simple property value change
                    if (mutation.attributeName==="value" && mutation.target.tagName==="PROPERTY"){
                        propertyChangedNodes.push(mutation.target);
                    }

                    // TODO: uuid and/or type added to concept that was previously missing it and was thus ignored
                    break;
            }
        }

        for(let [uuid, node] of addedConcepts.entries()) {
            let possibleChangedPropertyNodes = await self.addConcept(node, uuid);
            if(possibleChangedPropertyNodes != null) {
                propertyChangedNodes.push(...possibleChangedPropertyNodes);
            }
        }

        for(let entry of removedConcepts.entries()) {
            await self.removeConcept(entry[1], entry[0]);

            //Filter property changes, don't run the ones where we removed the concept!
            propertyChangedNodes = propertyChangedNodes.filter((propertyNode)=>{
                let conceptElement = propertyNode.parentElement;
                let conceptUUID = conceptElement.getAttribute("uuid");

                return conceptUUID != entry[0];
            });
        }
        for(let propertyNode of propertyChangedNodes) {
            try {
                await self.synchronizePropertyElementFromDOM(propertyNode);
            } catch(e) {
                console.error("Error synchronizing property element from dom: ", e);
            }
        }
    }

    createBackingStore(concept, property) {
        if(DOMDataStore.DEBUG) {
            console.log("DOMDataStore Mapping "+concept.name+"."+property.name);
        }

        const self = this;
        if (!concept)
            throw new Error('Cannot map invalid concept to DOM: ' + concept);
        if (!property)
            throw new Error('Cannot map invalid property to DOM for concept: ' + concept + "." + property);
        if (this.isPropertyMapped(concept, property))
            throw new Error('Already mapped a DOM backing store for: ' + concept.name + "." + property.name);

        if (!this.isConceptMapped(concept)){
            // TODO: This is the first time we hear about this concept, add some create/delete or appear/disappear events as well
        }
        let getter = (uuid) => {
            if(DOMDataStore.DEBUG) {
                console.log("DOMDataStore getter: "+concept.name+"."+property.name);
            }

            let mark = VarvPerformance.start();

            let conceptElement = self.queryCache.querySelector("concept[uuid='" + uuid + "']");
            if (!conceptElement)
                throw new Error("No DOM data stored at all for "+concept.name+" with UUID "+uuid+" while getting "+concept.name+"."+property.name);
            let propertyElement = conceptElement.querySelector("property[name='" + property.name + "']");
            if (!propertyElement)
                throw new Error('No DOM data for property ' + concept.name + "." + property.name + " stored yet with UUID "+uuid);

            let result = self.getPropertyFromDOM(concept, propertyElement, property);

            VarvPerformance.stop("DOMDataStore.getter.nonCached", mark);

            return result;
        }

        let setter = (uuid, value) => {
            let mark = VarvPerformance.start();

            if(DOMDataStore.DEBUG) {
                console.log("DOMDataStore setter: "+concept.name+"."+property.name);
            }

            this.executeObserverless(()=>{
                let conceptElement = self.getConceptElementOrCreate(uuid, concept);

                let propertyElement = conceptElement.querySelector("property[name='" + property.name + "']");
                if (!propertyElement) {
                    propertyElement = document.createElement("property", { approved: true });
                    propertyElement.setAttribute("name", property.name, { approved: true });
                    conceptElement.appendChild(propertyElement);
                }

                let oldValue;

                try {
                    oldValue = property.typeCast(getter(uuid));
                } catch(e) {
                    //Ignore
                }

                if(property.isSame(value, oldValue)) {
                    //This value was already set in DOM, dont set it again
                    if(DOMDataStore.DEBUG) {
                        console.log("Skipping because same value...");
                    }
                    return;
                }

                if (Array.isArray(value)) {
                    let entryElement = document.createElement("temp");
                    value.forEach((entryValue) => {
                        let entry = document.createElement("entry", {approved: true});
                        if (Array.isArray(entryValue))
                            throw new Error('Nested arrays not supported yet'); // TODO
                        entry.setAttribute("value", entryValue);
                        entryElement.appendChild(entry);
                    });
                    propertyElement.innerHTML = entryElement.innerHTML;
                } else {
                    propertyElement.setAttribute("value", value, { approved: true });
                }
            });
            VarvPerformance.stop("DOMDataStore.setter", mark);
        }
        property.addSetCallback(setter);
        property.addGetCallback(getter);

        // Check if concept already is mapped, if not, register it
        this.internalAddPropertyMapping(concept, property, {setter: setter, getter: getter});
    }

    getConceptElementOrCreate(uuid, concept) {
        let mark = VarvPerformance.start();
        let conceptElement = this.queryCache.querySelector("concept[uuid='" + uuid + "']");
        if (!conceptElement) {
            conceptElement = document.createElement("concept", {approved: true});
            conceptElement.setAttribute("type", concept.name, { approved: true });
            conceptElement.setAttribute("uuid", uuid, { approved: true });
            this.backingElement.appendChild(conceptElement);
        }
        VarvPerformance.stop("DOMDataStore.getConceptElementOrCreate", mark);
        return conceptElement;
    }

    removeBackingStore(concept, property) {
        if (!concept)
            throw new Error('Cannot unmap invalid concept from DOM: ' + concept);
        if (!property)
            throw new Error('Cannot unmap invalid property from DOM for concept: ' + concept + "." + property);
        if (!this.isConceptMapped(concept))
            throw new Error('Cannot unmap property from concept not managed by DOM: ' + concept.name);
        if (!this.isPropertyMapped(concept, property))
            throw new Error('Cannot unmap property on managed DOM concept because the property was not mapped: ' + concept.name + "." + property.name);

        let trackingData = this.internalPropertyTrackingData(concept, property);
        property.removeSetCallback(trackingData.setter);
        property.removeGetCallback(trackingData.getter);

        // TODO: If this was the last mapping for this concept, also remove delete/create or appear/disappear events, we no longer care
        this.internalRemovePropertyMapping(concept, property);
    }

    /**
     * Loads all concept instances currently registered as backed from serialized state
     *
     * @returns {undefined}
     */
    async loadBackingStore() {
        // We restore the state by faking that someone else just added all the contents of the
        // backing element to our DOM
        let fakeAddMutationList = [{
            type: "childList",
            target: this.backingElement,
            addedNodes: Array.from(this.backingElement.children),
            removedNodes: []
        }];
        await this.mutationCallback(fakeAddMutationList);
    }

    /**
     * Starts this DOM datastore's mutation observer
     * @ignore
     * @protected
     */
    startObserver() {
        this.observer.observe(this.backingElement, {
            attributes: true,
            childList: true,
            subtree: true,
            attributeOldValue: true,
            characterData: false,
            characterDataOldValue: false
        });
    }

    /**
     * Stops this DOM datastore's mutation observer, handling any mutations that is queued before stopping.
     * @ignore
     * @protected
     */
    stopObserver() {
        let mutations = this.observer.takeRecords();
        if (mutations.length > 0) {
            this.mutationCallback(mutations);
        }
        this.observer.disconnect();
    }

    /**
     * Run the given method without triggering the mutation observer
     * @ignore
     * @protected
     * @param {Function} method - Method to call. Important: must not be async, the observer will be restarted as soon as this promise returns.
     */
    executeObserverless(method) {
        this.stopObserver();

        //Run our method, potentially adding mutations
        method();

        this.startObserver();
    }

    /**
     * Reconstruct a value from DOM
     * @param {Concept} concept
     * @param {Element} propertyElement
     * @param {Property} propertyObject
     * @returns {any}
     */
    getPropertyFromDOM(concept, propertyElement, propertyObject){
        // Reconstruct the value
        if (propertyObject.type === "array") {
            // Unpack as array property
            let value = [];

            propertyElement.querySelectorAll(":scope > entry").forEach((childNode) => {
                let entryValue = childNode.getAttribute("value");
                if (entryValue === null)
                    throw new Error("Illegal array entry stored in DOM, cannot unmarshal " + concept.name + "." + propertyObject.name);
                value.push(entryValue);
            });

            return value;
        } else {
            // Unpack as flat property
            let value = propertyElement.getAttribute("value");
            if (value === null)
                throw new Error('No actual value stored in DOM backed property for ' + concept.name + "." + propertyObject.name);

            return value;
        }
    }

    /**
     * Takes the element and looks up everything else from that and pushes its state
     * to the concept
     * @param {element} propertyElement The element with the property to push to concept
     */
    synchronizePropertyElementFromDOM(propertyElement){
        const self = this;

        // Lookup concept
        let conceptElement = propertyElement.parentElement;

        if(conceptElement.parentElement == null) {
            console.warn("Parent was not inside dom, skipping synchronize!");
            return;
        }

        if(DOMDataStore.DEBUG) {
            console.log("Synchronizing:", conceptElement, propertyElement);
        }

        let conceptInstance = this.getConceptInstanceFromConceptElement(conceptElement);

        // Lookup property
        let propertyName = propertyElement.getAttribute("name");
        if (propertyName === null) throw new Error("No property name on DOM property node "+conceptInstance.concept.name+" "+propertyElement);
        let propertyObject = conceptInstance.concept.getProperty(propertyName);

        return new Promise((resolve)=>{
            // Fire a set on the property which in turn calls our setter method while pausing our observer to sync with other datastores
            let value = self.getPropertyFromDOM(conceptInstance.concept, propertyElement, propertyObject);
            if(DOMDataStore.DEBUG) {
                console.log("DOM: Pushing remote change to " + conceptInstance.uuid + " " + conceptInstance.concept.name + "." + propertyObject.name + "=" + value);
            }
            propertyObject.setValue(conceptInstance.uuid, propertyObject.typeCast(value)).then(()=>{
                resolve();
            }).catch(()=>{
                //Unable to synchronize from dom, as dom did not validate
                resolve();
            });
        });
    }

    /**
     * Lookup concept and uuid from a concept element
     * @param {Element} conceptElement
     * @returns {any}
     */
    getConceptInstanceFromConceptElement(conceptElement){
        if (!conceptElement) throw new Error("Cannot get instance from undefined/null element");

        // TODO: Consider if manually added elements should get autogenerated uuid somehow, for now ignore it
        let uuid = conceptElement.getAttribute("uuid");
        if (uuid===null) throw new Error("Incomplete null concept instance in DOM");

        let type = conceptElement.getAttribute("type");
        if (type===null) throw new Error("Incomplete concept instance in DOM ignored, missing type: "+conceptElement.innerHTML);
        if (!this.isConceptTypeMapped(type)) throw new Error("DOM storage contains data for unmapped type, ignoring: "+type);

        // Lookup Concept by type through registry
        let concept = VarvEngine.getConceptFromType(type);
        if (!concept) throw new Error("DOM storage contains data for mapped type that is not registered in the system: "+type);

        return {concept: concept, uuid: uuid};
    }
}
DOMDataStore.DEBUG = false;
window.DOMDataStore = DOMDataStore;

//Register default dom datastore
Datastore.registerDatastoreType("dom", DOMDataStore);

class QuerySelectorCache {
    constructor(optionalParent) {
        this.parent = optionalParent!=null?optionalParent:document;
        this.cache = new Map();
        this.reverseLookup = new Map();

        this.setupObserver();
    }

    setupObserver() {
        const self = this;

        this.observer = new MutationObserver((mutations)=>{
            mutations.forEach((mutation)=>{
                mutation.removedNodes.forEach((node)=>{
                    let selectors = self.reverseLookup.get(node);
                    if(selectors != null) {
                        selectors.forEach((selector)=>{
                            self.cache.delete(selector);
                        });
                        self.reverseLookup.delete(node);
                        if(DOMDataStore.DEBUG) {
                            console.log("Updated cache for: ", node);
                        }
                    }
                });
            });
        });

        this.observer.observe(this.parent, {
            childList: true
        });
    }

    querySelector(selector) {
        let mark = VarvPerformance.start();
        let cacheEntry = this.cache.get(selector);
        if(cacheEntry != null) {
            VarvPerformance.stop("DOMDataStore.querySelector.cached", mark);
            return cacheEntry;
        }

        let result = this.parent.querySelector(selector);

        if(result != null) {
            this.cache.set(selector, result);
            let selectors = this.reverseLookup.get(result);
            if(selectors == null) {
                selectors = new Set();
                this.reverseLookup.set(result, selectors);
            }
            selectors.add(selector);
        }

        VarvPerformance.stop("DOMDataStore.querySelector.nonCached", mark);

        return result;
    }
}

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="varv-repos" id="varv-dom-triggers" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Varv engine triggers for DOM elements",
    "description": "A set of event handlers for triggering on DOM elements",
    "dependencies": [

    ],
    "optionalDependencies": [
        "#varv-engine"
    ],
    "assets": [],
    "license": "MIT",
    "version": "0.1",
    "changelog": {}
}

</SCRIPT><SCRIPT id="DOMTriggers-script" type="disabled">
/**
 *  DOMTriggers - Triggers based on DOM events
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */


// click(concept/element-property)
// hover(concept/element-property)
// focus(concept/element-property)
// key(key, concept/element-property focus, event=key-up, shift=false, meta=false)
// drag-n-drop hell

/**
 * General MouseTrigger class, for use for the different ones
 */
class MouseTrigger extends Trigger {
    static options() {
        return {
            "$mouseTarget": "@enumValue[concept,property,view,runtimeLookup]",
            "where": "filter"
        }
    }

    constructor(name, options, concept, type) {
        if(typeof options === "string") {
            options = {
                runtimeLookup: options
            }
        }

        super(name, options, concept);

        this.type = type;

        this.triggerDelete = null;
    }

    enable() {
        const self = this;

        this.triggerDelete = Trigger.registerTriggerEvent(this.type, async (context)=> {
            //Try looking up shorthand
            let options = Object.assign({}, this.options);

            if(options.runtimeLookup != null) {
                let lookupResult = VarvEngine.lookupReference(options.runtimeLookup, self.concept);
                options = Object.assign(options, lookupResult);
            }

            //Always only 1 entry in array
            context = context[0];

            let resultContext = Action.cloneContext(context);

            if(options.exactConceptMatch && options.concept == null) {
                //We are matching excact on concept, but have no concept, use owning concept
                options.concept = self.concept.name;
            }

            //Check if this context matches our options
            if(options.concept != null) {
                //Reset target, we will set it if matching concept is found
                resultContext.target = null;

                for(let i = context.conceptUUIDs.length-1; i >= 0; i--) {
                    let uuid = context.conceptUUIDs[i];
                    let concept = await VarvEngine.getConceptFromUUID(uuid);

                    if(concept != null) {
                        if(options.exactConceptMatch) {
                            //Exact match
                            if(concept.name === options.concept) {
                                resultContext.target = uuid;
                                break;
                            }
                        } else {
                            if(concept.isA(options.concept)) {
                                resultContext.target = uuid;
                                break;
                            }
                        }
                    }
                }

                if(resultContext.target == null) {
                    return;
                }
            }

            if(options.view != null) {
                if(!context.targetElement.closest("[view='"+options.view+"']")) {
                    return;
                }
            }

            if(options.property) {
                let foundPropertyBinding = null;
                for(let i = context.properties.length-1; i>= 0; i--) {
                    let propertyBinding = context.properties[i];
                    if(propertyBinding.property.name === options.property) {
                        foundPropertyBinding = propertyBinding;
                    }
                }

                if(!foundPropertyBinding) {
                    return;
                }

                //Set target to the property's owner.
                resultContext.target = foundPropertyBinding.uuid;

                if(context.targetElement.viewParticle != null) {
                    if(typeof foundPropertyBinding.boundValue !== "undefined") {
                        Action.setVariable(resultContext, "propertyValue", foundPropertyBinding.value);
                    }
                    if(typeof foundPropertyBinding.index !== "undefined") {
                        Action.setVariable(resultContext, "propertyIndex", foundPropertyBinding.index);
                    }

                } else {
                    try {
                        let propertyValueLookup = foundPropertyBinding.property.name + ".value";
                        let propertyValue = await DOMView.singleton.evaluateValueInScope(propertyValueLookup, context.targetElement.scope);
                        Action.setVariable(resultContext, "propertyValue", propertyValue);
                    } catch(e) {
                        console.warn("Error evaluating property value:", e);
                    }

                    try {
                        let propertyIndexLookup = foundPropertyBinding.property.name + ".index";
                        let propertyIndex = await DOMView.singleton.evaluateValueInScope(propertyIndexLookup, context.targetElement.scope);
                        Action.setVariable(resultContext, "propertyIndex", propertyIndex);
                    } catch(e) {
                        console.warn("Error evaluating property index:", e);
                    }
                }
            }

            if(options.unknown != null) {
                //Lookup of reference failed, skip trigger
                if(DOMTriggers.DEBUG) {
                    console.log("Unable to lookup reference, skipping trigger:", self);
                }
                return;
            }

            //Filter based on where
            if(options.where != null) {
                let filter = await FilterAction.constructFilter(options.where);

                if(await filter.filter(resultContext)) {
                } else {
                    if(DOMTriggers.DEBUG) {
                        console.log("Mouse trigger was filtered because of where:", options.where, context);
                    }
                    return;
                }
            }

            if(options.preventDefault) {
                context.originalEvent.preventDefault();
            }

            await Trigger.trigger(self.name, resultContext).then(()=>{
                //Ignore
            });
        });
    }

    disable() {
        if(this.triggerDelete != null) {
            this.triggerDelete.delete();
        }
        this.triggerDelete = null;
    }
}

/**
 * A trigger "click" that listens for clicks on DOM elements
 * @memberOf Triggers
 * @example
 * {
 *     "click": {
 *         "concept": "theConceptIWantToHearClickTriggerOn"
 *     }
 * }
 * @example
 * //Match concept exact, not allowing any injected concepts to match
 * {
 *     "click": {
 *         "concept": "theConceptIWantToHearClickTriggerOn",
 *         "exactConceptMatch": true
 *     }
 * }
 * @example
 * {
 *     "click": {
 *         "view": "aViewBindingIWantToHearClickTriggerOn"
 *     }
 * }
 * @example
 * {
 *     "click": {
 *         "property": "aPropertyIWantToHearClickTriggerOn"
 *     }
 * }
 */
class ClickTrigger extends MouseTrigger {
    constructor(name, options, concept) {
        super(name, options, concept, "click");
    }
}
Trigger.registerTrigger("click", ClickTrigger);
window.ClickTrigger = ClickTrigger;

/**
 * A trigger "mousedown" that listens for mousdown events on DOM elements
 * @memberOf Triggers
 * @example
 * {
 *     "mousedown": {
 *         "concept": "theConceptIWantToHearMousedownTriggerOn"
 *     }
 * }
 * @example
 * //Match concept exact, not allowing any injected concepts to match
 * {
 *     "mousedown": {
 *         "concept": "theConceptIWantToHearMousedownTriggerOn",
 *         "exactConceptMatch": true
 *     }
 * }
 * @example
 * {
 *     "mousedown": {
 *         "view": "aViewBindingIWantToHearMousedownTriggerOn"
 *     }
 * }
 * @example
 * {
 *     "mousedown": {
 *         "property": "aPropertyIWantToHearMousedownTriggerOn"
 *     }
 * }
 */
class MousedownTrigger extends MouseTrigger {
    constructor(name, options, concept) {
        super(name, options, concept, "mousedown");
    }
}
Trigger.registerTrigger("mousedown", MousedownTrigger);
window.MousedownTrigger = MousedownTrigger;

/**
 * A trigger "mouseup" that listens for mouseup events on DOM elements
 * @memberOf Triggers
 * @example
 * {
 *     "mouseup": {
 *         "concept": "theConceptIWantToHearMouseupTriggerOn"
 *     }
 * }
 * @example
 * //Match concept exact, not allowing any injected concepts to match
 * {
 *     "mouseup": {
 *         "concept": "theConceptIWantToHearMouseupTriggerOn",
 *         "exactConceptMatch": true
 *     }
 * }
 * @example
 * {
 *     "mouseup": {
 *         "view": "aViewBindingIWantToHearMouseupTriggerOn"
 *     }
 * }
 * @example
 * {
 *     "mouseup": {
 *         "property": "aPropertyIWantToHearMouseupTriggerOn"
 *     }
 * }
 */
class MouseupTrigger extends MouseTrigger {
    constructor(name, options, concept) {
        super(name, options, concept, "mouseup");
    }
}
Trigger.registerTrigger("mouseup", MouseupTrigger);
window.MouseupTrigger = MouseupTrigger;

/**
 * A trigger "contextmenu" that listens for contextmenu events on DOM elements
 * @memberOf Triggers
 * @example
 * {
 *     "contextmenu": {
 *         "concept": "theConceptIWantToHearMouseupTriggerOn"
 *     }
 * }
 * @example
 * //Match concept exact, not allowing any injected concepts to match
 * {
 *     "contextmenu": {
 *         "concept": "theConceptIWantToHearMouseupTriggerOn",
 *         "exactConceptMatch": true
 *     }
 * }
 * @example
 * {
 *     "contextmenu": {
 *         "view": "aViewBindingIWantToHearMouseupTriggerOn"
 *     }
 * }
 * @example
 * {
 *     "contextmenu": {
 *         "property": "aPropertyIWantToHearMouseupTriggerOn"
 *     }
 * }
 */
class ContextmenuTrigger extends MouseTrigger {
    constructor(name, options, concept) {
        super(name, options, concept, "contextmenu");
    }
}
Trigger.registerTrigger("contextmenu", ContextmenuTrigger);
window.ContextmenuTrigger = ContextmenuTrigger;

/**
 * A trigger "mousemove" that listens for mousemove events on DOM elements
 * @memberOf Triggers
 * @example
 * {
 *     "mousemove": {
 *         "concept": "theConceptIWantToHearMousemoveTriggerOn"
 *     }
 * }
 * @example
 * //Match concept exact, not allowing any injected concepts to match
 * {
 *     "mousemove": {
 *         "concept": "theConceptIWantToHearMousemoveTriggerOn",
 *         "exactConceptMatch": true
 *     }
 * }
 * @example
 * {
 *     "mousemove": {
 *         "view": "aViewBindingIWantToHearMousemoveTriggerOn"
 *     }
 * }
 * @example
 * {
 *     "mousemove": {
 *         "property": "aPropertyIWantToHearMousemoveTriggerOn"
 *     }
 * }
 */
class MousemoveTrigger extends MouseTrigger {
    constructor(name, options, concept) {
        super(name, options, concept, "mousemove");
    }
}
Trigger.registerTrigger("mousemove", MousemoveTrigger);
window.MousemoveTrigger = MousemoveTrigger;

/**
 * A trigger "mouseover" that listens for mouseover events on DOM elements
 * @memberOf Triggers
 * @example
 * {
 *     "mouseover": {
 *         "concept": "theConceptIWantToHearMouseoverTriggerOn"
 *     }
 * }
 * @example
 * //Match concept exact, not allowing any injected concepts to match
 * {
 *     "mouseover": {
 *         "concept": "theConceptIWantToHearMouseoverTriggerOn",
 *         "exactConceptMatch": true
 *     }
 * }
 * @example
 * {
 *     "mouseover": {
 *         "view": "aViewBindingIWantToHearMouseoverTriggerOn"
 *     }
 * }
 * @example
 * {
 *     "mouseover": {
 *         "property": "aPropertyIWantToHearMouseoverTriggerOn"
 *     }
 * }
 */
class MouseoverTrigger extends MouseTrigger {
    constructor(name, options, concept) {
        super(name, options, concept, "mouseover");
    }
}
Trigger.registerTrigger("mouseover", MouseoverTrigger);
window.MouseoverTrigger = MouseoverTrigger;

/**
 * A trigger "mouseout" that listens for mouseout events on DOM elements
 * @memberOf Triggers
 * @example
 * {
 *     "mouseout": {
 *         "concept": "theConceptIWantToHearMouseoutTriggerOn"
 *     }
 * }
 * @example
 * //Match concept exact, not allowing any injected concepts to match
 * {
 *     "mouseout": {
 *         "concept": "theConceptIWantToHearMouseoutTriggerOn",
 *         "exactConceptMatch": true
 *     }
 * }
 * @example
 * {
 *     "mouseout": {
 *         "view": "aViewBindingIWantToHearMouseoutTriggerOn"
 *     }
 * }
 * @example
 * {
 *     "mouseout": {
 *         "property": "aPropertyIWantToHearMouseoutTriggerOn"
 *     }
 * }
 */
class MouseoutTrigger extends MouseTrigger {
    constructor(name, options, concept) {
        super(name, options, concept, "mouseout");
    }
}
Trigger.registerTrigger("mouseout", MouseoutTrigger);
window.MouseoutTrigger = MouseoutTrigger;

/**
 * A trigger "wheel" that listens for wheel events on DOM elements
 * @memberOf Triggers
 * @example
 * {
 *     "wheel": {
 *         "concept": "theConceptIWantToHearWheelTriggerOn"
 *     }
 * }
 * @example
 * //Match concept exact, not allowing any injected concepts to match
 * {
 *     "wheel": {
 *         "concept": "theConceptIWantToHearWheelTriggerOn",
 *         "exactConceptMatch": true
 *     }
 * }
 * @example
 * {
 *     "wheel": {
 *         "view": "aViewBindingIWantToHearWheelTriggerOn"
 *     }
 * }
 * @example
 * {
 *     "wheel": {
 *         "property": "aPropertyIWantToHearWheelTriggerOn"
 *     }
 * }
 */
class WheelTrigger extends MouseTrigger {
    constructor(name, options, concept) {
        super(name, options, concept, "wheel");
    }
}
Trigger.registerTrigger("wheel", WheelTrigger);
window.WheelTrigger = WheelTrigger;

/**
 * A trigger "key" that listens for key events in the DOM
 * <br />
 * Options:
 * <ul>
 * <li>event - The event to filter on, keyDown | keyPress | keyUp (Defaults to keyPress)</li>
 * <li>key - The key to filter on, ex. "a" or "Enter"</li>
 * <li>ctrl - If ctrl should be pressed or not (If omitted, then state of ctrl is not checked)</li>
 * <li>alt - If alt should be pressed or not (If omitted, then state of alt is not checked)</li>
 * <li>shift - If shift should be pressed or not (If omitted, then state of shift is not checked)</li>
 * <li>meta - If meta should be pressed or not (If omitted, then state of meta is not checked)</li>
 * <li>focus - If anything should be in focus for the event to trigger, supports concept and view</li>
 * <li>focus.exactConceptMatch - Should an exact match on concept be enforced. If no focus.concept is defined, the owning concept is used instead.</li>
 * </ul>
 * @memberOf Triggers
 * @example
 * //Trigger when key "Enter" is pressed and shift is held
 * {
 *     "key": {
 *         "event": "keyPress",
 *         "key": "Enter",
 *         "shift": true
 *     }
 * }
 *
 * //Trigger when key "Enter" is pressed and ctrl is held, and view 'myView' is in focus
 * {
 *     "key": {
 *         "event": "keyPress",
 *         "key": "Enter",
 *         "ctrl": true,
 *         "focus": {"view": "myView"}
 *     }
 * }
 *
 * //Trigger when key "Enter" is pressed and ctrl is held, and view 'myView' is in focus, and owning concept matches exact on focused concept
 * {
 *     "key": {
 *         "event": "keyPress",
 *         "key": "Enter",
 *         "ctrl": true,
 *         "focus": {"view": "myView", "exactConceptMatch": true}
 *     }
 * }
 */
class KeyTrigger extends Trigger {
    static options() {
        return {
            "event": "enum[keyUp,keyDown,keyPress]",
            "key": "@string",
            "ctrl": "boolean%false",
            "alt": "boolean%false",
            "shift": "boolean%false",
            "meta": "boolean%false",
            "focus": "@enumValue[concept,view]"
        }
    }

    constructor(name, options, concept) {
        const defaultOptions = {
            event: "keyPress"
        }

        super(name, Object.assign({}, defaultOptions, options), concept);
    }

    enable() {
        const self = this;

        this.triggerDelete = Trigger.registerTriggerEvent("key", async (context) => {
            //Always only 1 entry in array
            context = context[0];

            let resultContext = Action.cloneContext(context);

            if(DOMTriggers.DEBUG) {
                console.log("Key trigger:", context, self.options);
            }

            if(self.options.key != null && self.options.code != null) {
                throw new Error("'key' trigger can only have one of \"key\" or \"code\" option, not both");
            }

            if(self.options.key != null && self.options.key.toLowerCase() !== context.variables.key.toLowerCase()) {
                //Key does not match
                if(DOMTriggers.DEBUG) {
                    console.log("key does not match!");
                }
                return;
            }

            if(self.options.code != null && self.options.code !== context.variables.code) {
                //Code does not match
                if(DOMTriggers.DEBUG) {
                    console.log("code does not match!");
                }
                return;
            }

            if(self.options.shift != null && self.options.shift !== context.variables.shift) {
                //Shift state does not match
                if(DOMTriggers.DEBUG) {
                    console.log("Shift state does not match!");
                }
                return;
            }

            if(self.options.ctrl != null && self.options.ctrl !== context.variables.ctrl) {
                //Ctrl state does not match
                if(DOMTriggers.DEBUG) {
                    console.log("Ctrl state does not match!");
                }
                return;
            }

            if(self.options.alt != null && self.options.alt !== context.variables.alt) {
                //Alt state does not match
                if(DOMTriggers.DEBUG) {
                    console.log("Alt state does not match!");
                }
                return;
            }

            if(self.options.meta != null && self.options.meta !== context.variables.meta) {
                //Meta state does not match
                if(DOMTriggers.DEBUG) {
                    console.log("Meta state does not match!");
                }
                return;
            }

            if(self.options.event != null && self.options.event !== context.event) {
                //Event type does not match
                if(DOMTriggers.DEBUG) {
                    console.log("Event type does not match!");
                }
                return;
            }

            if(self.options.focus != null) {
                let focusOptions = self.options.focus;

                if(typeof focusOptions === "string") {
                    focusOptions = VarvEngine.lookupReference(self.options.focus, self.concept);
                }

                if(self.options.focus.exactConceptMatch && focusOptions.concept == null) {
                    focusOptions.concept = self.concept.name;
                }

                if(focusOptions.concept != null) {
                    let foundFocusConcept = false;
                    for(let uuid of context.conceptUUIDs) {
                        let concept = await VarvEngine.getConceptFromUUID(uuid);
                        if(self.options.focus.exactConceptMatch) {
                            if (concept.name === self.options.focus) {
                                foundFocusConcept = true;
                                break;
                            }
                        } else {
                            if (concept.isA(self.options.focus)) {
                                foundFocusConcept = true;
                                break;
                            }
                        }
                    }

                    if (!foundFocusConcept) {
                        if (DOMTriggers.DEBUG) {
                            console.log("Focus concept does not match!");
                        }
                        return;
                    }
                }

                if(focusOptions.view != null) {
                    let foundView = context.targetElement.closest("[view='"+focusOptions.view+"']");
                    if(!foundView) {
                        if(DOMTriggers.DEBUG) {
                            console.log("Focus view does not match!");
                        }
                        return;
                    }
                }

                if(focusOptions.property != null) {
                    throw new Error("Unsupported focus on property for key trigger");
                }

                if(focusOptions.unknown != null) {
                    if(DOMTriggers.DEBUG) {
                        console.log("Focus unknown does not match!");
                    }
                    return;
                }
            }

            await Trigger.trigger(self.name, resultContext)
        });
    }

    disable() {
        if(this.triggerDelete != null) {
            this.triggerDelete.delete();
        }
        this.triggerDelete = null;
    }
}
Trigger.registerTrigger("key", KeyTrigger);
window.KeyTrigger = KeyTrigger;

class DOMTriggers {
    static setup(targetDocument = document) {
        if (targetDocument.registeredDOMTriggers){
            console.log("DOMTriggers: Trying to register on a document that was already registered, ignoring");
            return;
        }

        function mouseHandler(mouseEvent, type) {
            let x = mouseEvent.pageX;
            let y = mouseEvent.pageY;

            let button = "unknown";

            switch(mouseEvent.button) {
                case 0: {
                    button = "left";
                    break;
                }
                case 1: {
                    button = "middle";
                    break;
                }
                case 2: {
                    button = "right";
                    break;
                }
            }

            let uuids = [];

            let target = null;

            let properties = [];

            if(DOMView.singleton != null) {
                uuids = DOMView.singleton.getConceptPath(mouseEvent.target).map((binding)=>{return binding.uuid});
                properties = DOMView.singleton.getPropertyPath(mouseEvent.target);
            }

            if(uuids.length > 0) {
                //Use nearest concept uuid as target, if ClickTrigger, does not filter on concept, this is the target that will be shown
                target = uuids[uuids.length-1];
            }

            let context = {
                variables: {
                    x: x,
                    y: y,
                    button: button
                },
                conceptUUIDs: uuids,
                targetElement: mouseEvent.target,
                properties: properties,
                target: target,
                originalEvent: mouseEvent
            };

            if(type === "wheel") {
                context.variables["wheelDelta"] = mouseEvent.wheelDelta;
            }

            Trigger.trigger(type, context);
        }

        //Setup click
        targetDocument.body.addEventListener("click", (evt)=>{
            mouseHandler(evt, "click");
        });
        targetDocument.body.addEventListener("pointermove", (evt)=>{
            mouseHandler(evt, "mousemove");
        });
        targetDocument.body.addEventListener("pointerover", (evt)=>{
            mouseHandler(evt, "mouseover");
        });
        targetDocument.body.addEventListener("pointerout", (evt)=>{
            mouseHandler(evt, "mouseout");
        });
        targetDocument.body.addEventListener("pointerup", (evt)=>{
            mouseHandler(evt, "mouseup");
        });
        targetDocument.body.addEventListener("pointerdown", (evt)=>{
            mouseHandler(evt, "mousedown");
        });
        targetDocument.body.addEventListener("contextmenu", (evt)=>{
            mouseHandler(evt, "contextmenu");
        });
        targetDocument.body.addEventListener("wheel", (evt)=>{
            mouseHandler(evt, "wheel");
        });

        //Setup key
        function keyHandler(keyEvent, evtType) {
            let shift = keyEvent.shiftKey;
            let ctrl = keyEvent.ctrlKey;
            let meta = keyEvent.metaKey;
            let alt = keyEvent.altKey;

            let target = null;
            let uuids = DOMView.singleton.getConceptPath(keyEvent.target).map((binding)=>{ return binding.uuid});

            let properties = DOMView.singleton.getPropertyPath(keyEvent.target);

            if(uuids.length > 0) {
                //Use nearest concept uuid as target, if ClickTrigger, does not filter on concept, this is the target that will be shown
                target = uuids[uuids.length-1];
            }

            let context = {
                variables: {
                    code: keyEvent.code,
                    key: keyEvent.key,
                    shift: shift,
                    ctrl: ctrl,
                    alt: alt,
                    meta: meta,
                },
                event: evtType,
                targetElement: keyEvent.target,
                conceptUUIDs: uuids,
                properties: properties,
                target: target,
                focusElement: targetDocument.activeElement,
                originalEvent: keyEvent
            }

            Trigger.trigger("key", context);
        }

        targetDocument.body.addEventListener("keydown", (evt)=>{
            keyHandler(evt, "keyDown");
        });
        targetDocument.body.addEventListener("keyup", (evt)=>{
            keyHandler(evt, "keyUp");
        });
        targetDocument.body.addEventListener("keypress", (evt)=>{
            keyHandler(evt, "keyPress");
        });

        targetDocument.registeredDOMTriggers = true;
    }
}

DOMTriggers.setup();
DOMTriggers.DEBUG = false;
window.DOMTriggers = DOMTriggers;

// Also find all present and future sub-documents and try to inject our listeners in those documents as well
function injectTriggers(frame){
    try {
        DOMTriggers.setup(frame.contentDocument);
    } catch (ex){
        console.log("DOMTriggers in iframe is experimental and being silly");
    }
    frame.addEventListener("load", ()=>{
        try {
            DOMTriggers.setup(frame.contentDocument);
        } catch (ex){
            console.log("DOMTriggers in iframe is experimental and being silly in a slower way");
        }
    });
}
document.querySelectorAll("iframe").forEach((frame)=>{
    injectTriggers(frame);
});
new MutationObserver((mutations) => {
    for(let mutation of mutations) {
        switch (mutation.type) {
            case 'childList':
                for(let node of mutation.addedNodes) {
                    if (node.tagName === "IFRAME") {
                        injectTriggers(frame);
                    }
                }
            break;
        }
    }
}).observe(document.body, {
    childList: true,
    subtree: true,
});

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="varv-repos" id="varv-dom-highlight" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Varv DOM Highlighting",
    "description": "Allows applications like Cauldron to highlight concepts, properties and similar directly in the DOMView",
    "dependencies": [
        "#varv-engine"
    ],
    "assets": [],
    "license": "MIT",
    "version": "0.1",
    "changelog": {}
}

</SCRIPT><SCRIPT id="DOMHighlight-script" type="disabled">
class DOMHighlighter {
    constructor(){
        let self = this;

        let conceptHighlightCallback = EventSystem.registerEventCallback("Varv.DOMView.HighlightConcept", (evt)=>{
            let concept = evt.detail;
            self.getViews().forEach((view)=>{
                self.walkView(view, self.clearHighlight);
                self.walkView(view, function highlightConcept(node){
                    for (let conceptBinding of DOMView.singleton.getConceptPath(node)){
                        if (conceptBinding.concept===concept){
                            self.highlight(node);
                            return false; // Don't highlight into children
                        }
                    }
                    return true;
                });
            });
        });

        let instanceHighlightCallback = EventSystem.registerEventCallback("Varv.DOMView.HighlightInstance", (evt)=>{
            let uuid = evt.detail;
            self.getViews().forEach((view)=>{
                self.walkView(view, self.clearHighlight);
                self.walkView(view, function highlightInstance(node){
                    for (let conceptBinding of DOMView.singleton.getConceptPath(node)){
                        if (conceptBinding.uuid===uuid){
                            self.highlight(node);
                            return false; // Don't highlight into children
                        }
                    }
                    return true;
                });
            });
        });

        let propertyHighlightCallback = EventSystem.registerEventCallback("Varv.DOMView.HighlightProperty", (evt)=>{
            let property = evt.detail;
            self.getViews().forEach((view)=>{
                self.walkView(view, self.clearHighlight);
                self.walkView(view, function highlightProperty(node){
                    for (let entry of DOMView.singleton.getPropertyPath(node)){
                        if (entry.property===property){
                            if (node.setAttribute){
                                node.setAttribute("varv-domview-highlight",true);
                            }
                            return false;
                        }
                    }
                    return true;
                });
            });
        });

        let clearHighlightCallback = EventSystem.registerEventCallback("Varv.DOMView.ClearHighlights", (evt)=>{
            self.getViews().forEach((view)=>{
                self.walkView(view, self.clearHighlight);
            });
        });
    }

    getViews(){
        return document.querySelectorAll("varv-view");
    }

    highlight(node){
        if (node.setAttribute){
            node.setAttribute("varv-domview-highlight",true);
        }
    }

    clearHighlight(node){
        if (node.getAttribute && node.getAttribute("varv-domview-highlight")){
            node.removeAttribute("varv-domview-highlight");
        }
        return true;
    }

    walkView(view, nodeCallback){
        let diveIntoChildren = nodeCallback(view);
        if (diveIntoChildren){
            for (let child of view.childNodes){
                this.walkView(child, nodeCallback);
            }
        }
    }
}

window.DOMHighlighter = DOMHighlighter;
window.DOMHighlighter.singleton = new DOMHighlighter();

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="varv-repos" id="varv-domdiff-view" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Varv DOMDiff View",
    "description": "Allow data to be visualized as a high-performance browser-based UI based on DOM-diffing",
    "dependencies": [
        "#varv-engine"
    ],
    "assets": [],
    "license": "MIT",
    "version": "0.1",
    "changelog": {}
}

</SCRIPT><SCRIPT id="UpdatingEvalutation-script" type="disabled">
class UpdatingEvaluation {
    constructor(originalText, scope, onChangeCallback){
        this.originalText = originalText;
        this.replacements = new Map();
        this.tokens = originalText.match(/{(.+?)}/g);
        if (!this.tokens) this.tokens = [];
        this.onChangeCallback = onChangeCallback;
        this.updateCallbacks = [];
        this.destroyed = false;

        let self = this;

        // Prepare it once manually
        for(let token of this.tokens) {
            token = token.trim();
            let lookupQuery = token.substring(1, token.length - 1);

            let replacement = {
                value: undefined,
                getText: null,
                binding: null,
                propertyName: null
            };
            if (lookupQuery.includes("?")){
                let regexp = /^(?<condition>.+?)\?(?<quote1>["']?)(?<true>.+?)\k<quote1>(?::(?<quote2>["']?)(?<false>.*)\k<quote2>)?$/gm;

                let match = regexp.exec(lookupQuery);

                replacement.propertyName = match.groups.condition;

                let negated = false;

                if(replacement.propertyName.startsWith("!")) {
                    negated = true;
                    replacement.propertyName = replacement.propertyName.substring(1);
                }

                // Fancy { x ? y : < } query
                binding = DOMView.getBindingFromScope(replacement.propertyName, scope);
                replacement.textFunction = ()=>{
                    if (replacement.binding===undefined) return undefined;
                    let trueValue = match.groups.true;
                    let falseValue = typeof match.groups.false === "undefined"?"":match.groups.false;

                    if(negated) {
                        let tmp = trueValue;
                        trueValue = falseValue;
                        falseValue = tmp;
                    }

                    return replacement.value?trueValue:falseValue;
                };
            } else {
                // Normal {} query, the entire thing is the name
                replacement.propertyName = lookupQuery;
                replacement.binding = DOMView.getBindingFromScope(replacement.propertyName, scope);
                replacement.textFunction = ()=>{
                    return replacement.value;
                };
            }
            this.replacements.set(lookupQuery, replacement);
        }

        this.initialUpdate = true;
        this.update();
    }

    async update(){
        let self = this;
        let mark = VarvPerformance.start();

        // Get the initial values the first time
        if (this.initialUpdate){
            await Promise.all(Array.from(this.replacements.values()).map(async (replacement)=>{
                // Fetch initial value
                if (!replacement.binding) return;
                replacement.value = await replacement.binding.getValueFor(replacement.propertyName);

                // Listen for future updates, if supported by the binding
                if (replacement.binding.generateRawChangeListener){
                    let changedCallback = replacement.binding.generateRawChangeListener(replacement.propertyName, replacement.value);
                    changedCallback.onChanged = async function updateUpdatingStringEvaluation(value){
                        replacement.value = value;
                        await self.update();
                    };
                    this.updateCallbacks.push(changedCallback);
                };
            }));

            this.initialUpdate = false;
        }

        try {
            let text = this.originalText;
            for(let token of this.tokens) {
                token = token.trim();
                let lookupQuery = token.substring(1, token.length - 1);

                let value = this.replacements.get(lookupQuery).textFunction();
                if (value !== undefined){
                    text = text.replace(token, value); // STUB: This can fail if the first token is replaced with something that looks like the second token
                }
            }

            await this.onChangeCallback(text);
        } catch (ex){
            console.error(ex);
        }

        VarvPerformance.stop("UpdatingStringEvaluation.update", mark);
    }

    destroy(){
        if (this.destroyed) {
            if (DOMView.DEBUG){
                console.warn("FIXME: Harmless double desctruction, ignoring - but try not to destroy me this much");
            }
            return;
        }
        for (let entry of this.updateCallbacks){
            entry.destroy();
        }
        this.destroyed = true;
    }
}

window.UpdatingEvaluation = UpdatingEvaluation;

</SCRIPT><SCRIPT id="ViewParticle-script" type="disabled">
/**
 * A view particle mst
 * @type type
 */
class ViewParticle {
    constructor(node, parseNode, scope){
        this.node = node;
        this.parseNode = parseNode;
        this.mountCallbacks = [];
        this.renderCallbacks = [];
        this.cleanup = [];
        this.scope = scope;
        this.initialRender = false;
        node.viewParticle = this;
    }

    getNode(){
        // TODO: error node when null
        return this.node;
    }

    getTargetDocument(){
        let doc = this.node.ownerDocument;
        if (!doc.createElement) console.log("Weird root node", this, this.node, doc, this.parseNode, this.scope);
        return doc;
    }

    addCleanup(callback){
        this.cleanup.push(callback);
    }

    addOnMountedCallback(callback){
        this.mountCallbacks.push(callback);
    }

    addOnRenderedCallback(callback){
        this.renderCallbacks.push(callback);
    }

    mountInto(parentElement, insertBeforeNode=null){
        parentElement.insertBefore(this.node, insertBeforeNode);
        this.mountCallbacks.forEach((callback)=>{
            callback();
        });
    }

    onRendered(){
        this.initialRender = true;
        this.renderCallbacks.forEach((callback)=>{
            callback();
        });
    }

    hasRendered(){
        return this.initialRender;
    }

    destroy(){
        if (DOMView.DEBUG) console.log("Destroying particle ",this);
        this.cleanup.forEach((callback)=>{
            callback();
        });
        this.node.remove();
    }
}

window.ViewParticle = ViewParticle;

</SCRIPT><SCRIPT id="ParseNode-script" type="disabled">
class ParseNode {
    constructor(templateElement){
        this.children = [];
        this.cleanupCallbacks = [];
        this.templateElement = templateElement;

        if (DOMView.DEBUG){
            console.log("adding ", templateElement);
        }
    }

    parseTemplateNode(elementNode, parseOptions={}){
        switch (elementNode.nodeType){
            // Nodes that cannot have attributes are treated directly
            case Node.COMMENT_NODE:
                // Drop all comments to minify view as much as possible - we cannot update them properly anyways
                return null;
            case Node.TEXT_NODE:
                return new TextParseNode(elementNode);

            // Nodes that may have attributes are handled below
            case Node.ELEMENT_NODE:
                break;

            // Unknown nodes are copied verbatim
            default:
                return new YotaParseNode(elementNode);
        }

        // Handle filtering/duplication attributes before anything else (may need duplication)
        if (!parseOptions.skipQuery){
            const atts = elementNode.attributes;
            if (atts && (atts["concept"] || atts["property"] || atts["if"])){
                // These are not valid on varv-template element
                if (elementNode==="VARV-TEMPLATE") {
                    console.log("concept, property or if used on varv-template element itself is invalid");
                }
                return new QueryParseNode(elementNode);
            }
        }

        // Handle HTML elements
        switch (elementNode.tagName){
            case "VARV-TEMPLATE":
                // Not used in output
                return null;
            case "TEMPLATE-REF":
                return new TemplateRefParseNode(elementNode);
            default:
                return new ElementParseNode(elementNode);
        }
    }

    getErrorView(targetDocument, scope, error, ex=null){
        console.log("DOMView runtime error", error, ex, scope, this.templateElement, this);

        let element = targetDocument.createElement("varv-failure");
        element.setAttribute("title", error + "\n" + ex);

        return new ViewParticle(element, this, scope);
    }
}

window.ParseNode = ParseNode;

</SCRIPT><SCRIPT id="YotaParseNode-script" type="disabled">
class YotaParseNode extends ParseNode {
    getView(targetDocument, scope){
        if (DOMView.DEBUG) console.log("instantiating yota", this.templateElement);

        return new ViewParticle(targetDocument.importNode(this.templateElement,false), this, scope);
    }
};

window.YotaParseNode = YotaParseNode;

</SCRIPT><SCRIPT id="TextParseNode-script" type="disabled">
class TextParseNode extends ParseNode {
    getView(targetDocument, scope){
        if (DOMView.DEBUG) console.log("instantiating text", this.templateElement);

        let textNode = targetDocument.createTextNode("");
        let view = new ViewParticle(textNode, this, scope);
        view.updatingEvaluation = new UpdatingEvaluation(this.templateElement.nodeValue, scope, function textNodeUpdated(text){
            textNode.nodeValue = text;
        });
        view.addCleanup(()=>{
            view.updatingEvaluation.destroy();
        });

        return view;
    }
};

window.TextParseNode = TextParseNode;

</SCRIPT><SCRIPT id="ScopedParseNode-script" type="disabled">
class ScopedParseNode extends ParseNode {
    constructor(templateElement){
        super(templateElement);
    }

    getView(targetDocument, scope){
        if (DOMView.DEBUG) console.log("instantiating scopedparsenode abstract view for ", this.templateElement);
        let self = this;
        let view = new ViewParticle(targetDocument.createProcessingInstruction("varv-scope-anchor", {}), this, scope);
        view.topGuardElement = view.getTargetDocument().createProcessingInstruction("varv-scope-topguard", {});
        view.childViews = [];
        this.generateScopes(view);

        view.addOnMountedCallback(()=>{
            // Plain move everything to new parent
            view.getNode().parentElement.insertBefore(view.topGuardElement, view.getNode());
            view.childViews.forEach((childView)=>{
                // Insert them before our anchor node
                childView.mountInto(view.getNode().parentElement, view.getNode());
            });
        });
        view.addCleanup(()=>{
            // Empty the view
            self.onScopesUpdated(view, []);
        });
        return view;
    }

    onScopesUpdated(view, newChildScopes){
        // Destroy views that are no longer in the new child scopes
        let self = this;
        let changes = 0;

        // Add new views for newly added scopes while reordering
        if (DOMView.DEBUG) console.log("Updating view scope, old=>new",view.childViews, newChildScopes);
        let oldChildViews = view.childViews;
        view.childViews = [];
        newChildScopes.forEach((newChildScope)=>{
            let existingView = false;
            oldChildViews.forEach((childView)=>{
                if (ScopedParseNode.fastDeepEqual(childView.localScope,newChildScope)) existingView = childView;
            });
            if (existingView){
                oldChildViews.splice(oldChildViews.indexOf(existingView),1);
                view.childViews.push(existingView);
            } else {
                view.childViews.push(()=>{
                    /**
                     * Very specific performance optimization:
                     * TODO: If the only change in the scope is a PropertyArrayEntryBinding index on the top of the scope stack
                     * we can migrate the view by performing binding updates instead of destroying it and recreating it here.
                     * This happens often when reordering list entries.
                     */
                    let newLastOfScope = newChildScope[newChildScope.length-1];
                    if (newLastOfScope instanceof PropertyArrayEntryBinding){
                        for (let oldChildView of oldChildViews){
                            let oldLastOfScope = oldChildView.localScope[oldChildView.localScope.length-1];
                            if (oldLastOfScope instanceof PropertyArrayEntryBinding){
                                if (oldLastOfScope.identicalExceptIndex(newLastOfScope)){
                                    // Identical tops (except index), compare rest of their localScope
                                    if (DOMView.DEBUG || DOMView.DEBUG_PERFORMANCE) console.log("Could optimize maybe", newChildScope, oldChildView.localScope);
                                    if (ScopedParseNode.fastDeepEqual(newChildScope.slice(0,-1),oldChildView.localScope.slice(0,-1))){
                                        if (DOMView.DEBUG || DOMView.DEBUG_PERFORMANCE) console.log("Optimized",oldChildView);
                                        oldChildViews.splice(oldChildViews.indexOf(oldChildView),1);
                                        oldLastOfScope.updateIndex(newLastOfScope.index);
                                        return oldChildView;
                                    }
                                }
                            }
                        };
                    }
                    // /very specific performance optimization

                    // Couldn't recover anything, just create a new view
                    let childView;
                    if (newLastOfScope instanceof RuntimeExceptionBinding){
                        childView = self.getErrorView(view.getTargetDocument(), [...view.scope, ...newChildScope], newLastOfScope.errorMessage, newLastOfScope.ex);
                    } else {
                        childView = self.children[0].getView(view.getTargetDocument(),[...view.scope, ...newChildScope]);
                    }
                    changes++;
                    childView.localScope = newChildScope;
                    return childView;
                });
            }
        });

        // Run optimizing functions
        view.childViews = view.childViews.map((value)=>{
            if (typeof(value)==="function") return value();
            return value;
        });

        for (let i = oldChildViews.length-1; i>=0; i--){
            let found = false;
            view.childViews.forEach((childView)=>{
                if (childView===oldChildViews[i]) found = true;
            });
            if (!found){
                oldChildViews[i].destroy();
                oldChildViews.splice(i,1);
                changes++;
            }
        }
        if (oldChildViews.length!==0) console.log("FIXME: DOMView oldChildViews postcondition inconsistency detected: 0!="+oldChildViews.length,oldChildViews);

        if ((DOMView.DEBUG||DOMView.DEBUG_PERFORMANCE) && changes===0 && newChildScopes.length>0){
            try {
                console.log("FIXME: DOMDiffView: Potential performance optimization for ScopedParseNode. onScopesUpdated() called but returned no change in scope",this);
                throw new Error("stacktrace");
            } catch (ex) {
                console.log(ex);
            }
        }

        this.stubResetView(view);
    }

    stubResetView(view){
        if (view.getNode().parentNode === null) return; // Not in any document yet

        let parent = view.getNode().parentNode;
        let viewCount = view.childViews.length;

        for (let i = 0; i < viewCount; i++){
            if (DOMView.DEBUG) console.log("Validating view", view.childViews[i]);
            let alreadyMountedCorrectly = true;

            // A view is mounted correctly if it is mounted here and no view that is supposed to be later is mounted before it
            if (view.childViews[i].getNode().parentElement!==parent){
                alreadyMountedCorrectly = false;
            }
            let anchorIndex = [...parent.childNodes].indexOf(view.childViews[i].getNode());
            if (i!==viewCount-1){
                for (let o = i+1; o < viewCount; o++){
                    let thisIndex = [...parent.childNodes].indexOf(view.childViews[o].getNode());
                    if (thisIndex < anchorIndex && view.childViews[o].getNode().parentElement===parent) {
                        console.log("Wrong location, found",anchorIndex, thisIndex,view.childViews[o].getNode());

                        alreadyMountedCorrectly = false;
                        break;
                    }
                }
            }

            // If not mounted correctly, mount after previous view (or top guard if first view)
            if (!alreadyMountedCorrectly){
                let mountAfter = view.topGuardElement;
                if (i!==0){
                    mountAfter = view.childViews[i-1].getNode();
                }
                view.childViews[i].mountInto(view.getNode().parentElement, mountAfter.nextSibling);
            }
        }

        view.onRendered();
    }

    showError(view, message, ex){
        console.log(ex);
        this.onScopesUpdated(view, []);
        view.childViews.push(this.getErrorView(view.getTargetDocument(), view.scope, message, ex));
        this.stubResetView(view);
    }

    static fastDeepEqual(a,b){
        if (a === b) return true;

        if (a && b && typeof a == 'object' && typeof b == 'object') {
          if (a.constructor !== b.constructor) return false;

          var length, i, keys;
          if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length) return false;
            for (i = length; i-- !== 0;)
              if (!ScopedParseNode.fastDeepEqual(a[i], b[i])) return false;
            return true;
          }

          if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
          if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
          if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

          keys = Object.keys(a);
          length = keys.length;
          if (length !== Object.keys(b).length) return false;

          for (i = length; i-- !== 0;)
            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

          for (i = length; i-- !== 0;) {
            var key = keys[i];
            if (key.startsWith("_")) continue;
            if (!ScopedParseNode.fastDeepEqual(a[key], b[key])) return false;
          }

          return true;
        }

        if(typeof a === "function" && typeof b === "function") {
            return true;
        }

        // true if both NaN, false otherwise
        return a!==a && b!==b;

    };
};

window.ScopedParseNode = ScopedParseNode;

</SCRIPT><SCRIPT id="TemplateRefParseNode-script" type="disabled">
class TemplateRefParseNode extends ScopedParseNode {
    constructor(templateElement){
        super(templateElement);
        this.children.push(new TemplateInstanceParseNode(templateElement));
    }

    getView(targetDocument, scope){
        if (DOMView.DEBUG) console.log("instantiating template-ref for ", this.templateElement);
        return super.getView(targetDocument, scope);
    }

    // Look at the TEMPLATE-NAME attribute and generate our scope(s)
    generateScopes(view){
        let self = this;
        let templateQuery = this.templateElement.getAttribute("template-name");
        let templateHookType = this.templateElement.getAttribute("template-hook");
        if ((templateQuery!==null) && templateQuery.trim().length>0){
            // Need to monitor a list of templates
            view.templateUpdatingEvaluation = new UpdatingEvaluation(templateQuery, view.scope, async function templateNameAttributeChanged(templateName){
                try {
                    // Find the template and create corresponding scopes
                    let templates = document.querySelectorAll("varv-template[name='" + templateName+"']");
                    let localScopes = [];

                    if (templates.length===0) throw new Error("Template with name '"+templateName+"' does not exist (yet?)");
                    switch (templateHookType){
                        case "all":
                            templates.forEach((template)=>{
                                localScopes.push([new TemplateBinding(template)]);
                            });
                            break;
                        case "first":
                            localScopes.push([new TemplateBinding(templates[0])]);
                            break;
                        case "last":
                        default:
                            localScopes.push([new TemplateBinding(templates[templates.length - 1])]);
                    }

                    self.onScopesUpdated(view, localScopes);
                } catch (ex){
                    self.showError(view, "Template-ref='"+templateQuery+"': "+ex, ex);
                    return;
                }
            });
            view.addCleanup(()=>{
                view.templateUpdatingEvaluation.destroy();
            });
        }
    }
}
window.TemplateRefParseNode = TemplateRefParseNode;

/**
 * A node that dynamically parses and renders a template from the scope all during getView rather than construction
 * @type type
 */
class TemplateInstanceParseNode extends ParseNode {
    getView(targetDocument, scope){
        let templateBinding = scope[scope.length-1];
        if (!templateBinding instanceof TemplateBinding) throw new Error("STUB: Currently TemplateBinding MUST be the last element on the scope stack when rendering template instances");

        // Dynamically parse and render the template now
        let referencedTemplateElement = templateBinding.getTemplateElement()
        if (DOMView.DEBUG) console.log("parsing template-instance for ", this.templateElement, referencedTemplateElement);
        let view = new ViewParticle(targetDocument.createProcessingInstruction("varv-template-anchor", {}), this, scope);
        let parseNodes = [];
        for (let childNode of referencedTemplateElement.childNodes){
            let parseChild = this.parseTemplateNode(childNode);
            if (parseChild){
                // If this actually needs parsing, add it
                parseNodes.push(parseChild);
            }
        }

        if (DOMView.DEBUG) console.log("creating template-instance view for ", view, parseNodes);
        view.childViews = [];
        parseNodes.forEach((parseChild)=>{
            view.childViews.push(parseChild.getView(targetDocument, scope));
        });

        // Also destroy the template view children when our view is destroyed
        view.addCleanup(()=>{
            view.childViews.forEach((childView)=>{
                childView.destroy();
            });
        });

        // When we are mounted into the document, think about the children!
        view.addOnMountedCallback(()=>{
            view.childViews.forEach((childView)=>{
                // Insert them before our anchor node
                childView.mountInto(view.getNode().parentNode, view.getNode());
            });
        });

        return view;
    }
};
window.TemplateInstanceParseNode = TemplateInstanceParseNode;

</SCRIPT><SCRIPT id="QueryParseNode-script" type="disabled">
class QueryParseNode extends ScopedParseNode {
    constructor(templateElement){
        super(templateElement);

        // We are our own only child
        this.children.push(this.parseTemplateNode(templateElement, {
            skipQuery: true
        }));
    }

    getView(targetDocument, scope){
        if (DOMView.DEBUG) console.log("instantiating query for ", this.templateElement);
        let view = super.getView(targetDocument, scope);
        view.addCleanup(()=>{
            // Change callbacks
            view.conceptAppearedCallback?.delete();
            view.conceptDisappearedCallback?.delete();

            // Attribute evaluators
            view.conceptUpdatingEvaluation?.destroy();
            view.propertyUpdatingEvaluation?.destroy();
            view.conditionalUpdatingEvaluation?.destroy();
        });
        return view;
    }

    generateScopes(view){
        view.propertyChangedCallbacks = [];
        this.generateConceptScopes(view);
    }

    // Look at the CONCEPT attribute and generate some scopes
    generateConceptScopes(view){
        let self = this;
        let conceptQuery = this.templateElement.getAttribute("concept");
        if ((conceptQuery!==null) && conceptQuery.trim().length>0){
            // Need to monitor a list of concept instances
            view.conceptUpdatingEvaluation = new UpdatingEvaluation(conceptQuery, view.scope, async function conceptAttributeUpdated(conceptName){
                try {
                    // Clean up any previous appeared/disappeared callbacks
                    view.conceptAppearedCallback?.delete();
                    view.conceptDisappearedCallback?.delete();

                    // Concept enumeration queries
                    let doConceptEnumeration = async function doConceptEnumerationForScopes(){
                        // TODO: possibly filter for performance
                        if (self.templateElement.getAttribute("property")) console.log("FIXME: DOMView concept='' enumerations combined with property='' lookups on same element can be optimized further, use filters here");
                        if (self.templateElement.getAttribute("if")) console.log("FIXME: DOMView concept='' enumerations combined with if='' can sometimes be optimized further, use filters here");
                        let instances = await VarvEngine.lookupInstances(VarvEngine.getAllImplementingConceptNames(conceptName)); // TODO: Fancy filtering opportunity here
                        let localScopes = await Promise.all(instances.map(async function lookupConcreteTypes(uuid){
                            let concreteConcept = await VarvEngine.getConceptFromUUID(uuid);
                            return [new ConceptInstanceBinding(concreteConcept, uuid)];
                        }));
                        self.generatePropertyScopes(view, localScopes);
                    };

                    // Populate the scope
                    await doConceptEnumeration();
                    let refreshTimer;
                    view.conceptAppearedCallback = VarvEngine.registerEventCallback("appeared", async (evt) => {
                        if (evt.concept.isA(conceptName)){
                            clearTimeout(refreshTimer);
                            refreshTimer = setTimeout(()=>{
                                doConceptEnumeration();
                            },0);
                        }
                    });
                    view.conceptDisappearedCallback = VarvEngine.registerEventCallback("disappeared", async (evt) => {
                        if (evt.concept.isA(conceptName)){
                            clearTimeout(refreshTimer);
                            refreshTimer = setTimeout(()=>{
                                doConceptEnumeration();
                            },0);
                        }
                    });
                } catch (ex){
                    self.showError(view, "Evaluating concept='"+conceptQuery+"': "+ex, ex);
                    return;
                }
            });

            // TODO: also run the above for concept added callbacks
        } else {
            // We can skip straight to property with just the view scope
            self.generatePropertyScopes(view, [[]]);
        }
    }

    // Look at the PROPERTY attribute and generate additional scopes for each given local scope
    generatePropertyScopes(view, localScopes){
        let self = this;

        // Clean potential previous evaluation of property-args so it stops updating
        if (view.propertyUpdatingEvaluation) {
            view.propertyUpdatingEvaluation.destroy();
            view.propertyUpdatingEvaluation = null;
        }

        let finalFiltering = function finalFiltering(scopeMap){
            // Concat the results into one big array and ship it to the UI
            let scopeCollection = [];
            scopeMap.forEach((subscopes)=>{
                subscopes.forEach((actualScope)=>{
                    scopeCollection.push(actualScope);
                });
            });
            self.generateConditionalScopes(view, scopeCollection);
        };

        // Look at property attribute
        let propertyQuery = this.templateElement.getAttribute("property");
        if ((propertyQuery!==null) && propertyQuery.trim().length>0){
            if (DOMView.DEBUG) console.log("Generating property scopes...");

            // Monitor property attribute for changes
            view.propertyUpdatingEvaluation = new UpdatingEvaluation(propertyQuery, view.scope, async function propertyAttributeUpdated(property){
                // Clean up previous callbacks
                view.propertyChangedCallbacks.forEach((callback)=>{
                    callback.destroy();
                });

                // Find the new properties for each existing scope
                if (DOMView.DEBUG) console.log("Property attribute value is now", property);
                if (property === undefined) throw new Error("Cannot render property '"+propertyQuery+"' which evaluates to undefined");
                try {
                    // Insert localScopes in the right order
                    let scopeMap = new Map(localScopes.map((localScope)=>{
                        return [localScope, []];
                    }));

                    // Calculate all the initial derived scopes in parallel
                    await Promise.all(localScopes.map(async function expandPropertyScope(localScope){
                        // Sanity checks
                        let binding = await DOMView.getBindingFromScope(property, [...view.scope, ...localScope]);
                        if (!binding) throw new Error("Selecting undefined property '"+property+"' not found in scope");
                        if (!(binding instanceof ConceptInstanceBinding)) throw new Error("Property='"+propertyQuery+"' (currently '"+property+"') must be a property on a concept");

                        // Find the new scopes from a value
                        let engineProperty = binding.getProperty(property);
                        let valueToScopes = async function propertyValueToScopes(propertyValue){
                            try {
                                if (DOMView.DEBUG) console.log("Property value is", propertyValue);
                                let as = self.templateElement.getAttribute("as");
                                if (propertyValue !== null && propertyValue !== undefined && propertyValue!=="") {
                                    if (engineProperty.getType()==="array") {
                                        // We need to map the array into additional childscopes with arrayentry bindings
                                        scopeMap.set(localScope, await Promise.all(propertyValue.map(async (arrayEntry, index)=>{
                                            let newScope = [...localScope];
                                            if (engineProperty.isConceptArrayType()) {
                                                newScope.push(new ConceptInstanceBinding(await VarvEngine.getConceptFromUUID(arrayEntry),arrayEntry));
                                            }
                                            newScope.push(new PropertyArrayEntryBinding(engineProperty, binding.uuid, arrayEntry, index, as));
                                            return newScope;
                                        })));
                                    } else {
                                        // Single property value, no duplication
                                        if (!engineProperty.isConceptType()) throw new Error("Cannot use a type for the property attribute that is not a list of references, a list of simple values or a single concept reference: "+propertyValue);
                                        scopeMap.set(localScope,[[
                                            ...localScope,
                                            new ConceptInstanceBinding(await VarvEngine.getConceptFromUUID(propertyValue),propertyValue),
                                            new PropertyBinding(engineProperty, binding.uuid, propertyValue, as)
                                        ]]);
                                    }
                                } else {
                                    scopeMap.set(localScope,[]); // Empty scope
                                }
                            } catch (ex){
                                scopeMap.set(localScope, [[new RuntimeExceptionBinding("Converting property value to scopes failed",ex)]]);
                            }
                        };

                        // Initial setup
                        let initialValue = await binding.getValueFor(property);
                        await valueToScopes(initialValue);

                        // Listen for changes in the looked up property and update the scopes if changed
                        if (binding.generateRawChangeListener){
                            let changedCallback = binding.generateRawChangeListener(property,initialValue);
                            changedCallback.onChanged = async function queryParseNodePropertyChanged(value){
                                // Update the scopeMap with the new value
                                await valueToScopes(value);
                                finalFiltering(scopeMap);
                            };
                            view.propertyChangedCallbacks.push(changedCallback);
                        };
                    }));

                    finalFiltering(scopeMap);
                } catch (ex){
                        self.showError(view, "Evaluating property='"+propertyQuery+"': "+ex, ex);
                        return;
                }

            });
        } else {
            // Skip straight to conditionals with the given local scopes
            self.generateConditionalScopes(view, localScopes);
        }
    }

    // Look at IF attribute and remove local scopes that do not fit
    generateConditionalScopes(view, localScopes){
        let self = this;

        // Clean potential previous evaluation of if-args so it stops updating
        if (view.conditionalPropertyUpdateListeners){
            view.conditionalPropertyUpdateListeners.forEach((listener)=>{
                listener.destroy();
            });
        }
        view.conditionalPropertyUpdateListeners = [];
        if (view.conditionalUpdatingEvaluation) {
            view.conditionalUpdatingEvaluation.destroy();
            view.conditionalUpdatingEvaluation = null;
        }

        // Look at the attribute
        let conditionalQuery = this.templateElement.getAttribute("if");
        if ((conditionalQuery!==null) && conditionalQuery.trim().length>0){
            // Monitor the if-condition for changes
            view.conditionalUpdatingEvaluation = new UpdatingEvaluation(conditionalQuery, view.scope, async function conditionalAttributeUpdated(condition){
                if (DOMView.DEBUG) console.log("If changed: ", condition);
                try {
                    // Configure the if-test
                    let negate = false;
                    let isTestingInstanceOf = false;
                    let testType;
                    let conditionSource = condition;
                    if(condition.startsWith("!")){
                        conditionSource = condition.substring(1);
                        negate = true;
                    }
                    if (conditionSource.includes("concept ")){ // Instance-of if
                        isTestingInstanceOf = true;

                        testType = conditionSource.substring(conditionSource.indexOf("concept ")+8);
                        conditionSource = conditionSource.replace("concept "+testType, "").trim();
                        if (conditionSource.length === 0){
                            conditionSource = "concept::uuid"; // Use most recently bound concept
                        }
                    }

                    // Insert localScopes in the right order
                    let scopeMap = new Map(localScopes.map((localScope)=>{
                        return [localScope, []];
                    }));

                    let onConditionalUpdateCompleted = function onConditionalUpdateCompleted(){
                        // Flatten results to list
                        let includedScopes = [];
                        scopeMap.forEach((value,key)=>{
                            if (value) includedScopes.push(key);
                        });

                        // Send to UI
                        self.onScopesUpdated(view, includedScopes);
                    };

                    // Perform the conditional test
                    await Promise.all(localScopes.map(async function applyConditional(localScope){
                        // Sanity checks
                        if (localScope.length>0 && (localScope[localScope.length-1] instanceof RuntimeExceptionBinding)){
                            // Pass thru exceptions always, no if-ing
                            console.log("Passing thru error",localScope);
                            scopeMap.set(localScope, true);
                            return;
                        }
                        let binding = await DOMView.getBindingFromScope(conditionSource, [...view.scope, ...localScope]);
                        if (!binding) throw new Error("if='"+condition+"' selecting boolean '"+conditionSource+"' not bound in scope");
                        let evaluateConditional = async function evaluateConditional(value){
                            // Actual test
                            let conditionalValue = false;
                            try {
                                if (isTestingInstanceOf){
                                    // This check must be against a uuid, look it up
                                    let testTarget = await VarvEngine.getConceptFromUUID(value);
                                    conditionalValue = testTarget.isA(testType);
                                } else {
                                    conditionalValue = value;
                                }
                                if(negate) {
                                    conditionalValue = !conditionalValue;
                                }
                            } catch (ex){
                                console.warn(ex);
                            }
                            scopeMap.set(localScope, conditionalValue);

                        };

                        let initialValue = await binding.getValueFor(conditionSource);
                        evaluateConditional(initialValue);

                        // Listen for changes in the looked up value and update this subscope if changed
                        if (binding.generateRawChangeListener){
                            let changedCallback = binding.generateRawChangeListener(conditionSource, initialValue);
                            changedCallback.onChanged = async function queryParseNodePropertyChanged(value){
                                // Update the scopeMap with the new value
                                await evaluateConditional(value);
                                onConditionalUpdateCompleted();
                            };
                            view.conditionalPropertyUpdateListeners.push(changedCallback);
                        };
                    }));

                    onConditionalUpdateCompleted();
                } catch (ex){
                    self.showError(view, "Evaluating if='"+conditionalQuery+"': "+ex, ex);
                    return;
                }
            });
        } else {
            // When there is no 'if=', all local scopes survive directly
            this.onScopesUpdated(view, localScopes);
        }
    }
};

window.QueryParseNode = QueryParseNode;

</SCRIPT><SCRIPT id="ElementParseNode-script" type="disabled">
class ElementParseNode extends ParseNode {
    constructor(templateElement){
        super(templateElement);

        // Parse the children
        for (let childNode of templateElement.childNodes){
            let parseChild = this.parseTemplateNode(childNode);
            if (parseChild){
                // If this actually needs parsing, add it
                this.children.push(parseChild);
            }
        }
    }

    getView(targetDocument, scope){
        let self = this;
        if (DOMView.DEBUG) console.log("instantiating element", this.templateElement);

        // Create the element itself
        let name = this.templateElement.tagName;
        let namespace = this.templateElement.namespaceURI;
        if (name==="DOM-VIEW-TEMPLATE") name = "varv-view"; // The template itself renames to view
        let element;
        if (namespace.endsWith("html")){
            element = targetDocument.createElement(name);
        } else {
            element = targetDocument.createElementNS(namespace, name);
        }
        let view = new ViewParticle(element, this, scope);
        element.scope = scope;
        element.templateElement = this.templateElement;
        element.parseNode = this;

        // Attach the children
        view.childViews = [];
        for (let child of this.children){
            let childView = child.getView(targetDocument, scope);
            view.childViews.push(childView);
            childView.mountInto(element);
        }

        // Evaluate all attributes
        for(let attr of Array.from(this.templateElement.attributes)) {
            // Filtering attributes are ignored
            if (attr.name==="concept" || attr.name==="property" || attr.name==="if") continue;

            // Selects are a bit special, they depend on their children being present in order to set value
            if (self.templateElement.tagName==="SELECT" && attr.name==="value"){
                let selectUpdater = function selectChildrenOptionsChanged(){
                    element.value = element.varvValue;
                };
                view.childViews.forEach((childView)=>{
                    childView.addOnRenderedCallback(()=>{
                        setTimeout(selectUpdater,0);
                    });
                });
            }

            // The rest are evaluated
            let updatingEvaluation = new UpdatingEvaluation(attr.value, scope, function attributeNodeUpdated(value){
                let shouldUpdateAttribute = true;

                // Check for special attributes
                if (attr.name==="value"){
                    switch (element.tagName){
                        case "INPUT":
                            shouldUpdateAttribute = false;
                            if (self.templateElement.type==="checkbox"){
                                element.checked = value==="true" || value===true;
                            } else {
                                element.value = value;
                            }
                            break;
                        case "TEXTAREA":
                            shouldUpdateAttribute = false;
                            element.value = value;
                            break;
                        case "SELECT":
                            // Update when children option render properly
                            shouldUpdateAttribute = false;
                            element.value = value;
                            element.varvValue = value;
                            break;
                        case "DIV":
                            shouldUpdateAttribute = false;
                            if (!element.blockReadbacks){
                                element.innerHTML = value;
                            }
                            break;
                    }
                } else if(attr.name === "disabled" && value === "false") {
                    // Don't move disabled=false over
                    shouldUpdateAttribute = false;
                    element.removeAttribute(attr.name);
                }
                if (shouldUpdateAttribute){
                    element.setAttribute(attr.name, value);
                }
            });
            view.addCleanup(()=>{
                updatingEvaluation.destroy();
            });
        }
        this.addAttributeWriteBacks(element, scope);

        // Also kill all the children if we get killed
        view.addCleanup(()=>{
            view.childViews.forEach((childView)=>{
                childView.destroy();
            });
        });
        return view;
    }

    addAttributeWriteBacks(element, scope){
        // Check for special elements that can push data back to the concepts
        if (element.tagName==="INPUT" || element.tagName==="TEXTAREA"){
            let writeBack = this.getAttributeWriteBack(this.templateElement.getAttribute("value"), scope);
            if (writeBack!==null){
                element.addEventListener("input", ()=>{
                    writeBack.set(element.getAttribute("type")==="checkbox"?element.checked:element.value);
                });
            }
        } else if (element.tagName==="SELECT"){
            let writeBack = this.getAttributeWriteBack(this.templateElement.getAttribute("value"), scope);
            if (writeBack!==null){
                element.addEventListener("input", ()=>{
                    writeBack.set(element.value);
                });
            }
        } else if (element.tagName==="DIV" && element.getAttribute("contenteditable")!==null){
            let writeBack = this.getAttributeWriteBack(this.templateElement.getAttribute("value"), scope);
            if (writeBack!==null){
                let coalesceTimer = null;
                let needsAnotherUpdate = false;
                element.addEventListener("input", async ()=>{
                    needsAnotherUpdate = true;
                    if (!coalesceTimer){
                        coalesceTimer = setTimeout(async ()=>{
                            while (needsAnotherUpdate){
                                needsAnotherUpdate = false;
                                element.blockReadbacks = true; // Avoid reading our own changes back
                                await writeBack.set(element.innerHTML);
                                element.blockReadbacks = false;
                            }
                            coalesceTimer = null;
                        }, 100);
                    }
                });
            }
        }
    }


    /**
     * Some attributes, like input.value, can bind to simple writebacks "{someProperty}" that are looked up in scope.
     * @returns {binding} A binding if it exists in scope or null
     */
    getAttributeWriteBack(rawAttributeValue, scope){
        if (rawAttributeValue===undefined || rawAttributeValue===null) return null; // Not set
        if (!(rawAttributeValue.startsWith("{") && rawAttributeValue.endsWith("}"))) return null; // Not a dynamic binding at all

        let valueLookupName = rawAttributeValue.substring(1, rawAttributeValue.length - 1);
        let binding = DOMView.getBindingFromScope(valueLookupName,scope);
        if (!(binding instanceof ConceptInstanceBinding)){
            console.warn("DOMDiffView: Writeback attribute resolves to something that is not a writable property on a concept, assuming read-only", rawAttributeValue);
            return null;
        } else {
            return {
                set: async function attributeWriteBack(value){
                    await binding.setValueFor(valueLookupName, value);
                }
            };
        }
    }

}

window.ElementParseNode = ElementParseNode;

</SCRIPT><SCRIPT id="RootParseNode-script" type="disabled">
class RootParseNode extends ElementParseNode {
    render(){
        // Find the target document
        let targetFrameSpec = this.templateElement.getAttribute("target-iframe");
        let targetDocument;
        if (targetFrameSpec){
            let frame = document.querySelector(targetFrameSpec);
            if (!frame) throw new Error("DOMDiffView: dom-view-template with target-iframe that does not exist in document failed to render", targetFrameSpec, templateElement);
            targetDocument = frame.contentDocument;
        } else {
            targetDocument = document;
        }

        // Construct the view
        let scope = [new TemplateBinding(this.templateElement)];
        let view = this.getView(targetDocument, scope);

        // Find the target element
        let targetSpec = this.templateElement.getAttribute("target-element");
        if (targetFrameSpec){
            // Rendering to an iframe
            if (targetSpec){
                // This template uses a custom render target element, try to find it
                let targetElement = targetDocument.querySelector(targetSpec);
                if (targetElement){
                    view.mountInto(targetElement);
                } else {
                    console.error("DOMView: Rendering into nothingness since template target-element does not exist in target iframe: ", targetFrameSpec, targetSpec);
                }
            } else {
                // Just plain add it to body
                view.mountInto(targetDocument.body);
            }
        } else {
            // Rendering to the local document
            if (targetSpec){
                // This template uses a custom render target element, try to find it
                let targetElement = targetDocument.querySelector(targetSpec);
                if (targetElement){
                    view.mountInto(targetElement);
                } else {
                    console.error("DOMView: Rendering into nothingness since template target-element does not exist in document: ", targetSpec);
                }
            } else {
                // Default is to render just after the template element.
                // Special-case for CodeStrates-based templates (avoid getting deleted inside autoDOM)
                let autoDOM = this.templateElement.closest(".autoDom");
                if (autoDOM){
                    // Add after autoDOM instead of inside of it
                    if (!autoDOM.parentNode){
                        console.log("DOMView: Was rendering an autoDOM template but it had no parent", templateElement);
                    }
                    view.mountInto(autoDOM.parentNode,autoDOM.nextElementSibling);
                } else {
                    // Outside we just insert after the template directly
                    if (!this.templateElement.parentNode){
                        console.log("DOMView: Was rendering a non autoDOM template but it had no parent", templateElement);
                    }
                    view.mountInto(this.templateElement.parentNode, this.templateElement.nextElementSibling);
                }
            }
        }

        return view;
    }
};

window.RootParseNode = RootParseNode;

</SCRIPT><SCRIPT id="TemplateBinding-script" type="disabled">
class TemplateBinding {
    constructor(templateRootElement) {
        this.templateElement = templateRootElement;
    }

    getTemplateElement(){
        return this.templateElement;
    }

    hasBindingFor(name) {
        return false;
    }
}

window.TemplateBinding = TemplateBinding;

</SCRIPT><SCRIPT id="ValueBinding-script" type="disabled">
class ValueBinding {
    constructor(bindings) {
        this.bindings = bindings;
    }

    hasBindingFor(name) {
        return this.bindings.hasOwnProperty(name);
    }

    getValueFor(name) {
        return this.bindings[name];
    }
}

window.ValueBinding = ValueBinding;

</SCRIPT><SCRIPT id="RuntimeExceptionBinding-script" type="disabled">
class RuntimeExceptionBinding {
    constructor(errorMessage, ex) {
        this.errorMessage = errorMessage;
        this.ex = ex;
    }

    hasBindingFor(name) {
        return false;
    }

    getValueFor(name) {
        throw new Error("Unsupported operation");
    }
}

window.RuntimeExceptionBinding = RuntimeExceptionBinding;

</SCRIPT><SCRIPT id="PropertyBinding-script" type="disabled">
class PropertyBinding {
    constructor(property, uuid, boundValue, as=null) {
        this.uuid = uuid;
        this.property = property;
        this.boundValue = boundValue;
        this.as = as;
    }

    hasBindingFor(name){
        if (name===".value") return true;
        if (this.as){
            // We are available under as.value
            return name===this.as+".value";
        } else {
            return name===this.property.name+".value";
        }

        return false;
    }

    getValueFor(name){
        if (!this.hasBindingFor(name)) throw new Error("PropertyBinding asked for value for "+name+" but only supports "+this.property.name+".value/"+this.as+".value");
        return this.boundValue;
    }
}

window.PropertyBinding = PropertyBinding;

</SCRIPT><SCRIPT id="PropertyArrayEntryBinding-script" type="disabled">
class PropertyArrayEntryBinding extends PropertyBinding {
    constructor(property, uuid, boundValue, index, as=null) {
        super(property, uuid, boundValue, as);
        this.index = index;
        this._reIndexCount = 0;
        this._indexCallbacks = [];
    }

    hasBindingFor(name){
        // We don't supply this ourselves
        if (super.hasBindingFor(name)){
            return true;
        }

        if (name===".index") return true;
        if (name==="view::reused") return true;
        if (this.as){
            // We are available under as.value
            return name===this.as+".index";
        } else {
            return name===this.property.name+".index";
        }
    }

    getValueFor(name){
        if (!this.hasBindingFor(name)) throw new Error("PropertyArrayEntryBinding asked for value for "+name+" but does not support it");
        if (name==="view::reused") return this._reIndexCount;

        if (name.endsWith(".index")){
            return this.index;
        } else {
            return this.boundValue;
        }
    }

    updateIndex(newIndex){
        this._reIndexCount++;
        this.index = newIndex;
        this._indexCallbacks.forEach((callback)=>{
            try {
                callback();
            } catch (ex){
                console.log(ex);
            }
        });
    }

    addIndexCallback(callback) {
        this._indexCallbacks.push(callback);
    }

    removeIndexCallback(callback) {
        let index = this._indexCallbacks.indexOf(callback);
        if (index===-1){
            console.warn("Cannot remove indexcallback that isn't part of list of callbacks: "+callback+" list is "+this._indexCallbacks);
            return;
        }
        this._indexCallbacks.splice(index, 1);
    }

    generateRawChangeListener(name, oldValue=null){
        if (!this.hasBindingFor(name)) throw new Error("PropertyArrayEntryBinding asked for change listener for "+name+" but does not support it");
        let self = this;

        let result = {
            onChanged: async ()=>{console.error("DOMView bug: PropertyArrayEntryBinding raw change listener called without anything hooked up to it");},
            destroy: ()=>{}
        };
        let changedCallback = false;
        if (name==="view::reused"){
            changedCallback = async function indexChanged(){
                await result.onChanged(self._reIndexCount);
            };
        } else if (name.endsWith(".index")){
            changedCallback = async function indexChanged(){
                await result.onChanged(self.index);
            };
        }

        if (changedCallback){
            self.addIndexCallback(changedCallback);
            result.destroy = ()=>{
                self.removeIndexCallback(changedCallback);
            };
        }
        return result;
    }

    identicalExceptIndex(otherBinding){
        return this.property === otherBinding.property &&
                this.uuid === otherBinding.uuid &&
                this.boundValue === otherBinding.boundValue;
    }
}

window.PropertyArrayEntryBinding = PropertyArrayEntryBinding;

</SCRIPT><SCRIPT id="ConceptInstanceBinding-script" type="disabled">
class ConceptInstanceBinding {
    constructor(concept, uuid) {
        if (!uuid) throw new Error("Invalid reference to concept instance with a null or undefined uuid '"+uuid+"' and concept '"+concept+"'");
        if (!concept) throw new Error("Invalid reference to unknown concept with uuid '"+uuid+"', concept is "+concept);
        this.concept = concept;
        this.uuid = uuid;
    }

    hasBindingFor(name) {
        try {
            this.getProperty(name);
            return true;
        } catch (ex) {
            return false;
        }
    }

    getProperty(lookupName){
        if(lookupName.startsWith(this.concept.name+".")) {
            lookupName = lookupName.substring(this.concept.name.length+1);
        }
        return this.concept.getProperty(lookupName);
    }

    generateRawChangeListener(lookupName, initialValue=null){
        let self = this;
        let oldValue;
        if (Array.isArray(initialValue)){
            oldValue = initialValue.slice();
        } else {
            oldValue = initialValue;
        }

        let property = this.getProperty(lookupName);

        let result = {
            onChanged: async ()=>{console.error("DOMView bug: ConceptInstanceBinding raw change listener called without anything hooked up to it", self.concept, self.uuid, self);}
        };

        // Listen for changes in the looked up property
        let changedCallback = async function queryParseNodePropertyChanged(uuid, value){
            if (uuid===self.uuid){
                let identical = false;
                if (Array.isArray(value)){
                    identical = ScopedParseNode.fastDeepEqual(value, oldValue);
                } else {
                    identical = (oldValue===value);
                }

                if (!identical){
                    if (Array.isArray(value)){
                        oldValue = value.slice();
                    } else {
                        oldValue = value;
                    }
                    await result.onChanged(value);
                }
            }
        };
        property.addUpdatedCallback(changedCallback);
        result.destroy = ()=>{
            property.removeUpdatedCallback(changedCallback);
        };
        return result;
    }

    async getValueFor(name) {
        let property = null;
        try {
            property = this.getProperty(name);
        } catch(e) {
            //Ignore
        }

        if(property === null) {
            return undefined;
        }

        return await property.getValue(this.uuid);
    }

    async setValueFor(name, value){
        const property = this.concept.getProperty(name);
        await property.setValue(this.uuid, property.typeCast(value));
    }
}

window.ConceptInstanceBinding = ConceptInstanceBinding;

</SCRIPT><SCRIPT id="DOMView-script" type="disabled">
class DOMView {
    constructor(){
        this.renders = [];
    }

    render(suggestedDelay=10){
        clearTimeout(this.renderTimer);
        this.renderTimer = setTimeout(()=>{
            // Cleanup
            this.renders.forEach((view)=>{
                view.destroy();
            });

            // Render new views
            document.querySelectorAll("dom-view-template").forEach(async (template)=>{
                if (DOMView.DEBUG) console.log("Parsing",template);
                let root = new RootParseNode(template);
                if (DOMView.DEBUG) console.log("Rendering",template);
                this.renders.push(root.render());
                if (DOMView.DEBUG) console.log("Ready for use");
            });
        },suggestedDelay);
    }

    existsAsViewElement(viewName){
        return document.querySelector("dom-view-template [view='"+viewName+"']");
    }

    /**
     * Gets the most specific binding with a value for a name in the scope
     * @param {type} bindingName
     * @param {type} scope
     * @returns {undefined|DOMView.getBindingFromScope.scope}
     */
    static getBindingFromScope(bindingName, scope){
        for (let i = scope.length - 1; i >= 0; i--) {
            if (scope[i].hasBindingFor(bindingName)) {
                return scope[i];
            }
        }
        return undefined;
    }

    /**
     * Convenience method that evaluates a value in scope
     * @param {type} bindingName
     * @param {type} scope
     * @returns {undefined}
     */
    async evaluateValueInScope(bindingName, scope) {
        let binding = DOMView.getBindingFromScope(bindingName, scope);
        if (binding===undefined) return undefined;

        return await binding.getValueFor(bindingName);
    }

    /**
     * Gets an ordered list from the scope mapped by the mapper function given
     */
    getFilteredPath(viewElement, mapperFunction){
        let element = viewElement;
        while (element != null && !element.scope){
            element = element.parentElement;
            if (element==null){
                // No concepts in this tree path at all
                return [];
            }
        }

        let result = [];
        if(element != null && element.viewParticle != null) {
            for (let binding of element.viewParticle.scope) {
                let mappedValue = mapperFunction(binding);
                if (mappedValue) result.push(mappedValue);
            }
        }
        return result;
    }

    /**
     * Gets an ordered list of concepts instances involved in rendering this view element
     * @param {HTMLElement} viewElement
     * @returns {string[]}
     */
    getConceptPath(viewElement){
        return this.getFilteredPath(viewElement, (binding)=>{
            if (binding instanceof ConceptInstanceBinding) return binding;
        });
    }

    /**
     * Gets an ordered list of template elements involved in rendering this view element
     * @param {HTMLElement} viewElement
     * @returns {string[]}
     */
    getTemplatePath(viewElement){
        return this.getFilteredPath(viewElement, (binding)=>{
            if (binding instanceof TemplateBinding) return binding.templateElement;
        });
    }

    /**
     * Gets an ordered list of properties involved in rendering this view element
     * @param {HTMLElement} viewElement
     * @returns {string[]}
     */
    getPropertyPath(viewElement){
        return this.getFilteredPath(viewElement, (binding)=>{
            if (binding instanceof PropertyBinding) return {uuid: binding.uuid, property: binding.property};
        });
    }
}

DOMView.DEBUG = false;
DOMView.DEBUG_PERFORMANCE = false;
DOMView.singleton = new DOMView();
window.DOMView = DOMView;


//If fragments exists postpone the DOMView until all fragments was loaded at least first time. (Fragments added later obviously does not count)
if(typeof Fragment !== "undefined") {
    Fragment.addAllFragmentsLoadedCallback(()=>{
        // We started after autoDOM has run, so no mutations. Bootstrap with what we have
        console.log("DOMDiffView: Full re-render due to initial page load via Codestrates");
        DOMView.singleton.render();

        // STUB: Reload when templates change
        let observer = new MutationObserver((mutations) => {
            let reload = function reloadDueToMutations(){
                console.log("STUB: DOMDiffView: Full re-render due to templates changing");
                DOMView.singleton.render(300);
            };
            for(let mutation of mutations) {
                // From inside a template
                if (
                       (mutation.target.matches && mutation.target.matches("dom-view-template"))
                    || (mutation.target.closest && mutation.target.closest("dom-view-template"))
                    || (mutation.target.parentElement && mutation.target.parentElement.closest("dom-view-template"))){
                    reload();
                    break;
                }

                // From outside a template
                if (mutation.type==="childList"){
                    for (let node of [...mutation.addedNodes, ...mutation.removedNodes]){
                        if (node.tagName === "DOM-VIEW-TEMPLATE" || (node.querySelector && node.querySelector("dom-view-template"))){
                            reload();
                            break;
                        }
                    }
                }
            };
        });
        observer.observe(document.body, {
            attributes: true,
            attributeOldValue: false,
            childList: true,
            subtree: true,
            characterData: true,
            characterDataOldValue: false
        });

        VarvEngine.registerEventCallback("engineReloaded", (evt) => {
            console.log("DOMDiffView: Full re-render due to engine reload");
            DOMView.singleton.render();
        });
    });
} else {
    VarvEngine.registerEventCallback("engineReloaded", (evt) => {
        console.log("DOMDiffView: Full re-render due to engine reload");
        DOMView.singleton.render();
    });
}

</SCRIPT><STYLE id="domview-style">
dom-view-template {
  display: none; }

varv-view {
  display: contents; }
  varv-view varv-failure:before {
    content: "?";
    width: 1em;
    height: 1em;
    display: flex;
    justify-content: center;
    align-items: center;
    background: red;
    cursor: pointer; }
  varv-view [varv-domview-highlight] {
    filter: invert(15%) drop-shadow(0 0 0.25em #6496ff); }

.hide-varv-errors varv-failure {
  display: none; }
</STYLE></WPM-PACKAGE><WPM-PACKAGE data-repository="varv-repos" id="varv-location" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Varv URL Data Store",
    "description": "Access properties of the URL as concept data",
    "dependencies": [
        "#varv-engine"
    ],
    "assets": [],
    "license": "MIT",
    "version": "0.1",
    "changelog": {}
}

</SCRIPT><SCRIPT id="LocationDataStore-script" type="disabled">
/**
 *  LocationDataStore - access/control the URL in browsers
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * A datastore that uses the location, query and hash as storage
 * @memberOf Datastores
 */
class LocationDataStore extends DirectDatastore {
    constructor(name, options = {}) {
        super(name, options);

        this.deleteCallbacks = [];
    }

    isShared() {
        return false;
    }

    destroy() {
        this.deleteCallbacks.forEach((deleteCallback)=>{
            deleteCallback.delete();
        })
    }

    async init() {
        const self = this;

        this.storageName = "memory";

        this.deleteCallbacks.push(VarvEngine.registerEventCallback("disappeared", async (context)=> {
            if(LocationDataStore.DEBUG) {
                console.log("Saw disappeared UUID (LocationDataStore):", context.target);
            }
            // Do nothing?
        }));
        this.deleteCallbacks.push(VarvEngine.registerEventCallback("appeared", async (context)=> {
            if(LocationDataStore.DEBUG) {
                console.log("Saw appeared UUID (LocationDataStore):", context.target);
            }
            let mark = VarvPerformance.start();
            // Do nothing? Maybe call them like onload?
            VarvPerformance.stop("LocationDataStore.registerEventCallback.appeared", mark);
        }));

        window.addEventListener("hashchange", function locationHashChanged(){
            self.onHashChange();
        });
    }

    createBackingStore(concept, property) {
        const self = this;
        if (this.isPropertyMapped(concept,property)) return;

        let setter = (uuid, value) => {
            let mark = VarvPerformance.start();

            if (property.name==="locationHash"){
                if (decodeURIComponent(location.hash.substring(1))!==value){
                    location.hash = value;
                }
            } else {
                // This is a parameter/location change if it differs from current
                let urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has(property.name)){
                    if (urlParams.get(property.name)!=value){
                        if (LocationDataStore.DEBUG) console.info("FIXME: Location datastore only supports getting, not setting URL paramters so far");
                    }
                }
                return;
            }

            VarvPerformance.stop("LocationDataStore.setter", mark);
        };
        let getter = (uuid) => {
            let mark = VarvPerformance.start();
            if (property.name==="locationHash"){
                let result = decodeURIComponent(location.hash.substring(1));
                if (result === "") throw new Exception("Cannot get empty locationHash");
                VarvPerformance.stop("LocationDataStore.getter.hash", mark);
                return result;
            } else {
                let urlParams = new URLSearchParams(window.location.search);
                if (!urlParams.has(property.name)) throw new Exception("Cannot get property not present in URL");
                VarvPerformance.stop("LocationDataStore.getter.argument", mark);
                return urlParams.get(property.name);
            }
        };
        property.addSetCallback(setter);
        property.addGetCallback(getter);

        // Check if concept already is mapped, if not, register it
        this.internalAddPropertyMapping(concept, property, {setter: setter, getter: getter});
    }

    removeBackingStore(concept, property) {
        if (!this.isPropertyMapped(concept, property)){
            throw new Error('Cannot unmap property from memory because the property was not mapped: ' + concept + "." + property);
        }

        let trackingData = this.internalPropertyTrackingData(concept, property);
        property.removeSetCallback(trackingData.setter);
        property.removeGetCallback(trackingData.getter);

        this.internalRemovePropertyMapping(concept, property);
    }

    async onHashChange(){
        if (LocationDataStore.DEBUG) console.log("Location hash changed", location.hash);
        // For each of our mapped concepts
        for (let [conceptName, properties] of this.mappedConcepts.entries()){
            if (properties.has("locationHash")){
                let concept = VarvEngine.getConceptFromType(conceptName);
                let property = concept.getProperty("locationHash");
                let value = decodeURIComponent(location.hash.substring(1));

                if (LocationDataStore.DEBUG) console.log("Firing location hash property set", property, value);
                let uuids = await VarvEngine.getAllUUIDsFromType(concept.name, true);
                uuids.forEach(async uuid=>{
                    await property.setValue(uuid, value);
                });
            }
        };
    }

    async loadBackingStore() {
        const self = this;

        if (LocationDataStore.DEBUG) console.info("LocationDataStore location is "+location);

        setTimeout(async function onLoadLocationTriggers(){
            if (location.hash){
                await self.onHashChange();
            }

            // On-load set the URL parameters too
            for (let [name,value] of new URLSearchParams(window.location.search).entries()){
                for (let [conceptName, properties] of self.mappedConcepts.entries()){
                    if (properties.has(name)){
                        let concept = VarvEngine.getConceptFromType(conceptName);
                        let property = concept.getProperty(name);

                        if (LocationDataStore.DEBUG) console.log("Firing URL parameter property set", conceptName, concept, property, value);
                        let uuids = await VarvEngine.getAllUUIDsFromType(conceptName, false); // nulllointer if true?
                        uuids.forEach(async uuid=>{
                            await property.setValue(uuid, value);
                        });
                    }
                };
            }

            self.hasLoaded = true;
        },0);
    }
}
LocationDataStore.DEBUG = false;
window.LocationDataStore = LocationDataStore;

// Register default dom datastore
Datastore.registerDatastoreType("location", LocationDataStore);

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="varv-repos" id="varv-memory" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Varv Memory Data Store",
    "description": "Allow data to be stored in memory",
    "dependencies": [
        "#varv-engine"
    ],
    "assets": [],
    "license": "MIT",
    "version": "0.1",
    "changelog": {}
}

</SCRIPT><SCRIPT id="MemoryDataStore-script" type="disabled">
/**
 *  MemoryDataStore - stores properties temporarily in memory
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 * @memberOf Datastores
 */
class MemoryDataStore extends DirectDatastore {
    constructor(name, options = {}) {
        super(name, options);

        this.deleteCallbacks = [];
    }

    isShared() {
        return false;
    }

    destroy() {
        this.deleteCallbacks.forEach((deleteCallback)=>{
            deleteCallback.delete();
        })
    }

    async init() {
        const self = this;
        this.typeVariable = "__memoryDataStore_internalType";

        this.storageName = "memory";
        if (this.options.storageName) this.storageName = this.options.storageName;

        this.deleteCallbacks.push(VarvEngine.registerEventCallback("disappeared", async (context)=> {
            if(MemoryDataStore.DEBUG) {
                console.log("Saw disappeared UUID (MemoryDataStore):", context.target);
            }

            context.concept.properties.forEach((property) => {
                if (self.isPropertyMapped(context.concept, property)) {
                    let data = self.internalPropertyTrackingData(context.concept, property);
                    delete data[context.target];
                }
            });
            self.getStorage().delete(context.target);
        }));
        this.deleteCallbacks.push(VarvEngine.registerEventCallback("appeared", async (context)=> {
            if(MemoryDataStore.DEBUG) {
                console.log("Saw appeared UUID (MemoryDataStore):", context.target);
            }
            let mark = VarvPerformance.start();
            if (self.isConceptMapped(context.concept) && !self.getStorage().has(context.target)){
                self.getStorage().set(context.target, {
                    [self.typeVariable]: context.concept.name
                });
            }
            VarvPerformance.stop("MemoryDataStore.registerEventCallback.appeared", mark);
        }));
    }

    getStorage(){
        if (!MemoryDataStore.storages[this.storageName]){
            MemoryDataStore.storages[this.storageName] = new Map();
        }
        return MemoryDataStore.storages[this.storageName];
    }

    createBackingStore(concept, property) {
        const self = this;

        if (this.isPropertyMapped(concept,property)) return;

        let setter = (uuid, value) => {
            let mark = VarvPerformance.start();
            if (!self.getStorage().has(uuid)){
                throw new Error("Tried to set concept in memory that never appeared: "+concept.name+"."+property.name);
            }

            let data = self.getStorage().get(uuid);
            data[property.name] = value;
            VarvPerformance.stop("MemoryDataStore.setter", mark);
        };
        let getter = (uuid) => {
            let mark = VarvPerformance.start();
            let data = self.getStorage().get(uuid);
            if (!data) throw new Error("Tried to get concept from memory that was never set: "+concept.name+"."+property.name);
            if (!data.hasOwnProperty(property.name)) throw new Error("Tried to get property from memory that was never set: "+concept.name+"."+property.name);
            let result = data[property.name];
            VarvPerformance.stop("MemoryDataStore.getter", mark);
            return result;
        };
        property.addSetCallback(setter);
        property.addGetCallback(getter);

        // Check if concept already is mapped, if not, register it
        this.internalAddPropertyMapping(concept, property, {setter: setter, getter: getter});
    }

    removeBackingStore(concept, property) {
        if (!this.isPropertyMapped(concept, property)){
            throw new Error('Cannot unmap property from memory because the property was not mapped: ' + concept + "." + property);
        }

        let trackingData = this.internalPropertyTrackingData(concept, property);
        property.removeSetCallback(trackingData.setter);
        property.removeGetCallback(trackingData.getter);

        this.internalRemovePropertyMapping(concept, property);
    }

    async loadBackingStore() {
        // For each of our stored and mapped concepts
        for(let [uuid,storedConcept] of this.getStorage().entries()) {
            if (MemoryDataStore.DEBUG) console.log("Loading from memory",uuid,storedConcept);

            let type = storedConcept[this.typeVariable];
            if ((!type) || !this.isConceptTypeMapped(type)){
                if (MemoryDataStore.DEBUG) console.log("Ignoring concept from memory since it is not mapped", storedConcept);
                continue;
            }

            // Check if already registered and only generate an appear event if not
            let conceptByUUID = await VarvEngine.getConceptFromUUID(uuid);
            let concept = VarvEngine.getConceptFromType(type);

            this.registerConceptFromUUID(uuid, concept);

            // Stil set the properties that we know about
            for (const [propertyName,value] of Object.entries(storedConcept)){
                if (propertyName !== this.typeVariable){
                    try {
                        let property = concept.getProperty(propertyName);
                        if (MemoryDataStore.DEBUG) console.log("Loading property", property, value);
                        if (this.isPropertyMapped(concept, property)){
                            await property.setValue(uuid, value);
                        }
                    } catch (ex){
                        console.error("Failed to push concept property from memory to concept", ex);
                    }
                }
            }

            if (!conceptByUUID) {
                await concept.appeared(uuid);
            }
        }
    }
}
MemoryDataStore.DEBUG = false;
window.MemoryDataStore = MemoryDataStore;
MemoryDataStore.storages = new Map();

// Register default dom datastore
Datastore.registerDatastoreType("memory", MemoryDataStore);

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="varv-repos" id="varv-localstorage" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Varv localStorage Datastore",
    "description": "Store data in the browsers's local storage database",
    "dependencies": [
        "#varv-engine"
    ],
    "assets": [],
    "license": "MIT",
    "version": "0.1",
    "changelog": {}
}

</SCRIPT><SCRIPT id="LocalStorageDataStore-script" type="disabled">
/**
 *  LocalStorageDataStore - serializes into the localStorage database
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */


/**
 * A storage that serializes into the localStorage database
 * <pre>
 * options:
 * storageName - The name of the prefix to store that data below (Default: "varv-data")
 * </pre>
 *
 * @memberOf Datastores
 */

class LocalStorageDataStore extends DirectDatastore {
    constructor(name, options = {}) {
        super(name, options);
        if (typeof webstrate !== "undefined"){
            this.storagePrefix = webstrate.webstrateId+"-datastore";
        } else if (location.protocol !== "file:"){
            this.storagePrefix = location.pathname+"-datastore";
        } else {
            this.storagePrefix = "varv-data";
        }
        this.entities = {};

        if (this.options.storageName) this.storagePrefix = this.options.storageName;

        this.deleteCallbacks = [];
    }

    isShared() {
        return false;
    }

    async init(){
        const self = this;

        if (!localStorage) throw new Error("Cannot use localStorage as the feature is not available on this js runtime platform");

        if (!localStorage.getItem(this.storagePrefix)) self.saveEntities();

        this.deleteCallbacks.push(VarvEngine.registerEventCallback("disappeared", async (context)=> {
            if(LocalStorageDataStore.DEBUG) {
                console.log("Saw disappeared UUID (LocalStorageDataStore):", context.target);
            }

            if (!self.entities[context.target]) return; // avoid loops when we caused the disappear event ourselves

            context.concept.properties.forEach((property) => {
                if (self.isPropertyMapped(context.concept, property)) {
                    localStorage.removeItem(self.storagePrefix + "-" + context.target + "-" + property.name);
                }
            });
            delete self.entities[context.target];
            self.saveEntities();
        }));
        this.deleteCallbacks.push(VarvEngine.registerEventCallback("appeared", async (context)=> {
            if(LocalStorageDataStore.DEBUG) {
                console.log("Saw appeared UUID (LocalStorageDataStore):", context.target);
            }

            let mark = VarvPerformance.start();
            if (self.entities[context.target]) return; // avoid loops when we caused the appear event ourselves

            if (self.isConceptMapped(context.concept)) {
                self.entities[context.target] = context.concept.name;
                self.saveEntities();
            }
            VarvPerformance.stop("LocalStorageDataStore.registerEventCallback.appeared", mark);
        }));

        this.storageEventListener = async function localStorageChangeUpdate(event){
            if (event.key===self.storagePrefix){
                // This is a change in the active entities, pull any new ones
                let storedEntities = JSON.parse(event.newValue);
                for (const [uuid,type] of Object.entries(storedEntities)){
                    if (!self.entities[uuid]){
                        // TODO: check mapped type?
                        self.entities[uuid] = type;
                        await self.pullConcept(uuid);
                    }
                }

                // and kill any that are gone
                for (const [uuid,type] of Object.entries(self.entities)){
                    if (!storedEntities[uuid]){
                        delete self.entities[uuid]; // delete our tracker BEFORE sending disappear event to avoid loops
                        await VarvEngine.getConceptFromType(type).disappeared(uuid);
                    }
                };
            } else if (event.key.startsWith(self.storagePrefix+"-")){
                // This could be a property change event if the key matches a property
                let matches = new RegExp("^([^-]+)\-(.+?)$").exec(event.key.substring(self.storagePrefix.length+1));
                if (matches.length===3){
                    if (event.newValue===null) return; // TODO: The property was removed, is there any way to handle this properly?

                    let uuid = matches[1];
                    let propertyName = matches[2];

                    let concept = self.getConceptFromUUID(uuid);
                    if (!concept){
                        console.log("Localstorage got property update from concept with UUID that does not exist locally", uuid);
                        return;
                    }
                    let property = concept.getProperty(propertyName);
                    if (!property){
                        console.log("Localstorage got property update from concept property that does not exist locally", concept, propertyName);
                        return;
                    }
                    await property.setValue(uuid, JSON.parse(event.newValue));
                }
            }
        };

        window.addEventListener("storage", this.storageEventListener);
    }

    destroy() {
        this.deleteCallbacks.forEach((deleteCallback)=>{
            deleteCallback.delete();
        });

        window.removeEventListener("storage", this.storageEventListener);
    }

    saveEntities(){
        localStorage.setItem(this.storagePrefix, JSON.stringify(this.entities));
    }

    createBackingStore(concept, property) {
        const self = this;

        if (this.isPropertyMapped(concept,property)) {
            console.log("FIXME: Trying to create localStorage backing store for already mapped property, ignored", concept, property);
            return;
        }

        let setter = (uuid, value) => {
            let mark = VarvPerformance.start();
            if (!self.entities[uuid]){
                throw new Error("Tried to set concept property in localStorage for concept instance that never appeared: "+concept.name+"."+property.name);
            }

            localStorage.setItem(self.storagePrefix+"-"+uuid+"-"+property.name, JSON.stringify(value));
            VarvPerformance.stop("LocalStorageDataStore.setter", mark);
        };
        let getter = (uuid) => {
            let mark = VarvPerformance.start();
            if (!self.entities[uuid]){
                throw new Error("Tried to get concept property from localStorage for concept instance that was never seen: "+concept.name+"."+property.name);
            }

            let data = localStorage.getItem(self.storagePrefix+"-"+uuid+"-"+property.name);
            if (data===null){
                throw new Error("Tried to get concept property from localStorage that was never set: "+concept.name+"."+property.name);
            }
            let result =  JSON.parse(data);
            VarvPerformance.stop("LocalStorageDataStore.getter", mark);
            return result;
        };
        property.addSetCallback(setter);
        property.addGetCallback(getter);

        // Check if concept already is mapped, if not, register it
        this.internalAddPropertyMapping(concept, property, {setter: setter, getter: getter});
    }

    removeBackingStore(concept, property) {
        if (!this.isPropertyMapped(concept, property)){
            throw new Error('Cannot unmap property from localStorage because the property was not mapped: ' + concept + "." + property);
        }

        let trackingData = this.internalPropertyTrackingData(concept, property);
        property.removeSetCallback(trackingData.setter);
        property.removeGetCallback(trackingData.getter);

        this.internalRemovePropertyMapping(concept, property);
    }

    /**
     * Loads all concept instances currently registered as backed from serialized state
     *
     * @returns {undefined}
     */
    async loadBackingStore() {
        let self = this;
        this.entities = JSON.parse(localStorage.getItem(this.storagePrefix));

        for (const [uuid,type] of Object.entries(this.entities)){
            await self.pullConcept(uuid);
        }
    }

    async pullConcept(uuid){
        let self = this;

        let conceptType = this.entities[uuid];
        if (!conceptType){
            throw new Error("Tried to pull a concept from localStorage that wasn't a known entity in there");
        }

        const concept = VarvEngine.getConceptFromType(conceptType);
        if (!concept) {
            if (LocalStorageDataStore.DEBUG) console.log("LocalStorage: Ignoring unknown concept with type", type);
            return;
        }

        if (!self.isConceptMapped(concept)){
            if (LocalStorageDataStore.DEBUG) console.log("LocalStorage: Ignoring concept with type that isn't mapped to localStorage", type);
            return;
        }

        let conceptByUUID = await VarvEngine.getConceptFromUUID(uuid);
        this.registerConceptFromUUID(uuid, concept);

        // Pull all properties
        for (const property of concept.properties){
            if (self.isPropertyMapped(concept, property)){
                try {
                    let value = localStorage.getItem(self.storagePrefix+"-"+uuid+"-"+property.name);
                    if (value!==null){
                        await property.setValue(uuid, JSON.parse(value));
                    }
                } catch (ex){
                    // Ignore
                }
            }
        };

        if (!conceptByUUID) {
            await concept.appeared(uuid);
        }
    }
}
LocalStorageDataStore.DEBUG = false;
window.LocalStorageDataStore = LocalStorageDataStore;

//Register default dom datastore
Datastore.registerDatastoreType("localStorage", LocalStorageDataStore);

</SCRIPT></WPM-PACKAGE><WPM-PACKAGE data-repository="varv-repos" id="varv-cauldron" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Varv Cauldron Datastore",
    "description": "A datastore that allows mapping parts of concepts so that they show up in the Cauldron TreeBrowser and can be inspected with the inspector",
    "dependencies": [
        "#varv-engine",
        "cauldron-repos #Cauldron"
    ],
    "assets": [],
    "license": "MIT",
    "version": "0.1",
    "changelog": {}
}

</SCRIPT><SCRIPT id="ConceptTreeGenerator-script" type="disabled">
/**
 *  ConceptDecorator - decorates Concept nodes in TreeBrowser trees
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 *
 */
class ConceptTreeGenerator extends TreeGenerator {
    constructor(parentNode) {
        super();

        this.rootNode = new TreeNode({
            type: "ConceptRootNode",
            context: null
        });
        TreeGenerator.decorateNode(this.rootNode);
        parentNode.addNode(this.rootNode);
    }

    onAddDatastore(datastore){
        let activeElement = document.activeElement;

        let self = this;
        let datastoreNode = new TreeNode({
            type: "DatastoreNode",
            lookupKey: datastore.name,
            context: datastore
        });
        TreeGenerator.decorateNode(datastoreNode);
        this.rootNode.addNode(datastoreNode);
        this.rootNode.unfold();

        datastore.registerDestroyCallback(()=>{
            self.destroyNode(datastoreNode);
        });

        // Concepts
        datastore.registerConceptAddedCallback((concept)=>{
            datastoreNode.unfold();

            let conceptNode = new TreeNode({
                type: "ConceptNode",
                lookupKey: concept.name,
                context: concept
            });

            // Instances
            let instanceAddedCallback = datastore.registerConceptInstanceAddedCallback(concept, (uuid)=>{
                let node = self.addInstanceNode(datastore, conceptNode, concept, uuid);
                let instanceRemovedCallback = datastore.registerConceptInstanceRemovedCallback(concept, (removedUUID)=>{
                    if (removedUUID===uuid){
                        self.destroyNode(node);
                    }
                });
                node.cleanup = [()=>{
                    datastore.removeConceptInstanceRemovedCallback(concept, instanceRemovedCallback);
                }];
            });

            TreeGenerator.decorateNode(conceptNode);
            datastoreNode.addNode(conceptNode);
        });

        // STUB: Concepts cannot be removed right now but should be cleaned up here
        // datastore.removeConceptInstanceAddedCallback(concept, instanceAddedCallback);

    }

    destroyNode(node){
        node.parentNode.removeNode(node);

        // Run cleanup
        if (node.cleanup){
            for (let entry of node.cleanup){
                entry();
            }
        }

        // Destroy children
        for (let child of Array.from(node.childNodes)){ // copy to avoid concurrent mods
            this.destroyNode(child);
        }
    }

    addInstanceNode(datastore, parentNode, concept, uuid){
        let instanceNode = new TreeNode({
            type: "ConceptInstanceNode",
            lookupKey: uuid,
            context: {concept, uuid, datastore}
        });
        TreeGenerator.decorateNode(instanceNode);
        parentNode.addNode(instanceNode);
        return instanceNode;
    }
}


EventSystem.registerEventCallback("Cauldron.TreeBrowserSpawned", ({detail: {root: rootNode}})=>{
    let generator = new ConceptTreeGenerator(rootNode);
    EventSystem.triggerEvent("Varv.ConceptTreeGeneratorSpawned", generator);
    window.ConceptTreeGenerator.instances.push(generator);
});

window.ConceptTreeGenerator = ConceptTreeGenerator;
window.ConceptTreeGenerator.instances = [];

</SCRIPT><SCRIPT id="CauldronDatastore-script" type="disabled">
/**
 *  CauldronDatastore
 *     A datastore that allows mapping parts of concepts so that they show up in
 *     the Cauldron TreeBrowser and are inspectable with the inspector
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 *
 */
class CauldronDatastore extends DirectDatastore {
    constructor(name, options = {}) {
        super(name, options);
        let self = this;

        this.destroyCallbacks = [];
        this.conceptAddedCallbacks = [];
        this.instanceAddedCallbacks = new Map();
        this.instanceRemovedCallbacks = new Map();

        this.appearCallback = VarvEngine.registerEventCallback("appeared", async (context)=> {
            let mark = VarvPerformance.start();
            if (self.isConceptMapped(context.concept)){
                let callbacks = self.instanceAddedCallbacks.get(context.concept.name);
                if (callbacks){
                    for (let callback of callbacks){
                        callback(context.target);
                    }
                }
            }
            VarvPerformance.stop("CauldronDatastore.registerEventCallback.appeared", mark);
        });
        this.disappearCallback = VarvEngine.registerEventCallback("disappeared", async (context)=> {
            if (self.isConceptMapped(context.concept)){
                let callbacks = self.instanceRemovedCallbacks.get(context.concept.name);
                if (callbacks){
                    for (let callback of callbacks){
                        callback(context.target);
                    }
                }
            }
        });
    }

    isShared() {
        return false;
    }

    destroy() {
        this.appearCallback.delete();
        this.disappearCallback.delete();
        this.engineReloadedCallback.delete();
        for (let callback of this.destroyCallbacks){
            callback(this);
        }
    }

    registerDestroyCallback(callback){
        this.destroyCallbacks.push(callback);
        return callback;
    }

    async init() {
        let self = this;

        this.engineReloadedCallback = VarvEngine.registerEventCallback("engineReloaded", ()=>{
            console.log("Engine reloaded, register on trees!");
            // Inform trees about us
            for (let tree of window.ConceptTreeGenerator.instances){
                tree.onAddDatastore(this);
            }

            // Listen for new ones
            EventSystem.registerEventCallback("Varv.ConceptTreeGeneratorSpawned", (evt)=>{
                evt.detail.onAddDatastore(self);
            });
        });
    }

    registerConceptAddedCallback(callback){
        this.conceptAddedCallbacks.push(callback);

        // Pre-feed with currently mapped
        for (const conceptName of this.mappedConcepts.keys()){
            callback(VarvEngine.getConceptFromType(conceptName));
        }

        return callback;
    }

    async registerConceptInstanceAddedCallback(concept, callback){
        if (!this.instanceAddedCallbacks.has(concept.name)){
            this.instanceAddedCallbacks.set(concept.name, []);
        }

        let callbacks = this.instanceAddedCallbacks.get(concept.name);
        callbacks.push(callback);

        // Pre-feed with currently mapped
        for (const conceptUUID of await VarvEngine.getAllUUIDsFromType(concept.name)){
            callback(conceptUUID);
        }

        return callback;
    }

    removeConceptInstanceAddedCallback(concept, callback){
        let callbacks = this.instanceAddedCallbacks.get(concept.name);
        if (!callbacks) {
            console.log("Cauldron: Tried to remove a concept callback but couldn't", concept.name, callback);
            return;
        };
        this.instanceAddedCallbacks.set(concept.name, callbacks.filter(e => e !== callback));
    }

    registerConceptInstanceRemovedCallback(concept, callback){
        if (!this.instanceRemovedCallbacks.has(concept.name)){
            this.instanceRemovedCallbacks.set(concept.name, []);
        }

        let callbacks = this.instanceRemovedCallbacks.get(concept.name);
        callbacks.push(callback);

        return callback;
    }

    removeConceptInstanceRemovedCallback(concept, callback){
        let callbacks = this.instanceRemovedCallbacks.get(concept.name);
        if (!callbacks) {
            console.log("Cauldron: Tried to remove a concept removed callback but couldn't", concept.name, callback);
            return;
        };
        this.instanceRemovedCallbacks.set(concept.name, callbacks.filter(e => e !== callback));
    }

    createBackingStore(concept, property) {
        const self = this;

        if (this.isPropertyMapped(concept,property)){
            console.log("Already mapped property");
            return;
        }

        if (!this.isConceptMapped(concept)){
            // Concept add update
            if(CauldronDatastore.DEBUG) {
                console.log("New concept", concept);
            }
            for (let callback of self.conceptAddedCallbacks){
                callback(concept);
            }
        }

        // Check if concept already is mapped, if not, register it
        this.internalAddPropertyMapping(concept, property, {});
    }

    removeBackingStore(concept, property) {
        if (!this.isPropertyMapped(concept, property))
            throw 'Cannot unmap property from memory because the property was not mapped: ' + concept + "." + property;

        // TODO: Remove concept update

        this.internalRemovePropertyMapping(concept, property);
    }

    loadBackingStore() {
        // No storage, do nothing
    }
}

window.CauldronDatastore = CauldronDatastore;

// Register default cauldron datastore
Datastore.registerDatastoreType("cauldron", CauldronDatastore);

</SCRIPT><SCRIPT id="InspectorConceptBinding-script" type="disabled">
/**
 *  InspectorConceptBinding - Allow inspection of Concepts in the inspector
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 *
 */
class InspectorConceptBinding {
    /**
     * Inspects the given TreeNode and if supported, returns a map of editable attributes
     * @param {TreeNode} treeNode
     * @returns {Cauldron.InspectorElement[]}
     */
    static inspect(treeNode) {
        let elements = [];
        let concept = null;
        let datastore = null;

        switch (treeNode.type){
            case "ConceptInstanceNode":
                concept = treeNode.context.concept;
                datastore = treeNode.context.datastore;

                let propertyEditors = new Cauldron.InspectorSegment("Properties", elements);
                elements.push(propertyEditors);
                for (const property of concept.properties.values()){
                    if (datastore.isPropertyMapped(concept, property) || property.isDerived()){
                        propertyEditors.push(new Cauldron.InspectorPropertyEditor(treeNode.context, property, treeNode.getTreeBrowser()));
                    }
                }

                return elements;
                break;
            case "ConceptNode":
                concept = treeNode.context;

                if (concept.properties.size>0){
                    let propertiesView = new Cauldron.InspectorSegment("Properties", elements);
                    elements.push(propertiesView);
                    for (const property of concept.properties.values()){
                        propertiesView.push(new Cauldron.InspectorPropertyView(treeNode.context, property, treeNode.getTreeBrowser()));
                    }
                }

                if (concept.behaviours.size>0){
                    let actionsView = new Cauldron.InspectorSegment("Actions", elements);
                    elements.push(actionsView);
                    for (const behaviour of concept.behaviours.values()){
                        actionsView.push(new Cauldron.InspectorBehaviourView(treeNode.context, behaviour, treeNode.getTreeBrowser()));
                    }
                }

                return elements;
                break;
            default:
                return null;
        }
    }
}
window.Cauldron.InspectorConceptBinding = InspectorConceptBinding;
Cauldron.CauldronInspector.registerContentBinding(InspectorConceptBinding, 10);

class InspectorBehaviourView extends Cauldron.InspectorElement {
    constructor(concept, behaviour, treeBrowser) {
        super();

        let label = document.createElement("span");
        label.classList.add("cauldron-inspector-element-label");
        label.textContent = behaviour.name;

        let triggersCausingView = document.createElement("span");
        triggersCausingView.classList.add("cauldron-inspector-element-field");
        let triggerList = "";
        for (let triggerName of behaviour.triggers.values()){
            let trigger = concept.getTrigger(triggerName);
            let triggerNameReal = "'"+triggerName+"'";
            try {
                triggerNameReal = trigger.constructor.name;
            } catch (ex){}
            triggerList += "@"+triggerNameReal+" ";
        }
        triggersCausingView.textContent = triggerList;

        // TODO: Jump to code link here

        this.html.appendChild(label);
        this.html.appendChild(triggersCausingView);
    }
}
window.Cauldron.InspectorBehaviourView = InspectorBehaviourView;

class InspectorPropertyView extends Cauldron.InspectorElement {
    constructor(concept, property, treeBrowser) {
        super();

        let label = document.createElement("span");
        label.classList.add("cauldron-inspector-element-label");
        label.textContent = property.name;

        let theType = document.createElement("span");
        theType.classList.add("cauldron-inspector-element-field");
        theType.textContent = property.type + (property.isDerived()?" (derived)":"");

        this.html.appendChild(label);
        this.html.appendChild(theType);
    }
}
window.Cauldron.InspectorPropertyView = InspectorPropertyView;



class InspectorPropertyEditor extends Cauldron.InspectorElement {
    /**
     *
     * @param {Element} domElement
     * @param {String} attrName
     * @param {String} overrideLabel
     */
    constructor(conceptInstance, property, browser) {
        super();
        this.browser = browser;

        let self = this;

        this.conceptInstance = conceptInstance;
        this.property = property;

        if(property.isDerived()) {
            this.readOnly = true;
        }

        if (property.type==="array"){
            this.editor = document.createElement("div");
        } else if (property.type==="boolean"){
            this.editor = document.createElement("input");
            this.editor.setAttribute("type", "checkbox");
        } else if (property.type==="number"){
            this.editor = document.createElement("input");
            this.editor.setAttribute("type", "number");
            this.editor.setAttribute("step", "1");
        } else {
            this.editor = document.createElement("input");
            this.editor.setAttribute("contenteditable", "true");
            this.editor.setAttribute("spellcheck", "false");
        }
        this.editor.classList.add("cauldron-inspector-element-editor");

        if(this.readOnly) {
            this.editor.setAttribute("disabled", true);
        }

        this.label = document.createElement("span");
        this.label.classList.add("cauldron-inspector-element-label");
        this.label.textContent = property.name;

        this.html.append(this.label);

        this.editorContainer = document.createElement("div");
        this.editorContainer.appendChild(this.editor);
        this.editorContainer.classList.add("cauldron-inspector-element-editor-container");
        this.editorContainer.classList.add("cauldron-inspector-element-field");

        this.html.appendChild(this.editorContainer);

        this.html.classList.add("inspector-property");

        this.html.addEventListener("click", ()=>{
            EventSystem.triggerEventAsync("Varv.DOMView.HighlightProperty", property);
        });

        if(this.property.isConceptType()) {
            this.autocompleteDiv = document.createElement("div");
            this.autocompleteDiv.classList.add("cauldron-inspector-element-autocomplete");
            this.autocompleteDiv.classList.add("hidden");
            this.editorContainer.appendChild(this.autocompleteDiv);

            if(!this.readOnly) {
                this.editor.addEventListener("focus", () => {
                    self.autoComplete(self.editor.value);
                });
                document.addEventListener("pointerdown", (evt) => {
                    if (evt.target.closest(".cauldron-inspector-element-editor-container") !== self.editorContainer) {
                        self.autocompleteDiv.innerHTML = "";
                        self.autocompleteDiv.classList.add("hidden");
                    }
                });
            }

            // Add the click-to-locate feature
            if (property.type!=="array"){
                this.locatorContainer = document.createElement("span");
                this.editorContainer.append(this.locatorContainer);
            }
        }

        this.html.addEventListener("keydown", (event)=>{
            if(event.code === "Enter") {
                event.preventDefault();
            }
        });

        // Send changes to concept
        this.html.addEventListener("input", (evt)=>{
            if(self.property.isConceptType()) {
                self.autoComplete(self.editor.value);
            }

            self.persistValue();
        });

        // Fetch changes from concept
        this.valueUpdaterCallback = async function onFieldUpdate(uuid, value){
            let mark = VarvPerformance.start();
            if (uuid===self.conceptInstance.uuid){
                if (property.type==="array"){
                    self.editor.innerHTML="";
                    let value = await property.getValue(conceptInstance.uuid);
                    for(let i = 0; i < value.length; i++){
                        let entry = value[i];
                        let entryElement = document.createElement("div");
                        entryElement.style.display = "flex";
                        entryElement.style.alignItems = "center";

                        if (!property.isDerived()){
                            let deleter = IconRegistry.createIcon("mdc:delete");
                            deleter.style.cursor = "pointer";
                            deleter.style.flex = "1 1 0%";
                            deleter.style.fontSize = "1.5em";
                            deleter.addEventListener("click", ()=>{
                                // Delete this entry
                                value.splice(i, 1);
                                property.setValue(conceptInstance.uuid, value);
                            });
                            entryElement.appendChild(deleter);
                        }

                        let theText = document.createElement("div");
                        theText.style.flex = "1 1 100%";
                        theText.innerText = entry;
                        entryElement.appendChild(theText);


                        if (property.isConceptArrayType()){
                            let link = self.getConceptLink(entry);
                            link.style.flex = "1 1 0%";
                            entryElement.appendChild(link);
                        }

                        self.editor.appendChild(entryElement);
                    }

                    if (!property.isDerived()){
                        let adder = document.createElement("button");
                        adder.innerText = "Add Entry";
                        adder.addEventListener("click", ()=>{
                            let newValue = prompt ("Value to add", "");
                            value.push(newValue);
                            property.setValue(conceptInstance.uuid, value);
                        });
                        self.editor.appendChild(adder);
                    }
                } else if (property.type==="boolean"){
                    self.editor.checked = value;
                } else {
                    self.editor.value = value;

                    if (property.isConceptType()){
                        self.updateLocator();
                    }
                }
            }
            VarvPerformance.stop("InspectorConceptBinding.valueUpdaterCallback", mark);
        };

        let possiblePromiseOrValue = property.getValue(conceptInstance.uuid);
        if(possiblePromiseOrValue instanceof Promise) {
            possiblePromiseOrValue.then((value)=>{
                self.valueUpdaterCallback(self.conceptInstance.uuid, value);
            });
        } else {
            self.valueUpdaterCallback(self.conceptInstance.uuid, possiblePromiseOrValue);
        }
        property.addUpdatedCallback(this.valueUpdaterCallback);
    }

    updateLocator() {
        this.locatorContainer.innerHTML = "";
        this.locatorContainer.appendChild(this.getConceptLink(this.editor.value));
    }

    persistValue() {
        try {
            let value = null;
            if (this.property.type==="boolean"){
                value = this.editor.checked;
            } else {
                value = this.property.typeCast(this.editor.value);
                if (this.property.isConceptType()){
                    this.updateLocator();
                }
            }
            this.property.setValue(this.conceptInstance.uuid, value);

            //What is this method?
            this.setFailing(false);
        } catch (ex){
            this.setFailing(true);
        };
    }

    async autoComplete() {
        const self = this;

        let allUUIDS = await VarvEngine.getAllUUIDsFromType(this.property.type, true);

        this.autocompleteDiv.innerHTML = "";

        let ul = document.createElement("ul");

        allUUIDS.forEach((uuid)=>{
            let li = document.createElement("li");
            li.textContent = uuid;
            ul.appendChild(li);

            li.addEventListener("mouseenter", ()=>{
                EventSystem.triggerEventAsync("Varv.DOMView.HighlightInstance", uuid);
            });

            li.addEventListener("mouseleave", ()=>{
                EventSystem.triggerEventAsync("Varv.DOMView.ClearHighlights");
            });

            li.addEventListener("click", ()=>{
                self.editor.value = uuid;
                self.autocompleteDiv.classList.add("hidden");
                self.persistValue();
            });
        });

        this.autocompleteDiv.appendChild(ul);
        this.autocompleteDiv.classList.remove("hidden");
    }

    getConceptLink(uuid){
        let linker = IconRegistry.createIcon("mdc:gps_fixed");
        linker.style.cursor = "pointer";
        linker.addEventListener("click", ()=>{
            let treeNodes = this.browser.findTreeNode(uuid);
            if(treeNodes.length > 0) {
                let treeNode = treeNodes[0];
                treeNode.reveal();
                treeNode.select();
            }
        });
        return linker;
    }

    destroy() {
        super.destroy();
        this.property.removeUpdatedCallback(this.valueUpdaterCallback);
    }

    focus(){
        this.editor.select();
    }
}

window.Cauldron.InspectorPropertyEditor = InspectorPropertyEditor;



EventSystem.registerEventCallback("TreeBrowser.Selection", ({detail: {selection: selection}})=>{
    if (selection.context && selection.context instanceof Concept){
        let concept = selection.context;
        EventSystem.triggerEventAsync("Varv.DOMView.HighlightConcept", concept);
    } else if (selection.context && selection.context.uuid) {
        EventSystem.triggerEventAsync("Varv.DOMView.HighlightInstance", selection.context.uuid);
    } else {
        EventSystem.triggerEventAsync("Varv.DOMView.ClearHighlights");
    }
});

</SCRIPT><SCRIPT id="ConceptDecorator-script" type="disabled">
/**
 *  ConceptDecorator - decorates Concept nodes in TreeBrowser trees
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

/**
 *
 */
class ConceptDecorator {
    /**
     * Attempts to decorate the given TreeNode
     * @param {TreeNode} node - The node to decorate
     * @returns {boolean} True/False depending on if the node was decorated
     */
    static decorate(node) {
        if(node.type === "ConceptNode") {
            node.setProperty("content", node.context.name);
            node.setProperty("icon", IconRegistry.createIcon("mdc:api"));
            return true;
        } else if(node.type === "ConceptInstanceNode") {
            node.setProperty("content", node.context.uuid);
            node.setProperty("icon", IconRegistry.createIcon("mdc:class"));
            return true;
        } else if(node.type === "DatastoreNode") {
            node.setProperty("content", node.context.name);
            node.setProperty("icon", IconRegistry.createIcon("mdc:circle"));
            return true;
        } else if(node.type === "ConceptRootNode") {
            node.setProperty("content", "Concepts");
            node.setProperty("icon", IconRegistry.createIcon("mdc:all_out"));
            return true;
        }

        return false;
    }

    /**
     * Attempts to decorate the given DataTransfer based on the given TreeNode
     * @param {TreeNode} node
     * @param {DataTransfer} dataTransfer
     * @returns {boolean} True/False depending on if the DataTransfer was decorated
     */
    static decorateDataTransfer(node, dataTransfer) {
        return false;
    }
}

window.ConceptDecorator = ConceptDecorator;

TreeGenerator.registerDecorator(ConceptDecorator, 10);

</SCRIPT><SCRIPT id="ConceptMenuActions-script" type="disabled">
/**
 *  ConceptTreeGenerator - Generate program/state structure to explore in Cauldron TreeBrowser
 *
 *  This code is licensed under the MIT License (MIT).
 *
 *  Copyright 2020, 2021, 2022 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the “Software”), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 */

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Create Instance",
    group: "ConceptActions",
    groupOrder: 0,
    icon: IconRegistry.createIcon("mdc:class"),
    onOpen: (menu)=>{
        return menu.context.type == "ConceptNode";
    },
    onAction: async (menuItem) =>{
        let id = await menuItem.menu.context.context.create();
        setTimeout(()=>{
            let treeBrowser = menuItem.menu.context.getTreeBrowser();
            let treeNodes = treeBrowser.findTreeNode(id);
            if(treeNodes.length > 0) {
                let treeNode = treeNodes[0];
                treeNode.reveal();
                treeNode.select();
            }
        }, 0);
    }
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Delete",
    group: "ConceptActions",
    groupOrder: 0,
    icon: IconRegistry.createIcon("mdc:delete"),
    onOpen: (menu)=>{
        return menu.context.type == "ConceptInstanceNode";
    },
    onAction: async (menuItem) =>{
        menuItem.menu.context.context.concept.delete(menuItem.menu.context.context.uuid);
    }
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Clone",
    group: "ConceptActions",
    groupOrder: 0,
    icon: IconRegistry.createIcon("mdc:copy"),
    onOpen: (menu)=>{
        return menu.context.type == "ConceptInstanceNode";
    },
    onAction: async (menuItem) =>{
        menuItem.menu.context.context.concept.clone(menuItem.menu.context.context.uuid);
    }
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Clone (Deep)",
    group: "ConceptActions",
    groupOrder: 0,
    icon: IconRegistry.createIcon("mdc:copy"),
    onOpen: (menu)=>{
        return menu.context.type == "ConceptInstanceNode";
    },
    onAction: async (menuItem) =>{
        menuItem.menu.context.context.concept.clone(menuItem.menu.context.context.uuid, true);
    }
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Copy ID",
    group: "ConceptActions",
    groupOrder: 0,
    icon: IconRegistry.createIcon("mdc:copy"),
    onOpen: (menu)=>{
        return menu.context.type == "ConceptInstanceNode";
    },
    onAction: async (menuItem) =>{
        await navigator.clipboard.writeText(menuItem.menu.context.context.uuid);
    }
});

MenuSystem.MenuManager.registerMenuItem("Cauldron.Help.Documentation", {
    label: "Varv",
    icon: IconRegistry.createIcon("webstrates:varv"),
    onAction: () => {
        window.open("https://varv.projects.cavi.au.dk/api/varv/");
    }
});

//Setup cauldron menu item
MenuSystem.MenuManager.registerMenuItem("Cauldron.Editor.Toolbar", {
    label: "JSON/YAML",
    icon: IconRegistry.createIcon("mdc:cached"),
    group: "EditActions",
    groupOrder: 0,
    order: 200,
    onOpen: (menu) => {
        return menu.context instanceof ConceptDefinitionFragment;
    },
    onAction: (menuItem) => {
        EventSystem.triggerEvent("Varv.Convert.YAMLJSON", {
            fragment: Fragment.one(menuItem.menu.context)
        });
    }
});

EventSystem.registerEventCallback("Varv.Convert.YAMLJSON", async (evt)=>{
    let fragment = evt.detail.fragment;
    let code = fragment.raw;

    let convertedCode = YAMLJSONConverter.convert(code);
    fragment.raw = convertedCode;

    const detail = {
        fragment: evt.detail.fragment,
    };

    EventSystem.triggerEvent("Cauldron.Open.FragmentEditor", detail);
});

</SCRIPT><STYLE id="base-style">
/* STUB: Not a proper MDC select popup, does not follow layouting guide */
.cauldron-inspector-element-autocomplete {
  border: 1px dotted #ccc;
  padding: 3px;
  position: fixed;
  z-index: 9000;
  background: var(--mdc-theme-surface, white);
  margin-top: 2em; }
  .cauldron-inspector-element-autocomplete.hidden {
    display: none; }
  .cauldron-inspector-element-autocomplete ul {
    list-style-type: none;
    padding: 0;
    margin: 0; }
    .cauldron-inspector-element-autocomplete ul li {
      padding: 5px 0;
      cursor: pointer; }
      .cauldron-inspector-element-autocomplete ul li:hover {
        background: #eee; }
</STYLE></WPM-PACKAGE><WPM-PACKAGE data-repository="varv-repos" id="varv-cauldron-delayloader" class="package" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "friendlyName": "Varv Cauldron (delayed)",
    "description": "A delayed loader for the varv-cauldron package",
    "dependencies": [
        "codestrates-repos #EventSystem"
    ],
    "optionalDependencies": [
        "#varv-cauldron",
        "#varv-dom-highlight"
    ],
    "assets": [],
    "license": "MIT",
    "version": "0.1",
    "changelog": {}
}

</SCRIPT><SCRIPT id="cauldron-delayloader-script" type="disabled">
// Run when/if Cauldron is initialized
{
    let alreadyInitializedDelayLoader = false;
    EventSystem.registerEventCallback("Cauldron.OnOpen", async ()=>{
            if (!alreadyInitializedDelayLoader){
                console.log("Fetching additional Varv packages for Cauldron integration");
                await wpm.require(["varv-cauldron", "varv-dom-highlight"]);

                // Cause a restart to update the TreeBrowser with the current Concepts
                EventSystem.triggerEvent("Varv.Restart");
                alreadyInitializedDelayLoader = true;
            }
    });
}

</SCRIPT></WPM-PACKAGE></head>

<body>
    <wpm-packages>

    <WPM-PACKAGE id="MirrorVerse-loading-skin" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "A simple loading skin for the bootloader to avoid seeing improperly rendered HTML while loading",
    "dependencies": [
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "0.4",
    "forceEmbedding": true
}

</SCRIPT><STYLE id="loading-style">html {
  background: #313131;
}

html:not([transient-wpm2-bootloader="loaded"]) > * {
  opacity: 0 !important;
}
html:not([transient-wpm2-bootloader="loaded"]) {
  contain: paint;
  overflow: hidden;
  max-height: 100vh;
}

@keyframes wpm-bootloader-spinning {
  from {
      filter: drop-shadow(0 0 1em rgba(255, 183, 0,0.5));
  }
  to {
      filter: drop-shadow(0 0 0em rgb(0, 170, 255));
  }
}

@keyframes wpm-bootloader-appears {
  from {
      opacity: 0;
  }
  to {
      opacity: 1;
  }
}


@keyframes wpm-bootloader-done {
  0% {
    transform: translate(-50%, -50%);
    opacity: 1;
  }
  5% {
    transform: translate(-50%, -50%) skew(0.4rad);
    opacity: 1;
  }
  25% {
    transform: translate(-60%, -50%) skew(0.312rad);
    opacity: 1;
  }
  30% {
    transform: translate(-61%, -50%) skew(-0.412rad);
    opacity: 0.8;
  }
  99% {
    transform: translate(200%, -50%) ;
    opacity: 0;
  }
  100% {
    visibility: hidden;
    transform: translate(-50%, -50%) scale(1.75);
    opacity: 0;
  }
}

html[transient-wpm2-bootloader="waiting"]:before, html[transient-wpm2-bootloader="waiting"]:before, html[transient-wpm2-bootloader="loading"]:before, html[transient-wpm2-bootloader="initializing"]:before, html[transient-wpm2-bootloader="loaded"]:before {
  content: "MIRRORVERSE";
  position: fixed;
  left: 50%;
  top: 50%;
  transform: translate(-50%,-50%);
  background-image: linear-gradient(#378DBC 0%, #B6E8F1 46%, #ffffff 50%, #32120E 54%, #FFC488 58%, #582C11 90%, #EC9B4E 100%);
  letter-spacing: 0.3px;
  font-weight: 900;
  padding: 0 16px;
  font-style: italic;
  font-size: 5vh;
  max-height: 100vh;
  white-space: nowrap;
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  -webkit-text-stroke: 0.4px #f5f5f5;
  pointer-events: none;
  z-index: 9999;
  font-family: sans-serif;
  animation: wpm-booloader-spinning 2s ease-in-out infinite, wpm-bootloader-appears 0.25s ease-in both;
}

html[transient-wpm2-bootloader="loaded"]:before {
  animation: wpm-bootloader-done 2s ease-in both;
}
</STYLE></WPM-PACKAGE></wpm-packages>





    <varv-data>

    <CONCEPT type="meeting" uuid="conceptfa30cc2b4590df112efa"><PROPERTY name="toolManager" value="concept84458120115041bf5ba1"></PROPERTY><PROPERTY name="rootRoom" value="conceptcfd3cd61e6079071d8db"></PROPERTY></CONCEPT><CONCEPT type="userManager" uuid="concepted88caef803f25f0deb2"></CONCEPT><CONCEPT type="audioManager" uuid="concept4cbd62195cdc41dad1c0"></CONCEPT><CONCEPT type="toolManager" uuid="concept84458120115041bf5ba1"></CONCEPT><CONCEPT type="chatManager" uuid="concept1b3661d8f146038f1d01"></CONCEPT><CONCEPT type="regularRoom" uuid="conceptcfd3cd61e6079071d8db"><PROPERTY name="left" value="0"></PROPERTY><PROPERTY name="top" value="0"></PROPERTY><PROPERTY name="width" value="300"></PROPERTY><PROPERTY name="height" value="200"></PROPERTY><PROPERTY name="name" value="Home"></PROPERTY></CONCEPT><CONCEPT type="user" uuid="conceptd5e030d471d39150d148"><PROPERTY name="name" value="Guest"></PROPERTY></CONCEPT></varv-data>


<DIV name="Varv Extensions"><WPM-PACKAGE id="StreamTools" name="StreamTools"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Varv extension that handles the WebRTC streaming and the audio routing control.",
    "dependencies": [],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><DIV id="cameraStreamChannelNode" name="cameraStreamChannelNode"></DIV><DIV name="audioStreamChannelNode" id="audioStreamChannelNode"></DIV><DIV id="screenStreamChannelNode" name="screenStreamChannelNode"></DIV><CODE-FRAGMENT data-type="text/javascript" name="Stream Handling" auto>window.cameraStreams = {};
window.audioStreams = {};
window.screenStreams = {};

const cameraChannel = document.querySelector('#cameraStreamChannelNode');
const audioChannel = document.querySelector('#audioStreamChannelNode');
const screenChannel = document.querySelector('#screenStreamChannelNode');



/**** Load Tuna library for audio filters ****/

// https://github.com/Theodeus/tuna
// https://github.com/Theodeus/tuna/wiki/Node-examples
await wpm.requireExternal('https://unpkg.com/tunajs@1.0.15/tuna-min.js');



/**** User interaction tracker for timing ****/

let clicked = false;

document.addEventListener('click', () => {
    clicked = true;
});



/**** Methods for Varv Actions and Trigger ****/

// Request camera sharing stream
const requestCameraStream = async () => {
    const stream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: false
    });
    addStream(stream, webstrate.clientId, 'camera', true);
    enableStreamSharing(stream, 'camera');
};

// Request audio sharing stream
const requestAudioStream = async () => {
    const stream = await navigator.mediaDevices.getUserMedia({
        video: false,
        audio: true
    });
    addStream(stream, webstrate.clientId, 'audio', true);
    enableStreamSharing(stream, 'audio');
};

// Request screen sharing stream
const requestScreenStream = async () => {
    const stream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
        audio: false
    });

    addStream(stream, webstrate.clientId, 'screen', true);
    enableStreamSharing(stream, 'screen');
};

const addStream = (stream, clientId, type, local = false) => {
    if (type === 'camera') {
        window.cameraStreams[clientId] = stream;
    } else if (type === 'audio') {
        window.audioStreams[clientId] = stream;
    } else {
        window.screenStreams[clientId] = stream;
    }
};



/**** Sharing and WebRTC ****/

const enableStreamSharing = (stream, type) => {
    setTimeout(() => {
        const channel = type === 'camera' ? cameraChannel : type === 'audio' ? audioChannel : screenChannel;
        channel.webstrate.signalStream((clientId, accept) => {
            console.log('Got stream request...');
            let conn = accept(stream, () => {
                console.log('Client accepted');
                // Connection has been established
            });
        });
    }, 0);
};

const  requestWebRTC = (type) => {
    setTimeout(function () {
        const channel = type === 'camera' ? cameraChannel : type === 'audio' ? audioChannel : screenChannel;
        channel.webstrate.on('signalStream', function (clientId, meta, accept) {
            let conn = accept((stream) => {
                console.log('Got stream...', stream, type);
                addStream(stream, clientId, type);
                const video = document.querySelector('video[data-stream="' + clientId + '"][data-stream-type="' + type + '"]');
                if (video) {
                    addStreamToVideo(video, clientId, type);
                }
            });
            console.log(conn);
        });
    }, 0);
};

Object.defineProperty(HTMLMediaElement.prototype, 'playing', {
    get: function () {
        return !!(this.currentTime > 0 && !this.paused && !this.ended && this.readyState > 2);
    }
});

const closeStream = (clientId, type) => {
    if (type === 'camera') {
        window.cameraStreams[clientId].getTracks().forEach(track => track.stop());
        delete window.cameraStreams[clientId];
    } else if (type === 'audio') {
        window.audioStreams[clientId].getTracks().forEach(track => track.stop());
        delete window.audioStreams[clientId];
    } else {
        window.screenStreams[clientId].getTracks().forEach(track => track.stop());
        delete window.screenStreams[clientId];
    }
};



/**** Element Live Query ****/

cQuery(document).liveQuery('video[data-stream]', {
    added: (video) => {
        cQuery(video).liveAttribute('data-stream', (video) => {
            handleChangedVideoElement(video);
        });
        handleChangedVideoElement(video);

        const type = video.getAttribute('data-stream-type');
        if (type === 'audio') {
            cQuery(video).liveAttribute('data-muted', (video) => {
                handleMutedChanged(video);
            });
            cQuery(video).liveAttribute('data-volume', (video) => {
                handleVolumeChanged(video);
            });
            cQuery(video).liveAttribute('data-filter', (video) => {
                handleFilterChanged(video);
            });
            handleMutedChanged(video);
            handleVolumeChanged(video);
            handleFilterChanged(video);
        }
    }
});

const handleChangedVideoElement = (video) => {
    if (video.src && video.src !== '' && video.src !== 'undefined') {
        console.log('Skipping!');
        return;
    };
    let type = video.getAttribute('data-stream-type');
    let streamId = video.getAttribute('data-stream');
    if (streamId === '{stream}' || !streamId) return;
    addStreamToVideo(video, streamId, type);
};

const addStreamToVideo = (video, streamId, type) => {
    // If it is an audio then we do not want the videoNode to play any audio
    if (type === 'audio') {
        const audioStream = window.audioStreams[streamId];

        video.crossOrigin = 'anonymous';
        video.srcObject = audioStream;

        // Setup audioSettings if not yet available and store on the stream
        if (clicked) {
            setTimeout(() => {
                setupAudioSettings(audioStream, streamId);
            }, 200);
        } else {
            document.addEventListener('click', () => {
                if (!video.playing) {
                    setupAudioSettings(audioStream, streamId);
                }
            });
        }
    } else {
        video.crossOrigin = 'anonymous';
        video.srcObject = type === 'camera' ? window.cameraStreams[streamId] : window.screenStreams[streamId];

        if (clicked) {
            setTimeout(() => {
                video.play();
            }, 200);
        } else {
            document.addEventListener('click', () => {
                if (!video.playing) {
                    video.play();
                }
            });
        }
    }
};



/**** Audio Setup and Handling ****/

const setupAudioSettings = (audioStream, streamId) => {
    if (audioStream == null) {
        return; // Stream not ready or existing
    }

    let audioSettings = audioStream.audioSettings;

    if (audioSettings == null) {
        const audioCtx = new AudioContext();
        const tuna = new Tuna(audioCtx);
        const source = audioCtx.createMediaStreamSource(audioStream);

        const volumeNode = audioCtx.createGain();
        const muteNode = audioCtx.createGain();
        const analyserNode = audioCtx.createAnalyser();
        analyserNode.smoothingTimeConstant = 0.1;
        analyserNode.fftSize = 1024;

        const biquadFilter = audioCtx.createBiquadFilter();
        const delay = audioCtx.createDelay(10.0);
        const overdrive = new tuna.Overdrive({
            outputGain: -9.154,           // -42 to 0 in dB
            drive: 0.197,                 // 0 to 1
            curveAmount: 0.979,           // 0 to 1
            algorithmIndex: 0,            // 0 to 5, selects one of the drive algorithms
            bypass: 0
        });

        source.connect(volumeNode);
        volumeNode.connect(muteNode);
        muteNode.connect(analyserNode);

        // Mute my own client but have the analyser work in the background
        if (streamId != webstrate.clientId) {
            analyserNode.connect(audioCtx.destination);
        }

        audioSettings = {
            audioCtx: audioCtx,
            source: source,
            volumeNode: volumeNode,
            muteNode: muteNode,
            analyserNode: analyserNode,
            biquadFilter: biquadFilter,
            delay: delay,
            overdrive: overdrive
        };
        audioStream.audioSettings = audioSettings;
    }
};

const handleMutedChanged = (video) => {
    const mutedString = video.getAttribute('data-muted');
    const muted = mutedString === 'true' ? true : false;

    const audioStream = video.srcObject;
    if (audioStream == null || audioStream.audioSettings == null) {
        return; // Stream not ready or existing
    }

    const muteNode = audioStream.audioSettings.muteNode;

    muteNode.gain.value = muted ? 0 : 1;
};

const handleVolumeChanged = (video) => {
    const volumeString = video.getAttribute('data-volume');
    const volume = Number(volumeString);

    if (isNaN(volume)) {
        return; // Invalid volume
    }

    const audioStream = video.srcObject;
    if (audioStream == null || audioStream.audioSettings == null) {
        return; // Stream not ready or existing
    }

    const volumeNode = audioStream.audioSettings.volumeNode;

    volumeNode.gain.value = Math.max(Math.min(volume, 1), 0);
};

const handleFilterChanged = async (video) => {
    const filterString = video.getAttribute('data-filter');

    const audioStream = video.srcObject;
    if (audioStream == null || audioStream.audioSettings == null) {
        return; // Stream not ready or existing
    }

    try {
        const audioSettings = audioStream.audioSettings;

        const source = audioSettings.source;
        const biquadFilter = audioSettings.biquadFilter;
        const delay = audioSettings.delay;
        const overdrive = audioSettings.overdrive;

        const volumeNode = audioSettings.volumeNode;

        // Disconnect existing connections
        source.disconnect();
        biquadFilter.disconnect();
        delay.disconnect();
        overdrive.disconnect();

        switch (filterString) {
            case 'muffled':
                biquadFilter.type = 'lowpass';
                biquadFilter.frequency.value = 400;

                source.connect(biquadFilter);
                biquadFilter.connect(volumeNode);

                break;
            case 'overdrive':
                source.connect(overdrive);
                overdrive.connect(volumeNode);

                break;
            default:
                source.connect(volumeNode);
        }
    } catch (e) {
        console.log('handleFilterChanged error');
        console.log(e);
    }
};



/**** Init ****/

requestWebRTC('camera');
requestWebRTC('audio');
requestWebRTC('screen');



/**** Window Variables ****/

window.requestWebRTC = requestWebRTC;

window.requestCameraStream = requestCameraStream;
window.requestAudioStream = requestAudioStream;
window.requestScreenStream = requestScreenStream;

window.closeStream = closeStream;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Get Stream Action" auto>class GetCameraStreamAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        try {
            await requestCameraStream();
        } catch (e) {
            console.error('GetCameraStreamAction', e);
        }

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            Action.setVariable(context, Action.defaultVariableName(self), webstrate.clientId);

            return context;
        });
    }
}

Action.registerPrimitiveAction('getCameraStream', GetCameraStreamAction);
window.GetCameraStreamAction = GetCameraStreamAction;



class GetAudioStreamAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        try {
            await requestAudioStream();
        } catch (e) {
            console.error('GetAudioStreamAction', e);
        }

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            Action.setVariable(context, Action.defaultVariableName(self), webstrate.clientId);

            return context;
        });
    }
}

Action.registerPrimitiveAction('getAudioStream', GetAudioStreamAction);
window.GetAudioStreamAction = GetCameraStreamAction;



class GetScreenStreamAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        try {
            await requestScreenStream();
        } catch (e) {
            console.error('GetScreenStreamAction', e);
        }

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            Action.setVariable(context, Action.defaultVariableName(self), webstrate.clientId);

            return context;
        });
    }
}

Action.registerPrimitiveAction('getScreenStream', GetScreenStreamAction);
window.GetScreenStreamAction = GetScreenStreamAction;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Close Stream Action" auto>class CloseStreamAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            closeStream(options.stream, options.type);

            return context;
        });
    }
}

Action.registerPrimitiveAction('closeStream', CloseStreamAction);
window.CloseStreamAction = CloseStreamAction;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Is Local Stream Action" auto>class IsStreamLocalAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            let result = false;

            if (options.stream) {
                result = options.stream == webstrate.clientId;
            }

            Action.setVariable(context, Action.defaultVariableName(self), result);

            return context;
        });
    }
}

Action.registerPrimitiveAction('isStreamLocal', IsStreamLocalAction);
window.IsStreamLocalAction = IsStreamLocalAction;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Volume Action" auto>class VolumeAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            let volume = 0;

            try {
                const video = document.querySelector(`.audioStreams video[data-stream="${options.stream}"][data-stream-type="audio"]`);
                const audioStream = video.srcObject;
                const analyserNode = audioStream.audioSettings.analyserNode;

                const bufferLength = analyserNode.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyserNode.getByteFrequencyData(dataArray);

                let sum = 0;
                for (const amplitude of dataArray) {
                    sum += amplitude * amplitude
                }

                volume = Math.sqrt(sum / dataArray.length);
            } catch (e) {
                // Do nothing
            }

            let resultName = Action.defaultVariableName(self);
            if (options.as != null) {
                resultName = options.as;
            }

            Action.setVariable(context, resultName, volume);

            return context;
        });
    }
}

Action.registerPrimitiveAction('volume', VolumeAction);
window.VolumeAction = VolumeAction;
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="RecordingTools" name="RecordingTools"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Varv extension that handles recording of camera feeds or the whole room using Videostrates.",
    "dependencies": [
        "#StreamTools"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Recording Handling" auto>// Adapted from: https://raw.githubusercontent.com/webrtc/samples/gh-pages/src/content/getusermedia/record/js/main.js

let mediaRecorder;
let recordedBlobs;
let recordingSource;



const handleDataAvailable = (event) => {
    console.log('handleDataAvailable', event);
    if (event.data && event.data.size > 0) {
        recordedBlobs.push(event.data);
    }
};

const getStreamFromId = (streamId) => {
    return window.cameraStreams[streamId];
};



const startRecording = (streamId, source) => {
    recordedBlobs = [];
    recordingSource = source;
    const mimeType = 'video/webm;codecs=vp9,opus';
    const options = { mimeType };
    const stream = getStreamFromId(streamId);
    // TODO: This only records video so far. This might be a solution for this: https://stackoverflow.com/a/36101484. But it conflicts with the audio routing.

    try {
        mediaRecorder = new MediaRecorder(stream, options);
    } catch (e) {
        console.error('Exception while creating MediaRecorder:', e);
        return;
    }

    console.log('Created MediaRecorder', mediaRecorder, 'with options', options);
    mediaRecorder.onstop = (event) => {
        console.log('Recorder stopped: ', event);
        console.log('Recorded Blobs: ', recordedBlobs);
    };
    mediaRecorder.ondataavailable = handleDataAvailable;
    mediaRecorder.start();
    console.log('MediaRecorder started', mediaRecorder);
};



const stopRecording = (streamId) => {
    mediaRecorder.stop();
    setTimeout(() => {
        // Either upload the recording or offer a download for the user
        uploadRecordingAsAsset();
        // downloadRecording();
    }, 100);
};

const uploadRecordingAsAsset = () => {
    const blob = new Blob(recordedBlobs, { type: 'video/webm' });
    const assetName = crypto.randomUUID() + '.webm';

    const formData = new FormData();
    formData.append('file', blob, assetName);

    const request = new XMLHttpRequest();
    request.open('POST', window.location.pathname);
    request.send(formData);
    request.addEventListener('load', (e) => {
        const asset = JSON.parse(request.responseText);
        console.log(asset);
        NewRecordingTrigger.trigger(asset.fileName, recordingSource);
    });
};

const downloadRecording = () => {
    const blob = new Blob(recordedBlobs, { type: 'video/webm' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    a.download = 'test.webm';
    document.body.appendChild(a);
    a.click();

    setTimeout(() => {
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
    }, 100);
};



window.startRecording = startRecording;
window.stopRecording = stopRecording;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Recording Actions" auto>class StartRecordingAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {

            if (options.streamId) {
                const source = options.source || false;

                startRecording(options.streamId, source);
            } else {
                console.warn('streamId is required to start a recording!')
            }

            return context;
        });
    }
}

Action.registerPrimitiveAction('startRecording', StartRecordingAction);
window.StartRecordingAction = StartRecordingAction;



class StopRecordingAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            stopRecording();
            return context;
        });
    }
}

Action.registerPrimitiveAction('stopRecording', StopRecordingAction);
window.StopRecordingAction = StopRecordingAction;



class StartRoomRecordingAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {

            if (options.fullscreenRoom) {
                // startRoomRecording(options.fullscreenRoom);
                console.warn('Room recordings are not available on the GitHub release of Mirrorverse.');
            } else {
                console.warn('fullscreenRoom is required to start a recording!')
            }

            return context;
        });
    }
}

Action.registerPrimitiveAction('startRoomRecording', StartRoomRecordingAction);
window.StartRoomRecordingAction = StartRoomRecordingAction;



class StopRoomRecordingAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            // stopRoomRecording();
            console.warn('Room recordings are not available on the GitHub release of Mirrorverse.');
            return context;
        });
    }
}

Action.registerPrimitiveAction('stopRoomRecording', StopRoomRecordingAction);
window.StopRoomRecordingAction = StopRoomRecordingAction;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="New Recording Trigger" auto>class NewRecordingTrigger extends Trigger {
    constructor(name, options, concept, type) {
        super(name, options, concept);
        this.type = type;
    }

    enable() {
        const self = this;

        this.deleteTrigger = Trigger.registerTriggerEvent('newRecording', async (contexts) => {
            await Trigger.trigger(self.name, contexts);
        });
    }

    disable() {
        if (this.deleteTrigger != null) {
            this.deleteTrigger.delete();
        }
    }

    static trigger(recordingUrl, source) {
        const sourceSafe = source || '';
        let context = {
            variables: {
                recordingUrl: recordingUrl,
                source: sourceSafe
            },
            target: null,
            properties: null,
        }
        Trigger.trigger('newRecording', context);
    }
}

Trigger.registerTrigger('newRecording', NewRecordingTrigger);
window.NewRecordingTrigger = NewRecordingTrigger;
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="FindAction" id="FindAction"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Varv extension that adds a 'Find' action that can find concepts with filtering and stores them in a variable.",
    "dependencies": [],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Find Action" auto>// Adapts the 'select' action of Varv
// https://github.com/Webstrates/Varv/blob/0bb1236308bb4f3c3d409d69c4f278b730a738ce/actions/ContextActions.js#L125

class FindAction extends Action {
    static options() {
        return {
            '$selectType': 'enumValue[concept,property,variable]',
            'where': 'filter',
            'as': '@string'
        };
    }

    constructor(name, options, concept) {
        //Handle shorthand
        if (typeof options === 'string') {
            if (options.trim().startsWith('$')) {
                options = {
                    target: options
                }
            } else {
                options = {
                    concept: options
                }
            }
        }

        const defaultOptions = {};

        options = Object.assign({}, defaultOptions, options);

        let wherePart = options.where;
        delete options.where;

        super(name, options, concept);

        this.wherePart = wherePart;
    }

    async apply(contexts, actionArguments) {
        const self = this;

        const DEBUG_SELECT = false;

        const globalConceptUUIDs = [];

        async function doSelect(context, options, originalOptions) {
            let mark = VarvPerformance.start();

            if (DEBUG_SELECT) {
                console.group('doSelect');
                console.log('Context:', context);
                console.log('Options:', options);
                console.log('Where:', self.wherePart);
            }

            let conceptUUIDs = [];
            let doFilter = true;

            if (options.concept != null) {
                // Select concept from type
                if (DEBUG_SELECT) {
                    console.log('Concept selection...');
                }

                doFilter = false;

                let filter = null;

                if (self.wherePart) {
                    let clonedVariables = Object.assign({}, context.variables);

                    let filterContext = { target: null, lastTarget: context.target, variables: clonedVariables };

                    let lookupWhereWithArguments = await Action.lookupArguments(self.wherePart, actionArguments);

                    let lookupWhereOptions = await Action.lookupVariables(lookupWhereWithArguments, filterContext);

                    filter = await FilterAction.constructFilter(lookupWhereOptions);
                }

                let limit = 0;

                if (options.limit != null) {
                    limit = options.limit;
                }

                conceptUUIDs = await VarvEngine.lookupInstances(VarvEngine.getAllImplementingConceptNames(options.concept), filter, context, limit, self.concept);

            } else if (options.target != null) {
                // Select concept from target
                if (Array.isArray(options.target)) {
                    conceptUUIDs.push(...options.target);
                } else {
                    conceptUUIDs.push(options.target);
                }
            } else if (options.property != null) {
                // Select concept from property of type concept or concept[]
                let lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.property);

                if (lookup == null) {
                    if (DEBUG_SELECT) {
                        console.groupEnd();
                    }
                    throw new Error('No property [' + options.property + '] found!');
                }

                if (lookup.property.isConceptType()) {
                    let value = await lookup.property.getValue(lookup.target)
                    conceptUUIDs.push(value);
                } else if (lookup.property.isConceptArrayType()) {
                    let value = await lookup.property.getValue(lookup.target)
                    conceptUUIDs.push(...value);
                } else {
                    if (DEBUG_SELECT) {
                        console.groupEnd();
                    }
                    throw new Error('Only able to select properties that are of concept or concept array type: [' + options.property + ':' + lookup.property.type + ']');
                }
            } else {
                if (DEBUG_SELECT) {
                    console.groupEnd();
                }
                throw new Error('Missing option "concept" or "target" on select action');
            }

            // Filtering already done?

            if (doFilter) {
                let filterMark = VarvPerformance.start();
                let filteredUUIDs = [];

                for (let uuid of conceptUUIDs) {
                    if (self.wherePart != null) {
                        let clonedVariables = Object.assign({}, context.variables);

                        let filterContext = { target: uuid, lastTarget: context.target, variables: clonedVariables };

                        let lookupWhereWithArguments = await Action.lookupArguments(self.wherePart, actionArguments);

                        let lookupWhereOptions = await Action.lookupVariables(lookupWhereWithArguments, filterContext);

                        let filter = await FilterAction.constructFilter(lookupWhereOptions);

                        if (await filter.filter(filterContext, self.concept)) {
                            filteredUUIDs.push(uuid);
                        }
                    } else {
                        filteredUUIDs.push(uuid);
                    }
                }
                VarvPerformance.stop('FindAction.doSelect.filtering', filterMark, { filter: self.wherePart, numConcepts: conceptUUIDs.length });

                conceptUUIDs = filteredUUIDs;
            }

            globalConceptUUIDs.push(...conceptUUIDs);

            VarvPerformance.stop('FindAction.doSelect', mark);

            if (DEBUG_SELECT) {
                console.groupEnd();
            }

            return context;
        }

        let result = [];

        let optionsWithArguments = await Action.lookupArguments(this.options, actionArguments);

        // Run the 'doSelect' method on each context to find the UUIDs and store them in the 'globalConceptUUIDs' variable
        result = await this.forEachContext(contexts, actionArguments, async (context, options) => {
            return await doSelect(context, options, optionsWithArguments);
        });

        // Add the global variable to all contexts
        result = await this.forEachContext(contexts, actionArguments, async (context, options) => {
            let resultName = Action.defaultVariableName(self);

            if (options.as != null) {
                resultName = options.as;
            }

            const uniqueGlobalConceptUUIDs = [...new Set(globalConceptUUIDs)]

            Action.setVariable(context, resultName, uniqueGlobalConceptUUIDs);

            return context;
        });

        return result;
    }
}

Action.registerPrimitiveAction('find', FindAction);
window.FindAction = FindAction;
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="WindowTools" id="WindowTools"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Varv extension that adds actions and triggers related to the window and viewport sizes.",
    "dependencies": [],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Window Resize Trigger">class WindowResizeTrigger extends Trigger {
    constructor(name, options, concept, type) {
        super(name, options, concept);
        this.type = type;
    }

    enable() {
        const self = this;

        this.deleteTrigger = Trigger.registerTriggerEvent('windowResized', async (contexts) => {
            await Trigger.trigger(self.name, contexts);
        });
    }

    disable() {
        if (this.deleteTrigger != null) {
            this.deleteTrigger.delete();
        }
    }

    static trigger(width, height) {
        let context = {
            variables: {
                windowWidth: width,
                windowHeight: height
            },
            target: null,
            properties: null
        }
        Trigger.trigger('windowResized', context);
    }
}

Trigger.registerTrigger('windowResized', WindowResizeTrigger);
window.WindowResizeTrigger = WindowResizeTrigger;



window.addEventListener('resize', (event) => {
    WindowResizeTrigger.trigger(event.target.innerWidth, event.target.innerHeight);
});
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Element Size Action" auto>class ElementRectAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            let element = document.body;

            if (options.element) {
                const customElement = document.querySelector(options.element);

                if (customElement) {
                    element = customElement;
                } else {
                    console.warn(`Could not find the element "${options.element}", using "document.body".`);
                }
            }

            const rect = element.getBoundingClientRect();

            Action.setVariable(context, 'elementLeft', rect.x);
            Action.setVariable(context, 'elementTop', rect.y);
            Action.setVariable(context, 'elementWidth', rect.width);
            Action.setVariable(context, 'elementHeight', rect.height);

            return context;
        });
    }
}

Action.registerPrimitiveAction('elementRect', ElementRectAction);
window.ElementRectAction = ElementRectAction;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Cursor Position Action" auto>let x, y;

class CursorPositionAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {

            Action.setVariable(context, 'x', x);
            Action.setVariable(context, 'y', y);

            return context;
        });
    }
}

Action.registerPrimitiveAction('cursorPosition', CursorPositionAction);
window.CursorPositionAction = CursorPositionAction;



document.addEventListener('mousemove', (event) => {
    x = event.clientX;
    y = event.clientY;
});
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" auto name="Modifier Keys Action">let ctrl = false;
let alt = false;
let shift = false;



class ModifierKeysAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {

            Action.setVariable(context, 'ctrl', ctrl);
            Action.setVariable(context, 'alt', alt);
            Action.setVariable(context, 'shift', shift);

            return context;
        });
    }
}

Action.registerPrimitiveAction('modifierKeys', ModifierKeysAction);
window.ModifierKeysAction = ModifierKeysAction;



class ModifierKeysChangeTrigger extends Trigger {
    constructor(name, options, concept, type) {
        super(name, options, concept);
        this.type = type;
    }

    enable() {
        const self = this;

        this.deleteTrigger = Trigger.registerTriggerEvent('modifierKeysChange', async (contexts) => {
            await Trigger.trigger(self.name, contexts);
        });
    }

    disable() {
        if (this.deleteTrigger != null) {
            this.deleteTrigger.delete();
        }
    }

    static trigger(ctrl, alt, shift) {
        let context = {
            variables: {
                ctrl: ctrl,
                alt: alt,
                shift: shift
            },
            target: null,
            properties: null
        }
        Trigger.trigger('modifierKeysChange', context);
    }
}

Trigger.registerTrigger('modifierKeysChange', ModifierKeysChangeTrigger);
window.ModifierKeysChangeTrigger = ModifierKeysChangeTrigger;



document.addEventListener('keydown', (event) => {
    updateModifierKey(event);
});
document.addEventListener('keyup', (event) => {
    updateModifierKey(event);
});

const updateModifierKey = (event) => {
    const oldCtrl = ctrl;
    const oldAlt = alt;
    const oldShift = shift;

    ctrl = event.ctrlKey || event.metaKey;
    alt = event.altKey;
    shift = event.shiftKey;

    if ((oldCtrl != ctrl) || (oldAlt != alt) || (oldShift != shift)) {
        ModifierKeysChangeTrigger.trigger(ctrl, alt, shift);
    }
};
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="TimeTools" id="TimeTools"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Varv extension that adds two time-related actions.",
    "dependencies": [],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Time Epoch Action" auto>class TimeEpochAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            const epoch = Date.now();

            let resultName = Action.defaultVariableName(self);
            if (options.as != null) {
                resultName = options.as;
            }

            Action.setVariable(context, resultName, epoch);

            return context;
        });
    }
}

Action.registerPrimitiveAction('timeEpoch', TimeEpochAction);
window.TimeEpochAction = TimeEpochAction;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" auto name="Epoch To Human Readable Action">class EpochToTimeAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            let epoch = Date.now();
            if (options.epoch != null) {
                epoch = new Date(options.epoch);
            }

            const timeString = epoch.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });

            let resultName = Action.defaultVariableName(self);
            if (options.as != null) {
                resultName = options.as;
            }

            Action.setVariable(context, resultName, timeString);

            return context;
        });
    }
}

Action.registerPrimitiveAction('epochToTime', EpochToTimeAction);
window.EpochToTimeAction = EpochToTimeAction;



class EpochToDateAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            let epoch = Date.now();
            if (options.epoch != null) {
                epoch = new Date(options.epoch);
            }

            const dateString = epoch.toLocaleDateString('de-DE', { month: '2-digit', day: '2-digit', year: 'numeric' });

            let resultName = Action.defaultVariableName(self);
            if (options.as != null) {
                resultName = options.as;
            }

            Action.setVariable(context, resultName, dateString);

            return context;
        });
    }
}

Action.registerPrimitiveAction('epochToDate', EpochToDateAction);
window.EpochToDateAction = EpochToDateAction;
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="RandomColorAction" name="RandomColorAction"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Varv extension that adds an action that creates random colors for avatars.",
    "dependencies": [],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Random Color Action" auto>// Adapted from: https://helderesteves.com/generating-random-colors-in-js-dark-light-colors/

const generateDarkColorHex = () => {
    let color = '#';
    for (let i = 0; i &lt; 3; i++) {
        color += ('0' + Math.floor(Math.random() * Math.pow(16, 2) / 2).toString(16)).slice(-2);
    }
    return color;
};

class RandomColorAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            const color = generateDarkColorHex();

            let resultName = Action.defaultVariableName(self);
            if (options.as != null) {
                resultName = options.as;
            }

            Action.setVariable(context, resultName, color);

            return context;
        });
    }
}

Action.registerPrimitiveAction('randomColor', RandomColorAction);
window.RandomColorAction = RandomColorAction;
</CODE-FRAGMENT></WPM-PACKAGE></DIV><DIV name="Mirrorverse"><WPM-PACKAGE id="Meeting" name="Meeting"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The main meeting concept.",
    "dependencies": [
        "#WindowTools"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Meeting Concepts" auto>{
    "dataStores": {
        "location": {
            "type":"location"
        }
    },
    "concepts": {
        "meeting": {
            "schema": {
                "rootRoom": "roomElement",
                "fullscreenRoom": "roomElement",
                "inRoot": { "boolean": {
                    "derive": {
                        "properties": [ "rootRoom", "fullscreenRoom" ],
                        "transform": [
                            { "get": "rootRoom" },
                            { "eval": {
                                "property": "fullscreenRoom",
                                "equals": "$get"
                            }}
                        ]
                    }
                }},
                "contentType": { "string": { "default": "cameraContent" }},
                "toolType": { "string": { "default": "gridTool" }},
                "modifierCtrl": "boolean",
                "modifierAlt": "boolean",
                "modifierShift": "boolean",
                "layoutMode": { "boolean": {
                    "derive": {
                        "properties": [ "modifierShift" ],
                        "transform": [
                            { "eval": {
                                "property": "modifierShift",
                                "equals": true
                            }}
                        ]
                    }
                }},
                "selectedElement": "element"
            },
            "mappings": {
                "fullscreenRoom": [ "localStorage", "cauldron" ],
                "contentType": [ "localStorage", "cauldron" ],
                "toolType": [ "localStorage", "cauldron" ],
                "modifierCtrl": [ "memory", "cauldron" ],
                "modifierAlt": [ "memory", "cauldron" ],
                "modifierShift": [ "memory", "cauldron" ],
                "layoutMode": [ "memory", "cauldron" ],
                "selectedElement": [ "memory", "cauldron" ]
            },
            "actions": {
                "checkIsfullscreenRoom": [
                    { "get": {
                        "property": "meeting.fullscreenRoom",
                        "as": "fullscreenRoom"
                    }},
                    { "where": {
                        "variable": "target",
                        "equals": "$fullscreenRoom",
                        "stopIfEmpty": true
                    }}
                ],
                "checkInfullscreenRoom": [
                    { "get": {
                        "property": "meeting.fullscreenRoom",
                        "as": "fullscreenRoom"
                    }},
                    { "where": {
                        "property": "parentRoom",
                        "equals": "$fullscreenRoom",
                        "stopIfEmpty": true
                    }}
                ],
                "selectfullscreenRoom": [
                    { "get": "meeting.fullscreenRoom" },
                    { "select": {
                        "target": "$get",
                        "stopIfEmpty": true
                    }}
                ],
                "addRoom": {
                    "when": { "click": { "view": "addRoomButton" }},
                    "then": [
                        { "set": { "variable": "type", "value": "regularRoom"}},
                        "addElement"
                    ]
                },
                "addContent": {
                    "when": { "click": { "view": "addContentButton" }},
                    "then": [
                        { "get": { "property": "meeting.contentType", "as": "type" }},
                        "addElement"
                    ]
                },
                "addTool": {
                    "when": { "click": { "view": "addToolButton" }},
                    "then": [
                        { "get": { "property": "meeting.toolType", "as": "type" }},
                        "addElement"
                    ]
                },
                "addElement": [
                    { "run": "deselectElements" },
                    { "get": { "property": "meeting.fullscreenRoom", "as": "parent" }},
                    { "new": {
                        "concept": "$type",
                        "with": {
                            "parentRoom": "$parent"
                        }
                    }}
                ],
                "enterBreadCrumb": {
                    "when": { "click": { "view": "enterBreadcrumbButton" }},
                    "then": [
                        { "set": { "meeting.fullscreenRoom": "$target" }},
                        { "run": "deselectElements" }
                    ]
                },
                "enterRoom": {
                    "when": { "click": { "view": "enterRoomButton" }},
                    "then": [
                        { "select": {
                            "concept": "roomElement",
                            "where": {
                                "property": "selected",
                                "equals": true
                            },
                            "stopIfEmpty": true
                        }},
                        { "limit": 1 },
                        { "set": { "meeting.fullscreenRoom": "$target" }},
                        { "run": "deselectElements" }
                    ]
                },
                "exitRoom": {
                    "when": [
                        { "click": { "view": "exitRoomButton" }}
                    ],
                    "then": [
                        "selectfullscreenRoom",
                        "selectparentRoom",
                        { "set": { "meeting.fullscreenRoom": "$target" }},
                        { "run": "deselectElements" }
                    ]
                },
                "gotoHomeRoom": {
                    "when": [
                        { "click": { "view": "homeButton" }}
                    ],
                    "then": [
                        { "get": "meeting.rootRoom" },
                        { "set": { "meeting.fullscreenRoom": "$get" }},
                        { "run": "deselectElements" }
                    ]
                },
                "checkCtrl": [
                    "modifierKeys",
                    { "where": {
                        "variable": "ctrl",
                        "equals": true,
                        "stopIfEmpty": true
                    }}
                ],
                "checkAlt": [
                    "modifierKeys",
                    { "where": {
                        "variable": "alt",
                        "equals": true,
                        "stopIfEmpty": true
                    }}
                ],
                "checkShift": [
                    "modifierKeys",
                    { "where": {
                        "variable": "shift",
                        "equals": true,
                        "stopIfEmpty": true
                    }}
                ],
                "checkNotCtrl": [
                    "modifierKeys",
                    { "where": {
                        "variable": "ctrl",
                        "equals": false,
                        "stopIfEmpty": true
                    }}
                ],
                "checkNotAlt": [
                    "modifierKeys",
                    { "where": {
                        "variable": "alt",
                        "equals": false,
                        "stopIfEmpty": true
                    }}
                ],
                "checkNotShift": [
                    "modifierKeys",
                    { "where": {
                        "variable": "shift",
                        "equals": false,
                        "stopIfEmpty": true
                    }}
                ],
                "checkInLayoutMode": [
                    { "get": "meeting.layoutMode" },
                    { "where": {
                        "variable": "get",
                        "equals": true,
                        "stopIfEmpty": true
                    }}
                ],
                "checkNotInLayoutMode": [
                    { "get": "meeting.layoutMode" },
                    { "where": {
                        "variable": "get",
                        "equals": false,
                        "stopIfEmpty": true
                    }}
                ],
                "updateModifierProperties": {
                    "when": [ "modifierKeysChange" ],
                    "then": [
                        { "set": { "meeting.modifierCtrl": "$ctrl" }},
                        { "set": { "meeting.modifierAlt": "$alt" }},
                        { "set": { "meeting.modifierShift": "$shift" }}
                    ]
                },
                "correctCursorPosition": [
                    { "elementRect": { "element": "varv-view > .meeting > .content" }},
                    { "set": {
                        "variable": "x",
                        "value": { "calculate": "$x$ - $elementLeft$" }
                    }},
                    { "set": {
                        "variable": "y",
                        "value": { "calculate": "$y$ - $elementTop$" }
                    }}
                ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="Meeting Template" auto>&lt;dom-view-template>
    &lt;div class="meeting" concept="meeting" data-modifier-ctrl="{modifierCtrl}" data-modifier-alt="{modifierAlt}" data-modifier-shift="{modifierShift}" data-layout-mode="{layoutMode}" data-videostrates="{videostrates}">
        &lt;div class="header">
            &lt;div class="header-content" if="fullscreenRoom">
                &lt;h1 class="mirrorverse">MIRRORVERSE&lt;/h1>
                &lt;div class="flex-spacer">&lt;/div>
                &lt;button view="addRoomButton">Add Room&lt;/button>
                &lt;div class="spacer">&lt;/div>
                &lt;label>
                    Content:
                    &lt;select value="{contentType}">
                        &lt;option value="cameraContent">Camera&lt;/option>
                        &lt;option value="screenContent">Screen Capture&lt;/option>
                        &lt;option value="videoContent">Video&lt;/option>
                        &lt;option value="imageContent">Image&lt;/option>
                        &lt;option value="noteContent">Note&lt;/option>
                        &lt;option value="sketchContent">Sketch&lt;/option>
                        &lt;option value="chatContent">Chat&lt;/option>
                        &lt;option value="avatarContent">Avatar&lt;/option>
                    &lt;/select>
                &lt;/label>
                &lt;button view="addContentButton">Add Content&lt;/button>
                &lt;div class="spacer">&lt;/div>
                &lt;label>
                    Tool:
                    &lt;select value="{toolType}">
                        &lt;option value="gridTool">Grid Layout&lt;/option>
                        &lt;option value="speakerViewTool">Speaker View Layout&lt;/option>
                        &lt;option value="layoutTemplateTool">Layout Template&lt;/option>
                        &lt;option value="highlightTool">Highlight&lt;/option>
                        &lt;option value="cameraShakerTool">Camera Shaker&lt;/option>
                        &lt;option value="recordingTool">Recording&lt;/option>
                        &lt;option value="roomRecordingTool">Room Recording&lt;/option>
                        &lt;option value="doorwayTool">Doorway&lt;/option>
                        &lt;option value="proximityBasedAudioTool">Proximity-based Audio&lt;/option>
                        &lt;option value="podiumTool">Podium&lt;/option>
                        &lt;option value="whisperTool">Whisper&lt;/option>
                        &lt;option value="broadcastTool">Broadcast&lt;/option>
                        &lt;option value="templateStoreTool">Template Store&lt;/option>
                    &lt;/select>
                &lt;/label>
                &lt;button view="addToolButton">Add Tool&lt;/button>
                &lt;div class="flex-spacer">&lt;/div>
                &lt;!-- &lt;label concept="audioManager" class="audio-routing-toggle">
                    Pause Audio Routing:
                    &lt;input value="{pauseAudioRouting}" type="checkbox">
                &lt;/label> -->
                &lt;div class="edit-button-spacer">&lt;/div>
            &lt;/div>
        &lt;/div>
        &lt;div class="panel-group">
            &lt;div class="panel tool-panel">
                &lt;div class="headline">Tool Panel&lt;/div>
                &lt;div property="fullscreenRoom" class="panel-inner">
                    &lt;template-ref template-name="element" property="childElements" if="inToolPanel">&lt;/template-ref>
                &lt;/div>
            &lt;/div>
        &lt;/div>
        &lt;div class="content" property="fullscreenRoom">
            &lt;div class="fullscreen-background" view="fullscreen-background">&lt;/div>
            &lt;template-ref template-name="element" property="childElements" if="!inToolPanel">&lt;/template-ref>
            &lt;div class="room-title">
                &lt;span class="breadcrumb-parent" property="parentRoom" view="enterBreadcrumbButton">
                    &lt;span class="breadcrumb-parent" property="parentRoom" view="enterBreadcrumbButton">
                        &lt;span class="breadcrumb-parent" property="parentRoom" view="enterBreadcrumbButton">
                            ... ›
                        &lt;/span>
                        {name} ›
                    &lt;/span>
                    {name} ›
                &lt;/span>
                {name}
            &lt;/div>
            &lt;div class="client-overview" title="Clients in this Room" if="clients">
                &lt;div class="client-thumbnail" property="clients" style="background: {color}">
                    &lt;span property="user" title="{user.name}: {client.name}">{name}&lt;/span>: {name}
                &lt;/div>
            &lt;/div>
        &lt;/div>
        &lt;div class="content" if="!fullscreenRoom">
            &lt;button class="welcome-button green" view="homeButton">Enter the Main Room&lt;/button>
        &lt;/div>
        &lt;div class="panel-group">
            &lt;div class="panel navigation-panel" if="fullscreenRoom">
                &lt;div class="headline">Navigation&lt;/div>
                &lt;div class="panel-inner" if="!inRoot">
                    &lt;button view="homeButton">Home&lt;/button>
                    &lt;button view="exitRoomButton">Exit Room&lt;/button>
                &lt;/div>
                &lt;div class="panel-inner" property="selectedElement">
                    &lt;div class="spacer" if="!inRoot" style="margin-top: -2px;">&lt;/div>
                    &lt;button view="enterRoomButton" if="isRoom">Enter Room&lt;/button>
                    &lt;button view="moveElementOutButton" if="!inRoot">Move Element Out of Room&lt;/button>
                &lt;/div>
            &lt;/div>
            &lt;div class="panel room-options-panel">
                &lt;div class="headline">Room Inspector&lt;/div>
                &lt;div class="panel-inner">
                    &lt;label property="fullscreenRoom">
                        Name:
                        &lt;input value="{name}">
                    &lt;/label>
                    &lt;label property="fullscreenRoom">
                        Audio Filter:
                        &lt;input value="{audioFilter}">
                    &lt;/label>
                &lt;/div>
            &lt;/div>
            &lt;div class="panel object-options-panel">
                &lt;div class="headline">Element Inspector&lt;/div>
                &lt;div class="panel-inner" property="selectedElement">
                    &lt;template-ref template-name="{elementType}Options">&lt;/template-ref>
                &lt;/div>
            &lt;/div>
        &lt;/div>
        &lt;div class="sidebar">
            &lt;div class="sidebar-content" if="fullscreenRoom">
                &lt;template-ref template-name="clientPanel" concept="userManager">&lt;/template-ref>
            &lt;/div>
        &lt;/div>
        &lt;template-ref template-name="audioStreams">&lt;/template-ref>
    &lt;/div>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/css" name="Roboto Font" auto>@import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,500;0,700;0,900;1,400;1,500;1,700;1,900&display=swap');

body,
body button,
body input,
body select,
body textarea {
    font-family: Roboto, Arial, sans-serif;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Meeting Style" auto>@mixin heading-font {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}



.m-ico {
    font-family: "Material Icons";
    font-weight: normal;
    font-style: normal;
    line-height: 1;
    letter-spacing: normal;
    text-transform: none;
    display: inline-block;
    white-space: nowrap;
    word-wrap: normal;
    direction: ltr;
    vertical-align: middle;
}



body {
    margin: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #313131;

    button {
        @include heading-font;

        user-select: none;
        border-radius: 4px;
        padding: 0 8px;
        background: #636363;
        color: #fff;
        vertical-align: middle;
        text-align: center;
        cursor: pointer;
        border: none;

        &:hover {
            background: #848484;
        }

        &.red {
            background: #d32f2f !important;

            &:hover {
                background: #ff6659 !important;
            }

            &:active {
                background: #9a0007 !important;
            }
        }

        &.green {
            background: #2e7d32 !important;

            &:hover {
                background: #60ad5e !important;
            }

            &:active {
                background: #005005 !important;
            }
        }
    }

    label {
        @include heading-font;

        user-select: none;
        white-space: nowrap;

        background: #eeeeee;
        color: #000000;

        border-radius: 4px;
        padding-left: 8px;
        padding-right: 8px;
        padding-right: 0;

        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        align-items: center;
        gap: 4px;

        input[type="checkbox"] {
            width: 24px;
        }

        input:not([type="checkbox"]),
        select {
            border-top-left-radius: 16px;
            border-bottom-left-radius: 16px;
            height: 100%;
        }
    }

    input:not([type="checkbox"]),
    select,
    textarea {
        border-radius: 4px;
        border: none;
        padding: 0 8px;
        text-overflow: ellipsis;
        outline: none;
        color: #000;
        width: 100%;
    }
}

.meeting {
    position: absolute;
    top: 64px;
    left: 16px;
    right: 96px;
    bottom: 0;
    overflow: auto;
    background: #313131;

    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    align-items: center;
    justify-content: center;
    gap: 16px;

    &[data-layout-mode="true"] {
        user-select: none;
    }

    &::-webkit-scrollbar {
        width: 8px;
        height: 8px;
    }

    /* Track */
    &::-webkit-scrollbar-track,
    &::-webkit-scrollbar-corner {
        background: none;
    }

    /* Handle */
    &::-webkit-scrollbar-thumb {
        background: #636363;
        border-radius: 4px;
    }

    /* Handle on hover */
    &::-webkit-scrollbar-thumb:hover {
        background: #848484;
    }
}

// Fix for problem of cut-off elements when leaving it centered
@media screen and (max-width: 1675px) {
    .meeting {
        justify-content: flex-start;
    }
}

@media screen and (max-height: 1096px) {
    .meeting {
        align-items: flex-start;
    }
}

// Absolute Content
.content {
    position: relative;
    flex: 0 0 auto;
    background: #424242;
    box-shadow: inset 0px 0px 8px 0px #333333;
    width: 1280px;
    height: 960px;
    overflow: hidden;
    border-radius: 20px;

    .welcome-button {
        position: absolute;
        width: 256px;
        height: 48px;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
    }

    >.room-title {
        @include heading-font;

        position: absolute;
        top: 0px;
        left: 0px;
        height: 32px;

        background: #313131;
        box-shadow: 0px 0px 8px 0px #333333;
        color: #CCCCCC;

        border-bottom-right-radius: 12px;
        border-top-left-radius: 8px;

        line-height: 32px;
        font-size: 14px;
        letter-spacing: 1px;
        padding: 3px 8px;
        user-select: none;
        z-index: 1000;

        &:empty {
            display: none;
        }

        .breadcrumb-parent {
            opacity: 0.66;
            cursor: pointer;
        }
    }

    >.client-overview {
        position: absolute;
        background: #313131;
        box-shadow: 0px 0px 8px 0px #333333;
        border-bottom-left-radius: 12px;
        border-top-right-radius: 8px;
        top: 0px;
        right: 0px;
        height: 30px;
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 4px;
        padding: 4px 6px;
        min-width: 30px;
        user-select: none;
        z-index: 1000;

        .client-thumbnail {
            color: #fff;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            overflow: hidden;
            user-select: none;
            font-size: 8px;
            line-height: 20px;
            padding: 4px;
            text-align: center;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
    }
}

.panel-group {
    position: relative;
    flex: 0 0 auto;

    width: 256px;
    height: 960px;

    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
    gap: 16px;
}

.navigation-panel {
    flex: 0 0 auto;
}

.room-options-panel {
    flex: 0 0 auto;
}

.object-options-panel {
    flex: 1 0 auto;
}

.tool-panel {
    flex: 1 0 auto;

    .element {
        position: relative;
        top: initial !important;
        left: initial !important;
        width: initial !important;
        height: initial !important;

        .move-handle,
        .resize-handle {
            display: none;
        }
    }
}

.panel {
    position: relative;
    max-height: calc(100% - 32px);

    background: #424242;
    box-shadow: inset 0px 0px 8px 0px #333333;

    padding: 16px;
    border-radius: 20px;
    color: #fff;

    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
    align-items: stretch;
    gap: 14px;

    .headline {
        @include heading-font;
        text-align: center;
        display: block;
        width: 100%;
        font-size: 14px;
        letter-spacing: 1px;
        color: #CCCCCC;
        height: 24px;
        line-height: 24px;
    }

    .panel-inner {
        display: flex;
        flex: 1 1 auto;
        max-height: 100%;
        overflow: auto;
        padding: 2px;

        flex-direction: column;
        flex-wrap: nowrap;
        align-items: stretch;
        gap: 8px;

        label,
        input,
        select,
        button {
            height: 32px;
        }

        .spacer {
            margin: 4px 0;
            height: 2px;
            border-radius: 2px;
            background: #848484;
        }
    }
}

.header {
    position: fixed;
    background: #212121;
    box-shadow: 0px 0px 4px 0px #212121;
    color: #FFF;
    height: 48px;
    left: 0;
    right: 0;
    z-index: 1000;
}

.header {
    top: 0;
}

.sidebar {
    position: fixed;
    background: hsl(0, 0%, 13%);
    box-shadow: 0px 0px 4px 0px #212121;
    color: #ffffff;
    width: 80px;
    right: 0;
    top: 64px;
    bottom: 16px;
    z-index: 1000;
    border-radius: 20px 0 0 20px;
}

.sidebar-content {
    width: calc(100% - 16px);
    height: calc(100% - 16px);
    margin: 8px;
    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
    gap: 8px;
    align-items: center;
}

.header-content {
    width: calc(100% - 16px);
    height: calc(100% - 16px);
    margin: 8px;
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    gap: 8px;
    align-items: stretch;

    .spacer {
        flex: 0 0 2px;
        border-radius: 2px;
        background-color: #848484;
        margin: 0 16px;
    }

    .flex-spacer {
        flex: 1 1 auto;
    }

    .edit-button-spacer {
        flex: 0 0 48px;
    }
}

.fullscreen-background {
    width: 100%;
    height: 100%;
}

.audio-routing-toggle {
    opacity: 0;
    transition: 250ms ease-in-out opacity;
    transition-delay: 1000ms;

    &:hover {
        opacity: 1;
        transition-delay: 0ms;
    }
}



button#cauldron-edit-button {
    top: 8px !important;
    right: 8px !important;
    height: 32px;
    width: 48px;

    opacity: 0;
    transition: 250ms ease-in-out opacity;
    transition-delay: 1000ms;

    z-index: 10000;

    &:hover {
        opacity: 1;
        transition-delay: 0ms;
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Mirrorverse Title" auto>// Adapted from: https://codepen.io/boldfacedesign/pen/DpXjzY

h1.mirrorverse,
h1.mirrorverse:hover:before {
    letter-spacing: 0.3px;
    font-weight: 900;
    padding: 0 16px;
    font-style: italic;
    font-size: 25px;
    white-space: nowrap;
    -webkit-background-clip: text;
    background-clip: text;
    user-select: none;
}

h1.mirrorverse {
    position: relative;
    background-image: -webkit-linear-gradient(#378DBC 0%, #B6E8F1 46%, #ffffff 50%, #32120E 54%, #FFC488 58%, #582C11 90%, #EC9B4E 100%);
    -webkit-text-fill-color: transparent;
    -webkit-text-stroke: 0.4px #f5f5f5;
    margin: 0;
    line-height: 32px;

    &:hover:before {
        position: absolute;
        content: 'MIRRORVERSE';
        left: 0;
        top: 0;
        z-index: 10;
        background-image: -webkit-linear-gradient(-40deg, transparent 0%, transparent 40%, #fff 50%, transparent 60%, transparent 100%);
        background-position: -150px 0;
        -webkit-text-stroke: 0;
        padding-right: 37.5px;
        -webkit-animation-name: chrome_effect;
        -webkit-animation-duration: 2.5s;
        -webkit-animation-timing-function: linear;
        -webkit-animation-iteration-count: infinite;
        animation-name: chrome_effect;
        animation-duration: 2.5s;
        animation-timing-function: linear;
        animation-iteration-count: infinite;
    }
}

@keyframes chrome_effect {
    0% {
        background-position: -100px 0;
    }

    20% {
        background-position: 100px 0;
    }

    100% {
        background-position: 100px 0;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Users" name="Users"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "User, client, and userManager concepts.",
    "dependencies": [
        "#FindAction",
        "#TimeTools",
        "#RandomColorAction"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Users Concepts" auto>{
    "concepts": {
        "userManager": {
            "schema": {
                "placeholder": "string",
                "loggedIn": "boolean",
                "localUser": { "user": { "default": "conceptd5e030d471d39150d148" }},
                "localRole": { "string":{
                    "derive": {
                        "properties": [ "localUser", "user.role" ],
                        "transform": [
                            { "select": { "property": "localUser" }},
                            { "get": "role" }
                        ]
                    }
                }},
                "localClient": "client",
                "audibleClients": { "array": "client" }
            },
            "mappings": {
                "loggedIn": [ "memory", "cauldron" ],
                "localUser": [ "localStorage", "cauldron" ],
                "localRole": [ "memory", "cauldron" ],
                "localClient": [ "localStorage", "cauldron" ],
                "audibleClients": [ "memory", "cauldron" ]
            },
            "actions": {
                "updateAudibleClients": {
                    "comment": "Optimzation: Run this as an action because the derived property would run once for each audioStream.",
                    "then": [
                        { "select": {
                            "concept": "audioStream",
                            "where": { "and": [
                                { "property": "muted", "equals": false },
                                { "property": "volume", "unequals": 0 }
                            ]}
                        }},
                        { "find": {
                            "concept": "client",
                            "where": {
                                "and": [
                                    { "property": "audioStream", "equals": "$lastTarget" },
                                    { "property": "local", "equals": false }
                                ]
                            }
                        }},
                        { "set": { "userManager.audibleClients": "$find" }}
                    ]
                },
                "addUser": {
                    "when": { "click": { "view": "addUserButton" }},
                    "then": [
                        "random",
                        { "new": {
                            "concept": "user",
                            "with": {
                                "name": "User $random$"
                            }
                        }},
                        { "set": { "userManager.localUser": "$target" }}
                    ]
                },
                "deleteUser": {
                    "when": { "click": { "view": "deleteUserButton" }},
                    "then": [
                        { "get": "userManager.localUser" },
                        { "select": "$get" },
                        "remove"
                    ]
                },
                "login": {
                    "when": { "click": { "view": "loginbutton" }},
                    "then": [
                        { "run": "reconnectClient" },
                        { "run": "newClient" },
                        "updateLocation"
                    ]
                },
                "reconnectClient": [
                    { "select": {
                        "concept": "client",
                        "where": {
                            "property": "local",
                            "equals": true
                        },
                        "as": "localClient",
                        "stopIfEmpty": true
                    }},
                    { "get": "audioStream" },
                    { "select": "$get" },
                    "updateAudioStream",
                    { "select": "$localClient" },
                    { "get": "cameraStream" },
                    { "select": "$get" },
                    "updateCameraStream",
                    { "set": { "userManager.loggedIn": true }}
                ],
                "newClient": [
                    { "exists": {
                        "concept": "client",
                        "where": {
                            "property": "local",
                            "equals": true
                        }
                    }},
                    { "where": {
                        "variable": "exists",
                        "equals": false,
                        "stopIfEmpty": true
                    }},
                    "newAudioStream",
                    "newCameraStream",
                    "randomColor",
                    { "get": "userManager.localUser" },
                    { "new": {
                        "concept": "client",
                        "with": {
                            "audioStream": "$newAudioStream",
                            "cameraStream": "$newCameraStream",
                            "color": "$randomColor",
                            "user": "$get"
                        },
                        "as": "newClient"
                    }},
                    { "select": "$newAudioStream" },
                    { "set": { "client": "$newClient" }},
                    { "select": "$newCameraStream" },
                    { "set": { "client": "$newClient" }},
                    { "set": { "userManager.loggedIn": true }},
                    { "set": { "userManager.localClient": "$newClient" }}
                ]
            }
        },
        "user": {
            "schema": {
                "name": "string",
                "role": { "string": { "default": "User" }},
                "local": { "boolean": {
                    "derive": {
                        "properties": [ "userManager.localUser" ],
                        "transform": [
                            { "eval": {
                                "property": "userManager.localUser",
                                "equals": "$target"
                            }}
                        ]
                    }
                }}
            },
            "mappings": {
                "local": [ "memory", "cauldron" ]
            }
        },
        "client": {
            "schema": {
                "name": { "string": { "default": "Client" }},
                "user": "user",
                "color": "string",
                "local": { "boolean": {
                    "derive": {
                        "properties": [ "userManager.localClient" ],
                        "transform": [
                            { "eval": {
                                "property": "userManager.localClient",
                                "equals": "$target"
                            }}
                        ]
                    }
                }},
                "location": "roomElement",
                "cameraStream": "cameraStream",
                "audioStream": "audioStream",
                "muted": "boolean",
                "logicalVolume": "number",
                "logicalDistance": "number",
                "distance": { "number": { "default": 10000 }},
                "lastSeen": "number",
                "timeout": "number",
                "clientTimedOut": { "boolean": {
                    "derive": {
                        "properties": [ "timeout" ],
                        "transform": [
                            { "eval": {
                                "and": [
                                    { "property": "timeout", "greaterThan": 60000 },
                                    { "property": "mockupClient", "equals": false }
                                ]
                            }}
                        ]
                    }
                }},
                "mockupClient": "boolean",
                "analyserVolume": "number",
                "analyserVolumeString": { "string": {
                    "derive": {
                        "properties": [ "analyserVolume" ],
                        "transform": [
                            { "switch": [
                                {
                                    "where": {
                                        "property": "analyserVolume",
                                        "equals": 0
                                    },
                                    "then": [
                                        { "set": {
                                            "variable": "result",
                                            "value": "silent"
                                        }}
                                    ]
                                },
                                {
                                    "where": {
                                        "property": "analyserVolume",
                                        "greaterThan": 50
                                    },
                                    "then": [
                                        { "set": {
                                            "variable": "result",
                                            "value": "loud"
                                        }}
                                    ]
                                },
                                {
                                    "where": {
                                        "property": "analyserVolume",
                                        "greaterThan": 25
                                    },
                                    "then": [
                                        { "set": {
                                            "variable": "result",
                                            "value": "medium"
                                        }}
                                    ]
                                },
                                {
                                    "then": [
                                        { "set": {
                                            "variable": "result",
                                            "value": "quiet"
                                        }}
                                    ]
                                }
                            ]},
                            { "concat": [ "$result" ]}
                        ]
                    }
                }}
            },
            "mappings": {
                "local": [ "memory", "cauldron" ],
                "logicalDistance": [ "memory", "cauldron" ],
                "distance": [ "memory", "cauldron" ],
                "timeout": [ "memory", "cauldron" ],
                "clientTimedOut": [ "memory", "cauldron" ],
                "analyserVolume": [ "memory", "cauldron" ],
                "analyserVolumeString": [ "memory", "cauldron" ]
            },
            "actions": {
                "selectLocalClient": [
                    { "select": {
                        "concept": "client",
                        "where": {
                            "property": "local",
                            "equals": true
                        },
                        "stopIfEmpty": true
                    }}
                ],
                "updateClientUser": {
                    "when": { "stateChanged": {
                        "concept": "userManager",
                        "property": "localUser"
                    }},
                    "then": [
                        "selectLocalClient",
                        { "set": { "user": "$currentValue" }}
                    ]
                },
                "updateLocation": {
                    "when": { "stateChanged": {
                        "concept": "meeting",
                        "property": "fullscreenRoom"
                    }},
                    "then": [
                        "selectLocalClient",
                        { "get": "meeting.fullscreenRoom" },
                        { "set": { "location": "$get" }}
                    ]
                },
                "updateLogicalDistance": {
                    "when": [
                        { "stateChanged": {
                            "concept": "client",
                            "property": "location"
                        }},
                        { "stateChanged": {
                            "concept": "userManager",
                            "property": "loggedIn"
                        }}
                    ],
                    "then": [
                        { "run": "resetTraversed" },
                        { "set": {
                            "variable": "distance",
                            "value": 0
                        }},
                        "selectfullscreenRoom",
                        "nextRecursionStep"
                    ]
                },
                "resetTraversed": [
                    { "select": "roomElement" },
                    { "set": { "traversed": false }}
                ],
                "nextRecursionStep": [
                    { "set": { "traversed": true }},
                    { "run": "setDistanceToClients" },
                    { "run": "recurseLogicalDistanceParent" },
                    { "run": "recurseLogicalDistanceChildren" }
                ],
                "setDistanceToClients": [
                    { "select": {
                        "concept": "client",
                        "where": {
                            "property": "location",
                            "equals": "$lastTarget"
                        },
                        "forEach": true,
                        "stopIfEmpty": true
                    }},
                    { "set": { "logicalDistance": "$distance" }}
                ],
                "recurseLogicalDistanceParent": [
                    { "select": {
                        "concept": "roomElement",
                        "where": {
                            "and": [
                                { "property": "childElements", "includes": "$lastTarget" },
                                { "property": "traversed", "equals": false }
                            ]
                        },
                        "forEach": true,
                        "stopIfEmpty": true
                    }},
                    { "increment": { "variable": "distance" }},
                    "nextRecursionStep"
                ],
                "recurseLogicalDistanceChildren": [
                    { "select": {
                        "concept": "roomElement",
                        "where": {
                            "and": [
                                { "property": "parentRoom", "equals": "$lastTarget" },
                                { "property": "traversed", "equals": false }
                            ]
                        },
                        "forEach": true,
                        "stopIfEmpty": true
                    }},
                    { "increment": { "variable": "distance" }},
                    "nextRecursionStep"
                ],
                "updateLastSeenAndTimeout": {
                    "when": { "interval": 60000 },
                    "then": [
                        { "run": "updateClientLastSeen" },
                        { "run": "updateClientTimeout" }
                    ]
                },
                "updateClientLastSeen": [
                    "selectLocalClient",
                    "timeEpoch",
                    { "set": { "lastSeen": "$timeEpoch" }}
                ],
                "updateClientTimeout": [
                    { "select": "client" },
                    { "get": "lastSeen" },
                    "timeEpoch",
                    { "calculate": "$timeEpoch$ - $get$" },
                    { "set": { "timeout": "$calculate" }}
                ],
                "removeClient": {
                    "when": { "click": "removeClientButton" },
                    "then": [
                        { "get": {
                            "property": "cameraStream",
                            "as": "cameraStream"
                        }},
                        { "get": {
                            "property": "audioStream",
                            "as": "audioStream"
                        }},
                        "remove",
                        { "select": "$cameraStream" },
                        "remove",
                        { "select": "$audioStream" },
                        "remove"
                    ]
                },
                "gotoClient": {
                    "when": { "click": { "view": "gotoOverlayButton" }},
                    "then": [
                        { "set": { "meeting.fullscreenRoom": "$target" }}
                    ]
                }
            }
        },
        "roomElement": {
            "schema": {
                "traversed": "boolean"
            },
            "mappings": {
                "traversed": [ "memory" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="Users Template" auto>&lt;dom-view-template>
    &lt;varv-template name="clientPanel">
        &lt;button class="login-button green" view="loginbutton" if="!loggedIn">Login&lt;/button>

        &lt;div class="sidebar-bubble" if="loggedIn">
            &lt;div class="sidebar-bubble-title">User&lt;/div>
            &lt;select value="{localUser}" title="Select a User">
                &lt;option concept="user" value="{concept::uuid}">{name}&lt;/option>
            &lt;/select>
            &lt;input property="localUser" value="{name}" title="Rename User">
            &lt;input property="localUser" value="{role}" title="Change Role">
            &lt;button view="addUserButton" class="sidebar-bubble-button" title="Add User">
                &lt;span class="m-ico">person_add&lt;/span>
            &lt;/button>
            &lt;button view="deleteUserButton" class="sidebar-bubble-button red" title="Delete User">
                &lt;span class="m-ico">person_remove&lt;/span>
            &lt;/button>
        &lt;/div>

        &lt;div class="sidebar-bubble" property="localClient" if="loggedIn">
            &lt;div class="sidebar-bubble-title" title="Your Current Client">Client&lt;/div>
            &lt;input value="{name}" title="Rename Client">
            &lt;label class="mute-button sidebar-bubble-button" title="Mute/Unmute Client">
                &lt;input type="checkbox" value="{muted}">
                &lt;span class="m-ico" if="muted">volume_off&lt;/span>
                &lt;span class="m-ico" if="!muted">volume_up&lt;/span>
            &lt;/label>
            &lt;template-ref template-name="clientChip">&lt;/template-ref>
        &lt;/div>

        &lt;div class="sidebar-bubble" if="loggedIn">
            &lt;div class="sidebar-bubble-title" title="Clients that You Can Hear">Audible&lt;/div>
            &lt;template-ref template-name="clientChip" property="audibleClients">&lt;/template-ref>
        &lt;/div>

        &lt;div class="sidebar-bubble" if="loggedIn">
            &lt;div class="sidebar-bubble-title" title="All Clients">All&lt;/div>
            &lt;template-ref template-name="clientChipLocation" concept="client" if="!local">&lt;/template-ref>
        &lt;/div>
    &lt;/varv-template>

    &lt;varv-template name="clientChip">
        &lt;div class="client" data-client-timed-out="{clientTimedOut}" style="background: {color}" data-client-analyser-volume="{analyserVolumeString}">
            &lt;div class="name" title="Client: {name}">&lt;span class="userName" property="user" title="User: {name}">{name}&lt;/span>: {name}&lt;/div>
            &lt;div class="audio-overlay m-ico" if="!muted">volume_up&lt;/div>
            &lt;div class="audio-overlay m-ico" if="muted">volume_off&lt;/div>
            &lt;button class="remove-overlay m-ico red" view="removeClientButton" if="clientTimedOut" title="Remove Client">delete&lt;/button>
        &lt;/div>
    &lt;/varv-template>

    &lt;varv-template name="clientChipLocation">
        &lt;div class="client" data-client-timed-out="{clientTimedOut}" style="background: {color}" if="!mockupClient">
            &lt;div class="name" title="Client: {name}">&lt;span class="userName" property="user" title="User: {name}">{name}&lt;/span>: {name}&lt;/div>
            &lt;div class="goto-overlay" property="location" view="gotoOverlayButton" title="Go to room “{name}”">{name}&lt;/div>
        &lt;/div>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Users Styles" auto>@mixin heading-font {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}



button.login-button {
    width: 100%;
    border-radius: 12px;
    padding: 12px 8px;
    font-size: 12px;
    letter-spacing: 1px;
}

.sidebar-bubble {
    width: calc(100% - 16px);
    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
    gap: 8px;
    align-items: center;
    background: #424242;
    border-radius: 12px;
    padding: 8px;
    overflow-x: hidden;
    overflow-y: scroll;

    &::-webkit-scrollbar {
        display: none;
    }

    .sidebar-bubble-title {
        @include heading-font;

        padding-top: 4px;
        padding-bottom: 4px;
        user-select: none;
        text-align: center;
    }

    .sidebar-bubble-button {
        font-size: 15px;
        user-select: none;
        width: 100%;
        height: 24px;
        padding: 0 8px;
        line-height: 24px;
        background: #636363;
        color: #fff;
        border-radius: 6px;
        text-align: center;
        cursor: pointer;
        border: none;
        display: block;

        &:hover {
            background: #848484;
        }
    }

    .mute-button {
        width: calc(100% - 16px);
        padding: 0 8px;

        >input {
            display: none;
        }
    }

    >input,
    select {
        width: 100%;
        padding: 4px 0;
        font-size: 10px;
        border-radius: 6px;
    }

    >input:not([type="checkbox"]) {
        width: calc(100% - 8px);
        padding: 4px;
    }

    .client {
        position: relative;
        width: 40px;
        height: 40px;
        background: #607d8b;
        border-radius: 6px;
        font-size: 10px;
        text-align: center;
        line-height: 40px;
        vertical-align: middle;
        user-select: none;
        text-overflow: ellipsis;
        padding: 4px;

        >.name {
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
            height: calc(100% - 4px);
            padding-top: 4px;
            line-height: 16px;

            >.userName {
                white-space: nowrap;
            }
        }

        &[data-client-timed-out="true"] {
            background: #cfd8dc !important;
        }

        .audio-overlay {
            display: block;
            position: absolute;
            background: #263238;
            border-radius: 50%;
            right: -4px;
            bottom: -4px;
            font-size: 10px;
            line-height: 20px;
            text-align: center;
            width: 20px;
            height: 20px;
            z-index: 1000;
            white-space: nowrap;
        }

        .remove-overlay {
            display: block;
            position: absolute;
            background: #ef9a9a;
            border-radius: 50%;
            right: -4px;
            bottom: -4px;
            font-size: 10px;
            line-height: 20px;
            text-align: center;
            width: 20px;
            height: 20px;
            z-index: 1000;
            padding: 0;
            white-space: nowrap;
            cursor: pointer;
        }

        .goto-overlay {
            display: block;
            position: absolute;
            background: #263238;
            border-radius: 10px;
            right: -4px;
            bottom: -4px;
            font-size: 10px;
            line-height: 20px;
            height: 20px;
            z-index: 1000;
            white-space: nowrap;
            padding: 0 6px;
            max-width: calc(100% - 4px);
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }

        &[data-client-analyser-volume="quiet"] {
            outline: solid 2px green;
        }

        &[data-client-analyser-volume="medium"] {
            outline: solid 3px orange;
        }

        &[data-client-analyser-volume="loud"] {
            outline: solid 4px red;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="Streams" id="Streams"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Audio, video, and screen streaming.",
    "dependencies": [
        "#StreamTools"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Streaming Concepts" auto>{
    "concepts": {
        "audioStream": {
            "schema": {
                "id": "string",
                "client": "client",
                "muted": "boolean",
                "volume": { "number": { "default": 1.0 }},
                "audioFilter": { "string": { "default": "none" }}
            },
            "mappings": {
                "muted": [ "memory", "cauldron" ],
                "volume": [ "memory", "cauldron" ],
                "audioFilter": [ "memory", "cauldron" ]
            },
            "actions": {
                "newAudioStream": [
                    "getAudioStream",
                    { "new": {
                        "concept": "audioStream",
                        "with": { "id": "$getAudioStream" },
                        "select": false,
                        "as": "newAudioStream"
                    }}
                ],
                "updateAudioStream": [
                    "getAudioStream",
                    { "set": { "id": "$getAudioStream" }}
                ]
            }
        },
        "cameraStream": {
            "schema": {
                "id": "string",
                "client": "client"
            },
            "actions": {
                "newCameraStream": [
                    "getCameraStream",
                    { "new": {
                        "concept": "cameraStream",
                        "with": { "id": "$getCameraStream" },
                        "select": false,
                        "as": "newCameraStream"
                    }}
                ],
                "updateCameraStream": [
                    "getCameraStream",
                    { "set": { "id": "$getCameraStream" }}
                ]
            }
        },
        "audioManager": {
            "schema": {
                "placeholder": "string",
                "pauseAudioRouting": "boolean"
            },
            "mappings": {
                "pauseAudioRouting": [ "memory", "cauldron" ]
            },
            "actions": {
                "updateAnalyserVolume": {
                    "when": { "interval": 1000 },
                    "then": [
                        { "select": "audioStream" },
                        { "get": {
                            "property": "id",
                            "as": "streamId"
                        }},
                        { "select": {
                            "concept": "client",
                            "where": { "and": [
                                { "property": "audioStream", "equals": "$lastTarget" },
                                { "property": "mockupClient", "equals": false }
                            ]},
                            "forEach": true
                        }},
                        { "volume": { "stream": "$streamId" }},
                        { "set": { "analyserVolume": "$volume" }}
                    ]
                },
                "selectOriginalAudioStream": [
                    { "select": {
                        "target": "$originalAudioStream",
                        "forEach": true
                    }}
                ],
                "selectClient": [
                    { "select": {
                        "target": "$client",
                        "forEach": true
                    }}
                ],
                "selectCurrentRoom": [
                    { "select": {
                        "target": "$currentRoom",
                        "forEach": true
                    }}
                ],
                "selectToolManager": [
                    { "select": {
                        "target": "$toolManager",
                        "forEach": true
                    }}
                ],
                "updateAudio": {
                    "when": { "interval": 1000 },
                    "then": [
                        { "where": {
                            "property": "audioManager.pauseAudioRouting",
                            "equals": false,
                            "stopIfEmpty": true
                        }},
                        { "select": {
                            "concept": "audioStream",
                            "stopIfEmpty": true
                        }},
                        { "set": { "variable": "originalAudioStream", "value": "$target" }},
                        { "get": { "property": "client", "as": "client" }},
                        { "get": { "property": "meeting.fullscreenRoom", "as": "currentRoom" }},
                        { "get": { "property": "meeting.toolManager", "as": "toolManager" }},
                        { "run": "mutedRootConnectionOptimized" },
                        { "run": "volumeRootConnectionOptimized" },
                        { "run": "audioFilterRootConnectionOptimized" },
                        { "run": "updateAudibleClients" }
                    ]
                },
                "mutedRootConnectionOptimized": [
                    { "run": "mutedRootConnection" }
                ],
                "volumeRootConnectionOptimized": [
                    { "where": {
                        "property": "muted",
                        "equals": false,
                        "stopIfEmpty": true
                    }},
                    { "run": "volumeRootConnection" }
                ],
                "audioFilterRootConnectionOptimized": [
                    { "where": {
                        "property": "muted",
                        "equals": false,
                        "stopIfEmpty": true
                    }},
                    { "where": {
                        "property": "volume",
                        "unequals": 0,
                        "stopIfEmpty": true
                    }},
                    "selectClient",
                    { "where": {
                        "property": "mockupClient",
                        "equals": false,
                        "stopIfEmpty": true
                    }},
                    "selectOriginalAudioStream",
                    { "run": "audioFilterRootConnection" }
                ]
            }
        },
        "toolManager": {
            "schema": {
                "placeholder": "string"
            }
        },
        "meeting": {
            "schema": {
                "toolManager": "toolManager"
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="Streaming Template" auto>&lt;dom-view-template>
    &lt;varv-template name="audioStreams">
        &lt;div class="audioStreams" style="display: none;">
            &lt;video concept="audioStream" data-stream="{id}" data-stream-type="audio" data-muted="{muted}" data-volume="{volume}" data-filter="{audioFilter}">&lt;/video>
        &lt;/div>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="Streaming Muted Routing" auto>{
  "rootConnections": {
    "muted": {
      "position": {
        "x": 2791.7000579833984,
        "y": 2800.893732070923
      },
      "connection": "ZmEA2h52Xn"
    }
  },
  "nodes": {
    "cOws1LEgka": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2557.0999603271484,
        "y": 3312.106267929077
      },
      "type": "muted"
    },
    "Sw0B1x9Vm9": {
      "nodeType": "ValueNode",
      "value": false,
      "position": {
        "x": 2760.7000579833984,
        "y": 3315.893732070923
      },
      "type": "muted"
    },
    "rYSeeaKep4": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientInDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 2,
          "connection": "cOws1LEgka"
        },
        {
          "comparator": "lessThan",
          "value": 2,
          "connection": "Sw0B1x9Vm9"
        }
      ],
      "position": {
        "x": 2584.7000579833984,
        "y": 3099.7061824798584
      }
    },
    "4GpHRhnuOX": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2857.9000396728516,
        "y": 3104.7062435150146
      },
      "type": "muted"
    },
    "ZmEA2h52Xn": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientMuted",
      "concept": "client",
      "property": "muted",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "rYSeeaKep4"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "4GpHRhnuOX"
        }
      ],
      "position": {
        "x": 2704.7000579833984,
        "y": 2895.893732070923
      }
    }
  },
  "unused": []
}</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="Streaming Volume Routing" auto>{
  "rootConnections": {
    "volume": {
      "position": {
        "x": 2787.25,
        "y": 2925.5
      },
      "connection": "LgEjFUx25k"
    }
  },
  "nodes": {
    "NJze4UOYlA": {
      "nodeType": "ValueNode",
      "value": 0,
      "position": {
        "x": 2637.25,
        "y": 3279.5
      },
      "type": "volume"
    },
    "S9gcODgW3g": {
      "nodeType": "ValueNode",
      "value": 0.5,
      "position": {
        "x": 2785.25,
        "y": 3278.5
      },
      "type": "volume"
    },
    "2bTYSJ6bNB": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 2931.25,
        "y": 3279.5
      },
      "type": "volume"
    },
    "LgEjFUx25k": {
      "nodeType": "DecisionNode",
      "name": "volumeClientLogicalDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 3,
      "decisions": [
        {
          "comparator": "greaterThan",
          "value": 1,
          "connection": "NJze4UOYlA"
        },
        {
          "comparator": "equals",
          "value": 1,
          "connection": "S9gcODgW3g"
        },
        {
          "comparator": "equals",
          "value": 0,
          "connection": "2bTYSJ6bNB"
        }
      ],
      "position": {
        "x": 2646.25,
        "y": 3042.5
      }
    }
  },
  "unused": []
}</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="Streaming Filter Routing" auto>{
  "rootConnections": {
    "audioFilter": {
      "position": {
        "x": 2680.25,
        "y": 2811.5
      },
      "connection": "1kWhmMpUFO"
    }
  },
  "nodes": {
    "JlMvMkXExA": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2598.25,
        "y": 3164.5
      },
      "type": "audioFilter"
    },
    "FUf0416U07": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2776.25,
        "y": 3402.5
      },
      "type": "audioFilter"
    },
    "rScKXNSFIH": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2948.25,
        "y": 3401.5
      },
      "type": "audioFilter"
    },
    "C5E6P2PNS1": {
      "nodeType": "DecisionNode",
      "name": "filterLocationHasFilter",
      "concept": "currentRoom",
      "property": "audioFilter",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": "",
          "connection": "FUf0416U07"
        },
        {
          "comparator": "unequals",
          "value": "",
          "connection": "rScKXNSFIH"
        }
      ],
      "position": {
        "x": 2763.25,
        "y": 3164.5
      }
    },
    "1kWhmMpUFO": {
      "nodeType": "DecisionNode",
      "name": "filterClientLogicalDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 1,
          "connection": "JlMvMkXExA"
        },
        {
          "comparator": "equals",
          "value": 0,
          "connection": "C5E6P2PNS1"
        }
      ],
      "position": {
        "x": 2596.25,
        "y": 2928.5
      }
    }
  },
  "unused": []
}</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Chat" name="Chat"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Chat funtionality.",
    "dependencies": [
        "#TimeTools"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Chat Concepts" auto>{
    "concepts": {
        "chatManager": {
            "schema": {
                "placeholder": "string"
            },
            "actions": {
                "newChat": [
                    { "new": {
                        "concept": "chat",
                        "select": false,
                        "forEach": true,
                        "as": "newChat"
                    }}
                ],
                "deleteChat": [
                    { "run": "cleanupMessages" },
                    "remove"
                ],
                "cleanupMessages": [
                    { "items": "messages" },
                    { "select": "$items" },
                    "remove"
                ]
            }
        },
        "chat": {
            "schema": {
                "name": { "string": { "default": "New Chat" }},
                "messages": { "array": "message" },
                "newMessageText": "string"
            },
            "mappings": {
                "newMessageText": [ "memory", "cauldron" ]
            },
            "actions": {
                "sendMessage": {
                    "when": [
                        { "click": { "view": "send-message-button" }},
                        { "key": { "key": "Enter", "focus": { "view": "messageInput" }}}
                    ],
                    "then": [
                        { "get": {
                            "property": "userManager.localUser",
                            "as": "localUser"
                        }},
                        { "get": {
                            "property": "newMessageText",
                            "as": "content"
                        }},
                        "timeEpoch",
                        { "new": {
                            "concept": "message",
                            "with": {
                                "user": "$localUser",
                                "time": "$timeEpoch",
                                "content": "$content"
                            },
                            "forEach": true,
                            "select": false
                        }},
                        { "prepend": {
                            "to": { "property": "messages" },
                            "item": "$new"
                        }},
                        { "set": { "newMessageText": "" }}
                    ]
                }
            }
        },
        "message": {
            "schema": {
                "user": "user",
                "local": { "boolean": {
                    "derive": {
                        "properties": [ "user", "userManager.localUser" ],
                        "transform": [
                            { "get": "userManager.localUser" },
                            { "eval": {
                                "property": "user",
                                "equals": "$get"
                            }}
                        ]
                    }
                }},
                "time": "number",
                "timeString": { "string": {
                    "derive": {
                        "properties": [ "time" ],
                        "transform": [
                            { "get": "time" },
                            { "epochToTime": { "epoch": "$get" }}
                        ]
                    }
                }},
                "dateString": { "string": {
                    "derive": {
                        "properties": [ "time" ],
                        "transform": [
                            { "get": "time" },
                            { "epochToDate": { "epoch": "$get" }}
                        ]
                    }
                }},
                "content": "string"
            },
            "mappings": {
                "local": [ "memory", "cauldron" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="Chat Template" auto>&lt;dom-view-template>
    &lt;varv-template name="chat">
        &lt;div class="chat">
            &lt;div class="messages">
                &lt;template-ref template-name="message" property="messages">&lt;/template-ref>
            &lt;/div>
            &lt;div class="new-message">
                &lt;input value="{newMessageText}" view="messageInput">
                &lt;button view="send-message-button">SEND&lt;/button>
            &lt;/div>
        &lt;/div>
    &lt;/varv-template>

    &lt;varv-template name="message">
        &lt;div class="message" data-local="{local}">
            &lt;div class="user" property="user">{name}&lt;/div>
            &lt;div class="message-content">
                {content}
                &lt;div class="time" title="{dateString}">{timeString}&lt;/div>
            &lt;/div>
        &lt;/div>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Chat Style" auto>@mixin heading-font {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}



.chat {
    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
    background: #333333;

    .messages {
        flex: 1 1 auto;
        display: flex;
        flex-direction: column-reverse;
        flex-wrap: nowrap;
        align-items: flex-start;
        gap: 10px;
        padding: 16px;
        overflow-x: hidden;

        .message {
            flex: 0 0 auto;
            position: relative;
            max-width: 80%;
            margin-bottom: 10px;

            .message-content {
                background: #F2F2F2;
                border-radius: 16px 16px 16px 2px;
                padding: 8px 12px;
            }

            .user {
                @include heading-font;
                font-size: 9px;
                position: absolute;
                bottom: -13px;
                left: 4px;
                color: #AAAAAA;
                white-space: nowrap;
            }

            .time {
                @include heading-font;
                font-size: 9px;
                color: #848484;
                margin-left: 4px;
                text-align: end;
                display: inline;
            }

            &[data-local="true"] {
                align-self: flex-end;

                .message-content {
                    border-radius: 16px 16px 2px 16px;
                }

                .user {
                    left: inherit;
                    right: 4px;
                }
            }
        }
    }

    .new-message {
        flex: 0 0 32px;
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 8px;
        padding: 8px;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Element" name="Element"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The abstract element concept.",
    "dependencies": [],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Element Concepts" auto>{
    "concepts": {
        "element": {
            "schema": {
                "parentRoom": "roomElement",
                "top": { "number": { "default": 100 }},
                "left": { "number": { "default": 100 }},
                "width": { "number": { "default": 200 }},
                "height": { "number": { "default": 150 }},
                "opacity": { "number": { "default": 1 }},
                "zIndex": "number",
                "elementType": { "string": {
                    "derive": { "transform": [ "getType" ] }
                }},
                "selected": "boolean",
                "inToolPanel": "boolean"
            },
            "mappings": {
                "selected": [ "memory", "cauldron" ]
            },
            "actions": {
                "elementDrop": [
                    "getType",
                    { "concat": [ "$getType", "Drop" ]},
                    { "run": "$concat" }
                ],
                "elementCleanup": [
                    "getType",
                    { "concat": [ "$getType", "Cleanup" ]},
                    { "switch": [
                        {
                            "where": { "variable": "getType", "equals": "cameraContent" },
                            "then": { "run": "cameraContentCleanup" }
                        },
                        {
                            "where": { "variable": "getType", "equals": "screenContent" },
                            "then": { "run": "screenContentCleanup" }
                        },
                        {
                            "where": { "variable": "getType", "equals": "regularRoom" },
                            "then": { "run": "regularRoomCleanup" }
                        },
                        {
                            "where": { "variable": "getType", "equals": "layoutTemplateTool" },
                            "then": { "run": "layoutTemplateToolCleanup" }
                        }
                    ]},
                    "remove"
                ],
                "selectElement": [
                    { "where": {
                        "property": "selected",
                        "equals": false,
                        "stopIfEmpty": true
                    }},
                    { "run": "deselectElements" },
                    "checkInfullscreenRoom",
                    { "set": { "selected": true }},
                    { "set": { "meeting.selectedElement": "$target" }}
                ],
                "deselectElements": [
                    { "select": "element" },
                    { "set": { "selected": false }},
                    { "set": { "meeting.selectedElement": "" }}
                ],
                "selectparentRoom": [
                    { "get": "parentRoom" },
                    { "select": {
                        "target": "$get",
                        "stopIfEmpty": true
                    }}
                ],
                "selectselectedElement": [
                    { "select": {
                        "concept": "element",
                        "where": {
                            "property": "selected",
                            "equals": true
                        },
                        "stopIfEmpty": true
                    }}
                ],
                "deleteElement": {
                    "when": { "click": {
                        "view": "deleteElementButton",
                        "exactConceptMatch": true
                    }},
                    "then": [
                        "checkInfullscreenRoom",
                        "elementCleanup"
                    ]
                }
            }
        },
        "meeting": {
            "actions": {
                "selectElementOnClick": {
                    "comment": "Do this in the meeting concept as it otherwise gets executed multiple times for each injected element type.",
                    "when": { "click": { "concept": "element" }},
                    "then": [ "selectElement" ]
                }
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="Element Template" auto>&lt;dom-view-template>
    &lt;varv-template name="element">
        &lt;div class="element {elementType}" style="left: {left}px; top: {top}px; width: {width}px; height: {height}px; opacity: {opacity}; z-index: {zIndex}" tabindex=0 data-selected="{selected}" data-is-being-moved="{isBeingMoved}" data-is-resizing="{isResizing}" data-is-drop-target="{isDropTarget}" data-is-content="{isContent}" data-is-room="{isRoom}" data-is-tool="{isTool}">
            &lt;div class="element-body">
                &lt;template-ref template-name="{elementType}Body">&lt;/template-ref>
            &lt;/div>
            &lt;div class="move-handle" view="moveHandle" if="concept movableMixin">&lt;/div>
            &lt;div class="resize-handle" view="resizeHandle" if="concept resizableMixin">&lt;/div>
        &lt;/div>
    &lt;/varv-template>

    &lt;varv-template name="elementBody">&lt;/varv-template>

    &lt;varv-template name="elementOptions">
        &lt;button class="red" view="deleteElementButton">Delete Element&lt;/button>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Element Style" auto>@mixin heading-font {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}



.element {
    position: absolute;
    background: #636363;
    border: 1px solid #848484;
    border-radius: 12px;
    transition: box-shadow 250ms ease-in-out;
    box-sizing: border-box;

    .move-handle {
        position: absolute;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
        cursor: move;
    }

    .resize-handle {
        position: absolute;
        background: #848484;
        border-top-left-radius: 6px;
        border-bottom-right-radius: 8px;
        bottom: 0;
        right: 0;
        width: 16px;
        height: 16px;
        cursor: nwse-resize;

        &:hover {
            background: #CCCCCC;
        }
    }

    .element-title {
        @include heading-font;

        position: absolute;
        top: 0;
        left: 0;
        height: 16px;

        background: #848484;
        color: #fff;

        border-bottom-right-radius: 6px;
        border-top-left-radius: 8px;

        line-height: 16px;
        padding: 2px 8px;
        user-select: none;

        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;

        max-width: calc(100% - 16px);

        z-index: 10;

        &:empty {
            display: none;
        }
    }

    .element-body {
        width: 100%;
        height: 100%;
        user-select: none;
        position: relative;
        overflow: hidden;
        border-radius: 11px;
    }
}

.element:hover {
    outline: 1px solid rgba(220, 220, 220, 0.5);
}

.element[data-selected="true"] {
    outline: 2px solid #dcdcdc;
    z-index: 100 !important;
}

.element[data-is-being-moved="true"] {
    z-index: 100 !important;
}

.element[data-is-resizing="true"] {
    z-index: 100 !important;
}

@keyframes wiggle {
    0% {
        transform: rotate(0deg);
    }

    25% {
        transform: rotate(0.3deg);
    }

    50% {
        transform: rotate(0deg);
    }

    75% {
        transform: rotate(-0.3deg);
    }

    100% {
        transform: rotate(0deg);
    }
}

.meeting[data-layout-mode="true"] {
    .content>.element {
        animation: wiggle 300ms infinite;
        box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.45);

        &:hover {
            box-shadow: 0 0 24px 0 rgba(0, 0, 0, 0.45);
        }
    }
}

.meeting[data-layout-mode="false"] {
    .move-handle,
    .resize-handle {
        display: none;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="RoomElement" id="RoomElement"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The abstract room concept.",
    "dependencies": [
        "#FindAction",
        "#Element",
        "#MovableMixin",
        "#ResizableMixin",
        "#DroppableMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="RoomElement Concepts" auto>{
    "concepts": {
        "roomElement": {
            "schema": {
                "isRoom": { "boolean": { "default": true }},
                "isContent": { "boolean": { "default": false }},
                "isTool": { "boolean": { "default": false }},
                "name": { "string": { "default": "New Room" }},
                "childElements": { "array": {
                    "items": "element",
                    "derive": {
                        "concepts": [
                            "regularRoom",

                            "cameraContent",
                            "screenContent",
                            "imageContent",
                            "noteContent",
                            "videoContent",
                            "sketchContent",
                            "chatContent",
                            "avatarContent",

                            "gridTool",
                            "speakerViewTool",
                            "layoutTemplateTool",
                            "highlightTool",
                            "cameraShakerTool",
                            "recordingTool",
                            "roomRecordingTool",
                            "doorwayTool",
                            "proximityBasedAudioTool",
                            "podiumTool",
                            "whisperTool",
                            "broadcastTool",
                            "templateStoreTool"
                        ],
                        "properties": [
                            "regularRoom.parentRoom",

                            "cameraContent.parentRoom",
                            "screenContent.parentRoom",
                            "imageContent.parentRoom",
                            "noteContent.parentRoom",
                            "videoContent.parentRoom",
                            "sketchContent.parentRoom",
                            "chatContent.parentRoom",
                            "avatarContent.parentRoom",

                            "gridTool.parentRoom",
                            "speakerViewTool.parentRoom",
                            "layoutTemplateTool.parentRoom",
                            "highlightTool.parentRoom",
                            "cameraShakerTool.parentRoom",
                            "recordingTool.parentRoom",
                            "roomRecordingTool.parentRoom",
                            "doorwayTool.parentRoom",
                            "proximityBasedAudioTool.parentRoom",
                            "podiumTool.parentRoom",
                            "whisperTool.parentRoom",
                            "broadcastTool.parentRoom",
                            "templateStoreTool.parentRoom"
                        ],
                        "transform": [
                            { "find": {
                                "concept": "element",
                                "where": {
                                    "property": "parentRoom",
                                    "equals": "$lastTarget"
                                }
                            }}
                        ]
                    }
                }},
                "clients": { "array": {
                    "items": "client",
                    "derive": {
                        "concepts": [ "client" ],
                        "properties": [ "client.location" ],
                        "transform": [
                            { "find": {
                                "concept": "client",
                                "where": {
                                    "property": "location",
                                    "equals": "$lastTarget"
                                }
                            }}
                        ]
                    }
                }},
                "hasClients": { "boolean": {
                    "derive": {
                        "properties": [ "clients" ],
                        "transform": [
                            { "length": "clients" },
                            { "eval": {
                                "variable": "length",
                                "unequals": 0
                            }}
                        ]
                    }
                }},
                "isInFullscreenRoom": { "boolean": {
                    "derive": {
                        "properties": [ "parentRoom", "meeting.fullscreenRoom" ],
                        "transform": [
                            { "get": "meeting.fullscreenRoom" },
                            { "eval": {
                                "property": "parentRoom",
                                "equals": "$get"
                            }}
                        ]
                    }
                }},
                "audioFilter": "string"
            },
            "actions": {
                "roomElementDrop": [
                    "moveElementInRoom"
                ],
                "roomElementCleanup": [
                    { "items": "childElements" },
                    { "select": "$items" },
                    "elementCleanup"
                ],
                "moveElementInRoom": [
                    { "select": "$movedElement" },
                    { "set": {
                        "property": "parentRoom",
                        "value": "$targetElement"
                    }}
                ],
                "moveElementOutOfRoom": [
                    { "select": "$movedElement" },
                    { "get": {
                        "property": "parentRoom",
                        "as": "oldParent"
                    }},
                    { "select": "$oldParent" },
                    { "get": {
                        "property": "parentRoom",
                        "as": "newParent"
                    }},
                    { "select": "$movedElement" },
                    { "set": {
                        "property": "parentRoom",
                        "value": "$newParent"
                    }},
                    { "run": "deselectElements" }
                ],
                "moveElementOutOfRoomReaction": [
                    "selectselectedElement",
                    { "get": {
                        "property": "meeting.rootRoom",
                        "as": "rootRoom"
                    }},
                    { "where": {
                        "property": "parentRoom",
                        "unequals": "$rootRoom",
                        "stopIfEmpty": true
                    }},
                    { "set": {
                        "variable": "movedElement",
                        "value": "$target"
                    }},
                    "moveElementOutOfRoom"
                ]
            },
            "extensions": { "inject": [ "element" ] }
        },
        "meeting": {
            "actions": {
                "moveElementOutOfRoomReaction": {
                    "comment": "Moved to the meeting as otherwise injection causes the action to be run multiple times.",
                    "when": { "click": { "view": "moveElementOutButton" }},
                    "then": "roomElement.moveElementOutOfRoomReaction"
                }
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="RoomElement Template" auto>&lt;dom-view-template>
    &lt;varv-template name="roomElementBody">&lt;/varv-template>

    &lt;varv-template name="roomElementOptions">
        &lt;label>
            Name:
            &lt;input value="{name}">
        &lt;/label>
        &lt;label>
            Audio Filter:
            &lt;input value="{audioFilter}">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="stackableMixinOptions">&lt;/template-ref>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="elementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="RoomElement Style" auto>.element[data-is-room="true"] .element-preview>* {
    pointer-events: none;
}

.element[data-is-room="true"] {
    border: 4px solid #848484;

    >.element-body {
        box-shadow: inset 0px 0px 8px 0px #333333;
        background: #535353;
        outline: 2px solid #848484;
        border-radius: 8px;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ContentElement" name="ContentElement"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The abstract content element concept.",
    "dependencies": [
        "#Element",
        "#MovableMixin",
        "#ResizableMixin",
        "#DroppableMixin",
        "#OpacityMixin",
        "#StackableMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ContentElement Concepts" auto>{
    "concepts": {
        "contentElement": {
            "schema": {
                "isRoom": { "boolean": { "default": false }},
                "isContent": { "boolean": { "default": true }},
                "isTool": { "boolean": { "default": false }}
            },
            "extensions": { "inject": [ "element" ] }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="ContentElement Template" auto>&lt;dom-view-template>
    &lt;varv-template name="contentElementBody">&lt;/varv-template>

    &lt;varv-template name="contentElementOptions">
        &lt;template-ref template-name="opacityMixinOptions">&lt;/template-ref>
        &lt;template-ref template-name="stackableMixinOptions">&lt;/template-ref>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="elementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="ContentElement Style" auto>.element[data-is-content="true"] .placeholder-icon {
    position: absolute;
    width: 32px;
    height: 32px;
    left: calc(50% - 16px);
    top: calc(50% - 16px);
    font-size: 32px;
    z-index: -1;
    color: #aaa;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="ToolElement" id="ToolElement"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The abstract tool concept.",
    "dependencies": [
        "#Element",
        "#MovableMixin",
        "#ResizableMixin",
        "#DroppableMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ToolElement Concepts" auto>{
    "concepts": {
        "toolElement": {
            "schema": {
                "isRoom": { "boolean": { "default": false }},
                "isContent": { "boolean": { "default": false }},
                "isTool": { "boolean": { "default": true }},
                "inToolPanel": { "boolean": { "default": true }}
            },
            "extensions": { "inject": [ "element" ] }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="ToolElement Template" auto>&lt;dom-view-template>
    &lt;varv-template name="toolElementBody">&lt;/varv-template>

    &lt;varv-template name="toolElementOptions">
        &lt;label>
            Move to Tool Panel:
            &lt;input value="{inToolPanel}" type="checkbox">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="elementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="ToolElement Style" auto>@mixin heading-font {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}



.element[data-is-tool="true"]>.element-body {
    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
    overflow-y: auto;
    width: calc(100% - 16px);
    height: calc(100% - 16px);
    padding: 8px;
    gap: 8px;
    background: #212121;

    &::-webkit-scrollbar {
        display: none;
    }

    >input,
    >button,
    >label {
        display: flex;
        flex: 1 0 24px;
        min-height: 32px;
        white-space: initial;
        text-align: center;
        justify-content: center;
        align-items: center;
    }

    .tool-title {
        @include heading-font;
        text-align: center;
        display: block;
        width: 100%;
        font-size: 14px;
        letter-spacing: 1px;
        color: #CCCCCC;
        height: 24px;
        line-height: 24px;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><DIV name="Mixins"><WPM-PACKAGE name="MovableMixin" id="MovableMixin"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Mixin for making elements movable.",
    "dependencies": [
        "#Element"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="MovableMixin Concept" auto>{
    "concepts": {
        "meeting": {
            "actions": {
                "move": {
                    "when": { "mousemove": {
                        "property": "fullscreenRoom"
                    }},
                    "then": [
                        { "select": {
                            "concept": "movableMixin",
                            "where": {
                                "property": "isBeingMoved",
                                "equals": true
                            },
                            "stopIfEmpty": true
                        }},
                        { "get": "movingOffsetLeft" },
                        { "calculate": { "expression": "$x$ - $get$", "as": "x" }},
                        { "get": "movingOffsetTop" },
                        { "calculate": { "expression": "$y$ - $get$", "as": "y" }},
                        { "set": { "left": "$x"}},
                        { "set": { "top": "$y"}}
                    ]
                }
            }
        },
        "movableMixin": {
            "schema": {
                "isBeingMoved": "boolean",
                "movingOffsetLeft": "number",
                "movingOffsetTop": "number"
            },
            "mappings": {
                "isBeingMoved": [ "memory", "cauldron" ],
                "movingOffsetLeft": [ "memory", "cauldron" ],
                "movingOffsetTop": [ "memory", "cauldron" ]
            },
            "actions": {
                "beginMove": {
                    "when": { "mousedown": {
                        "view": "moveHandle",
                        "exactConceptMatch": true
                    }},
                    "then": [
                        "checkInfullscreenRoom",
                        { "set": { "isBeingMoved": true }},
                        { "get": "left" },
                        { "calculate": "$x$ - $get$" },
                        { "set": { "movingOffsetLeft": "$calculate" }},
                        { "get": "top" },
                        { "calculate": "$y$ - $get$" },
                        { "set": { "movingOffsetTop": "$calculate" }}
                    ]
                },
                "endMove": {
                    "when": { "mouseup": {
                        "exactConceptMatch": true
                    }},
                    "then": [
                        "checkInfullscreenRoom",
                        { "run": "moveEndDrop" },
                        { "select": {
                            "concept": "movableMixin",
                            "stopIfEmpty": true
                        }},
                        { "set": { "isBeingMoved": false }}
                    ]
                }
            }
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ResizableMixin" name="ResizableMixin"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Mixins for making elements resizable.",
    "dependencies": [
        "#Element"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ResizableMixin Concept" auto>{
    "concepts": {
        "meeting": {
            "actions": {
                "resize": {
                    "when": { "mousemove": {
                        "property": "fullscreenRoom"
                    }},
                    "then": [
                        { "select": {
                            "concept": "resizableMixin",
                            "where": { "property": "isResizing", "equals": true },
                            "stopIfEmpty": true
                        }},
                        { "get": { "property": "resizeInitialX", "as": "initialX" }},
                        { "get": { "property": "resizeInitialWidth", "as": "width" }},
                        { "calculate": { "expression": "$width$ + ( $x$ - $initialX$ )", "as": "w" }},
                        { "get": { "property": "resizeInitialY", "as": "initialY" }},
                        { "get": { "property": "resizeInitialHeight", "as": "height" }},
                        { "calculate": { "expression": "$height$ + ( $y$ - $initialY$ )", "as": "h" }},
                        { "set": { "width": "$w"}},
                        { "set": { "height": "$h"}}
                    ]
                }
            }
        },
        "resizableMixin": {
            "schema": {
                "isResizing": "boolean",
                "resizeInitialX": "number",
                "resizeInitialY": "number",
                "resizeInitialWidth": "number",
                "resizeInitialHeight": "number"
            },
            "mappings": {
                "isResizing": [ "memory", "cauldron" ],
                "resizeInitialX": [ "memory", "cauldron" ],
                "resizeInitialY": [ "memory", "cauldron" ],
                "resizeInitialWidth": [ "memory", "cauldron" ],
                "resizeInitialHeight": [ "memory", "cauldron" ]
            },
            "actions": {
                "beginResize": {
                    "when": { "mousedown": {
                        "view": "resizeHandle",
                        "exactConceptMatch": true
                    }},
                    "then": [
                        "checkInfullscreenRoom",
                        { "set": { "isResizing": true }},
                        { "set": { "resizeInitialX": "$x" }},
                        { "set": { "resizeInitialY": "$y" }},
                        { "get": "width" },
                        { "set": { "resizeInitialWidth": "$get" }},
                        { "get": "height" },
                        { "set": { "resizeInitialHeight": "$get" }}
                    ]
                },
                "endResize": {
                    "when": { "mouseup": {
                        "exactConceptMatch": true
                    }},
                    "then": [
                        { "select": {
                            "concept": "resizableMixin",
                            "stopIfEmpty": true
                        }},
                        { "set": { "isResizing": false }}
                    ]
                }
            }
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="DroppableMixin" name="DroppableMixin"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Mixin for making elements droppable into each other.",
    "dependencies": [
        "#WindowTools",
        "#Element",
        "#MovableMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="DroppableMixin Concept" auto>{
    "concepts": {
        "droppableMixin": {
            "schema": {
                "isDropTarget": "boolean"
            },
            "mappings": {
                "isDropTarget": [ "memory", "cauldron" ]
            },
            "actions": {
                "moveEndDrop": {
                    "then": [
                        "checkCtrl",
                        "checkInfullscreenRoom",
                        { "limit": 1 },
                        { "run": "drop" },
                        "resetHovered"
                    ]
                },
                "moveDrop": {
                    "comment": "Optimization: Use interval here for better performance as mouse move is too fast.",
                    "when": { "interval": 500 },
                    "then": [
                        { "select": {
                            "concept": "droppableMixin",
                            "where": {
                                "property": "isBeingMoved",
                                "equals": true
                            },
                            "stopIfEmpty": true
                        }},
                        { "run": "resetHovered" },
                        "checkCtrl",
                        "checkHovered"
                    ]
                },
                "resetHovered": [
                    { "select": {
                        "concept": "droppableMixin",
                        "stopIfEmpty": true
                    }},
                    { "set": { "isDropTarget": false }}
                ],
                "checkHovered": [
                    { "select": {
                        "concept": "droppableMixin",
                        "where": {
                            "property": "isBeingMoved",
                            "equals": false
                        },
                        "stopIfEmpty": true
                    }},
                    "checkInfullscreenRoom",
                    "cursorPosition",
                    "correctCursorPosition",
                    { "where": {
                        "and": [
                            { "variable": "x", "greaterThan": "$target.left" },
                            { "variable": "x", "lessThan": { "calculate": "$target.left$+$target.width$" } },
                            { "variable": "y", "greaterThan": { "calculate": "$target.top$" }},
                            { "variable": "y", "lessThan": { "calculate": "$target.top$+$target.height$" }},
                            { "property": "inToolPanel", "equals": false }
                        ],
                        "stopIfEmpty": true
                    }},
                    { "set": { "isDropTarget": true }}
                ],
                "drop": [
                    { "select": {
                        "concept": "movableMixin",
                        "where": {
                            "property": "isBeingMoved",
                            "equals": true
                        },
                        "stopIfEmpty": true,
                        "as": "movedElements"
                    }},
                    { "removeFirst": {
                        "of": { "variable": "movedElements" },
                        "as": "movedElement"
                    }},
                    { "select": {
                        "concept": "droppableMixin",
                        "where": {
                            "property": "isDropTarget",
                            "equals": true
                        },
                        "stopIfEmpty": true,
                        "as": "targetElements"
                    }},
                    { "removeFirst": {
                        "of": { "variable": "targetElements" },
                        "as": "targetElement"
                    }},
                    { "select": "$targetElement" },
                    { "run": "elementDrop" },
                    { "run": "deselectElements" }
                ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="DroppableMixin Style" auto>.element[data-is-drop-target="true"] {
    outline: 2px solid salmon;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="OpacityMixin" id="OpacityMixin"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Mixin for being able to change element's opacity.",
    "dependencies": [
        "#Element"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="OpacityMixin Concept" auto>{
    "concepts": {
        "opacityMixin": {
            "schema": {
                "opacity": { "number": {
                    "default": 1,
                    "min": 0.1,
                    "max": 1
                }}
            },
            "actions": {
                "wheelToChangeOpacity": {
                    "when": { "wheel": {
                        "exactConceptMatch": true
                    }},
                    "then": [
                        "checkInLayoutMode",
                        { "get": "opacity" },
                        { "calculate": "max(0.1, min(1, $get$ + $wheelDelta$ / 1000))" },
                        { "set": { "opacity": "$calculate" }}
                    ]
                }
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="OpacityMixin Template" auto>&lt;dom-view-template>
    &lt;varv-template name="opacityMixinOptions">
        &lt;label title="Change with mousewheel">
            Opacity:
            &lt;input value="{opacity}" type="number" min="0.1" max="1" step="0.1">
        &lt;/label>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="StackableMixin" id="StackableMixin"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Mixin for making elements stackable.",
    "dependencies": [
        "#Element"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="StackableMixin Concept" auto>{
    "concepts": {
        "stackableMixin": {
            "schema": {
                "zIndex": "number"
            },
            "actions": {
                "moveStackUp": {
                    "when": { "key": {
                        "key": "u"
                    }},
                    "then": [
                        "checkInLayoutMode",
                        { "select": {
                            "concept": "stackableMixin",
                            "where": {
                                "property": "selected",
                                "equals": true
                            },
                            "stopIfEmpty": true
                        }},
                        { "increment": "zIndex" }
                    ]
                },
                "moveStackDown": {
                    "when": { "key": {
                        "key": "d"
                    }},
                    "then": [
                        "checkInLayoutMode",
                        { "select": {
                            "concept": "stackableMixin",
                            "where": {
                                "property": "selected",
                                "equals": true
                            },
                            "stopIfEmpty": true
                        }},
                        { "get": "zIndex" },
                        { "calculate": "max(0, $get$ - 1)" },
                        { "set": { "zIndex": "$calculate" }}
                    ]
                }
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="StackableMixin Template" auto>&lt;dom-view-template>
    &lt;varv-template name="stackableMixinOptions">
        &lt;label title="Change by pressing 'u' or 'd'">
            Z-Index:
            &lt;input value="{zIndex}" type="number" min="0">
        &lt;/label>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ToolFunctionMixin" name="ToolFunctionMixin"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Mixin for tools that can be activated and deactivated.",
    "dependencies": [
        "#ToolElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ToolFunctionMixin Concepts" auto>{
    "concepts": {
        "toolFunctionMixin": {
            "schema": {
                "disabled": "boolean",
                "role": "string",
                "isActive": { "boolean": {
                    "derive": {
                        "properties": [
                            "disabled",
                            "role",
                            "parentRoom",
                            "meeting.fullscreenRoom",
                            "userManager.localRole"
                        ],
                        "transform": [
                            { "get": {
                                "property": "meeting.fullscreenRoom",
                                "as": "fullscreenRoom"
                            }},
                            { "get": {
                                "property": "userManager.localRole",
                                "as": "localRole"
                            }},
                            { "eval": {
                                "and": [
                                    { "property": "parentRoom", "equals": "$fullscreenRoom" },
                                    { "property": "disabled", "equals": false },
                                    { "or": [
                                        { "property": "role", "equals": "$localRole" },
                                        { "property": "role", "equals": "" }
                                    ]}
                                ]
                            }}
                        ]
                    }
                }}
            },
            "mappings": {
                "isActive": [ "memory", "cauldron" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="ToolFunctionMixin Template" auto>&lt;dom-view-template>
    &lt;varv-template name="toolFunctionMixinBody">
        &lt;label if="isActive" class="toolFunctionStatus status-active">Tool active&lt;/label>
        &lt;label if="!isActive" class="toolFunctionStatus status-not-active">Tool not active&lt;/label>
    &lt;/varv-template>

    &lt;varv-template name="toolFunctionMixinOptions">
        &lt;label>
            Disabled:
            &lt;input value="{disabled}" type="checkbox">
        &lt;/label>
        &lt;label>
            Role:
            &lt;input value="{role}" title="Role">
        &lt;/label>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="ToolFunctionMixin Style" auto>.element {
    .toolFunctionStatus {
        color: #fff;
        font-size: 14px;
    }

    .status-active {
        background: #2e7d32;
    }

    .status-not-active {
        background: #d32f2f;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ToolLayoutMixin" name="ToolLayoutMixin"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Mixin for tools that change the layout of a room.",
    "dependencies": [
        "#FindAction",
        "#ToolElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ToolLayoutMixin Concepts" auto>{
    "concepts": {
        "toolLayoutMixin": {
            "schema": {
                "active": "boolean",
                "elements": { "array": {
                    "items": "element",
                    "derive": {
                        "properties": [
                            "parentRoom",

                            "regularRoom.childElements",

                            "gridTool.inToolPanel",
                            "speakerViewTool.inToolPanel",
                            "layoutTemplateTool.inToolPanel",
                            "highlightTool.inToolPanel",
                            "cameraShakerTool.inToolPanel",
                            "recordingTool.inToolPanel",
                            "roomRecordingTool.inToolPanel",
                            "doorwayTool.inToolPanel",
                            "proximityBasedAudioTool.inToolPanel",
                            "podiumTool.inToolPanel",
                            "whisperTool.inToolPanel",
                            "broadcastTool.inToolPanel",
                            "templateStoreTool.inToolPanel"
                        ],
                        "transform": [
                            { "get": "parentRoom" },
                            { "find": {
                                "concept": "element",
                                "where": { "and": [
                                    { "property": "parentRoom", "equals": "$get" },
                                    { "property": "inToolPanel", "equals": false }
                                ]}
                            }}
                        ]
                    }
                }},
                "elementCount": { "number": {
                    "derive": {
                        "properties": [ "elements" ],
                        "transform": [
                            { "length": "elements" }
                        ]
                    }
                }}
            }
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE></DIV><DIV name="Room Types"><WPM-PACKAGE id="RegularRoom" name="RegularRoom"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A regular room concept.",
    "dependencies": [
        "#RoomElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="RegularRoom Concepts" auto>{
    "concepts": {
        "regularRoom": {
            "actions": {
                "regularRoomDrop": [
                    "roomElementDrop"
                ],
                "regularRoomCleanup": [
                    "roomElementCleanup"
                ]
            },
            "extensions": { "inject": [
                "element",
                "roomElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="RegularRoom Template" auto>&lt;dom-view-template>
    &lt;varv-template name="regularRoomBody">
        &lt;div class="element-title" title="Room Name">{name}&lt;/div>
        &lt;div class="client-overview" title="Clients in this Room" if="hasClients">
            &lt;div class="client-thumbnail" property="clients" style="background: {color}" title="{name}">{name}&lt;/div>
        &lt;/div>
        &lt;div class="element-preview" if="isInFullscreenRoom">
            &lt;template-ref template-name="element" property="childElements" if="!inToolPanel">&lt;/template-ref>
        &lt;/div>
        &lt;button view="enterRoomButton" class="enter-room-button" if="isInFullscreenRoom">Enter Room&lt;/button>
    &lt;/varv-template>

    &lt;varv-template name="regularRoomOptions">
        &lt;template-ref template-name="roomElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="RegularRoom Style" auto>.regularRoom {
    .client-overview {
        position: absolute;
        background: #848484;
        border-bottom-left-radius: 6px;
        border-top-right-radius: 8px;
        top: 0;
        right: 0;
        height: 16px;
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 4px;
        padding: 2px;
        min-width: 16px;
        user-select: none;
        z-index: 10;

        .client-thumbnail {
            color: #fff;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            overflow: hidden;
            user-select: none;
            font-size: 8px;
            line-height: 12px;
            padding: 2px;
        }
    }

    .element-preview {
        width: 300%;
        height: 300%;
        transform: scale(0.333);
        transform-origin: top left;
    }

    button.enter-room-button {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50%;
        height: 50%;
        max-width: 192px;
        max-height: 48px;
        box-shadow: 0px 0px 4px 0px #424242;
    }

    &[data-selected="true"] {
        background: #424242;

        .element-preview {
            opacity: 20%;
        }

        button.enter-room-button {
            display: block;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE></DIV><DIV name="Content Types"><WPM-PACKAGE name="CameraContent" id="CameraContent"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The camera content concept.",
    "dependencies": [
        "#ContentElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="CameraContent Concepts" auto>{
    "concepts": {
        "cameraContent": {
            "schema": {
                "cameraStream": "cameraStream",
                "fit": { "string": {
                    "enum": [ "cover", "contain" ],
                    "default": "cover"
                }},
                "fitOptions": { "array": {
                    "items": "string",
                    "derive": {
                        "transform": [
                            { "enums": "fit" }
                        ]
                    }
                }},
                "scale": { "number": {
                    "min": 100,
                    "max": 200,
                    "default": 100
                }},
                "cropOffsetLeft": { "number": {
                    "min": 0,
                    "max": 100,
                    "default": 50
                }},
                "cropOffsetTop": { "number": {
                    "min": 0,
                    "max": 100,
                    "default": 50
                }},
                "aspectRatioWide": { "boolean": {
                    "derive": {
                        "properties": [ "width", "height" ],
                        "transform": [
                            { "get": { "property": "width", "as": "width" }},
                            { "get": { "property": "height", "as": "height" }},
                            { "calculate": "$width$ / $height$" },
                            { "eval": {
                                "variable": "calculate",
                                "greaterThan": 1.33
                            }}
                        ]
                    }
                }},
                "videoWidth": { "number": {
                    "derive": {
                        "properties": [ "aspectRatioWide", "width", "height", "scale" ],
                        "transform": [
                            { "get": { "property": "width", "as": "width" }},
                            { "get": { "property": "height", "as": "height" }},
                            { "get": { "property": "scale", "as": "scale" }},
                            { "get": { "property": "aspectRatioWide", "as": "aspectRatioWide" }},
                            { "switch": [
                                {
                                    "where": { "variable": "aspectRatioWide", "equals": true },
                                    "then": [
                                        { "set": { "variable": "videoWidth", "value": "$width" }}
                                    ]
                                },
                                {
                                    "where": { "variable": "aspectRatioWide", "equals": false },
                                    "then": [
                                        { "calculate": "floor($height$ * 1.33)"},
                                        { "set": { "variable": "videoWidth", "value": "$calculate" }}
                                    ]
                                }
                            ]},
                            { "calculate": "$videoWidth$ * ($scale$ / 100)" }
                        ]
                    }
                }},
                "videoHeight": { "number": {
                    "derive": {
                        "properties": [ "aspectRatioWide", "width", "height", "scale" ],
                        "transform": [
                            { "get": { "property": "width", "as": "width" }},
                            { "get": { "property": "height", "as": "height" }},
                            { "get": { "property": "scale", "as": "scale" }},
                            { "get": { "property": "aspectRatioWide", "as": "aspectRatioWide" }},
                            { "switch": [
                                {
                                    "where": { "variable": "aspectRatioWide", "equals": true },
                                    "then": [
                                        { "calculate": "floor($width$ / 1.33)"},
                                        { "set": { "variable": "videoHeight", "value": "$calculate" }}
                                    ]
                                },
                                {
                                    "where": { "variable": "aspectRatioWide", "equals": false },
                                    "then": [
                                        { "set": { "variable": "videoHeight", "value": "$height" }}
                                    ]
                                }
                            ]},
                            { "calculate": "$videoHeight$ * ($scale$ / 100)" }
                        ]
                    }
                }},
                "cropOffsetLeftCorrected": { "number": {
                    "derive": {
                        "properties": [ "videoWidth", "cropOffsetLeft" ],
                        "transform": [
                            { "get": { "property": "width", "as": "width" }},
                            { "get": { "property": "videoWidth", "as": "videoWidth" }},
                            { "calculate": "($videoWidth$ / $width$) - 1" },
                            { "get": "cropOffsetLeft" },
                            { "calculate": "$get$ * $calculate$" }
                        ]
                    }
                }},
                "cropOffsetTopCorrected": { "number": {
                    "derive": {
                        "properties": [ "videoHeight", "cropOffsetTop" ],
                        "transform": [
                            { "get": { "property": "height", "as": "height" }},
                            { "get": { "property": "videoHeight", "as": "videoHeight" }},
                            { "calculate": "($videoHeight$ / $height$) - 1" },
                            { "get": "cropOffsetTop" },
                            { "calculate": "$get$ * $calculate$" }
                        ]
                    }
                }},
                "clientInRoom": { "boolean": {
                    "derive": {
                        "properties": [ "cameraStream", "client.location" ],
                        "transform": [
                            { "get": { "property": "cameraStream", "as": "cameraStream" }},
                            { "get": { "property": "parentRoom", "as": "parentRoom" }},
                            { "select": {
                                "target": "$cameraStream",
                                "forEach": true,
                                "stopIfEmpty": true
                            }},
                            { "get": "client" },
                            { "select": {
                                "target": "$get",
                                "forEach": true,
                                "stopIfEmpty": true
                            }},
                            { "eval": { "and": [
                                {
                                    "variable": "cameraStream",
                                    "unequals": "null"
                                },
                                {
                                    "variable": "cameraStream",
                                    "unequals": ""
                                },
                                {
                                    "property": "location",
                                    "equals": "$parentRoom"
                                }
                            ]}}
                        ]
                    }
                }}
            },
            "actions": {
                "cameraContentCleanup": [
                    { "where": {
                        "property": "stream",
                        "unequals": "",
                        "stopIfEmpty": true
                    }},
                    "stopCamera"
                ],
                "startCamera": {
                    "when": { "click": { "view": "startCameraButton" }},
                    "then": [
                        { "set": {
                            "variable": "element",
                            "value": "$target"
                        }},
                        { "select": {
                            "concept": "client",
                            "where": {
                                "property": "local",
                                "equals": true
                            },
                            "stopIfEmpty": true
                        }},
                        { "get": "cameraStream" },
                        { "select": "$element" },
                        { "set": { "cameraStream": "$get" }}
                    ]
                },
                "stopCamera": {
                    "when": { "click": { "view": "stopCameraButton" }},
                    "then": [
                        { "set": { "cameraStream": "" }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "contentElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "opacityMixin",
                "stackableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="CameraContent Template" auto>&lt;dom-view-template>
    &lt;varv-template name="cameraContentBody">
        &lt;div class="element-title" property="cameraStream">
            &lt;span property="client">
                &lt;span property="user">{name}: &lt;/span>{name}
            &lt;/span>
        &lt;/div>
        &lt;div class="placeholder-icon m-ico">photo_camera&lt;/div>
        &lt;video property="cameraStream" data-stream="{id}" data-stream-type="camera" style="object-fit: {fit}; width: {videoWidth}px; height: {videoHeight}px; left: -{cropOffsetLeftCorrected}%; top: -{cropOffsetTopCorrected}%;" data-client-in-room="{clientInRoom}">&lt;/video>
    &lt;/varv-template>

    &lt;varv-template name="cameraContentOptions">
        &lt;button view="startCameraButton">Start Camera&lt;/button>
        &lt;button view="stopCameraButton">Stop Camera&lt;/button>
        &lt;div class="spacer">&lt;/div>
        &lt;label>
            Fit:
            &lt;select value="{fit}">
                &lt;option property="fitOptions">{fitOptions.value}&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;label>
            Scale:
            &lt;input value="{scale}" type="range" min="100" max="200" step="1">
        &lt;/label>
        &lt;label>
            Crop Left:
            &lt;input value="{cropOffsetLeft}" type="range" min="0" max="100" step="1">
        &lt;/label>
        &lt;label>
            Crop Top:
            &lt;input value="{cropOffsetTop}" type="range" min="0" max="100" step="1">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="contentElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="CameraContent Style" auto>.cameraContent video {
    width: 100%;
    height: 100%;
    transform: scaleX(-1);
    position: absolute;
    transition: filter 500ms ease-in-out;

    &[data-client-in-room="false"] {
        filter: blur(12px) grayscale(50%);
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ScreenContent" name="ScreenContent"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The screen content concept.",
    "dependencies": [
        "#StreamTools",
        "#ContentElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ScreenContent Concepts" auto>{
    "concepts": {
        "screenContent": {
            "schema": {
                "stream": "string",
                "local": { "boolean": {
                    "derive": {
                        "properties": [ "stream" ],
                        "transform": [
                            { "get": "stream" },
                            { "isStreamLocal": { "stream": "$get" }}
                        ]
                    }
                }},
                "fit": { "string": {
                    "enum": [ "cover", "contain" ],
                    "default": "contain"
                }},
                "fitOptions": { "array": {
                    "items": "string",
                    "derive": {
                        "transform": [
                            { "enums": "fit" }
                        ]
                    }
                }}
            },
            "mappings": {
                "local": [ "memory", "cauldron" ]
            },
            "actions": {
                "screenContentCleanup": [
                    { "where": {
                        "property": "stream",
                        "unequals": "",
                        "stopIfEmpty": true
                    }},
                    "stopScreen"
                ],
                "startScreen": {
                    "when": { "click": { "view": "startScreenButton" }},
                    "then": [
                        "getScreenStream",
                        { "set": { "stream": "$getScreenStream" }}
                    ]
                },
                "stopScreen": {
                    "when": { "click": { "view": "stopScreenButton" }},
                    "then": [
                        { "get": "stream" },
                        { "closeStream": {
                            "stream": "$get",
                            "type": "screen"
                        }},
                        { "set": { "stream": "" }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "contentElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "opacityMixin",
                "stackableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="ScreenContent Template" auto>&lt;dom-view-template>
    &lt;varv-template name="screenContentBody">
        &lt;div class="placeholder-icon m-ico">cast&lt;/div>
        &lt;video data-stream="{stream}" data-stream-type="screen" style="object-fit: {fit};">&lt;/video>
    &lt;/varv-template>

    &lt;varv-template name="screenContentOptions">
        &lt;button view="startScreenButton">Start Screen&lt;/button>
        &lt;button view="stopScreenButton" if="local">Stop Screen&lt;/button>
        &lt;div class="spacer">&lt;/div>
        &lt;label>
            Fit:
            &lt;select value="{fit}">
                &lt;option property="fitOptions">{fitOptions.value}&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="contentElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="ScreenContent Style" auto>.screenContent video {
    width: 100%;
    height: 100%;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="VideoContent" id="VideoContent"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The video content element.",
    "dependencies": [
        "#ContentElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="VideoContent Concepts" auto>{
    "concepts": {
        "videoContent": {
            "schema": {
                "title": "string",
                "videoUrl": "string",
                "videoUrlEmpty": { "boolean": {
                    "derive": {
                        "properties": [ "videoUrl" ],
                        "transform": [
                            { "eval": {
                                "property": "videoUrl",
                                "equals": ""
                            }}
                        ]
                    }
                }},
                "fit": { "string": {
                    "enum": [ "cover", "contain" ],
                    "default": "cover"
                }},
                "fitOptions": { "array": {
                    "items": "string",
                    "derive": {
                        "transform": [
                            { "enums": "fit" }
                        ]
                    }
                }}
            },
            "extensions": { "inject": [
                "element",
                "contentElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "opacityMixin",
                "stackableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="VideoContent Template" auto>&lt;dom-view-template>
    &lt;varv-template name="videoContentBody">
        &lt;div class="element-title">{title}&lt;/div>
        &lt;div class="placeholder-icon m-ico">theaters&lt;/div>
        &lt;video if="!videoUrlEmpty" src="{videoUrl}" class="video-element-video" draggable="false" style="object-fit: {fit};" loop controls>&lt;/video>
    &lt;/varv-template>

    &lt;varv-template name="videoContentOptions">
        &lt;label>
            Title:
            &lt;input value="{title}">
        &lt;/label>
        &lt;label>
            Video URL:
            &lt;input value="{videoUrl}">
        &lt;/label>
        &lt;label>
            Fit:
            &lt;select value="{fit}">
                &lt;option property="fitOptions">{fitOptions.value}&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="contentElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="VideoContent Style" auto>.video-element-video {
    width: 100%;
    height: 100%;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="ImageContent" id="ImageContent"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The image content concept.",
    "dependencies": [
        "#ContentElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ImageContent Concepts" auto>{
    "concepts": {
        "imageContent": {
            "schema": {
                "imageUrl": "string",
                "imageUrlEmpty": { "boolean": {
                    "derive": {
                        "properties": [ "imageUrl" ],
                        "transform": [
                            { "eval": {
                                "property": "imageUrl",
                                "equals": ""
                            }}
                        ]
                    }
                }},
                "fit": { "string": {
                    "enum": [ "cover", "contain" ],
                    "default": "cover"
                }},
                "fitOptions": { "array": {
                    "items": "string",
                    "derive": {
                        "transform": [
                            { "enums": "fit" }
                        ]
                    }
                }}
            },
            "extensions": { "inject": [
                "element",
                "contentElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "opacityMixin",
                "stackableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="ImageContent Template" auto>&lt;dom-view-template>
    &lt;varv-template name="imageContentBody">
        &lt;div class="placeholder-icon m-ico">image&lt;/div>
        &lt;img src="{imageUrl}" class="image-element-image" draggable="false" style="object-fit: {fit};" if="!imageUrlEmpty">
    &lt;/varv-template>

    &lt;varv-template name="imageContentOptions">
        &lt;label>
            Image URL:
            &lt;input value="{imageUrl}">
        &lt;/label>
        &lt;label>
            Fit:
            &lt;select value="{fit}">
                &lt;option property="fitOptions">{fitOptions.value}&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="contentElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="ImageContent Style" auto>.imageContent .image-element-image {
    width: 100%;
    height: 100%;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="NoteContent" id="NoteContent"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The note content concept.",
    "dependencies": [
        "#ContentElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="NoteContent Concepts" auto>{
    "concepts": {
        "noteContent": {
            "schema": {
                "content": "string",
                "color": { "string": {
                    "default": "Yellow",
                    "enum": [
                        "Yellow",
                        "Red",
                        "Blue",
                        "Green"
                    ]
                }},
                "colors": { "array": {
                    "items": "string",
                    "derive": {
                        "transform": [
                            { "enums": "color" }
                        ]
                    }
                }}
            },
            "extensions": { "inject": [
                "element",
                "contentElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "opacityMixin",
                "stackableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="NoteContent Template" auto>&lt;dom-view-template>
    &lt;varv-template name="noteContentBody">
        &lt;textarea value="{content}" data-color="{color}">&lt;/textarea>
    &lt;/varv-template>

    &lt;varv-template name="noteContentOptions">
        &lt;label>
            Color:
            &lt;select value="{color}">
                &lt;option property="colors">{colors.value}&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="contentElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="NoteContent Style" auto>.noteContent>.element-body {
    display: flex;
}

.noteContent {
    textarea {
        flex: 1 1 auto;
        resize: none;
        padding: 16px;
        font-size: 14px;
        background: #fff475;
    }

    textarea[data-color="Yellow"] {
        background: #fff475;
    }

    textarea[data-color="Red"] {
        background: #f28b82;
    }

    textarea[data-color="Blue"] {
        background: #cbf0f8;
    }

    textarea[data-color="Green"] {
        background: #ccff90;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="SketchContent" id="SketchContent"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The sketch content concept.",
    "dependencies": [
        "#ContentElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="SketchContent Concepts" auto>{
    "concepts": {
        "sketchContent": {
            "schema": {
                "baseURL": { "string": { "default": "https://beta.tldraw.com/r" }},
                "sessionId": "string"
            },
            "extensions": { "inject": [
                "element",
                "contentElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "opacityMixin",
                "stackableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="SketchContent Template" auto>&lt;dom-view-template>
    &lt;varv-template name="sketchContentBody">
        &lt;iframe src="{baseURL}/{sessionId}">&lt;/iframe>
    &lt;/varv-template>
    &lt;varv-template name="sketchContentOptions">
        &lt;label>
            Session:
            &lt;input value="{sessionId}">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="contentElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="SketchContent Style" auto>.sketchContent iframe {
    width: 100%;
    height: 100%;
    border: none;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ChatContent" name="ChatContent"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The chat content concept.",
    "dependencies": [
        "#Chat",
        "#ContentElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ChatContent Concepts" auto>{
    "concepts": {
        "chatContent": {
            "schema": {
                "chat": "chat"
            },
            "actions": {
                "createChatInElement": {
                    "when": { "click": { "view": "createChat" }},
                    "then": [
                        "newChat",
                        { "set": { "chat": "$newChat" }}
                    ]
                },
                "deleteChatInElement": {
                    "when": { "click": { "view": "deleteChat" }},
                    "then": [
                        { "get": "chat" },
                        { "set": { "chat": "" }},
                        { "select": "$get" },
                        "deleteChat"
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "contentElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "opacityMixin",
                "stackableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="ChatContent Template" auto>&lt;dom-view-template>
    &lt;varv-template name="chatContentBody">
        &lt;template-ref template-name="chat" property="chat">&lt;/template-ref>
    &lt;/varv-template>

    &lt;varv-template name="chatContentOptions">
        &lt;button view="createChat">Create New Chat&lt;/button>
        &lt;label>
            Chat:
            &lt;select value="{chat}">
                &lt;option concept="chat" value="{concept::uuid}">{name}&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;label property="chat">
            Name:
            &lt;input value="{name}">
        &lt;/label>
        &lt;button class="red" view="deleteChat" if="chat">Delete Chat&lt;/button>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="contentElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="ChatContent Style" auto>.chatContent .chat {
    width: 100%;
    height: 100%;

    .messages {
        &::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        /* Track */
        &::-webkit-scrollbar-track,
        &::-webkit-scrollbar-corner {
            background: none;
        }

        /* Handle */
        &::-webkit-scrollbar-thumb {
            background: #636363;
            border-radius: 4px;
        }

        /* Handle on hover */
        &::-webkit-scrollbar-thumb:hover {
            background: #848484;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="AvatarContent" name="AvatarContent"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The avatar content concept. Works together with proximity-based audio.",
    "dependencies": [
        "#ContentElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" auto name="AvatarContent Concepts">{
    "concepts": {
        "avatarContent": {
            "schema": {
                "user": "user",
                "avatarUrl": { "string": {
                    "default": "your-avatar-url.png"
                }},
                "distance": { "number": { "default": 10000 }},
                "inDistance": { "boolean": {
                    "derive": {
                        "properties": [ "distance" ],
                        "transform": [
                            { "eval": {
                                "property": "distance",
                                "lessThan": 150
                            }}
                        ]
                    }
                }}
            },
            "mappings": {
                "distance": [ "memory", "cauldron" ],
                "inDistance": [ "memory", "cauldron" ]
            },
            "actions": {
                "moveOwnRight": {
                    "when": { "key": { "key": "d" }},
                    "then": [
                        "selectOwnAvatarInRoom",
                        { "increment": { "property": "left", "by": 32 }}
                    ]
                },
                "moveOwnLeft": {
                    "when": { "key": { "key": "a" }},
                    "then": [
                        "selectOwnAvatarInRoom",
                        { "decrement": { "property": "left", "by": 32 }}
                    ]
                },
                "moveOwnDown": {
                    "when": { "key": { "key": "s" }},
                    "then": [
                        "selectOwnAvatarInRoom",
                        { "increment": { "property": "top", "by": 32 }}
                    ]
                },
                "moveOwnUp": {
                    "when": { "key": { "key": "w" }},
                    "then": [
                        "selectOwnAvatarInRoom",
                        { "decrement": { "property": "top", "by": 32 }}
                    ]
                },
                "selectOwnAvatarInRoom": [
                    { "select": "avatarContent" },
                    "checkInfullscreenRoom",
                    { "get": "userManager.localUser" },
                    { "where": {
                        "property": "user",
                        "equals": "$get"
                    }}
                ],
                "selectOtherAvatarsInRoom": [
                    { "select": "avatarContent" },
                    "checkInfullscreenRoom",
                    { "get": "userManager.localUser" },
                    { "where": {
                        "property": "user",
                        "unequals": "$get"
                    }}
                ],
                "updateDistance": {
                    "when": [
                        { "stateChanged": {
                            "concept": "avatarContent",
                            "property": "left"
                        }},
                        { "stateChanged": {
                            "concept": "avatarContent",
                            "property": "top"
                        }},
                        { "stateChanged": {
                            "concept": "client",
                            "property": "location"
                        }}
                    ],
                    "then": [
                        { "where": {
                            "property": "toolManager.proximityBasedAudioActive",
                            "equals": true,
                            "stopIfEmpty": true
                        }},
                        "selectOwnAvatarInRoom",
                        { "get": { "property": "left", "as": "ownLeft" }},
                        { "get": { "property": "top", "as": "ownTop" }},
                        { "select": "avatarContent" },
                        "checkInfullscreenRoom",
                        { "get": { "property": "left", "as": "otherLeft" }},
                        { "get": { "property": "top", "as": "otherTop" }},
                        { "calculate": {
                            "expression": "floor(sqrt(square($ownLeft$ - $otherLeft$) + square($ownTop$ - $otherTop$)))",
                            "as": "distance"
                        }},
                        { "set": { "distance": "$distance" }},
                        { "select": {
                            "property": "user",
                            "forEach": true
                        }},
                        { "select": {
                            "concept": "client",
                            "where": {
                                "property": "user",
                                "equals": "$lastTarget"
                            },
                            "forEach": true
                        }},
                        { "set": { "distance": "$distance" }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "contentElement",
                "movableMixin",
                "droppableMixin",
                "opacityMixin",
                "stackableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" auto name="AvatarContent Template">&lt;dom-view-template>
    &lt;varv-template name="avatarContentBody">
        &lt;img src="{avatarUrl}" class="avatar-image no-user" draggable="false" tabindex=0 if="!user" title="Missing User">
        &lt;img src="{avatarUrl}" class="avatar-image" data-in-distance="{inDistance}" draggable="false" tabindex=0 property="user" title="{name}">
    &lt;/varv-template>

    &lt;varv-template name="avatarContentOptions">
        &lt;label>
            User:
            &lt;select value="{user}">
                &lt;option value="">None&lt;/option>
                &lt;option concept="user" value="{concept::uuid}">{name}&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;label>
            Avatar URL:
            &lt;input value="{avatarUrl}">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="contentElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" auto name="AvatarContent Style">.avatarContent {
    background: none;
    border: none;
    width: 48px !important;
    height: 96px !important;
    padding: 4px;
    box-shadow: none !important;
    transition: left 100ms linear,
        top 100ms linear;

    .element-body {
        overflow: visible;

        .avatar-image {
            object-fit: scale-down;
            width: 100%;
            height: 100%;
            outline: none;
            transition: filter 350ms ease-in-out;

            &[data-in-distance="true"] {
                filter: drop-shadow(0 0 2px orange) drop-shadow(0 0 3px orange) drop-shadow(0 0 8px #cccccc);
            }

            &.no-user {
                filter: grayscale(100%) brightness(0.2);
            }
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE></DIV><DIV name="Tool Types"><WPM-PACKAGE id="GridTool" name="GridTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Changes the layout to a grid.",
    "dependencies": [
        "#WindowTools",
        "#ToolElement",
        "#ToolLayoutMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="GridTool Concepts" auto>{
    "concepts": {
        "gridTool": {
            "schema": {
                "gap": { "number": { "default": 8 }},
                "columnCount": { "number": {
                    "derive": {
                        "properties": [ "elementCount" ],
                        "transform": [
                            { "get": "elementCount" },
                            { "calculate": "ceil(sqrt($get$))" }
                        ]
                    }
                }},
                "rowCount": { "number": {
                    "derive": {
                        "properties": [ "elementCount" ],
                        "transform": [
                            { "get": "elementCount" },
                            { "calculate": "round(sqrt($get$))" }
                        ]
                    }
                }}
            },
            "actions": {
                "autoupdateElementSizes": {
                    "when": { "stateChanged": { "property": "elements" }},
                    "then": [
                        { "select": {
                            "concept": "gridTool",
                            "where": {
                                "property": "active",
                                "equals": true
                            },
                            "stopIfEmpty": true
                        }},
                        "checkInfullscreenRoom",
                        { "limit": 1 },
                        "updateElementSizes"
                    ]
                },
                "updateElementSizes": {
                    "when": { "click": { "view": "activateGridButton" }},
                    "then": [
                        { "elementRect": { "element": "varv-view > .meeting > .content" }},
                        { "get": {
                            "property": "columnCount",
                            "as": "columnCount"
                        }},
                        { "get": {
                            "property": "rowCount",
                            "as": "rowCount"
                        }},
                        { "get": {
                            "property": "gap",
                            "as": "gap"
                        }},
                        { "calculate": {
                            "expression": "$elementWidth$-(($columnCount$+1)*$gap$)",
                            "as": "elementSpaceWidth"
                        }},
                        { "calculate": {
                            "expression": "$elementHeight$-(($rowCount$+1)*$gap$)",
                            "as": "elementSpaceHeight"
                        }},
                        { "calculate": {
                            "expression": "floor($elementSpaceWidth$/$columnCount$)",
                            "as": "elementWidth"
                        }},
                        { "calculate": {
                            "expression": "floor($elementSpaceHeight$/$rowCount$)",
                            "as": "elementHeight"
                        }},
                        { "items": "elements" },
                        { "select": "$items" },
                        { "index": {
                            "of": { "variable": "items" },
                            "item": "$target",
                            "as": "gridIndex"
                        }},
                        { "calculate": {
                            "expression": "mod($gridIndex$, $columnCount$)",
                            "as": "columnIndex"
                        }},
                        { "calculate": {
                            "expression": "floor($gridIndex$/$columnCount$)",
                            "as": "rowIndex"
                        }},
                        { "set": { "top": { "calculate": "($rowIndex$ * $elementHeight$) + (($rowIndex$) * $gap$) + $gap$" }}},
                        { "set": { "left": { "calculate": "($columnIndex$ * $elementWidth$) + (($columnIndex$) * $gap$) + $gap$" }}},
                        { "set": { "width": "$elementWidth" }},
                        { "set": { "height": "$elementHeight" }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "toolLayoutMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="GridTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="gridToolBody">
        &lt;div class="tool-title">Grid Tool&lt;/div>
        &lt;button view="activateGridButton">Change to Grid&lt;/button>
    &lt;/varv-template>

    &lt;varv-template name="gridToolOptions">
        &lt;label>
            Continuous Active:
            &lt;input value="{active}" type="checkbox">
        &lt;/label>
        &lt;label>
            Gap:
            &lt;input value="{gap}" type="number">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="SpeakerViewTool" id="SpeakerViewTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Changes the layout to one big speaker and a film strip for other elements.",
    "dependencies": [
        "#WindowTools",
        "#ToolElement",
        "#ToolLayoutMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="SpeakerViewTool Concepts" auto>{
    "concepts": {
        "speakerViewTool": {
            "schema": {
                "speaker": "element"
            },
            "actions": {
                "speakerViewToolDrop": [
                    { "set": { "speaker": "$movedElement" }},
                    "updateElementSizes"
                ],
                "setSpeaker": {
                    "when": { "mousedown": { "view": "setSpeakerButton" }},
                    "then": [
                        { "get": "meeting.selectedElement"},
                        { "set": { "speaker": "$get" }},
                        "updateElementSizes"
                    ]
                },
                "autoupdateElementSizes": {
                    "then": [
                        { "select": {
                            "concept": "speakerViewTool",
                            "where": {
                                "property": "active",
                                "equals": true
                            },
                            "stopIfEmpty": true
                        }},
                        "checkInfullscreenRoom",
                        { "limit": 1 },
                        "updateElementSizes"
                    ]
                },
                "updateElementSizes": {
                    "when": { "click": { "view": "activateSpeakerViewButton" }},
                    "then": [
                        { "elementRect": { "element": "varv-view > .meeting > .content" }},
                        { "select": "speakerViewTool" },
                        "checkInfullscreenRoom",
                        { "limit": 1 },
                        { "get": {
                            "property": "speaker",
                            "as": "speaker"
                        }},
                        { "calculate": {
                            "expression": "$elementHeight$ * 0.75",
                            "as": "speakerHeight"
                        }},
                        { "calculate": {
                            "expression": "$elementHeight$ * 0.25",
                            "as": "audienceHeight"
                        }},
                        { "run": "updateSpeaker" },
                        { "run": "updateAudience" }
                    ]
                },
                "updateSpeaker": [
                    { "select": "$speaker" },
                    "checkInfullscreenRoom",
                    { "set": { "left": 8 }},
                    { "set": { "top": { "calculate": "$audienceHeight$ + 8" }}},
                    { "set": { "width": { "calculate": "$elementWidth$ - 16" }}},
                    { "set": { "height": { "calculate": "$speakerHeight$ - 16" }}}
                ],
                "updateAudience": [
                    { "get": {
                        "property": "elementCount",
                        "as": "elementCount"
                    }},
                    { "calculate": {
                        "expression": "($elementWidth$ - ($elementCount$ * 8)) / ($elementCount$ - 1)",
                        "as": "audienceWidth"
                    }},
                    { "get": "elements" },
                    { "index": {
                        "of": { "variable": "get" },
                        "item": "$speaker"
                    }},
                    { "removeItem": {
                        "of": { "variable": "get" },
                        "index": "$index"
                    }},
                    { "select": "$get" },
                    { "index": {
                        "of": { "variable": "get" },
                        "item": "$target",
                        "as": "columnIndex"
                    }},
                    { "set": { "left": { "calculate": "($columnIndex$ * ($audienceWidth$ + 8)) + 8" }}},
                    { "set": { "top": 8 }},
                    { "set": { "width": "$audienceWidth" }},
                    { "set": { "height": { "calculate": "$audienceHeight$ - 8" }}}
                ]
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "toolLayoutMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="SpeakerViewTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="speakerViewToolBody">
        &lt;div class="tool-title">Speaker View Tool&lt;/div>
        &lt;button view="activateSpeakerViewButton">Change to Speaker View&lt;/button>
        &lt;button view="setSpeakerButton">Set Element as Speaker&lt;/button>
    &lt;/varv-template>

    &lt;varv-template name="speakerViewToolOptions">
        &lt;label>
            Continuous Active:
            &lt;input value="{active}" type="checkbox">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="LayoutTemplateTool" id="LayoutTemplateTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Stores the current layout in a template.",
    "dependencies": [
        "#ToolElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="LayoutTemplateTool Concepts" auto>{
    "concepts": {
        "elementLayoutTemplate": {
            "schema": {
                "element": "element",
                "top": "number",
                "left": "number",
                "width": "number",
                "height": "number",
                "opacity": "number",
                "zIndex": "number"
            }
        },
        "layoutTemplateTool": {
            "schema": {
                "templateName": "string",
                "elementLayoutTemplates": { "array": "elementLayoutTemplate" }
            },
            "actions": {
                "layoutTemplateToolCleanup": [
                    { "items": "elementLayoutTemplates" },
                    { "select": "$items" },
                    "remove"
                ],
                "storeTemplate": {
                    "when": { "click": { "view": "storeTemplateButton" }},
                    "then": [
                        { "run": "cleanupTemplates" },
                        { "set": {
                            "variable": "originaltemplateTool",
                            "value": "$target"
                        }},
                        { "get": "parentRoom" },
                        { "select": {
                            "concept": "element",
                            "where": {
                                "property": "parentRoom",
                                "equals": "$get"
                            },
                            "stopIfEmpty": true
                        }},
                        { "new": {
                            "concept": "elementLayoutTemplate",
                            "with": {
                                "element": "$target",
                                "top": "$target.top",
                                "left": "$target.left",
                                "width": "$target.width",
                                "height": "$target.height",
                                "opacity": "$target.opacity",
                                "zIndex": "$target.zIndex"
                            },
                            "forEach": true,
                            "select": "false"
                        }},
                        { "select": {
                            "target": "$originaltemplateTool",
                            "forEach": true
                        }},
                        { "append": {
                            "property": "elementLayoutTemplates",
                            "item": "$new"
                        }}
                    ]
                },
                "restoreTemplate": {
                    "when": { "click": { "view": "restoreTemplateButton" }},
                    "then": [
                        { "get": "meeting.fullscreenRoom" },
                        { "set": { "$fullscreenRoom": "$get" }},
                        { "items": {
                            "property": "elementLayoutTemplates",
                            "as": "elementLayoutTemplates"
                        }},
                        { "select": {
                            "target": "$elementLayoutTemplates",
                            "stopIfEmpty": true
                        }},
                        { "restoreProperty": { "propertyName": "top" }},
                        { "restoreProperty": { "propertyName": "left" }},
                        { "restoreProperty": { "propertyName": "width" }},
                        { "restoreProperty": { "propertyName": "height" }},
                        { "restoreProperty": { "propertyName": "opacity" }},
                        { "restoreProperty": { "propertyName": "zIndex" }}
                    ]
                },
                "cleanupTemplates": [
                    { "items": "elementLayoutTemplates" },
                    { "select": {
                        "target": "$items",
                        "stopIfEmpty": true
                    }},
                    "remove"
                ],
                "restoreProperty": [
                    { "get": "@propertyName" },
                    { "select": {
                        "property": "element",
                        "forEach": true
                    }},
                    { "where": {
                        "property": "parentRoom",
                        "equals": "$fullscreenRoom",
                        "stopIfEmpty": true
                    }},
                    { "set": { "@propertyName": "$get" }},
                    { "select": "$elementLayoutTemplates" }
                ]
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="LayoutTemplateTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="layoutTemplateToolBody">
        &lt;div class="tool-title">Layout Template Tool&lt;/div>
        &lt;button view="storeTemplateButton">Store Template&lt;/button>
        &lt;button view="restoreTemplateButton">Restore Template&lt;/button>
    &lt;/varv-template>

    &lt;varv-template name="layoutTemplateToolOptions">
        &lt;label>
            Template Name:
            &lt;input value="{templateName}">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="HighlightTool" id="HighlightTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Allows to globally highlight elements.",
    "dependencies": [
        "#ToolElement",
        "#ToolFunctionMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="HighlightTool Concepts" auto>{
    "concepts": {
        "highlightTool": {
            "schema": {
                "placeholder": "string"
            },
            "actions": {
                "checkHighlightActive": [
                    { "exists": {
                        "concept": "highlightTool",
                        "where": {
                            "property": "isActive",
                            "equals": true
                        }
                    }},
                    { "where": {
                        "variable": "exists",
                        "equals": true,
                        "stopIfEmpty": true
                    }}
                ]
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "toolFunctionMixin"
            ]}
        },
        "element": {
            "schema": {
                "globalHighlighted": "boolean"
            }
        },
        "meeting": {
            "actions": {
                "resetGlobalHighlightOnFullscreenClick": {
                    "when": { "click": { "concept": "element" }},
                    "then": [
                        "checkHighlightActive",
                        "checkIsfullscreenRoom",
                        "resetGlobalHighlight"
                    ]
                },
                "resetGlobalHighlight": [
                    { "select": "element" },
                    "checkInfullscreenRoom",
                    { "set": { "globalHighlighted": false }}
                ],
                "setGlobalHighlight": {
                    "when": { "mousedown": { "concept": "contentElement" }},
                    "then": [
                        "checkHighlightActive",
                        "checkInfullscreenRoom",
                        { "where": {
                            "property": "selected",
                            "equals": true,
                            "stopIfEmpty": true
                        }},
                        { "run": "resetGlobalHighlight" },
                        { "set": { "globalHighlighted": true }}
                    ]
                }
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="HighlightTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="highlightToolBody">
        &lt;div class="tool-title">Highlight Tool&lt;/div>
        &lt;template-ref template-name="toolFunctionMixinBody">&lt;/template-ref>
    &lt;/varv-template>

    &lt;varv-template name="highlightToolOptions">
        &lt;template-ref template-name="toolFunctionMixinOptions">&lt;/template-ref>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>

    &lt;varv-template name="element">
        &lt;div class="element {elementType}" style="left: {left}px; top: {top}px; width: {width}px; height: {height}px; opacity: {opacity}; z-index: {zIndex}" tabindex=0 data-selected="{selected}" data-is-being-moved="{isBeingMoved}" data-is-resizing="{isResizing}" data-is-drop-target="{isDropTarget}" data-is-content="{isContent}" data-is-room="{isRoom}" data-is-tool="{isTool}" data-is-global-highlighted="{globalHighlighted}">
            &lt;div class="element-body">
                &lt;template-ref template-name="{elementType}Body">&lt;/template-ref>
            &lt;/div>
            &lt;div class="move-handle" view="moveHandle" if="concept movableMixin">&lt;/div>
            &lt;div class="resize-handle" view="resizeHandle" if="concept resizableMixin" title="{elementType}">&lt;/div>
        &lt;/div>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="HighlightTool Style" auto>.element[data-is-global-highlighted="true"] {
    outline: 4px solid #EEFF41;
    box-shadow: 0 0 16px #EEFF41;
    z-index: 900 !important;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="CameraShakerTool" id="CameraShakerTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Shakes the camera content of users that speak loudly.",
    "dependencies": [
        "#ToolElement",
        "#ToolFunctionMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="CameraShakerTool Concepts" auto>{
    "concepts": {
        "cameraShakerTool": {
            "schema": {
                "placeholder": "string"
            },
            "actions": {
                "checkcameraShakerActive": [
                    { "exists": {
                        "concept": "cameraShakerTool",
                        "where": {
                            "property": "isActive",
                            "equals": true
                        }
                    }},
                    { "where": {
                        "variable": "exists",
                        "equals": true,
                        "stopIfEmpty": true
                    }}
                ],
                "updateShakingState": {
                    "when": { "stateChanged": {
                        "concept": "client",
                        "property": "analyserVolumeString"
                    }},
                    "then": [
                        { "get": "cameraStream" },
                        { "select": {
                            "concept": "cameraContent",
                            "where": {
                                "property": "cameraStream",
                                "equals": "$get"
                            },
                            "stopIfEmpty": true
                        }},
                        "checkInfullscreenRoom",
                        { "set": { "shaking": false }},
                        "checkcameraShakerActive",
                        { "where": {
                            "variable": "currentValue",
                            "equals": "loud",
                            "stopIfEmpty": true
                        }},
                        { "set": { "shaking": true }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "toolFunctionMixin"
            ]}
        },
        "cameraContent": {
            "schema": {
                "shaking": "boolean"
            },
            "mappings": {
                "shaking": [ "memory", "cauldron" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="CameraShakerTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="cameraShakerToolBody">
        &lt;div class="tool-title">Camera Shaker Tool&lt;/div>
        &lt;template-ref template-name="toolFunctionMixinBody">&lt;/template-ref>
    &lt;/varv-template>

    &lt;varv-template name="cameraShakerToolOptions">
        &lt;template-ref template-name="toolFunctionMixinOptions">&lt;/template-ref>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>

    &lt;varv-template name="cameraContentBody">
        &lt;div class="element-title" property="cameraStream">
            &lt;span property="client">
                &lt;span property="user">{name}: &lt;/span>{name}
            &lt;/span>
        &lt;/div>
        &lt;div class="placeholder-icon m-ico">photo_camera&lt;/div>
        &lt;video property="cameraStream" data-stream="{id}" data-stream-type="camera" style="object-fit: {fit}; width: {videoWidth}px; height: {videoHeight}px; left: -{cropOffsetLeftCorrected}%; top: -{cropOffsetTopCorrected}%;" data-client-in-room="{clientInRoom}" data-shaking="{shaking}">&lt;/video>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="CameraShakerTool Style" auto>.cameraContent video[data-stream-type="camera"][data-shaking="true"] {
    animation: shake 0.5s;
    animation-iteration-count: infinite;
    filter: contrast(200%);
}

// https://www.w3schools.com/howto/howto_css_shake_image.asp
@keyframes shake {
    0% { transform: scaleX(-1) scale(1.1) translate(1px, 1px) rotate(0deg); }
    10% { transform: scaleX(-1) scale(1.1) translate(-1px, -2px) rotate(-1deg); }
    20% { transform: scaleX(-1) scale(1.1) translate(-3px, 0px) rotate(1deg); }
    30% { transform: scaleX(-1) scale(1.1) translate(3px, 2px) rotate(0deg); }
    40% { transform: scaleX(-1) scale(1.1) translate(1px, -1px) rotate(1deg); }
    50% { transform: scaleX(-1) scale(1.1) translate(-1px, 2px) rotate(-1deg); }
    60% { transform: scaleX(-1) scale(1.1) translate(-3px, 1px) rotate(0deg); }
    70% { transform: scaleX(-1) scale(1.1) translate(3px, 1px) rotate(-1deg); }
    80% { transform: scaleX(-1) scale(1.1) translate(-1px, -1px) rotate(1deg); }
    90% { transform: scaleX(-1) scale(1.1) translate(1px, 2px) rotate(0deg); }
    100% { transform: scaleX(-1) scale(1.1) translate(1px, -2px) rotate(-1deg); }
  }
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="RecordingTool" id="RecordingTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Records a single camera feed.",
    "dependencies": [
        "#RecordingTools",
        "#ToolElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="RecordingTool Concepts" auto>{
    "concepts": {
        "recordingTool": {
            "schema": {
                "isRecording": "boolean",
                "showRecordingEmbedded": "boolean",
                "lastRecordingUrl": "string"
            },
            "mappings": {
                "isRecording": [ "memory", "cauldron" ]
            },
            "actions": {
                "recordingToolDrop": [
                    { "select": "$movedElement" },
                    "getType",
                    { "where": {
                        "variable": "getType",
                        "equals": "cameraContent"
                    }},
                    { "get": "cameraStream" },
                    { "select": "$get" },
                    { "get": "id" },
                    { "startRecording": {
                        "streamId": "$get",
                        "source": "$targetElement"
                    }},
                    { "select": "$targetElement" },
                    { "set": { "isRecording": true }}
                ],
                "stopRecording": {
                    "when": { "click": { "view": "stopRecordingButton" }},
                    "then": [
                        "stopRecording",
                        { "set": { "isRecording": false }}
                    ]
                },
                "handleNewRecording": {
                    "then": [
                        "debugContext",
                        { "select": "meeting" },
                        { "get": { "property": "fullscreenRoom", "as": "parent" }},
                        { "new": {
                            "concept": "videoContent",
                            "with": {
                                "videoUrl": "$recordingUrl",
                                "parentRoom": "$parent"
                            }
                        }},
                        { "select": {
                            "target": "$source",
                            "stopIfEmpty": true
                        }},
                        { "set": { "lastRecordingUrl": "$recordingUrl" }}
                    ]
                },
                "handleNewRecordingEmbedded": {
                    "when": "newRecording",
                    "then": [
                        { "select": {
                            "target": "$source",
                            "stopIfEmpty": true
                        }},
                        { "set": { "lastRecordingUrl": "$recordingUrl" }},
                        { "where": {
                            "property": "showRecordingEmbedded",
                            "equals": false,
                            "stopIfEmpty": true
                        }},
                        { "get": { "property": "fullscreenRoom", "as": "parent" }},
                        { "new": {
                            "concept": "videoContent",
                            "with": {
                                "videoUrl": "$recordingUrl",
                                "parentRoom": "$parent"
                            }
                        }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="RecordingTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="recordingToolBody">
        &lt;div class="tool-title">Recording Tool&lt;/div>
        &lt;video if="showRecordingEmbedded" src="{lastRecordingUrl}" class="recording-video" draggable="false" controls>&lt;/video>
        &lt;label if="!showRecordingEmbedded">Drop Video to Start Recording&lt;/label>
        &lt;label if="isRecording">Recording video ...&lt;/label>
        &lt;button view="stopRecordingButton" if="isRecording">Stop Recording&lt;/button>
    &lt;/varv-template>

    &lt;varv-template name="recordingToolOptions">
        &lt;label>
            Show recording embedded:
            &lt;input value="{showRecordingEmbedded}" type="checkbox">
        &lt;/label>
        &lt;label if="showRecordingEmbedded">
            Last recording URL:
            &lt;input value="{lastRecordingUrl}">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="RecordingTool Style" auto>.recordingTool .recording-video {
    width: 100%;
    border-radius: 4px;
    flex: 1 0 auto;
    object-fit: cover;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="RoomRecordingTool" id="RoomRecordingTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Records the whole workspace of a room (not working on GitHub release of Mirrorverse).",
    "dependencies": [
        "#RecordingTools",
        "#ToolElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="RoomRecordingTool Concepts" auto>{
    "concepts": {
        "roomRecordingTool": {
            "schema": {
                "placeholder": "string",
                "isRecording": "boolean"
            },
            "mappings": {
                "isRecording": [ "memory", "cauldron" ]
            },
            "actions": {
                "startRecording": {
                    "when": { "click": { "view": "startRoomRecordingButton" }},
                    "then": [
                        { "get": "meeting.fullscreenRoom" },
                        { "startRoomRecording": { "fullscreenRoom": "$get" }},
                        { "set": { "isRecording": true }}
                    ]
                },
                "stopRecording": {
                    "when": { "click": { "view": "stopRoomRecordingButton" }},
                    "then": [
                        "stopRoomRecording",
                        { "set": { "isRecording": false }}
                    ]
                },
                "handleNewRoomRecording": {
                    "when": "newRoomRecording",
                    "then": [
                        { "select": "meeting" },
                        { "get": { "property": "fullscreenRoom", "as": "parent" }},
                        { "new": {
                            "concept": "videoContent",
                            "with": {
                                "videoUrl": "$recordingUrl",
                                "parentRoom": "$parent"
                            }
                        }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin"
            ]}
        },
        "meeting": {
            "schema": {
                "videostrates": "boolean",
                "videostratesFullscreenRoom": "roomElement"
            },
            "mappings": {
                "videostrates": [ "location", "cauldron" ],
                "videostratesFullscreenRoom": [ "location", "cauldron" ]
            },
            "actions": {
                "videostrates": {
                    "when": { "interval": 5000 },
                    "then": [
                        { "where": {
                            "property": "meeting.videostrates",
                            "equals": true,
                            "stopIfEmpty": true
                        }},
                        { "get": "meeting.videostratesFullscreenRoom" },
                        { "where": {
                            "property": "meeting.fullscreenRoom",
                            "unequals": "$get",
                            "stopIfEmpty": true
                        }},
                        { "set": { "meeting.fullscreenRoom": "$get" }}
                    ]
                }
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="RoomRecordingTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="roomRecordingToolBody">
        &lt;div class="tool-title">Room Recording Tool&lt;/div>
        &lt;button view="startRoomRecordingButton" if="!isRecording">Start Room Recording&lt;/button>
        &lt;button view="stopRoomRecordingButton" if="isRecording">Stop Room Recording&lt;/button>
    &lt;/varv-template>

    &lt;varv-template name="roomRecordingToolOptions">
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Videostrates Recording Style" auto>.meeting[data-videostrates="true"] {
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    align-items: flex-start;
    justify-content: flex-start;

    .header,
    .panel-group,
    .sidebar {
        display: none;
    }

    .content {
        border-radius: 0;

        .element-title,
        .client-overview {
            display: none;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="DoorwayTool" id="DoorwayTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Allows listening into rooms.",
    "dependencies": [
        "#WindowTools",
        "#ToolElement",
        "#ToolFunctionMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="DoorwayTool Concepts" auto>{
    "concepts": {
        "doorwayTool": {
            "schema": {
                "placholder": "string"
            },
            "actions": {
                "updateIsHoveredForListeningIn": {
                    "when": { "interval": 1000 },
                    "then": [
                        { "where": {
                            "property": "toolManager.doorwayActive",
                            "equals": true,
                            "stopIfEmpty": true
                        }},
                        { "select": "roomElement" },
                        "checkInfullscreenRoom",
                        { "run": "resetIsHoveredForListeningIn" },
                        "cursorPosition",
                        "correctCursorPosition",
                        { "where": {
                            "and": [
                                { "variable": "x", "greaterThan": "$target.left" },
                                { "variable": "x", "lessThan": { "calculate": "$target.left$+$target.width$" } },
                                { "variable": "y", "greaterThan": { "calculate": "$target.top$" }},
                                { "variable": "y", "lessThan": { "calculate": "$target.top$+$target.height$" }}
                            ],
                            "stopIfEmpty": true
                        }},
                        { "set": { "isHoveredForListeningIn": true }},
                        { "select": { "property": "clients", "forEach": true }},
                        { "set": { "inHoveredRoom": true }}
                    ]
                },
                "resetIsHoveredForListeningIn": [
                    { "set": { "isHoveredForListeningIn": false }},
                    { "select": { "property": "clients", "forEach": true }},
                    { "set": { "inHoveredRoom": false }}
                ]
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "toolFunctionMixin"
            ]}
        },
        "roomElement": {
            "schema": {
                "isHoveredForListeningIn": "boolean"
            },
            "mappings": {
                "isHoveredForListeningIn": [ "memory", "cauldron" ]
            }
        },
        "toolManager": {
            "schema": {
                "doorwayActive": { "boolean": {
                    "derive": {
                        "properties": [ "doorwayTool.isActive" ],
                        "transform": [
                            { "exists": {
                                "concept": "doorwayTool",
                                "where": {
                                    "property": "isActive",
                                    "equals": true
                                }
                            }}
                        ]
                    }
                }},
                "doorwayHoveredExists": { "boolean": {
                    "derive": {
                        "properties": [ "regularRoom.isHoveredForListeningIn" ],
                        "transform": [
                            { "exists": {
                                "concept": "roomElement",
                                "where": {
                                    "property": "isHoveredForListeningIn",
                                    "equals": true
                                }
                            }}
                        ]
                    }
                }}
            },
            "mappings": {
                "doorwayActive": [ "memory", "cauldron" ],
                "doorwayHoveredExists": [ "memory", "cauldron" ]
            }
        },
        "client": {
            "schema": {
                "inHoveredRoom": "boolean"
            },
            "mappings": {
                "inHoveredRoom": [ "memory", "cauldron" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="DoorwayMirror Template" auto>&lt;dom-view-template>
    &lt;varv-template name="doorwayToolBody">
        &lt;div class="tool-title">Doorway Tool&lt;/div>
        &lt;template-ref template-name="toolFunctionMixinBody">&lt;/template-ref>
    &lt;/varv-template>

    &lt;varv-template name="doorwayToolOptions">
        &lt;template-ref template-name="toolFunctionMixinOptions">&lt;/template-ref>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="DoorwayTool Volume Routing" auto>{
  "rootConnections": {
    "volume": {
      "position": {
        "x": 2745.75,
        "y": 2616
      },
      "connection": "19raEkariU"
    }
  },
  "nodes": {
    "NJze4UOYlA": {
      "nodeType": "ValueNode",
      "value": 0,
      "position": {
        "x": 2643.75,
        "y": 3575
      },
      "type": "volume"
    },
    "S9gcODgW3g": {
      "nodeType": "ValueNode",
      "value": 0.5,
      "position": {
        "x": 2799.75,
        "y": 3572
      },
      "type": "volume"
    },
    "2bTYSJ6bNB": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 2946.75,
        "y": 3575
      },
      "type": "volume"
    },
    "LgEjFUx25k": {
      "nodeType": "DecisionNode",
      "name": "volumeClientLogicalDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 3,
      "decisions": [
        {
          "comparator": "greaterThan",
          "value": 1,
          "connection": "NJze4UOYlA"
        },
        {
          "comparator": "equals",
          "value": 1,
          "connection": "S9gcODgW3g"
        },
        {
          "comparator": "equals",
          "value": 0,
          "connection": "2bTYSJ6bNB"
        }
      ],
      "position": {
        "x": 2658.75,
        "y": 3359
      }
    },
    "RLbhSiMhtj": {
      "nodeType": "ValueNode",
      "value": 0,
      "position": {
        "x": 2895.75,
        "y": 3295
      },
      "type": "volume"
    },
    "umLpbpAwFh": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 3038.75,
        "y": 3292
      },
      "type": "volume"
    },
    "ke15KV1cSe": {
      "nodeType": "DecisionNode",
      "name": "volumeClientInHovered",
      "concept": "client",
      "property": "inHoveredRoom",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "RLbhSiMhtj"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "umLpbpAwFh"
        }
      ],
      "position": {
        "x": 2898.75,
        "y": 3105
      }
    },
    "73Ca7JJHAw": {
      "nodeType": "DecisionNode",
      "name": "volumeExistsHovered",
      "concept": "toolManager",
      "property": "doorwayHoveredExists",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "LgEjFUx25k"
        },
        {
          "comparator": "equals",
          "value": false,
          "connection": "ke15KV1cSe"
        }
      ],
      "position": {
        "x": 2770.75,
        "y": 2914
      }
    },
    "19raEkariU": {
      "nodeType": "DecisionNode",
      "name": "volumedoorwayActive",
      "concept": "toolManager",
      "property": "doorwayActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "LgEjFUx25k"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "73Ca7JJHAw"
        }
      ],
      "position": {
        "x": 2657.75,
        "y": 2720
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="DoorwayTool Filter Routing" auto>{
  "rootConnections": {
    "audioFilter": {
      "position": {
        "x": 2647.25,
        "y": 2560
      },
      "connection": "3qEccHXEYd"
    }
  },
  "nodes": {
    "K3uZTNW6VQ": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2563.25,
        "y": 3271
      },
      "type": "audioFilter"
    },
    "FUf0416U07": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2714.25,
        "y": 3635
      },
      "type": "audioFilter"
    },
    "rScKXNSFIH": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2893.25,
        "y": 3634
      },
      "type": "audioFilter"
    },
    "C5E6P2PNS1": {
      "nodeType": "DecisionNode",
      "name": "filterLocationHasFilter",
      "concept": "currentRoom",
      "property": "audioFilter",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": "",
          "connection": "FUf0416U07"
        },
        {
          "comparator": "unequals",
          "value": "",
          "connection": "rScKXNSFIH"
        }
      ],
      "position": {
        "x": 2705.25,
        "y": 3433
      }
    },
    "1kWhmMpUFO": {
      "nodeType": "DecisionNode",
      "name": "filterClientLogicalDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 1,
          "connection": "K3uZTNW6VQ"
        },
        {
          "comparator": "equals",
          "value": 0,
          "connection": "C5E6P2PNS1"
        }
      ],
      "position": {
        "x": 2565.25,
        "y": 3032
      }
    },
    "g2JEiwDI38": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2845.25,
        "y": 3283
      },
      "type": "audioFilter"
    },
    "UrFfooDXhs": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 3004.25,
        "y": 3282
      },
      "type": "audioFilter"
    },
    "fOt7eLofpb": {
      "nodeType": "DecisionNode",
      "name": "filterClientInHovered",
      "concept": "client",
      "property": "inHoveredRoom",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "g2JEiwDI38"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "UrFfooDXhs"
        }
      ],
      "position": {
        "x": 2858.25,
        "y": 3061
      }
    },
    "bm9IK40lob": {
      "nodeType": "DecisionNode",
      "name": "filterExistsHovered",
      "concept": "toolManager",
      "property": "doorwayHoveredExists",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "1kWhmMpUFO"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "fOt7eLofpb"
        }
      ],
      "position": {
        "x": 2846.25,
        "y": 2837
      }
    },
    "3qEccHXEYd": {
      "nodeType": "DecisionNode",
      "name": "filterDoorwayActive",
      "concept": "toolManager",
      "property": "doorwayActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "1kWhmMpUFO"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "bm9IK40lob"
        }
      ],
      "position": {
        "x": 2561.25,
        "y": 2667
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="ProximityBasedAudioTool" id="ProximityBasedAudioTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Proximity-based audio in a room. Uses the avatar content elements.",
    "dependencies": [
        "#FindAction",
        "#ToolElement",
        "#ToolFunctionMixin",
        "#AvatarContent"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ProximityBasedAudioTool Concepts" auto>{
    "concepts": {
        "proximityBasedAudioTool": {
            "schema": {
                "placeholder": "string",
                "proximityUsersWithoutPodium": { "array": {
                    "items": "user",
                    "derive": {
                        "properties": [
                            "avatarContent.distance",
                            "meeting.fullscreenRoom"
                        ],
                        "transform": [
                            { "get": { "property": "meeting.fullscreenRoom", "as": "fullscreen" }},
                            { "select": {
                                "concept": "avatarContent",
                                "where": { "and": [
                                    { "property": "parentRoom", "equals": "$fullscreen" },
                                    { "property": "distance", "lessThan": 150 }
                                ]}
                            }},
                            { "find": { "property": "user" }}
                        ]
                    }
                }}
            },
            "mappings": {
                "proximityUsers": [ "memory", "cauldron" ]
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "toolFunctionMixin"
            ]}
        },
        "user": {
            "schema": {
                "proximityClients": { "array": {
                    "items": "client",
                    "derive": {
                        "properties": [
                            "client.location",
                            "client.user",
                            "meeting.fullscreenRoom"
                        ],
                        "transform": [
                            { "get": { "property": "meeting.fullscreenRoom", "as": "fullscreen" }},
                            { "find": {
                                "concept": "client",
                                "where": { "and": [
                                    { "property": "location", "equals": "$fullscreen" },
                                    { "property": "user", "equals": "$lastTarget" }
                                ]}
                            }}
                        ]
                    }
                }}
            },
            "mappings": {
                "proximityClients": [ "memory", "cauldron" ]
            }
        },
        "toolManager": {
            "schema": {
                "proximityBasedAudioActive": { "boolean": {
                    "derive": {
                        "properties": [ "proximityBasedAudioTool.isActive" ],
                        "transform": [
                            { "exists": {
                                "concept": "proximityBasedAudioTool",
                                "where": {
                                    "property": "isActive",
                                    "equals": true
                                }
                            }}
                        ]
                    }
                }}
            },
            "mappings": {
                "proximityBasedAudioActive": [ "memory", "cauldron" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="ProximityBasedAudioTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="proximityBasedAudioToolBody">
        &lt;div class="tool-title">Proximity-based Audio Tool&lt;/div>
        &lt;div property="proximityUsers" class="proximity-users">
            &lt;div class="user-title">{name}&lt;/div>
            &lt;div property="proximityClients" class="proximity-clients" title="Client {name}">
                &lt;div class="video-title">{name}&lt;/div>
                &lt;video property="cameraStream" data-stream="{id}" data-stream-type="camera">
                &lt;/video>
            &lt;/div>
        &lt;/div>
    &lt;/varv-template>

    &lt;varv-template name="proximityBasedAudioToolOptions">
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="ProximityBasedAudioTool Style" auto>@mixin heading-font {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}



.proximityBasedAudioTool>.element-body {
    flex-wrap: nowrap !important;
    flex-direction: column !important;

    .proximity-users {
        flex: 1 1 auto;

        @include heading-font;
        text-align: center;

        display: flex;
        flex-wrap: nowrap;
        flex-direction: column;
        gap: 4px;

        background: #424242;
        border-radius: 8px;
        padding: 4px;

        .user-title {
            padding: 2px 0;
        }

        .proximity-clients {
            flex: 1 1 144px;
            background: #333333;
            border: 1px solid #848484;
            border-radius: 8px;
            overflow: hidden;
            position: relative;

            .video-title {
                @include heading-font;

                position: absolute;
                top: 0px;
                left: 0px;
                height: 16px;

                background: #848484;
                color: #fff;

                border-bottom-right-radius: 6px;
                border-top-left-radius: 4px;

                line-height: 16px;
                padding: 2px 8px;
                user-select: none;

                &:empty {
                    display: none;
                }
            }

            video {
                width: 100% !important;
                height: 100% !important;
                object-fit: cover;
                transform: scaleX(-1);
                border-radius: 8px;
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="ProximityBasedAudioTool Muted Routing" auto>{
  "rootConnections": {
    "muted": {
      "position": {
        "x": 2765.800048828125,
        "y": 2603.5
      },
      "connection": "ZmEA2h52Xn"
    }
  },
  "nodes": {
    "cOws1LEgka": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2606.199951171875,
        "y": 3221.7125358581543
      },
      "type": "muted"
    },
    "Sw0B1x9Vm9": {
      "nodeType": "ValueNode",
      "value": false,
      "position": {
        "x": 2685.800048828125,
        "y": 3393.5
      },
      "type": "muted"
    },
    "0AuPuPxxYm": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2806.800048828125,
        "y": 3598.5
      },
      "type": "muted"
    },
    "0t8RSi0qGv": {
      "nodeType": "ValueNode",
      "value": false,
      "position": {
        "x": 2951.800048828125,
        "y": 3600.5
      },
      "type": "muted"
    },
    "L9CueKVYRa": {
      "nodeType": "DecisionNode",
      "name": "mutedInProximityDistance",
      "concept": "client",
      "property": "distance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 150,
          "connection": "0AuPuPxxYm"
        },
        {
          "comparator": "lessThan",
          "value": 150,
          "connection": "0t8RSi0qGv"
        }
      ],
      "position": {
        "x": 2833.800048828125,
        "y": 3386.5
      }
    },
    "pWndXjd86V": {
      "nodeType": "DecisionNode",
      "name": "mutedproximityBasedAudioActive",
      "concept": "toolManager",
      "property": "proximityBasedAudioActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "Sw0B1x9Vm9"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "L9CueKVYRa"
        }
      ],
      "position": {
        "x": 2746.800048828125,
        "y": 3185.5
      }
    },
    "rYSeeaKep4": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientInDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 2,
          "connection": "cOws1LEgka"
        },
        {
          "comparator": "lessThan",
          "value": 2,
          "connection": "pWndXjd86V"
        }
      ],
      "position": {
        "x": 2611.800048828125,
        "y": 2987.3124504089355
      }
    },
    "4GpHRhnuOX": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2763.000030517578,
        "y": 2906.312511444092
      },
      "type": "muted"
    },
    "ZmEA2h52Xn": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientMuted",
      "concept": "client",
      "property": "muted",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "rYSeeaKep4"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "4GpHRhnuOX"
        }
      ],
      "position": {
        "x": 2678.800048828125,
        "y": 2713.5
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="PodiumTool" name="PodiumTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A podium to talk to all avatars when using proximity-based audio.",
    "dependencies": [
        "#FindAction",
        "#ToolElement",
        "#ProximityBasedAudioTool"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" auto name="PodiumTool Concepts">{
    "concepts": {
        "podiumTool": {
            "schema": {
                "inToolPanel": { "boolean": { "default": false }}
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin"
            ]}
        },
        "client": {
            "schema": {
                "onPedestal": "boolean"
            }
        },
        "avatarContent": {
            "schema": {
                "onPedestal": "boolean"
            },
            "actions": {
                "updatePedestal": {
                    "when": [
                        { "stateChanged": {
                            "concept": "avatarContent",
                            "property": "left"
                        }},
                        { "stateChanged": {
                            "concept": "avatarContent",
                            "property": "top"
                        }},
                        { "stateChanged": {
                            "concept": "podiumTool",
                            "property": "left"
                        }},
                        { "stateChanged": {
                            "concept": "podiumTool",
                            "property": "top"
                        }},
                        { "stateChanged": {
                            "concept": "client",
                            "property": "location"
                        }}
                    ],
                    "then": [
                        { "where": {
                            "property": "toolManager.proximityBasedAudioActive",
                            "equals": true,
                            "stopIfEmpty": true
                        }},
                        "selectOwnAvatarInRoom",
                        { "set": { "onPedestal": false }},
                        { "set": { "variable": "myAvatar", "value": "$target" }},
                        { "get": { "property": "left", "as": "ownLeft" }},
                        { "get": { "property": "top", "as": "ownTop" }},
                        { "select": "podiumTool" },
                        "checkInfullscreenRoom",
                        { "limit": 1 },
                        { "get": { "property": "left", "as": "otherLeft" }},
                        { "get": { "property": "top", "as": "otherTop" }},
                        { "calculate": {
                            "expression": "floor(sqrt(square($ownLeft$ - $otherLeft$) + square($ownTop$ - $otherTop$)))",
                            "as": "distance"
                        }},
                        { "eval": {
                            "variable": "distance",
                            "lessThan": 150
                        }},
                        { "select": "$myAvatar" },
                        { "set": { "onPedestal": "$eval" }},
                        { "select": {
                            "property": "user",
                            "forEach": true
                        }},
                        { "select": {
                            "concept": "client",
                            "where": {
                                "property": "user",
                                "equals": "$lastTarget"
                            },
                            "forEach": true
                        }},
                        { "set": { "onPedestal": "$eval" }}
                    ]
                }
            }
        },
        "proximityBasedAudioTool": {
            "schema": {
                "proximityUsers": { "array": {
                    "items": "user",
                    "derive": {
                        "properties": [
                            "avatarContent.distance",
                            "avatarContent.onPedestal",
                            "meeting.fullscreenRoom"
                        ],
                        "transform": [
                            { "get": { "property": "meeting.fullscreenRoom", "as": "fullscreen" }},
                            { "select": {
                                "concept": "avatarContent",
                                "where": { "and": [
                                    { "property": "parentRoom", "equals": "$fullscreen" },
                                    { "or": [
                                        { "property": "distance", "lessThan": 150 },
                                        { "property": "onPedestal", "equals": true }
                                    ]}
                                ]}
                            }},
                            { "find": { "property": "user" }}
                        ]
                    }
                }}
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" auto name="PodiumTool Template">&lt;dom-view-template>
    &lt;varv-template name="podiumToolBody">
        &lt;div class="tool-title">Podium Tool&lt;/div>
    &lt;/varv-template>

    &lt;varv-template name="podiumToolOptions">
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>

    &lt;varv-template name="avatarContentBody">
        &lt;img src="{avatarUrl}" class="avatar-image no-user" draggable="false" tabindex=0 if="!user" title="Missing User">
        &lt;img src="{avatarUrl}" class="avatar-image" data-in-distance="{inDistance}" data-on-pedestal="{onPedestal}" draggable="false" tabindex=0 property="user" title="{name}">
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" auto name="PodiumTool Style">.avatarContent>.element-body .avatar-image[data-on-pedestal="true"] {
    filter: drop-shadow(0 0 2px red) drop-shadow(0 0 3px red) drop-shadow(0 0 8px #cccccc);
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="PodiumTool Muted Routing" auto>{
  "rootConnections": {
    "muted": {
      "position": {
        "x": 2664.300048828125,
        "y": 2538.5
      },
      "connection": "ZmEA2h52Xn"
    }
  },
  "nodes": {
    "cOws1LEgka": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2579.699951171875,
        "y": 3148.7125358581543
      },
      "type": "muted"
    },
    "Sw0B1x9Vm9": {
      "nodeType": "ValueNode",
      "value": false,
      "position": {
        "x": 2659.300048828125,
        "y": 3320.5
      },
      "type": "muted"
    },
    "0AuPuPxxYm": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2578.300048828125,
        "y": 3718.5
      },
      "type": "muted"
    },
    "0t8RSi0qGv": {
      "nodeType": "ValueNode",
      "value": false,
      "position": {
        "x": 2860.300048828125,
        "y": 3729.5
      },
      "type": "muted"
    },
    "L9CueKVYRa": {
      "nodeType": "DecisionNode",
      "name": "mutedInProximityDistance",
      "concept": "client",
      "property": "distance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 150,
          "connection": "0AuPuPxxYm"
        },
        {
          "comparator": "lessThan",
          "value": 150,
          "connection": "0t8RSi0qGv"
        }
      ],
      "position": {
        "x": 2636.300048828125,
        "y": 3509.5
      }
    },
    "Q7C3YKmRd8": {
      "nodeType": "DecisionNode",
      "name": "mutedOnPedestal",
      "concept": "client",
      "property": "onPedestal",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "L9CueKVYRa"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "0t8RSi0qGv"
        }
      ],
      "position": {
        "x": 2850.300048828125,
        "y": 3317.5
      }
    },
    "pWndXjd86V": {
      "nodeType": "DecisionNode",
      "name": "mutedproximityBasedAudioActive",
      "concept": "toolManager",
      "property": "proximityBasedAudioActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "Sw0B1x9Vm9"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "Q7C3YKmRd8"
        }
      ],
      "position": {
        "x": 2720.300048828125,
        "y": 3112.5
      }
    },
    "rYSeeaKep4": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientInDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 2,
          "connection": "cOws1LEgka"
        },
        {
          "comparator": "lessThan",
          "value": 2,
          "connection": "pWndXjd86V"
        }
      ],
      "position": {
        "x": 2585.300048828125,
        "y": 2914.3124504089355
      }
    },
    "4GpHRhnuOX": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2736.500030517578,
        "y": 2833.312511444092
      },
      "type": "muted"
    },
    "ZmEA2h52Xn": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientMuted",
      "concept": "client",
      "property": "muted",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "rYSeeaKep4"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "4GpHRhnuOX"
        }
      ],
      "position": {
        "x": 2583.300048828125,
        "y": 2636.5
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="WhisperTool" id="WhisperTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Allows whispering directly to other clients.",
    "dependencies": [
        "#FindAction",
        "#WindowTools",
        "#ToolElement",
        "#ToolFunctionMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="WhisperTool Concepts" auto>{
    "concepts": {
        "whisperTool": {
            "schema": {
                "placholder": "string"
            },
            "actions": {
                "updateWhisperTarget": {
                    "when": { "interval": 1000 },
                    "then": [
                        { "where": {
                            "property": "toolManager.whisperActive",
                            "equals": true,
                            "stopIfEmpty": true
                        }},
                        "selectLocalClient",
                        { "set": { "whisperTarget": "" }},
                        { "select": "cameraContent" },
                        "checkInfullscreenRoom",
                        "cursorPosition",
                        "correctCursorPosition",
                        { "where": {
                            "and": [
                                { "variable": "x", "greaterThan": "$target.left" },
                                { "variable": "x", "lessThan": { "calculate": "$target.left$+$target.width$" } },
                                { "variable": "y", "greaterThan": { "calculate": "$target.top$" }},
                                { "variable": "y", "lessThan": { "calculate": "$target.top$+$target.height$" }}
                            ],
                            "stopIfEmpty": true
                        }},
                        { "limit": 1 },
                        { "select": {
                            "property": "cameraStream",
                            "forEach": true,
                            "stopIfEmpty": true
                        }},
                        { "select": {
                            "property": "client",
                            "forEach": true,
                            "stopIfEmpty": true
                        }},
                        { "set": { "variable": "whisperTarget", "value": "$target" }},
                        { "select": {
                            "concept": "client",
                            "where": {
                                "property": "local",
                                "equals": true
                            },
                            "forEach": true,
                            "stopIfEmpty": true
                        }},
                        { "set": { "whisperTarget": "$whisperTarget" }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "toolFunctionMixin"
            ]}
        },
        "client": {
            "schema": {
                "whisperTarget": "client"
            }
        },
        "toolManager": {
            "schema": {
                "whisperActive": { "boolean": {
                    "derive": {
                        "properties": [ "whisperTool.isActive" ],
                        "transform": [
                            { "exists": {
                                "concept": "whisperTool",
                                "where": {
                                    "property": "isActive",
                                    "equals": true
                                }
                            }}
                        ]
                    }
                }},
                "whisperTargeted": { "boolean": {
                    "derive": {
                        "properties": [ "client.whisperTarget" ],
                        "transform": [
                            { "get": "userManager.localClient" },
                            { "exists": {
                                "concept": "client",
                                "where": {
                                    "property": "whisperTarget",
                                    "equals": "$get"
                                }
                            }}
                        ]
                    }
                }},
                "whisperTargetedBy": { "array": {
                    "items": "client",
                    "derive": {
                        "properties": [ "client.whisperTarget" ],
                        "transform": [
                            { "get": "userManager.localClient" },
                            { "find": {
                                "concept": "client",
                                "where": {
                                    "property": "whisperTarget",
                                    "equals": "$get"
                                }
                            }}
                        ]
                    }
                }}
            },
            "mappings": {
                "whisperActive": [ "memory", "cauldron" ],
                "whisperTargeted": [ "memory", "cauldron" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="WhisperTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="whisperToolBody">
        &lt;div class="tool-title">Whisper Tool&lt;/div>
        &lt;template-ref template-name="toolFunctionMixinBody">&lt;/template-ref>
        &lt;div class="whisper-section" concept="userManager" property="localClient">
            &lt;div class="whisper-section-title">Whispering to:&lt;/div>
            &lt;div class="whisper-client" property="whisperTarget">
                &lt;span property="user">{name}: &lt;/span>{name}
            &lt;/div>
        &lt;/div>
        &lt;div class="whisper-section" concept="toolManager">
            &lt;div class="whisper-section-title">Being whispered to by:&lt;/div>
            &lt;div class="whisper-client" property="whisperTargetedBy">
                &lt;span property="user">{name}: &lt;/span> {name}
            &lt;/div>
        &lt;/div>
    &lt;/varv-template>

    &lt;varv-template name="whisperToolOptions">
        &lt;template-ref template-name="toolFunctionMixinOptions">&lt;/template-ref>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="WhisperTool Style" auto>@mixin heading-font {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}



.whisperTool>.element-body {
    flex-wrap: nowrap !important;
    flex-direction: column !important;

    .whisper-section {
        flex: 1 1 auto;

        @include heading-font;
        text-align: center;

        display: flex;
        flex-wrap: nowrap;
        flex-direction: column;
        gap: 4px;

        background: #424242;
        border-radius: 8px;
        padding: 4px;

        .whisper-section-title {
            padding: 2px 0;
        }

        .whisper-client {
            flex: 1 0 32px;
            background: #333333;
            border: 1px solid #848484;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="WhisperTool Volume Routing" auto>{
  "rootConnections": {
    "volume": {
      "position": {
        "x": 2558.4500274658203,
        "y": 2447.200023651123
      },
      "connection": "7nfLkWCxEa"
    }
  },
  "nodes": {
    "NoVla0FWWm": {
      "nodeType": "ValueNode",
      "value": 0,
      "position": {
        "x": 2451.449935913086,
        "y": 2978.800037384033
      },
      "type": "volume"
    },
    "CAIcGVCsm0": {
      "nodeType": "ValueNode",
      "value": 0.5,
      "position": {
        "x": 2617.0499725341797,
        "y": 2977.399890899658
      },
      "type": "volume"
    },
    "OIc3npFR9a": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 2505.049819946289,
        "y": 3741.4001960754395
      },
      "type": "volume"
    },
    "tpy4gmRP9g": {
      "nodeType": "ValueNode",
      "value": 0.3,
      "position": {
        "x": 2830.6499786376953,
        "y": 3748.799976348877
      },
      "type": "volume"
    },
    "xmzFZT3Tpu": {
      "nodeType": "DecisionNode",
      "name": "volumeAnyoneWhispersToMe",
      "concept": "toolManager",
      "property": "whisperTargeted",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "OIc3npFR9a"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "tpy4gmRP9g"
        }
      ],
      "position": {
        "x": 2664.449905395508,
        "y": 3491.799976348877
      }
    },
    "vgXQprbLv0": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 3108.0499725341797,
        "y": 3744.9875259399414
      },
      "type": "volume"
    },
    "IsSVGugff8": {
      "nodeType": "DecisionNode",
      "name": "volumeWhispersToMe",
      "concept": "toolManager",
      "property": "whisperTargetedBy",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "includes",
          "value": "$client",
          "connection": "tpy4gmRP9g"
        },
        {
          "comparator": "includes",
          "value": "$client",
          "connection": "vgXQprbLv0"
        }
      ],
      "position": {
        "x": 2936.249954223633,
        "y": 3494.400074005127
      }
    },
    "KVFodKj9zO": {
      "nodeType": "DecisionNode",
      "name": "volumeIsWhispering",
      "concept": "client",
      "property": "whisperTarget",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": "",
          "connection": "xmzFZT3Tpu"
        },
        {
          "comparator": "unequals",
          "value": "",
          "connection": "IsSVGugff8"
        }
      ],
      "position": {
        "x": 2845.850051879883,
        "y": 3269.7999153137207
      }
    },
    "0aHAiVw4QT": {
      "nodeType": "DecisionNode",
      "name": "volumeWhisperActive",
      "concept": "toolManager",
      "property": "whisperActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "OIc3npFR9a"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "KVFodKj9zO"
        }
      ],
      "position": {
        "x": 2672.649917602539,
        "y": 3059.8000984191895
      }
    },
    "tlE8U4K1WI": {
      "nodeType": "DecisionNode",
      "name": "volumeClientLogicalDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 3,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 1,
          "connection": "NoVla0FWWm"
        },
        {
          "comparator": "equals",
          "value": 1,
          "connection": "CAIcGVCsm0"
        },
        {
          "comparator": "equals",
          "value": 0,
          "connection": "0aHAiVw4QT"
        }
      ],
      "position": {
        "x": 2459.4500274658203,
        "y": 2772.6001777648926
      }
    },
    "hH1J0Lq5ax": {
      "nodeType": "ValueNode",
      "value": 0,
      "position": {
        "x": 2952.2498931884766,
        "y": 3008.800037384033
      },
      "type": "volume"
    },
    "EwpAvM8psA": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 3098.249954223633,
        "y": 3008.2000617980957
      },
      "type": "volume"
    },
    "94TJMgUpTV": {
      "nodeType": "DecisionNode",
      "name": "volumeClientInHovered",
      "concept": "client",
      "property": "inHoveredRoom",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "hH1J0Lq5ax"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "EwpAvM8psA"
        }
      ],
      "position": {
        "x": 2972.0498809814453,
        "y": 2815.800006866455
      }
    },
    "e9x6WwtBbb": {
      "nodeType": "DecisionNode",
      "name": "volumeExistsHovered",
      "concept": "toolManager",
      "property": "doorwayHoveredExists",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "tlE8U4K1WI"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "94TJMgUpTV"
        }
      ],
      "position": {
        "x": 2911.0499420166016,
        "y": 2590.4000282287598
      }
    },
    "7nfLkWCxEa": {
      "nodeType": "DecisionNode",
      "name": "volumedoorwayActive",
      "concept": "toolManager",
      "property": "doorwayActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "tlE8U4K1WI"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "e9x6WwtBbb"
        }
      ],
      "position": {
        "x": 2471.0499725341797,
        "y": 2559.600025177002
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="WhisperTool Filter Routing" auto>{
  "rootConnections": {
    "audioFilter": {
      "position": {
        "x": 2509.75,
        "y": 2273.5
      },
      "connection": "3qEccHXEYd"
    }
  },
  "nodes": {
    "mmR7pI87cW": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2420.75,
        "y": 2959.5
      },
      "type": "audioFilter"
    },
    "FUf0416U07": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2446.75,
        "y": 3928.5
      },
      "type": "audioFilter"
    },
    "rScKXNSFIH": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2618.75,
        "y": 3930.5
      },
      "type": "audioFilter"
    },
    "C5E6P2PNS1": {
      "nodeType": "DecisionNode",
      "name": "filterLocationHasFilter",
      "concept": "currentRoom",
      "property": "audioFilter",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": "",
          "connection": "FUf0416U07"
        },
        {
          "comparator": "unequals",
          "value": "",
          "connection": "rScKXNSFIH"
        }
      ],
      "position": {
        "x": 2428.75,
        "y": 3718.5
      }
    },
    "MfMGQHme7X": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2792.75,
        "y": 3702.5
      },
      "type": "audioFilter"
    },
    "wjx55vVir8": {
      "nodeType": "DecisionNode",
      "name": "filterAnyoneWhispersToMe",
      "concept": "toolManager",
      "property": "whisperTargeted",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "C5E6P2PNS1"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "MfMGQHme7X"
        }
      ],
      "position": {
        "x": 2644.75,
        "y": 3460.5
      }
    },
    "jQ2IkTyaGV": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2976.75,
        "y": 3706.5
      },
      "type": "audioFilter"
    },
    "hIw3Kw5Hb2": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 3145.75,
        "y": 3705.5
      },
      "type": "audioFilter"
    },
    "pS4ziWX0BD": {
      "nodeType": "DecisionNode",
      "name": "filterWhispersToMe",
      "concept": "toolManager",
      "property": "whisperTargetedBy",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "includes",
          "value": "$client",
          "connection": "jQ2IkTyaGV"
        },
        {
          "comparator": "includes",
          "value": "$client",
          "connection": "hIw3Kw5Hb2"
        }
      ],
      "position": {
        "x": 2998.75,
        "y": 3477.5
      }
    },
    "d2EkOYpR8O": {
      "nodeType": "DecisionNode",
      "name": "filterIsWhispering",
      "concept": "client",
      "property": "whisperTarget",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": "",
          "connection": "wjx55vVir8"
        },
        {
          "comparator": "unequals",
          "value": "",
          "connection": "pS4ziWX0BD"
        }
      ],
      "position": {
        "x": 2811.75,
        "y": 3257.5
      }
    },
    "xq0UNVtXei": {
      "nodeType": "DecisionNode",
      "name": "filterWhisperActive",
      "concept": "toolManager",
      "property": "whisperActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "C5E6P2PNS1"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "d2EkOYpR8O"
        }
      ],
      "position": {
        "x": 2509.75,
        "y": 3072.5
      }
    },
    "1kWhmMpUFO": {
      "nodeType": "DecisionNode",
      "name": "filterClientLogicalDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 1,
          "connection": "mmR7pI87cW"
        },
        {
          "comparator": "equals",
          "value": 0,
          "connection": "xq0UNVtXei"
        }
      ],
      "position": {
        "x": 2423.75,
        "y": 2736.5
      }
    },
    "g2JEiwDI38": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2703.75,
        "y": 2987.5
      },
      "type": "audioFilter"
    },
    "UrFfooDXhs": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2862.75,
        "y": 2986.5
      },
      "type": "audioFilter"
    },
    "fOt7eLofpb": {
      "nodeType": "DecisionNode",
      "name": "filterClientInHovered",
      "concept": "client",
      "property": "inHoveredRoom",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "g2JEiwDI38"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "UrFfooDXhs"
        }
      ],
      "position": {
        "x": 2716.75,
        "y": 2765.5
      }
    },
    "bm9IK40lob": {
      "nodeType": "DecisionNode",
      "name": "filterExistsHovered",
      "concept": "toolManager",
      "property": "doorwayHoveredExists",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "1kWhmMpUFO"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "fOt7eLofpb"
        }
      ],
      "position": {
        "x": 2704.75,
        "y": 2541.5
      }
    },
    "3qEccHXEYd": {
      "nodeType": "DecisionNode",
      "name": "filterDoorwayActive",
      "concept": "toolManager",
      "property": "doorwayActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "1kWhmMpUFO"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "bm9IK40lob"
        }
      ],
      "position": {
        "x": 2419.75,
        "y": 2371.5
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="BroadcastTool" name="BroadcastTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Allows broadcasting your voice to users in other rooms.",
    "dependencies": [
        "#ToolElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="BroadcastTool Concepts" auto>{
    "concepts": {
        "broadcastTool": {
            "schema": {
                "broadcasting": "boolean"
            },
            "mappings": {
                "broadcasting": [ "memory", "cauldron" ]
            },
            "actions": {
                "startBroadCasting": {
                    "when": { "mousedown": { "view": "broadcastButton" }},
                    "then": [
                        { "set": { "broadcasting": true }},
                        "selectLocalClient",
                        { "set": { "broadcasting": true }}
                    ]
                },
                "stopBroadCasting": {
                    "when": "mouseup",
                    "then": [
                        { "set": { "broadcasting": false }},
                        "selectLocalClient",
                        { "set": { "broadcasting": false }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin"
            ]}
        },
        "client": {
            "schema": {
                "broadcasting": "boolean"
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="BroadcastTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="broadcastToolBody">
        &lt;div class="tool-title">Broadcast Tool&lt;/div>
        &lt;button view="broadcastButton" class="broadcast-button" data-broadcasting="{broadcasting}">Broadcast&lt;/button>
    &lt;/varv-template>

    &lt;varv-template name="broadcastToolOptions">
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="BroadcastTool Style" auto>.broadcastTool .broadcast-button[data-broadcasting="true"] {
    background: #2e7d32;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="BroadcastTool Routing Muted" auto>{
  "rootConnections": {
    "muted": {
      "position": {
        "x": 2657.9000244140625,
        "y": 2378.5
      },
      "connection": "ZmEA2h52Xn"
    }
  },
  "nodes": {
    "cOws1LEgka": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2579.699951171875,
        "y": 3148.7125358581543
      },
      "type": "muted"
    },
    "Sw0B1x9Vm9": {
      "nodeType": "ValueNode",
      "value": false,
      "position": {
        "x": 2659.300048828125,
        "y": 3320.5
      },
      "type": "muted"
    },
    "0AuPuPxxYm": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2578.300048828125,
        "y": 3718.5
      },
      "type": "muted"
    },
    "0t8RSi0qGv": {
      "nodeType": "ValueNode",
      "value": false,
      "position": {
        "x": 2860.300048828125,
        "y": 3729.5
      },
      "type": "muted"
    },
    "L9CueKVYRa": {
      "nodeType": "DecisionNode",
      "name": "mutedInProximityDistance",
      "concept": "client",
      "property": "distance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 150,
          "connection": "0AuPuPxxYm"
        },
        {
          "comparator": "lessThan",
          "value": 150,
          "connection": "0t8RSi0qGv"
        }
      ],
      "position": {
        "x": 2636.300048828125,
        "y": 3509.5
      }
    },
    "Q7C3YKmRd8": {
      "nodeType": "DecisionNode",
      "name": "mutedOnPedestal",
      "concept": "client",
      "property": "onPedestal",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "L9CueKVYRa"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "0t8RSi0qGv"
        }
      ],
      "position": {
        "x": 2850.300048828125,
        "y": 3317.5
      }
    },
    "pWndXjd86V": {
      "nodeType": "DecisionNode",
      "name": "mutedproximityBasedAudioActive",
      "concept": "toolManager",
      "property": "proximityBasedAudioActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "Sw0B1x9Vm9"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "Q7C3YKmRd8"
        }
      ],
      "position": {
        "x": 2720.300048828125,
        "y": 3112.5
      }
    },
    "rYSeeaKep4": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientInDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 2,
          "connection": "cOws1LEgka"
        },
        {
          "comparator": "lessThan",
          "value": 2,
          "connection": "pWndXjd86V"
        }
      ],
      "position": {
        "x": 2585.300048828125,
        "y": 2914.3124504089355
      }
    },
    "coKNOWx7Gg": {
      "nodeType": "ValueNode",
      "value": false,
      "position": {
        "x": 2858.1875,
        "y": 2899.1500244140625
      },
      "type": "muted"
    },
    "glgxeBTrE9": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientBroadcasting",
      "concept": "client",
      "property": "broadcasting",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "rYSeeaKep4"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "coKNOWx7Gg"
        }
      ],
      "position": {
        "x": 2595,
        "y": 2701.1499633789062
      }
    },
    "4GpHRhnuOX": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2851.7001037597656,
        "y": 2690.9125175476074
      },
      "type": "muted"
    },
    "ZmEA2h52Xn": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientMuted",
      "concept": "client",
      "property": "muted",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "glgxeBTrE9"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "4GpHRhnuOX"
        }
      ],
      "position": {
        "x": 2580.9000244140625,
        "y": 2480.4999389648438
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="BroadcastTool Routing Volume" auto>{
  "rootConnections": {
    "volume": {
      "position": {
        "x": 2631.2500762939453,
        "y": 1973.6000328063965
      },
      "connection": "cWXvbLUMwS"
    }
  },
  "nodes": {
    "NoVla0FWWm": {
      "nodeType": "ValueNode",
      "value": 0,
      "position": {
        "x": 2451.449935913086,
        "y": 2978.800037384033
      },
      "type": "volume"
    },
    "CAIcGVCsm0": {
      "nodeType": "ValueNode",
      "value": 0.5,
      "position": {
        "x": 2617.0499725341797,
        "y": 2977.399890899658
      },
      "type": "volume"
    },
    "OIc3npFR9a": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 2505.049819946289,
        "y": 3741.4001960754395
      },
      "type": "volume"
    },
    "tpy4gmRP9g": {
      "nodeType": "ValueNode",
      "value": 0.3,
      "position": {
        "x": 2830.6499786376953,
        "y": 3748.799976348877
      },
      "type": "volume"
    },
    "xmzFZT3Tpu": {
      "nodeType": "DecisionNode",
      "name": "volumeAnyoneWhispersToMe",
      "concept": "toolManager",
      "property": "whisperTargeted",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "OIc3npFR9a"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "tpy4gmRP9g"
        }
      ],
      "position": {
        "x": 2664.449905395508,
        "y": 3491.799976348877
      }
    },
    "vgXQprbLv0": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 3108.0499725341797,
        "y": 3744.9875259399414
      },
      "type": "volume"
    },
    "IsSVGugff8": {
      "nodeType": "DecisionNode",
      "name": "volumeWhispersToMe",
      "concept": "toolManager",
      "property": "whisperTargetedBy",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "includes",
          "value": "$client",
          "connection": "tpy4gmRP9g"
        },
        {
          "comparator": "includes",
          "value": "$client",
          "connection": "vgXQprbLv0"
        }
      ],
      "position": {
        "x": 2936.249954223633,
        "y": 3494.400074005127
      }
    },
    "KVFodKj9zO": {
      "nodeType": "DecisionNode",
      "name": "volumeIsWhispering",
      "concept": "client",
      "property": "whisperTarget",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": "",
          "connection": "xmzFZT3Tpu"
        },
        {
          "comparator": "unequals",
          "value": "",
          "connection": "IsSVGugff8"
        }
      ],
      "position": {
        "x": 2845.850051879883,
        "y": 3269.7999153137207
      }
    },
    "0aHAiVw4QT": {
      "nodeType": "DecisionNode",
      "name": "volumeWhisperActive",
      "concept": "toolManager",
      "property": "whisperActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "OIc3npFR9a"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "KVFodKj9zO"
        }
      ],
      "position": {
        "x": 2672.649917602539,
        "y": 3059.8000984191895
      }
    },
    "tlE8U4K1WI": {
      "nodeType": "DecisionNode",
      "name": "volumeClientLogicalDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 3,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 1,
          "connection": "NoVla0FWWm"
        },
        {
          "comparator": "equals",
          "value": 1,
          "connection": "CAIcGVCsm0"
        },
        {
          "comparator": "equals",
          "value": 0,
          "connection": "0aHAiVw4QT"
        }
      ],
      "position": {
        "x": 2459.4500274658203,
        "y": 2772.6001777648926
      }
    },
    "hH1J0Lq5ax": {
      "nodeType": "ValueNode",
      "value": 0,
      "position": {
        "x": 2952.2498931884766,
        "y": 3008.800037384033
      },
      "type": "volume"
    },
    "EwpAvM8psA": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 3098.249954223633,
        "y": 3008.2000617980957
      },
      "type": "volume"
    },
    "94TJMgUpTV": {
      "nodeType": "DecisionNode",
      "name": "volumeClientInHovered",
      "concept": "client",
      "property": "inHoveredRoom",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "hH1J0Lq5ax"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "EwpAvM8psA"
        }
      ],
      "position": {
        "x": 2972.0498809814453,
        "y": 2815.800006866455
      }
    },
    "e9x6WwtBbb": {
      "nodeType": "DecisionNode",
      "name": "volumeExistsHovered",
      "concept": "toolManager",
      "property": "doorwayHoveredExists",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "tlE8U4K1WI"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "94TJMgUpTV"
        }
      ],
      "position": {
        "x": 2832.649917602539,
        "y": 2584.8000526428223
      }
    },
    "7nfLkWCxEa": {
      "nodeType": "DecisionNode",
      "name": "volumedoorwayActive",
      "concept": "toolManager",
      "property": "doorwayActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "tlE8U4K1WI"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "e9x6WwtBbb"
        }
      ],
      "position": {
        "x": 2529.449996948242,
        "y": 2370.0000801086426
      }
    },
    "geuhhE9asE": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 2666.0125732421875,
        "y": 2280.5501098632812
      },
      "type": "volume"
    },
    "cWXvbLUMwS": {
      "nodeType": "DecisionNode",
      "name": "volumeIsClientBroadcasting",
      "concept": "client",
      "property": "broadcasting",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "7nfLkWCxEa"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "geuhhE9asE"
        }
      ],
      "position": {
        "x": 2549.8126220703125,
        "y": 2076.550079345703
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="BroadcastTool Routing Filter" auto>{
  "rootConnections": {
    "audioFilter": {
      "position": {
        "x": 2518.550048828125,
        "y": 2028.6999969482422
      },
      "connection": "O5u4OJq7BL"
    }
  },
  "nodes": {
    "mmR7pI87cW": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2420.75,
        "y": 2959.5
      },
      "type": "audioFilter"
    },
    "FUf0416U07": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2446.75,
        "y": 3928.5
      },
      "type": "audioFilter"
    },
    "rScKXNSFIH": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2618.75,
        "y": 3930.5
      },
      "type": "audioFilter"
    },
    "C5E6P2PNS1": {
      "nodeType": "DecisionNode",
      "name": "filterLocationHasFilter",
      "concept": "currentRoom",
      "property": "audioFilter",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": "",
          "connection": "FUf0416U07"
        },
        {
          "comparator": "unequals",
          "value": "",
          "connection": "rScKXNSFIH"
        }
      ],
      "position": {
        "x": 2428.75,
        "y": 3718.5
      }
    },
    "MfMGQHme7X": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2792.75,
        "y": 3702.5
      },
      "type": "audioFilter"
    },
    "wjx55vVir8": {
      "nodeType": "DecisionNode",
      "name": "filterAnyoneWhispersToMe",
      "concept": "toolManager",
      "property": "whisperTargeted",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "C5E6P2PNS1"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "MfMGQHme7X"
        }
      ],
      "position": {
        "x": 2644.75,
        "y": 3460.5
      }
    },
    "jQ2IkTyaGV": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2976.75,
        "y": 3706.5
      },
      "type": "audioFilter"
    },
    "hIw3Kw5Hb2": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 3145.75,
        "y": 3705.5
      },
      "type": "audioFilter"
    },
    "pS4ziWX0BD": {
      "nodeType": "DecisionNode",
      "name": "filterWhispersToMe",
      "concept": "toolManager",
      "property": "whisperTargetedBy",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "includes",
          "value": "$client",
          "connection": "jQ2IkTyaGV"
        },
        {
          "comparator": "includes",
          "value": "$client",
          "connection": "hIw3Kw5Hb2"
        }
      ],
      "position": {
        "x": 2998.75,
        "y": 3477.5
      }
    },
    "d2EkOYpR8O": {
      "nodeType": "DecisionNode",
      "name": "filterIsWhispering",
      "concept": "client",
      "property": "whisperTarget",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": "",
          "connection": "wjx55vVir8"
        },
        {
          "comparator": "unequals",
          "value": "",
          "connection": "pS4ziWX0BD"
        }
      ],
      "position": {
        "x": 2811.75,
        "y": 3257.5
      }
    },
    "xq0UNVtXei": {
      "nodeType": "DecisionNode",
      "name": "filterWhisperActive",
      "concept": "toolManager",
      "property": "whisperActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "C5E6P2PNS1"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "d2EkOYpR8O"
        }
      ],
      "position": {
        "x": 2509.75,
        "y": 3072.5
      }
    },
    "1kWhmMpUFO": {
      "nodeType": "DecisionNode",
      "name": "filterClientLogicalDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 1,
          "connection": "mmR7pI87cW"
        },
        {
          "comparator": "equals",
          "value": 0,
          "connection": "xq0UNVtXei"
        }
      ],
      "position": {
        "x": 2423.75,
        "y": 2736.5
      }
    },
    "g2JEiwDI38": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2703.75,
        "y": 2987.5
      },
      "type": "audioFilter"
    },
    "UrFfooDXhs": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2862.75,
        "y": 2986.5
      },
      "type": "audioFilter"
    },
    "fOt7eLofpb": {
      "nodeType": "DecisionNode",
      "name": "filterClientInHovered",
      "concept": "client",
      "property": "inHoveredRoom",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "g2JEiwDI38"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "UrFfooDXhs"
        }
      ],
      "position": {
        "x": 2716.75,
        "y": 2765.5
      }
    },
    "bm9IK40lob": {
      "nodeType": "DecisionNode",
      "name": "filterExistsHovered",
      "concept": "toolManager",
      "property": "doorwayHoveredExists",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "1kWhmMpUFO"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "fOt7eLofpb"
        }
      ],
      "position": {
        "x": 2704.75,
        "y": 2541.5
      }
    },
    "3qEccHXEYd": {
      "nodeType": "DecisionNode",
      "name": "filterDoorwayActive",
      "concept": "toolManager",
      "property": "doorwayActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "1kWhmMpUFO"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "bm9IK40lob"
        }
      ],
      "position": {
        "x": 2419.75,
        "y": 2371.5
      }
    },
    "aZXrp19rNQ": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2724.800048828125,
        "y": 2366.1500244140625
      },
      "type": "audioFilter"
    },
    "O5u4OJq7BL": {
      "nodeType": "DecisionNode",
      "name": "filterIsClientBroadcasting",
      "concept": "client",
      "property": "broadcasting",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "3qEccHXEYd"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "aZXrp19rNQ"
        }
      ],
      "position": {
        "x": 2445.8001708984375,
        "y": 2139.350067138672
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="TemplateStoreTool" id="TemplateStoreTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Stores templates of room layout for reuse.",
    "dependencies": [
        "#ToolElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="TemplateStoreTool Concepts" auto>{
    "concepts": {
        "templateStoreTemplate": {
            "schema": {
                "name": "string",
                "blueprints": { "array": "templateStoreToolBlueprint" }
            }
        },
        "templateStoreToolBlueprint": {
            "schema": {
                "elementType": "string",
                "top": "number",
                "left": "number",
                "width": "number",
                "height": "number",
                "opacity": "number",
                "zIndex": "number",
                "inToolPanel": "boolean"
            }
        },
        "templateStoreTool": {
            "schema": {
                "overwriteExistingElements": { "boolean": { "default": true }},
                "templateName": "string",
                "selectedTemplate": "templateStoreTemplate",
                "previewScaleFactor": { "number": {
                    "derive": {
                        "properties": [ "width" ],
                        "transform": [
                            { "get": "width" },
                            { "calculate": "($get$ - 16) / 1280"}
                        ]
                    }
                }}
            },
            "actions": {
                "storeStoreTemplate": {
                    "when": { "click": { "view": "storeStoreTemplateButton" }},
                    "then": [
                        { "get": {
                            "property": "templateName",
                            "as": "templateName"
                        }},
                        { "new": {
                            "concept": "templateStoreTemplate",
                            "with": {
                                "name": "$templateName"
                            },
                            "forEach": true,
                            "select": false,
                            "as": "newTemplateStoreTemplate"
                        }},
                        { "get": "parentRoom" },
                        { "select": {
                            "concept": "element",
                            "where": { "and": [
                                {
                                    "property": "parentRoom",
                                    "equals": "$get"
                                },
                                {
                                    "property": "elementType",
                                    "unequals": "templateStoreTool"
                                }
                            ]},
                            "stopIfEmpty": true
                        }},
                        { "new": {
                            "concept": "templateStoreToolBlueprint",
                            "with": {
                                "elementType": "$target.elementType",
                                "top": "$target.top",
                                "left": "$target.left",
                                "width": "$target.width",
                                "height": "$target.height",
                                "opacity": "$target.opacity",
                                "zIndex": "$target.zIndex",
                                "inToolPanel": "$target.inToolPanel"
                            },
                            "forEach": true
                        }},
                        { "set": {
                            "variable": "blueprint",
                            "value": "$target"
                        }},
                        { "select": {
                            "target": "$newTemplateStoreTemplate",
                            "forEach": true
                        }},
                        { "append": {
                            "property": "blueprints",
                            "item": "$blueprint"
                        }}
                    ]
                },
                "restoreStoreTemplate": {
                    "when": { "click": { "view": "restoreStoreTemplateButton" }},
                    "then": [
                        { "run": "cleanupElements" },
                        { "select": {
                            "property": "selectedTemplate",
                            "forEach": true,
                            "stopIfEmpty": true
                        }},
                        { "select": {
                            "property": "blueprints",
                            "forEach": true,
                            "stopIfEmpty": true
                        }},
                        { "get": { "property": "meeting.fullscreenRoom", "as": "parent" }},
                        { "new": {
                            "concept": "$target.elementType",
                            "with": {
                                "parentRoom": "$parent",
                                "top": "$target.top",
                                "left": "$target.left",
                                "width": "$target.width",
                                "height": "$target.height",
                                "opacity": "$target.opacity",
                                "zIndex": "$target.zIndex",
                                "inToolPanel": "$target.inToolPanel"
                            },
                            "forEach": true
                        }}
                    ]
                },
                "cleanupElements": [
                    { "where": {
                        "property": "overwriteExistingElements",
                        "equals": true,
                        "stopIfEmpty": true
                    }},
                    { "get": "parentRoom" },
                    { "select": {
                        "concept": "element",
                        "where": { "and": [
                            {
                                "property": "parentRoom",
                                "equals": "$get"
                            },
                            {
                                "property": "elementType",
                                "unequals": "templateStoreTool"
                            }
                        ]},
                        "stopIfEmpty": true
                    }},
                    "elementCleanup"
                ],
                "deleteStoreTemplate": {
                    "when": { "click": { "view": "deleteStoreTemplateButton" }},
                    "then": [
                        { "get": "selectedTemplate" },
                        { "set": { "selectedTemplate": "" }},
                        { "select": {
                            "target": "$get",
                            "stopIfEmpty": true
                        }},
                        { "items": "blueprints" },
                        { "run": "deleteStoreTemplateBlueprints" },
                        "remove"
                    ]
                },
                "deleteStoreTemplateBlueprints": [
                    { "select": "$items" },
                    "remove"
                ]
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="TemplateStoreTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="templateStoreToolBody">
        &lt;div class="tool-title">Template Store Tool&lt;/div>
        &lt;div class="template-preview-container">
            &lt;div class="template-preview" property="selectedTemplate" style="transform: scale({previewScaleFactor})">
                &lt;div class="blueprint-preview {elementType}" property="blueprints" if="!inToolPanel" style="top: {top}px; left: {left}px; width: {width}px; height: {height}px;">&lt;/div>
            &lt;/div>
        &lt;/div>
        &lt;label>
            Template:
            &lt;select value="{selectedTemplate}">
                &lt;option concept="templateStoreTemplate" value="{concept::uuid}">{name}&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;label property="selectedTemplate">
            Rename:
            &lt;input value="{name}">
        &lt;/label>
        &lt;button view="deleteStoreTemplateButton" if="selectedTemplate" class="red">Delete Template&lt;/button>
        &lt;button view="restoreStoreTemplateButton">Restore Template&lt;/button>
        &lt;div class="tool-title">—&lt;/div>
        &lt;label>
            Template Name:
            &lt;input value="{templateName}">
        &lt;/label>
        &lt;button view="storeStoreTemplateButton">Store Template&lt;/button>
    &lt;/varv-template>

    &lt;varv-template name="templateStoreToolOptions">
        &lt;label>
            Overwrite Existing Elements:
            &lt;input value="{overwriteExistingElements}" type="checkbox">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="TemplateStoreTool Style" auto>.templateStoreTool {
    .template-preview-container {
        aspect-ratio: 4 / 3;
        width: 100%;
        overflow: hidden;
        border-radius: 4px;
        background: #313131;
        flex: 0 0 auto;
    }

    .template-preview {
        position: relative;
        width: 1280px;
        height: 960px;
        transform-origin: 0 0;

        .blueprint-preview {
            position: absolute;
            background: #636363;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;

            &:before {
                color: #b2b2b2;
                font-family: "Material Icons";
                font-weight: normal;
                font-style: normal;
                font-size: 80px;
                line-height: 1;
                letter-spacing: normal;
                text-transform: none;
                display: inline-block;
                white-space: nowrap;
                word-wrap: normal;
                direction: ltr;
                content: "build";
            }

            &.cameraContent:before {
                content: "photo_camera";
            }

            &.screenContent:before {
                content: "cast";
            }

            &.videoContent:before {
                content: "theaters";
            }

            &.imageContent:before {
                content: "image";
            }

            &.noteContent:before {
                content: "description";
            }

            &.sketchContent:before {
                content: "brush";
            }

            &.chatContent:before {
                content: "chat";
            }

            &.avatarContent:before {
                content: "account_circle";
            }

            &.regularRoom:before {
                content: "meeting_room";
            }
        }
    }
}

// Use fixed scale in the tool panel
.tool-panel {
    .templateStoreTool {
        .template-preview {
            transform: scale(0.1578125) !important;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE></DIV><WPM-PACKAGE id="Audio Routing Fixes" name="Audio Routing Fixes"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Fixes minor shortcomings of the audio routing GUI and updates property list and style.",
    "dependencies": [],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Audio Routing Fixes" auto>{
    "concepts": {
        "audioManager": {
            "actions": {
                "filterLocationHasFilterNodeConnection2": [
                    { "get": "audioFilter" },
                    "selectOriginalAudioStream",
                    { "set": { "audioFilter": "$get" }}
                ],
                "volumeWhispersToMeNodeDecision1": [
                    { "where": { "not": {
                        "property": "whisperTargetedBy",
                        "stopIfEmpty": true,
                        "includes": "$client"
                    }}},
                    "volumeWhispersToMeNodeConnection1"
                ],
                "filterWhispersToMeNodeDecision1": [
                    { "where": { "not": {
                        "property": "whisperTargetedBy",
                        "stopIfEmpty": true,
                        "includes": "$client"
                    }}},
                    "filterWhispersToMe1NodeConnection1"
                ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Audio Routing Property List" auto>MirrorVerseAudioRouter.conceptPropertyList = {
    "client": [
        "name",
        "local",
        "muted",
        "logicalDistance",
        "logicalVolume",
        "analyserVolume",
        "inHoveredRoom",
        "distance",
        "onPedestal",
        "whisperTarget",
        "broadcasting"
    ],
    "currentRoom": [
        "name",
        "audioFilter"
    ],
    "toolManager": [
        "doorwayActive",
        "doorwayHoveredExists",
        "proximityBasedAudioActive",
        "whisperActive",
        "whisperTargeted",
        "whisperTargetedBy"
    ]
};
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Audio Routing GUI Style" auto>@mixin heading-font {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}



.codestrates-editor-core.component {
    overflow: hidden;
}

div.mirrorverse-audio-router-maximized {
    background-image: radial-gradient(#ccc 1px, transparent 0);
    background-size: 24px 24px;
    background-position: -11px -11px;
    cursor: grab;
    user-select: none;

    &:active {
        cursor: grabbing;
    }
}

.mirrorverse-audio-router {
    font-family: Roboto, sans-serif;

    .mirrorverse-audio-routing-connection {
        stroke: #005005;
    }

    .connectionOut {
        cursor: default;
        background: #2e7d32 !important;
        border-radius: 2px;
        margin: 4px;

        &:hover {
            background: #60ad5e;
        }

        &:active {
            background: #005005;
        }
    }

    .mirrorVerseAudioRouterNode {
        background-color: #eee;
        border: 1px solid #ccc;
        border-radius: 8px;
        align-items: stretch;
        gap: 4px;
        cursor: move;
        // z-index: 1000;

        &:hover {
            background: #f2f2f2;
        }

        &:active {
            background: #eaeaea;
        }

        >div:not(.decisions) {
            font-weight: 700;
            height: 22px;
        }

        .addDecision,
        .removeDecision {
            user-select: none;
            border-radius: 4px;
            background: #fff;
            color: #000;
            vertical-align: middle;
            text-align: center;
            cursor: pointer;
            border: 1px solid #ccc;
            font-weight: 500;
        }

        .removeDecision {
            margin-left: 3px;
        }

        .decisions {
            gap: 8px;
            flex-wrap: wrap;
            position: relative;

            .decision {
                background-color: #ccc;
                border: none;
                padding: 4px;
                border-radius: 4px;

                &:not([data-type='boolean']) .select {
                    display: flex;
                    gap: 4px;
                }
            }

            >div:not(.decision) {
                background: #2e7d32 !important;
                border-radius: 2px;
                cursor: default;
            }
        }

    }

    .mirrorVerseAudioRouterRootNode {
        width: 48px;
        height: 48px;
        align-items: center;

        .title {
            @include heading-font;
            color: #000;
        }

        .connectionOut {
            width: 18px;
            height: 18px;
            position: initial;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE></DIV></body></html>
