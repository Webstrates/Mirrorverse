<!doctype html>
<html data-protected="all"><head>
    <title>Mirrorverse</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <script type="text/json+bootconfig">{
    "creator": "WPMPackageManager",
    "created": 1650368097912,
    "require": [
        {
            "repositories": {
                "codestrates-repos": "https://raw.githubusercontent.com/Webstrates/Codestrates-v2/6510b083f08b77086ce9b2e57446539cf10d6fb7/codestrates.html",
                "webstrate-components-repos": "https://raw.githubusercontent.com/Webstrates/WebstrateComponents/3d434f104a3fbb3b50fa4d4aa3c23e4b3b7ef027/components.html",
                "cauldron-repos": "https://raw.githubusercontent.com/Webstrates/Cauldron/8a35a746feb1d3937f3cf1bc75ce0cb3c6c2f262/cauldron.html",
                "wpm_js_libs": "https://raw.githubusercontent.com/Webstrates/WebstrateLibraryRepository/0d13df65478a6afb645b63a8b4c335eeb6f7f419/libraries.html",
                "varv-repos": "https://raw.githubusercontent.com/Webstrates/Varv/0bb1236308bb4f3c3d409d69c4f278b730a738ce/varv.html",
                "wpm-repos": "https://raw.githubusercontent.com/Webstrates/WPM/master/build.html"
            },
            "dependencies": [
                {
                    "package": "CauldronURLLauncher",
                    "repository": "cauldron-repos"
                },
                {
                    "package": "CauldronButtonLauncher",
                    "repository": "cauldron-repos"
                },
                {
                    "package": "fragment_js",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_html",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_json",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_wpm-descriptor",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_css",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_scss",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "varv-location",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-inspector",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-codestrates-extensions",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-cauldron-delayloader",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-cauldron",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-localstorage",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-memory",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-domdiff-view",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-dom-triggers",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-dom",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-builtin-triggers",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-builtin-actions",
                    "repository": "varv-repos"
                },
                {
                    "package": "varv-engine",
                    "repository": "varv-repos"
                },
                {
                    "package": "mirrorverse-audio-router",
                    "repository": "varv-repos"
                },
                {
                    "package": "WPM",
                    "repository": "wpm-repos"
                }
            ],
            "options": {}
        }
    ],
    "updated": 1693216278971,
    "knownRepositories": []
}</script>
<WPM-PACKAGE data-repository="wpm-repos" id="WPM" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "Webstrate Package Manager",
    "dependencies": [
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "2.42",
    "forceEmbedding": true
}

</SCRIPT><SCRIPT id="WPMv2-script" type="text/javascript">
/**
 * WPMv2 - Webstrate Package Manager
 *
 * Copyright 2019 Rolf Bagge, Janus Bager Kristensen,
 * CAVI - Center for Advanced Visualisation and Interaction,
 * Aarhus University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

/* global Promise, webstrate, eval */

//Encapsulate WPMv2, so we can decide which methods are public
((window) => {

    const WPM_ALIASES = "WPM.repoAliases";

    let runningRequiresPromiseMap = [];

    let allInstalledCallbacksStack = [];

    const requireQueue = [];

    /**
     * WebstratePackageManager version 2
     *
     * It is used to install WPM packages into webstrates.
     *
     * <pre><code>WPMv2.require([
     *      {package: "somePackageName", repository: "/somewebstraterepo"},
     *      {package: "someOtherPackageName", repository: "/somewebstraterepo"}
     * ]).then(()=>{
     *     //Packages are now installed
     * });
     * </code></pre>
     * @hideconstructor
     */
    class WPMv2 {
        static async bootstrap(packageDom, options, requireToken, triggerOnPackageInstalled = false) {
            let wpmPackage = WPMv2.getWPMPackageFromDOM(packageDom);
            let promises = [];

            /**
             * @class WPMInterface
             * @classdesc
             * Internal WPM interface that is provided for every package that is installed via WPMv2. Is accessed as just wpm, when inside package code.
             * @hideconstructor
             * @memberof WPMv2
             */
            let wpmInterface = {};

            /**
             * Reads metadata from the given package. If no packagename is given, metadata from the current package is read.
             *
             * @example
             * let metadata = wpm.readMetadata();
             *
             * @param {string} [packageName] - The package to read metadata from
             * @returns {json}
             * @memberof WPMv2.WPMInterface
             * @name readMetadata
             * @method
             */
            wpmInterface.readMetadata = (packageName = null) => {
                if (packageName == null) {
                    packageName = packageDom.getAttribute("id");
                }

                return WPMv2.readMetadata(packageName);
            };

            /**
             * Registers a callback to be called when this package is installed.
             *
             * @example
             * wpm.onInstalled(()=>{
             *     //Package is now installed
             * });
             *
             * @param {method} callback
             * @memberof WPMv2.WPMInterface
             * @name onInstalled
             * @method
             */
            wpmInterface.onInstalled = (callback) => {
                packageDom.addEventListener("wpm.packageInstalled", callback, {"once": true});
            };

            /**
             * Registers a callback to be called when all packages are installed. (When installing multiple packages at the same time.)
             *
             * @example
             * wpm.onAllInstalled(()=>{
             *     //All packages are installed
             * });
             *
             * @param {method} callback
             * @memberof WPMv2.WPMInterface
             * @name onAllInstalled
             * @method
             */
            wpmInterface.onAllInstalled = (callback) => {
                //Retrieve from stack
                let allInstalledCallbacks = allInstalledCallbacksStack[allInstalledCallbacksStack.length-1];
                if (allInstalledCallbacks){
                    allInstalledCallbacks.push(callback);
                } else {
                    // STUB: Remove FIXME if ok
                    console.log("FIXME: WPMv2 - No allInstalledCallbacks in allInstalledCallbacksStack, assuming no more packages? Is this ok?");
                    // Immediately call the callback since no more packages are left
                    callback();
                }

            };

            /**
             * Registers a callback to be called when this package is removed.
             *
             * @example
             * wpm.onRemoved(({detail: packageName})=>{
             *     //Package is removed, packageName is provided for ease of access, will be same as the package this callback was registered from.
             * });
             *
             * @param {method} callback
             * @memberof WPMv2.WPMInterface
             * @name onRemoved
             * @method
             */
            wpmInterface.onRemoved = (callback) => {
                packageDom.addEventListener("wpm.packageRemoved", callback, {"once": true});
            };

            /**
             * Registers a callback to be called when any package is removed.
             *
             * @example
             * wpm.onRemovedAny(({detail: packageName})=>{
             *      //Package with name "packageName" has been removed
             * });
             *
             * @param {method} callback
             * @memberof WPMv2.WPMInterface
             * @name onRemovedAny
             * @method
             */
            wpmInterface.onRemovedAny = (callback) => {
                document.addEventListener("wpm.packageRemovedAny", callback);
            };

            wpmInterface.require = async (packageRequests, extraOptions) => {
                let convertedPackages = [];

                if (packageRequests != null) {
                    if (!Array.isArray(packageRequests)) {
                        packageRequests = [packageRequests];
                    }

                    for (let packageRequest of packageRequests) {
                        if (typeof packageRequest === "string") {
                            //Shorthand for requiring dependency, lookup in our descriptor
                            let packageName = packageRequest;
                            let repo = wpmPackage.optionalDependencyMap.get(packageName);

                            convertedPackages.push({
                                package: packageName,
                                repository: repo
                            });
                        } else {
                            convertedPackages.push(packageRequest);
                        }
                    }
                } else {
                    //packages == null, means require all dependencies!
                    wpmPackage.optionalDependencyMap.forEach((repo, packageName) => {
                        convertedPackages.push({
                            package: packageName,
                            repository: repo
                        });
                    });
                }

                const combinedOptions = Object.assign({}, options, extraOptions);

                promises.push(WPMv2.require(convertedPackages, combinedOptions, requireToken));

                return Promise.all(promises);
            };

            async function loadExternalCSS(response) {
                let styleContent = await response.text();

                //Attempt linking stylesheets instead of inlining them
                let style = document.createElement("style");

                let transient = document.createElement("transient");
                transient.appendChild(style);

                //Disable sourcemap

                styleContent = styleContent.replace(/\/\*#\s*sourceMappingURL=\S+\s*\*\//, "");
                //styleContent = styleContent.replace(/\/\/#\s*sourceMappingURL=\S+/, "");

                style.innerHTML = styleContent;

                document.head.append(transient);
            }

            async function loadExternalJS(response) {
                let scriptContent = await response.text();

                //Hack to make requirejs work, and be able to hide it
                const origDefine = window.define;
                if (window.define != null) {
                    window.define = undefined;
                }

                //Disable sourcemap
                //scriptContent = scriptContent.replace(/\/\*#\s*sourceMappingURL=\S+\s*\*\//, "");
                scriptContent = scriptContent.replace(/\/\/# sourceMappingURL=\S+/, "");

                eval.call(null, scriptContent);

                //Restore previous define, if this script did not set define
                if (window.define == null && origDefine != null) {
                    window.define = origDefine;
                }
            }

            /**
             * Fetches and evaluates external javascript, or loads css.
             *
             * The server response header Content-Type will be used to determine if its a JS or CSS.
             *
             * @example
             * await wpm.requireExternal("https://some.site.com/someScript.js");
             * //someScript.js has now been parsed and evaluated
             *
             * @param {string|string[]} urls - The URLs to the wanted JS, CSS
             * @returns {Promise<void>} - Resolves when all scripts/styles are fetched and evaluated/loaded
             * @memberof WPMv2.WPMInterface
             * @name requireExternal
             * @method
             */
            wpmInterface.requireExternal = async (urls) => {
                if(!(urls instanceof Array)) {
                    urls = [urls];
                }

                for(let url of urls) {

                    let promise = new Promise(async (resolve, reject)=>{
                        try {
                            let response = await fetch(url, {credentials: 'same-origin'});

                            let contentType = response.headers.get("Content-Type").trim();
                            let indexOfSemicolon = contentType.indexOf(";");
                            if (indexOfSemicolon !== -1) {
                                contentType = contentType.substring(0, indexOfSemicolon).trim();
                            }

                            switch (contentType) {
                                case "text/css": {
                                    await loadExternalCSS(response);
                                    break;
                                }
                                case "text/javascript":
                                case "application/javascript":
                                case "application/x-javascript": {
                                    await loadExternalJS(response);
                                    break;
                                }
                                default:
                                    console.warn("Unhandled contentType:", contentType, url);
                                    console.warn("Loading unknown as JS for know. please report...")
                                    await loadExternalJS(response);
                            }
                            resolve();
                        } catch(e) {
                            reject("Unable to fetch: "+url);
                        }
                    });

                    //promises.push(promise);

                    await promise;
                }
            };

            let scripts = packageDom.querySelectorAll("script[type='disabled']");

            for (let i = 0; i < scripts.length; i++) {
                let script = scripts[i];

                let scriptContent = "";

                if (script.src != null && script.src.length > 0) {
                    let response = await fetch(script.src, {credentials: 'same-origin'});
                    scriptContent = await response.text();
                } else {
                    scriptContent = script.innerText;
                }

                scriptContent = 'try{'+scriptContent+'} catch (ex){console.error("Bootstrap runtime error in '+packageDom.getAttribute("id").replaceAll("'","")+':", ex);}';

                const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;

                try {
                    let functionArgs = [];
                    functionArgs.push("wpm");

                    let functionArgValues = [];
                    functionArgValues.push(wpmInterface);

                    if(options.context != null) {
                        const contextKeys = Object.keys(options.context);
                        functionArgs.push(...contextKeys);

                        const contextValues = Object.values(options.context);
                        functionArgValues.push(...contextValues);
                    }

                    let wpmEval = new AsyncFunction(...functionArgs, scriptContent);
                    await wpmEval(...functionArgValues);
                } catch (e) {
                    console.error("Bootstrap parse error in " + packageDom.getAttribute("id"), e);
                }
            }

            await Promise.all(promises);

            if (triggerOnPackageInstalled) {
                packageDom.dispatchEvent(new CustomEvent("wpm.packageInstalled"));
            }
        }

        /**
         * Installs all packages at the given repository into the current page
         *
         * @example
         * WPMv2.requireAll("https://some.site.com/myRepo");
         *
         * @param {string} repository - The repository to lookup packages from
         * @param {WPMv2~PackageOptions} options - options to use for overriding packages options, also applies for dependencies
         * @returns {Promise<void>} - Resolved when packages are installed
         */
        static async requireAll(repository, options = {}) {
            let packages = [];

            let wpmPackages = await WPMv2.getPackagesFromRepository(repository);

            wpmPackages.forEach((pkg) => {
                if(options.blacklist != null && options.blacklist instanceof Array && options.blacklist.includes(pkg.name)) {
                    //Skip this package
                    return;
                }

                let pkgOptions = {
                    repository: pkg.repository,
                    package: pkg.name
                };
                packages.push(pkgOptions);
            });

            return WPMv2.require(packages, options);
        }

        /**
         * @typedef {Object} WPMv2~PackageOptions
         * @property {string} [repository] - The repository to lookup the package inside. If left unset, the current page is used.
         * @property {HTMLElement|string} [appendTarget] - The dom node to append to. If a string, will be looked up by document.querySelector(appendTarget). Defaults to a transient div inside document.head
         * @property {('append'|'before'|'after'|'prepend')} [appendMethod] - How to append to the appendTarget. Defaults to 'append'.
         */

        /**
         * @typedef {Object} WPMv2~PackageJson
         * @property {string} package - The name of the package
         * @property {string} [repository] - The repository to lookup the package inside. If left unset, the current page is used.
         * @property {HTMLElement|string} [appendTarget] - The dom node to append to. If a string, will be looked up by document.querySelector(appendTarget). Defaults to a transient div inside document.head
         * @property {('append'|'before'|'after'|'prepend')} [appendMethod] - How to append to the appendTarget. Defaults to 'append'.
         */

        /**
         *
         * @param {WPMv2.WPMPackage[]}packages
         * @returns {Promise<void>}
         */
        static async findCompletePackageTreeSorted(packages = [], defaultOptions, overrideOptions = {}) {
            const numPackages = packages.length;

            if (!Array.isArray(packages)) {
                packages = [packages];
            }

            let alreadySorting = [];
            let convertedPackages = [];

            async function addRepo(repoUrl, options) {
                if(overrideOptions.repository != null) {
                    console.warn("Adding a full repository, does not atm support overriding options for repository...");
                }

                try {
                    let packages = await WPMv2.getPackagesFromRepository(repoUrl);
                    for(let pkg of packages) {
                        if(options != null) {
                            pkg.updateFromOptions(options);
                        }
                        await addPackage(pkg);
                    }
                } catch (ex){
                    console.error("WPMv2 very important error: Could not resolve repository. This will probably cause the site to fail horribly! ", repoUrl, ex);
                }
            }

            async function addPackage(wpmPackage) {
                //Check if package is in local dom
                let localPackageDom = document.querySelector(".packages .package#" + wpmPackage.name + ", wpm-package#" + wpmPackage.name);
                let repoOverride = wpmPackage.repository;
                if(localPackageDom != null) {
                    //Local package exists, override repository with local ? This breaks dependencies that are "same repository", since they now lookup on the local repository.
                    //Not setting local repository, makes the update from dom, happen on the non embedded version, which is also wrong?
                    //wpmPackage.repository = WPMv2.getLocalRepositoryURL();
                    repoOverride = WPMv2.getLocalRepositoryURL();
                }

                let name = WPMv2.getName(wpmPackage);
                if(!alreadySorting.includes(name)){
                    alreadySorting.push(name);
                    try {
                        wpmPackage = await WPMv2.getLatestPackageFromPackage(wpmPackage, repoOverride);
                        let dependencies = await WPMv2.findAllDependencies(wpmPackage, Object.assign({}, overrideOptions));

                        for(let dependency of dependencies) {
                            await addPackage(dependency);
                        }
                        convertedPackages.push(wpmPackage);
                    } catch (ex){
                        console.error("WPMv2 very important error: Could not resolve package. This will probably cause the site to fail horribly! ", wpmPackage, ex);
                    }
                }
            }

            // Resolve all the packages
            await Promise.all(packages.map(async (pkg)=>{
                let wpmPackage = null;
                if (pkg instanceof WPMPackage) {
                    //Already a WPMPackage
                    wpmPackage = pkg;
                    wpmPackage.updateFromOptions(overrideOptions);
                } else if(typeof pkg === "string") {
                    if(pkg.startsWith("http") || (pkg.startsWith("/") && pkg.indexOf(" ") === 0)) {
                        //Full repository, http(s)://myrepourl or /my-relative-url
                        await addRepo(pkg);
                        return;
                    } else {
                        //Single package, name or including repository
                        let split = pkg.split(" ");

                        if(split.length === 1) {
                            //Single local package
                            let options = Object.assign({}, defaultOptions, {
                                "package": split[0]
                            }, overrideOptions);
                            wpmPackage = new WPMPackage(options.package, options.repository);
                            wpmPackage.updateFromOptions(options);
                        } else if(split.length === 2) {
                            //Single package from given repository
                            let options = Object.assign({}, defaultOptions, {
                                "package": split[1].replace("#", ""),
                                "repository": split[0]
                            }, overrideOptions);
                            wpmPackage = new WPMPackage(options.package, options.repository);
                            wpmPackage.updateFromOptions(options);
                        } else {
                            console.warn("Unable to parse package from string:", pkg);
                        }
                    }
                } else {
                    if(pkg.repository != null && pkg.package != null) {
                        //Full package, add
                        let options = Object.assign({}, defaultOptions, pkg, overrideOptions);
                        wpmPackage = new WPMPackage(options.package, options.repository);
                        wpmPackage.updateFromOptions(options);
                    } else if(pkg.repository != null) {
                        //Full repo, add all
                        await addRepo(pkg.repository, pkg);
                        return;
                    }
                }

                if(wpmPackage != null) {
                    await addPackage(wpmPackage);
                } else {
                    console.log("Was null:", pkg);
                }
            }));

            const sortedPackages = [];
            let lastLength = convertedPackages.length;
            while(convertedPackages.length > 0) {
                let packagesWithDependenciesInstalled = convertedPackages.filter((pkg)=>{
                    let ready = true;

                    for(let dep of pkg.dependencyMap) {
                        //If any dependency is not sorted to be installed yet, this is not ready
                        if(!WPMv2.hasPackage(sortedPackages, {"package": dep[0]})) {
                            ready = false;
                            break;
                        }
                    }
                    for(let dep of pkg.optionalDependencyMap) {
                        //If not already sorted to be installed, and among packages to install, this is not ready yet
                        if(!WPMv2.hasPackage(sortedPackages, {"package": dep[0]}) && WPMv2.hasPackage(convertedPackages, {"package": dep[0]})) {
                            ready = false;
                            break;
                        }
                    }

                    return ready;
                });

                packagesWithDependenciesInstalled.forEach((pkg)=>{
                    sortedPackages.push(pkg);
                    convertedPackages.splice(convertedPackages.indexOf(pkg), 1);
                });

                if(convertedPackages.length === lastLength) {
                    console.warn("Not able to add any more packages:", convertedPackages);
                    break;
                }
                lastLength = convertedPackages.length;
            }

            return sortedPackages;
        }

        /**
         * Finds all dependencies of a package
         * @param pkg
         * @returns {Promise<WPMv2.WPMPackage[]>}
         * @private
         */
        static async findAllDependencies(pkg, overrideOptions = {}) {
            let dependencies = [];

            for(let dependencyEntry of pkg.dependencyMap) {
                let dependency = new WPMPackage(dependencyEntry[0], dependencyEntry[1]);
                dependency.updateFromOptions(overrideOptions);
                dependencies.push(dependency);
            }

            return dependencies;
        }

        /**
         * Checks if the given array, contains the given package
         * @private
         */
        static hasPackage(packages, searchPackage) {
            return packages.find((pkg)=>{
                let pkgName = WPMv2.getName(pkg);
                let searchPackageName = WPMv2.getName(searchPackage);

                if(pkgName == null || searchPackageName == null) {
                    console.warn("Unable to compare as one was null");
                    return false;
                }

                return pkgName === searchPackageName;
            }) != null;
        }

        static getName(searchPackage){
            if(searchPackage instanceof WPMPackage) {
                return searchPackage.name;
            } else if(searchPackage.package != null) {
                return searchPackage.package;
            } else {
                console.warn("Unable to infer package name from:", searchPackage);
                return null;
            }
        }

        /**
         * Installs the given packages into the current document
         *
         * Override options set in overrideOptions, override the options given in packages.
         *
         * @example
         * WPMv2.require([{package: "myPackage", repository: "myRepositoryUrl"}]);
         *
         * @param {WPMv2.WPMPackage[]|WPMv2.WPMPackage|WPMv2~PackageJson[]|WPMv2~PackageJson} packages - the packages to install
         * @param {WPMv2~PackageOptions} overrideOptions - options to use for overriding packages options, also applies for dependencies
         * @returns {Promise<void>} - Resolves when the packages are done installing
         */
        static async require(packages = [], overrideOptions = {}, givenRequireToken = null) {
            const defaultOptions = {
                repository: WPMv2.getLocalRepositoryURL(),
                appendMethod: "append",
                appendTarget: null,
                bootstrap: true
            };

            //Make sure we dont override package
            if(overrideOptions.hasOwnProperty("package")) {
                console.warn("Overriding package...", overrideOptions);
                delete overrideOptions.package;
            }

            const completePackageTreeSorted = await WPMv2.findCompletePackageTreeSorted(packages, defaultOptions, overrideOptions);

            if (packages.length === 0) {
                return;
            }

            let requireToken = givenRequireToken;

            let timerId = [...Array(10)].map(_ => (Math.random() * 36 | 0).toString(36)).join``;
            let requireTimerId = "Require time [" +timerId +"]";

            if (givenRequireToken == null) {
                allInstalledCallbacksStack.push([]);
                requireToken = {};
                console.time(requireTimerId);
            }

            // Schedule all the package promises in parallel, but keep track of package inter-dependencies too
            let packagePromiseMap = new Map();

            //Save the currently running require
            runningRequiresPromiseMap.push(packagePromiseMap);

            for (let pkg of completePackageTreeSorted) {
                // At this point, since the tree is sorted, a dependency is either hard and supposed to be in the tree or soft and maybe in the tree (if not, then not installed)
                // If the depedency is hard and not in the tree then a missing package error has already happened and we are going by best-effort anyways, so ignore this case.

                //Check for another require already promising to install this package
                let foundPromise = null;
                for(let promiseMap of runningRequiresPromiseMap) {
                    if(promiseMap.has(pkg.name)) {
                        //Use other require promise, to tell us when package is installed
                        foundPromise = promiseMap.get(pkg.name);
                        break;
                    }
                }

                if(foundPromise != null) {
                    packagePromiseMap.set(pkg.name, foundPromise);
                } else {

                    packagePromiseMap.set(pkg.name, async function multithreadedFetchPackage() {
                        // Lookup all hard and optional dependencies and wait for them before starting ours
                        await Promise.all([...pkg.dependencyMap.keys(), ...pkg.optionalDependencyMap.keys()].map((dependency) => {
                            return packagePromiseMap.get(dependency);
                        }));

                        // Install this package
                        let options = Object.assign({}, defaultOptions, pkg.getPackageOptions(), overrideOptions);

                        //Check if package is in dom
                        let packageDom = document.querySelector(".packages .package#" + pkg.name + ", wpm-package#" + pkg.name);

                        let alreadyInstalled = false;

                        let wpmPackage = null;

                        let needsAppending = false;

                        if (packageDom == null) {
                            //We need to fetch and install package to dom
                            let fetchedPackageDom = await WPMv2.getPackageDOM(pkg.repository, pkg.name);

                            //Rewrite packageDom to a wpm-package
                            packageDom = document.createElement("wpm-package");

                            for (let index = fetchedPackageDom.attributes.length - 1; index > -1; --index) {
                                let attribute = fetchedPackageDom.attributes[index];
                                packageDom.setAttribute(attribute.name, attribute.value);
                            }

                            // Instead of display:none, hide it otherwise due to Chrome bug for SVGs
                            packageDom.style.width = 0;
                            packageDom.style.height = 0;
                            packageDom.style.position = "absolute";
                            packageDom.style.visibility = "hidden";

                            Array.from(fetchedPackageDom.children).forEach((child) => {
                                packageDom.appendChild(child);
                            });

                            WPMv2.stripProtection(packageDom);

                            wpmPackage = WPMv2.getWPMPackageFromDOM(packageDom);

                            needsAppending = true;
                        } else {
                            wpmPackage = WPMv2.getWPMPackageFromDOM(packageDom);
                            alreadyInstalled = true;
                        }

                        //Install into page
                        if (needsAppending) {
                            let appendTarget = options.appendTarget;

                            if (typeof appendTarget === "string") {
                                appendTarget = document.querySelector(appendTarget);
                            }

                            if (appendTarget == null) {
                                appendTarget = document.createElement("div");
                                appendTarget.setAttribute("transient-element", "");
                                appendTarget.setAttribute("transient-wpmid", packageDom.id);
                                document.head.appendChild(appendTarget);
                            }

                            switch (options.appendMethod.toLowerCase()) {
                                case "before":
                                    appendTarget.parentNode.insertBefore(packageDom, appendTarget);
                                    break;

                                case "after":
                                    appendTarget.parentNode.insertBefore(packageDom, appendTarget.nextSibling);
                                    break;
                                case "prepend":
                                    appendTarget.prepend(packageDom);
                                    break;

                                case "append":
                                default:
                                    appendTarget.append(packageDom);
                            }

                            // POST all assets to the target
                            if (wpmPackage.assets.length > 0) {
                                let repoAssetsUrl = WPMv2.lookupRepoAlias(wpmPackage.repository);
                                let repoAssets = await WPMv2.fetchAssets(repoAssetsUrl);

                                let localAssetsUrl = location.pathname + "?assets&latest";
                                let localAssets = await WPMv2.fetchAssets(localAssetsUrl);

                                let formData = new FormData();
                                let assetPromises = [];
                                wpmPackage.assets.forEach(function (asset) {
                                    //If we already have same filehash of this asset, skip
                                    let localAsset = localAssets.get(asset);
                                    let repoAsset = repoAssets.get(asset);

                                    if (localAsset != null && repoAsset != null && localAsset.fileHash === repoAsset.fileHash) {
                                        return;
                                    }

                                    assetPromises.push(new Promise(async function (resolve, reject) {
                                        let blob = await WPMv2.fetchAsset(repoAssetsUrl, asset);

                                        // Fetch it and append to POST
                                        formData.append("file", blob, asset);
                                        resolve();
                                    }));
                                });

                                if (assetPromises.length > 0) {
                                    await Promise.all(assetPromises);

                                    await fetch(location.pathname, {
                                        body: formData,
                                        credentials: 'same-origin',
                                        method: "post"
                                    });
                                }
                            }
                        }

                        //Check if package is live
                        if (packageDom.getAttribute("transient-wpm-live") == null) {
                            if(pkg.bootstrap) {
                                //Make package live
                                await WPMv2.bootstrap(packageDom, overrideOptions, requireToken, !alreadyInstalled);

                                packageDom.setAttribute("transient-wpm-live", "");
                            } else {
                                //Ignore
                            }
                        } else {
                            //Already live
                        }
                    }());
                }
            }

            // Wait for all packages to finish installation
            await Promise.all(Array.from(packagePromiseMap.values()));

            //Splice the finished require away
            runningRequiresPromiseMap.splice(runningRequiresPromiseMap.indexOf(packagePromiseMap), 1);

            //Only the first outer call to require, has givenAllInstalledCallbacks set to null
            if (givenRequireToken === null) {
                let allInstalledCallbacks = allInstalledCallbacksStack.pop();
                console.timeEnd(requireTimerId);

                let allInstalledTimerId = "All Installed [" + timerId + "]";

                console.time(allInstalledTimerId);
                for(let allInstalledCallback of allInstalledCallbacks) {
                    await allInstalledCallback();
                }
                console.timeEnd(allInstalledTimerId);
            }
        }

        /**
         * Get the package data based on the package DOM node
         *
         * @param {Node} packageDOM the package dom node
         * @returns {WPMPackage} the package
         * @ignore
         */
        static getWPMPackageFromDOM(packageDOM) {
            try {
                let name = packageDOM.getAttribute("id");

                let descriptorDom = packageDOM.querySelector("script[type='descriptor'], wpm-descriptor");

                if (descriptorDom !== null) {
                    try {
                        let packageJson = JSON.parse(descriptorDom.textContent);
                        let repository = packageDOM.getAttribute("data-repository");

                        if(repository == null) {
                            repository = WPMv2.getLocalRepositoryURL();
                        }

                        return new WPMPackage(name, repository, packageJson);
                    } catch (e){
                        console.error("Erroneous package descriptor", e, descriptorDom.textContent, packageDOM);
                    }
                } else {
                    console.error("Missing package descriptor: ", packageDOM);
                }
            } catch (e) {
                console.error(e);
            }
        }

        static getLocalRepositoryURL() {
            return location.origin + location.pathname + "?raw";
        }

        /**
         * Retrieve the package dom from a repository
         *
         * @param {String} repository the repository to retrieve from
         * @param {String} packageName the package to retrieve
         * @returns {Node} the package dom node
         * @ignore
         */
        static async getPackageDOM(repository, packageName) {
            let dom = null;

            if(repository == this.getLocalRepositoryURL()) {
                dom = document.querySelector("html");
            } else {
                dom = await WPMv2.fetchDom(repository);
            }

            let packageDOMSource = dom.querySelector(".packages .package#" + packageName + ", wpm-package#" + packageName);
            if (packageDOMSource === null) {
                throw new Error("Invalid package '" + packageName + "' specified, no such package in repository '" + repository + "'");
            }

            let packageDOM = packageDOMSource.cloneNode(true);
            if(!packageDOM.hasAttribute("data-repository")) {
                packageDOM.setAttribute("data-repository", repository);
            }

            return packageDOM;
        }

        /**
         * Get an array of all packages that is currently installed in the dom
         *
         * @example
         * let installedPackages = WPMv2.getCurrentlyInstalledPackages();
         *
         * @returns {WPMv2.WPMPackage[]}
         */
        static getCurrentlyInstalledPackages() {
            let packages = [];

            document.querySelectorAll(".packages .package, wpm-package").forEach(function (v) {
                packages.push(WPMv2.getWPMPackageFromDOM(v));
            });

            return packages;
        }

        /**
         * Retrieve the latest package data from the original repository this package is from
         *
         * @example
         * WPMv2.getCurrentlyInstalledPackages().forEach((pkg)=>{
         *     let package = WPMv2.getLatestPackageFromPackage(pkg);
         *     //package now holds the latest data retrieved from the original repo it was installed from: like version, dependencies, changelog etc.
         * });
         *
         * @param {WPMv2.WPMPackage} p - The package to update package data for
         * @returns {Promise<WPMv2.WPMPackage>}
         */
        static async getLatestPackageFromPackage(p, repoOverride=null) {
            let fetchRepository = p.repository;
            if(repoOverride != null) {
                fetchRepository = repoOverride;
            }
            let packageDOM = await WPMv2.getPackageDOM(fetchRepository, p.name);

            let updatedPackage = WPMv2.getWPMPackageFromDOM(packageDOM);

            updatedPackage.updateFromOptions(p.getPackageOptions());

            return updatedPackage;
        }

        /**
         * Find all packages at a repository
         *
         * @example
         * WPMv2.getPackagesFromRepository("some.site.com/myRepo").then((packages)=>{
         *     console.log("Packages at repo:");
         *     packages.forEach((pkg)=>{
         *         console.log(pkg);
         *     }):
         * });
         *
         * @param {String} repositoryUrl the repository to search
         * @returns {Promise<WPMv2.WPMPackage[]>} the packages found
         */
        static async getPackagesFromRepository(repositoryUrl) {
            let packages = [];

            let dom = await WPMv2.fetchDom(repositoryUrl);

            dom.querySelectorAll(".packages .package, wpm-package").forEach(function (v) {
                if(!v.hasAttribute("data-repository")) {
                    v.setAttribute("data-repository", repositoryUrl);
                }
                packages.push(WPMv2.getWPMPackageFromDOM(v));
            });

            return packages;
        }

        static readMetadata(packageName) {
            let packageDom = document.querySelector(".packages .package#" + packageName + ", wpm-package#" + packageName);

            if(packageDom != null) {
                let metadataDom = packageDom.querySelector("script[type='descriptor'], wpm-descriptor");

                if (metadataDom != null) {
                    return JSON.parse(metadataDom.textContent);
                }
            }
            return null;
        }

        static async fetchAsset(url, asset) {
            if(Array.isArray(url)) {
                for(let u of url) {
                    try {
                        let fetchedAsset = await WPMv2.fetchAsset(u, asset);
                        if(fetchedAsset != null) {
                            return fetchedAsset;
                        }
                    } catch(e) {
                        //Ignore
                    }
                }
            }

            let assetUrl = url.substring(0, url.indexOf("?"));
            if (!assetUrl.endsWith("/")) {
                assetUrl += "/";
            }

            assetUrl += asset;

            let response = await fetch(assetUrl, {credentials: 'same-origin'});
            let blob = await response.blob();

            return blob;
        }

        static async fetchAssets(url) {
            if(Array.isArray(url)) {
                for(let u of url) {
                    try {
                        let assets = await WPMv2.fetchAssets(u);
                        if (assets != null) {
                            return assets;
                        }
                    } catch(e) {
                        //Ignore ?
                    }
                }
            }

            if(!url.endsWith("?assets&latest")) {
                url = url.substring(0, url.indexOf("?")) + "?assets&latest";
            }

            if (WPMv2.assetsCache[url] != null) {
                if (Date.now() - WPMv2.assetsCache[url].timestamp < WPMv2.cacheTimeout) {
                    return WPMv2.assetsCache[url].assets;
                }
            }

            let response = await fetch(url, {credentials: 'same-origin'});

            let assetsJson = await response.json();

            let assetResult = new Map();

            assetsJson.forEach((asset)=>{
                let current = assetResult.get(asset.fileName);

                if(current == null || current.v < asset.v) {
                    assetResult.set(asset.fileName, asset);
                }
            });

            WPMv2.assetsCache[url] = {
                assets: assetResult,
                timestamp: Date.now()
            };

            return assetResult;
        }

        static lookupRepoAlias(alias) {
            let localStorageAliases = {};
            let sessionStorageAliases = {};
            try {
                localStorageAliases = JSON.parse(localStorage.getItem(WPM_ALIASES));
            } catch (ex){
                console.warn("Unparseable localStorage.repositoryAliases", ex);
            }
            try {
                sessionStorageAliases = JSON.parse(sessionStorage.getItem(WPM_ALIASES));
            } catch (ex){
                console.warn("Unparseable sessionStorage.repositoryAliases", ex);
            }

            if(localStorageAliases?.hasOwnProperty(alias)) {
                let result = localStorageAliases[alias];
                return result;
            } else if(sessionStorageAliases?.hasOwnProperty(alias)) {
                let result = sessionStorageAliases[alias];
                return result;
            } else {
                //Check if alias might be an url already?
                if(alias.startsWith("http") || alias.startsWith("/")) {
                    //Probabely an url
                    return alias;
                }
            }

            return ["/"+alias+"/?raw", "/"+alias+"/index.html"];
        }

        static async fetchDom(url) {
            //Lookup repos aliases
            url = WPMv2.lookupRepoAlias(url);

            if(Array.isArray(url)) {
                //Call again for each url in array
                for(let u of url) {
                    try {
                        let fetchedDom = await this.fetchDom(u);
                        if(fetchedDom != null) {
                            return fetchedDom;
                        }
                    } catch(e) {
                        //Ignore?
                        console.warn(e);
                    }
                }
            } else {
                if(url.endsWith("?raw") && !url.endsWith("/?raw")) {
                    url = url.substring(0, url.lastIndexOf("?raw")) + "/?raw";
                }

                // Check the cache for ongoing fetches for this URL
                let cachedDom = WPMv2.domCache.get(url);
                if (cachedDom != null) {
                    cachedDom = await cachedDom;
                    if (Date.now() - cachedDom.timestamp < WPMv2.cacheTimeout) {
                        return cachedDom.dom;
                    }
                }

                // No ongoing fetches, start one
                let fetcherPromise = (async function fetchDOMPromise(){
                    let response = await fetch(url, {credentials: 'same-origin'});
                    if(response != null) {
                        let documentText = await response.text();

                        let parsedDom = WPMv2.parser.parseFromString(documentText, "text/html");
                        if (parsedDom.readyState === "loading") {
                            await new Promise((resolve, reject) => {
                                parsedDom.addEventListener("DOMContentLoaded", () => {
                                    resolve();
                                });
                            });
                        }

                        return {
                            dom: parsedDom,
                            timestamp: Date.now()
                        };
                    }
                })();
                WPMv2.domCache.set(url, fetcherPromise);

                return (await fetcherPromise).dom;
            }

            console.error("Unable to fetchDOM from: ", url);
            return null;
        }

        /**
         * Strips all Webstrate protection from the given dom element and its children.
         *
         * @example
         * WPMv2.stripProtection(document.querySelector("#myElement"));
         *
         * @param {HTMLElement} html - The element to strip protection from
         */
        static stripProtection(html) {
            function stripAttributeProtection(elm) {
                if (!elm.__approvedAttributes) {
                    try {
                        elm.__approvedAttributes = new Set();
                    } catch (e) {
                    }
                }

                if (elm.attributes != null) {
                    for (let i = 0, atts = elm.attributes, n = atts.length; i < n; i++) {
                        elm.__approvedAttributes.add(atts[i].nodeName);
                    }
                }
            }

            if (html instanceof Array) {
                html.forEach((entry) => {
                    if (entry != null) {
                        WPMv2.stripProtection(entry);
                    }
                });
                return;
            }

            if (!html.__approved) {
                try {
                    html.__approved = true;
                } catch (e) {
                }
            }

            if (html.removeAttribute != null) {
                html.removeAttribute("unapproved");
            }

            stripAttributeProtection(html);

            if (html.childNodes != null) {
                Array.from(html.childNodes).forEach((child) => {
                    WPMv2.stripProtection(child);
                });
            } else if (html.children != null) {
                Array.from(html.children).forEach((child) => {
                    WPMv2.stripProtection(child);
                });
            }

            if (html.content != null) {
                WPMv2.stripProtection(html.content);
            }
        }

        /**
         * Updates the version of WPMv2 in the current page, with the version in the given url
         *
         * @example
         * await WPMv2.updateWPM("https://some.site.com/containsLatestWPMv2");
         * //WPMv2 is now updated
         *
         * @param {string} url - URL to the webstrate to update WPMv2 from
         * @returns {Promise<void>} - Resolves when WPMv2 is updated
         */
        static async updateWPM(url) {
            console.group("Updating WPM...");
            if(url == null) {
                console.log("No repository given for update, defaulting to \"/wpm/?raw\"");
                url = "/wpm/?raw";
            }

            console.log("Version before update:", window.WPMv2.version);

            let dom = await WPMv2.fetchDom(url);

            let newWpm = dom.querySelector("#WPMv2-script");

            let ourWpm = document.querySelector("#WPMv2-script");

            ourWpm.textContent = newWpm.textContent;

            if(ourWpm.hasAttribute("src")) {
                ourWpm.removeAttribute("src");
                console.warn("Removed src attribute on WPMScript, now inlined instead!");
            }
            eval.call(null, ourWpm.textContent);
            console.log("Version after update:", window.WPMv2.version);
            console.groupEnd();
        }

        /**
         * Installs WPMv2 into the given webstrate. Can be given as an iframe that already points to a transcluded webstrate, or the url to a webstrate.
         *
         * @example
         * await WPMv2.installWPMInto("https://some.site.com/myWebstrate");
         * //WPMv2 is now installed
         *
         * @param {HTMLIFrameElement|string} iframeOrUrl - The iframe or url that WPMv2 should be installed into
         * @returns {Promise<void>} - Resolves when WPMv2 is done installing.
         */
        static async installWPMInto(iframeOrUrl) {
            let iframe = null;
            let transient = null;

            if (typeof iframeOrUrl === "string") {
                iframe = document.createElement("iframe");
                iframe.src = iframeOrUrl;
                let promise = new Promise((resolve, reject) => {
                    iframe.webstrate.on("transcluded", function once() {
                        iframe.webstrate.off("transcluded", once);
                        resolve();
                    });
                });

                transient = document.createElement("transient");
                transient.append(iframe);
                document.body.append(transient);

                await promise;
            } else {
                //Attempt to unpack cQuery/jQuery objects
                if (iframeOrUrl[0] != null) {
                    iframeOrUrl = iframeOrUrl[0];
                }

                if (iframeOrUrl instanceof HTMLIFrameElement) {
                    iframe = iframeOrUrl;
                } else {
                    console.log("Unknown iframe/url: ", iframeOrUrl);
                    return;
                }
            }

            let targetHead = iframe.contentDocument.head;

            //Remove old WPMv2 if present
            let oldWpm = iframe.contentDocument.querySelector("#WPMv2-script");
            if (oldWpm != null) {
                oldWpm.parentNode.removeChild(oldWpm);
            }

            let clonedScript = document.querySelector("#WPMv2-script").cloneNode(true);

            if (clonedScript.src != null && clonedScript.src.length > 0) {
                let response = await fetch(clonedScript.src, {credentials: 'same-origin'});
                let scriptContent = await response.text();

                clonedScript.removeAttribute("src");
                clonedScript.textContent = scriptContent;
            }

            WPMv2.stripProtection(clonedScript);
            targetHead.insertBefore(clonedScript, targetHead.firstChild);

            iframe.contentWindow.eval.call(null, clonedScript.textContent);

            await iframe.contentWindow.webstrate.dataSaved();

            if (transient != null) {
                document.body.removeChild(transient);
            }
        }

        static notifyRemove(packageName, packageDom) {
            let event = new CustomEvent("wpm.packageRemoved", {detail: packageName});
            packageDom.dispatchEvent(event);

            let eventAny = new CustomEvent("wpm.packageRemovedAny", {detail: packageName});
            document.dispatchEvent(eventAny);
        }

        static getRegisteredRepositories(useLocalStorage) {
            let currentAliases = null;

            try {
                if(useLocalStorage) {
                    currentAliases = JSON.parse(localStorage.getItem(WPM_ALIASES));
                } else {
                    currentAliases = JSON.parse(sessionStorage.getItem(WPM_ALIASES));
                }
            } catch (ex){}
            if (currentAliases == null || typeof currentAliases !== "object"){
                currentAliases = {};
            }

            return currentAliases;
        }

        /**
         * Registers a repository alias
         * @param alias The alias to register
         * @param repository The repository to register the alias to
         * @param useLocalStorage If true, the registered alias is registered in localStorage, if not, in sessionStorage
         */
        static registerRepository(alias, repository, useLocalStorage = false) {
            let currentAliases = null;

            try {
                if(useLocalStorage) {
                    currentAliases = JSON.parse(localStorage.getItem(WPM_ALIASES));
                } else {
                    currentAliases = JSON.parse(sessionStorage.getItem(WPM_ALIASES));
                }
            } catch (ex){}
            if (currentAliases == null || typeof currentAliases !== "object"){
                currentAliases = {};
            }

            currentAliases[alias] = repository;

            if(useLocalStorage) {
                localStorage.setItem(WPM_ALIASES, JSON.stringify(currentAliases));
            } else {
                sessionStorage.setItem(WPM_ALIASES, JSON.stringify(currentAliases));
            }
        }

        /**
         * Unregisters a repository alias
         * @param alias The alias to unregister
         * @param useLocalStorage If true, the alias is removed from localStorage, if not, from sessionStorage
         */
        static unregisterRepository(alias, useLocalStorage = false) {
            let currentAliases = null;

            try {
                if(useLocalStorage) {
                    currentAliases = JSON.parse(localStorage.getItem(WPM_ALIASES));
                } else {
                    currentAliases = JSON.parse(sessionStorage.getItem(WPM_ALIASES));
                }
            } catch (ex){
                console.error(ex);
            }
            if (currentAliases == null || typeof currentAliases !== "object"){
                console.log(currentAliases);
                currentAliases = {};
            }

            delete currentAliases[alias];

            if(useLocalStorage) {
                localStorage.setItem(WPM_ALIASES, JSON.stringify(currentAliases));
            } else {
                sessionStorage.setItem(WPM_ALIASES, JSON.stringify(currentAliases));
            }
        }

        /**
         * Clears all registered aliases from storage
         * @param useLocalStorage If true, clears from localStorage, if not, from sessionStorage
         */
        static clearRegisteredRepositories(useLocalStorage = false) {
            if(useLocalStorage) {
                localStorage.setItem(WPM_ALIASES, "{}");
            } else {
                sessionStorage.setItem(WPM_ALIASES, "{}");
            }
        }
    }

    WPMv2.domCache = new Map();
    WPMv2.assetsCache = {};
    WPMv2.parser = new DOMParser();
    WPMv2.cacheTimeout = 5000;

    /**
     * A WPM package
     * @memberof WPMv2
     */
    class WPMPackage {
        /**
         * Create a new WPMPackage
         * @param {string} name - The package name
         * @param {string} repository - The repository that the package should be fetched from
         * @param {json} [descriptorJson] - Package Descriptor
         */
        constructor(name, repository, descriptorJson = {}) {
            /**
             * The name of the package
             * @type {string}
             */
            this.name = name;
            /**
             * The repository the package is fetched from
             * @type {string}
             */
            this.repository = repository;

            /**
             * The version of the package
             * @type {number}
             */
            this.version = -1;
            /**
             * Package dependencies that will be installed when the package is installed
             * @type {string[]}
             */
            this.dependencies = [];
            /**
             * Optional Package dependencies
             * @type {string[]}
             */
            this.optionalDependencies = [];
            /**
             * Assets that the package uses, will be copied over to the webstrate where the package is installed
             * @type {Array.<string>}
             */
            this.assets = [];
            /**
             * A description of the package
             * @type {string}
             */
            this.description = "";
            /**
             * A human friendly name for the package
             * @type {string}
             */
            this.friendlyName = "";
            /**
             * Changelog, holding any changelog information for the package
             * @type {object}
             */
            this.changelog = {};
            /**
             * Link to documentation of the package if any exists
             * @type {string}
             */
            this.documentationLink = "";

            this.dependencyMap = new Map();
            this.optionalDependencyMap = new Map();

            this.appendMethod = "append";
            this.appendTarget = null;

            this.bootstrap = true;

            this.updateFromJson(descriptorJson);
        }

        updateFromOptions(options) {
            ["appendMethod", "appendTarget", "repository", "bootstrap"].forEach((optionProperty)=>{
                if(options.hasOwnProperty(optionProperty)) {
                    this[optionProperty] = options[optionProperty];
                }
            })
        }

        getPackageOptions() {
            let options = {};

            ["appendMethod", "appendTarget", "repository", "bootstrap"].forEach((optionProperty)=>{
                options[optionProperty] = this[optionProperty];
            });

            return options;
        }

        updateFromJson(packageJson) {
            let self = this;

            this.descriptor = packageJson;

            ["version", "friendlyName", "dependencies", "optionalDependencies", "description", "changelog", "documentationLink", "license"].forEach((packageProperty)=>{
                if (packageJson.hasOwnProperty(packageProperty)){
                    this[packageProperty] = packageJson[packageProperty];
                }
            });

            if (packageJson.hasOwnProperty("assets")) {
                packageJson.assets.forEach((asset) => {
                    if (asset.src != null) {
                        self.assets.push(asset.src);
                    } else {
                        self.assets.push(asset);
                    }
                });
            }

            this.dependencies.forEach((dep) => {
                let split = dep.split(" ");

                let repo = null;
                let packageName = null;

                if (split.length === 1) {
                    packageName = split[0].replace("#", "");
                    repo = this.repository;
                } else {
                    packageName = split[1].replace("#", "");
                    repo = split[0];
                }

                self.dependencyMap.set(packageName, repo);
            });

            this.optionalDependencies.forEach((dep) => {
                let split = dep.split(" ");

                let repo = null;
                let packageName = null;

                if (split.length === 1) {
                    packageName = split[0].replace("#", "");
                    repo = this.repository;
                } else {
                    packageName = split[1].replace("#", "");
                    repo = split[0];
                }

                self.optionalDependencyMap.set(packageName, repo);
            });
        }

        toString() {
            return this.name + "[" + this.version + "]";
        }
    }

    let removedObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            mutation.removedNodes.forEach((node) => {
                if (node.matches != null && node.matches(".packages .package, wpm-package")) {
                    WPMv2.notifyRemove(node.id, node);
                } else if (node.querySelectorAll != null) {
                    node.querySelectorAll(".packages .package, wpm-package").forEach((child) => {
                        WPMv2.notifyRemove(child.id, child);
                    });
                }
            });
        });
    });

    removedObserver.observe(document, {
        childList: true,
        attributes: false,
        subtree: true
    });

    //Setup attribute "transient-element" that marks a DOM element as transient
    if(typeof webstrate !== "undefined") {
        let oldIsTransientElement = webstrate.config.isTransientElement;
        webstrate.config.isTransientElement = (node) => {
            if (node.hasAttribute("transient-element")) {
                return true;
            }

            return oldIsTransientElement(node);
        };
    }

    //WPMv2 Interface to the world!
    window.WPMv2 = {
        require: WPMv2.require,
        requireAll: WPMv2.requireAll,
        installWPMInto: WPMv2.installWPMInto,
        stripProtection: WPMv2.stripProtection,
        updateWPM: WPMv2.updateWPM,
        getPackagesFromRepository: WPMv2.getPackagesFromRepository,
        getCurrentlyInstalledPackages: WPMv2.getCurrentlyInstalledPackages,
        getLatestPackageFromPackage: WPMv2.getLatestPackageFromPackage,
        registerRepository: WPMv2.registerRepository,
        unregisterRepository: WPMv2.unregisterRepository,
        clearRegisteredRepositories: WPMv2.clearRegisteredRepositories,
        getRegisteredRepositories: WPMv2.getRegisteredRepositories,
        getLocalRepositoryURL: WPMv2.getLocalRepositoryURL,
        version: 2.42,
        revision: "$Id: WPMv2.js 1023 2023-03-14 10:02:57Z au182811@uni.au.dk $",
        test: WPMv2
    };

    window.WPM = window.WPMv2;
    window.WPMPackage = WPMPackage;
})(window);

// Provide bootloader functionality
class WPMBoot {
    static loadedCallbacks = [];
    static isLoaded = false;

    static async wpmv2_bootloader(){
        document.querySelector("html").setAttribute("transient-wpm2-bootloader", "loading");

        let bootConfigElement = document.querySelector("head script[type='text/json+bootconfig']");
        if (!bootConfigElement){
            return;
        }

        let bootConfig = null;
        try {
            bootConfig = JSON.parse(bootConfigElement.textContent);
        } catch (ex){
            console.error("WPM bootloader cannot parse boot config", bootConfigElement.textContent, ex);
            return;
        }

        if (!bootConfig.require){
            console.warn("WPM bootloader did not find required 'require' section in boot config, ignoring");
            return;
        }

        if (!Array.isArray(bootConfig.require)){
            console.warn("WPM bootloader 'require' section in boot config is not an array, ignoring");
            return;
        }

        // Load all required packages with WPM
        for (let requireStep of bootConfig.require){
            if (!(requireStep.dependencies && Array.isArray(requireStep.dependencies))){
                console.warn("WPM bootloader skipping incorrect requirestep, dependency list is missing", requireStep);
                continue;
            }
            if (requireStep.repositories){
                if (typeof requireStep.repositories !== "object"){
                    console.warn("WPM bootloader skipping registration of repositories because requireStep.repositories isn't an object map of name->url", requireStep);
                } else {
                    for (const [key, value] of Object.entries(requireStep.repositories)) {
                        WPMv2.registerRepository(key, value);
                    }
                }
            }

            if (requireStep.options){
                await WPMv2.require(requireStep.dependencies, requireStep.options);
            } else {
                await WPMv2.require(requireStep.dependencies);
            }
        }

        // Fire loaded events
        document.querySelector("html").setAttribute("transient-wpm2-bootloader", "initializing");
        while (WPMBoot.loadedCallbacks.length>0){
            let callback = WPMBoot.loadedCallbacks.pop();
            try {
                await callback();
            } catch (ex){
                console.error("WPMv2 Bootloader exception in WPMBoot.onLoaded(...) callback", ex, callback);
            }
        }
        document.querySelector("html").setAttribute("transient-wpm2-bootloader", "loaded");
    }

    static async onLoaded(callback){
        if (WPMBoot.isLoaded){
            await callback();
        } else {
            WPMBoot.loadedCallbacks.push(callback);
        }
    }
}
window.WPMBoot = WPMBoot;

document.querySelector("html").setAttribute("transient-wpm2-bootloader", "waiting");
if(typeof webstrate  !== "undefined") {
    // Webstrate mode
    webstrate.on("loaded", async function wpmv2_bootloader_loader() {
        await WPMBoot.wpmv2_bootloader();
    });
} else {
    // Standalone mode
    document.addEventListener("DOMContentLoaded", async function(event) {
        await WPMBoot.wpmv2_bootloader();
    });
}

</SCRIPT></WPM-PACKAGE></head>

<body>
    <wpm-packages>

    <WPM-PACKAGE id="MirrorverseLoadingSkin" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "A simple loading skin for the bootloader to avoid seeing improperly rendered HTML while loading",
    "dependencies": [
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "0.4",
    "forceEmbedding": true
}

</SCRIPT><STYLE id="loading-style">html {
  background: #313131;
}

html:not([transient-wpm2-bootloader="loaded"]) > * {
  opacity: 0 !important;
}
html:not([transient-wpm2-bootloader="loaded"]) {
  contain: paint;
  overflow: hidden;
  max-height: 100vh;
}

@keyframes wpm-bootloader-spinning {
  from {
      filter: drop-shadow(0 0 1em rgba(255, 183, 0,0.5));
  }
  to {
      filter: drop-shadow(0 0 0em rgb(0, 170, 255));
  }
}

@keyframes wpm-bootloader-appears {
  from {
      opacity: 0;
  }
  to {
      opacity: 1;
  }
}


@keyframes wpm-bootloader-done {
  0% {
    transform: translate(-50%, -50%);
    opacity: 1;
  }
  5% {
    transform: translate(-50%, -50%) skew(0.4rad);
    opacity: 1;
  }
  25% {
    transform: translate(-60%, -50%) skew(0.312rad);
    opacity: 1;
  }
  30% {
    transform: translate(-61%, -50%) skew(-0.412rad);
    opacity: 0.8;
  }
  99% {
    transform: translate(200%, -50%) ;
    opacity: 0;
  }
  100% {
    visibility: hidden;
    transform: translate(-50%, -50%) scale(1.75);
    opacity: 0;
  }
}

html[transient-wpm2-bootloader="waiting"]:before, html[transient-wpm2-bootloader="waiting"]:before, html[transient-wpm2-bootloader="loading"]:before, html[transient-wpm2-bootloader="initializing"]:before, html[transient-wpm2-bootloader="loaded"]:before {
  content: "MIRRORVERSE";
  position: fixed;
  left: 50%;
  top: 50%;
  transform: translate(-50%,-50%);
  background-image: linear-gradient(#378DBC 0%, #B6E8F1 46%, #ffffff 50%, #32120E 54%, #FFC488 58%, #582C11 90%, #EC9B4E 100%);
  letter-spacing: 0.3px;
  font-weight: 900;
  padding: 0 16px;
  font-style: italic;
  font-size: 5vh;
  max-height: 100vh;
  white-space: nowrap;
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  -webkit-text-stroke: 0.4px #f5f5f5;
  pointer-events: none;
  z-index: 9999;
  font-family: sans-serif;
  animation: wpm-booloader-spinning 2s ease-in-out infinite, wpm-bootloader-appears 0.25s ease-in both;
}

html[transient-wpm2-bootloader="loaded"]:before {
  animation: wpm-bootloader-done 2s ease-in both;
}
</STYLE></WPM-PACKAGE></wpm-packages>





    <varv-data>

    <CONCEPT type="meeting" uuid="conceptfa30cc2b4590df112efa"><PROPERTY name="toolManager" value="concept84458120115041bf5ba1"></PROPERTY><PROPERTY name="rootRoom" value="conceptcfd3cd61e6079071d8db"></PROPERTY></CONCEPT><CONCEPT type="userManager" uuid="concepted88caef803f25f0deb2"></CONCEPT><CONCEPT type="audioManager" uuid="concept4cbd62195cdc41dad1c0"></CONCEPT><CONCEPT type="toolManager" uuid="concept84458120115041bf5ba1"></CONCEPT><CONCEPT type="chatManager" uuid="concept1b3661d8f146038f1d01"></CONCEPT><CONCEPT type="regularRoom" uuid="conceptcfd3cd61e6079071d8db"><PROPERTY name="left" value="0"></PROPERTY><PROPERTY name="top" value="0"></PROPERTY><PROPERTY name="width" value="300"></PROPERTY><PROPERTY name="height" value="200"></PROPERTY><PROPERTY name="name" value="Home"></PROPERTY></CONCEPT><CONCEPT type="user" uuid="conceptd5e030d471d39150d148"><PROPERTY name="name" value="Guest"></PROPERTY></CONCEPT></varv-data>


<DIV name="Varv Extensions"><WPM-PACKAGE id="StreamTools" name="StreamTools"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Varv extension that handles the WebRTC streaming and the audio routing control.",
    "dependencies": [],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><DIV id="cameraStreamChannelNode" name="cameraStreamChannelNode"></DIV><DIV name="audioStreamChannelNode" id="audioStreamChannelNode"></DIV><DIV id="screenStreamChannelNode" name="screenStreamChannelNode"></DIV><CODE-FRAGMENT data-type="text/javascript" name="Stream Handling" auto>window.cameraStreams = {};
window.audioStreams = {};
window.screenStreams = {};

const cameraChannel = document.querySelector('#cameraStreamChannelNode');
const audioChannel = document.querySelector('#audioStreamChannelNode');
const screenChannel = document.querySelector('#screenStreamChannelNode');



/**** Load Tuna library for audio filters ****/

// https://github.com/Theodeus/tuna
// https://github.com/Theodeus/tuna/wiki/Node-examples
await wpm.requireExternal('https://unpkg.com/tunajs@1.0.15/tuna-min.js');



/**** User interaction tracker for timing ****/

let clicked = false;

document.addEventListener('click', () => {
    clicked = true;
});



/**** Methods for Varv Actions and Trigger ****/

// Request camera sharing stream
const requestCameraStream = async () => {
    const stream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: false
    });
    addStream(stream, webstrate.clientId, 'camera', true);
    enableStreamSharing(stream, 'camera');
};

// Request audio sharing stream
const requestAudioStream = async () => {
    const stream = await navigator.mediaDevices.getUserMedia({
        video: false,
        audio: true
    });
    addStream(stream, webstrate.clientId, 'audio', true);
    enableStreamSharing(stream, 'audio');
};

// Request screen sharing stream
const requestScreenStream = async () => {
    const stream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
        audio: false
    });

    addStream(stream, webstrate.clientId, 'screen', true);
    enableStreamSharing(stream, 'screen');
};

const addStream = (stream, clientId, type, local = false) => {
    if (type === 'camera') {
        window.cameraStreams[clientId] = stream;
    } else if (type === 'audio') {
        window.audioStreams[clientId] = stream;
    } else {
        window.screenStreams[clientId] = stream;
    }
};



/**** Sharing and WebRTC ****/

const enableStreamSharing = (stream, type) => {
    setTimeout(() => {
        const channel = type === 'camera' ? cameraChannel : type === 'audio' ? audioChannel : screenChannel;
        channel.webstrate.signalStream((clientId, accept) => {
            console.log('Got stream request...');
            let conn = accept(stream, () => {
                console.log('Client accepted');
                // Connection has been established
            });
        });
    }, 0);
};

const  requestWebRTC = (type) => {
    setTimeout(function () {
        const channel = type === 'camera' ? cameraChannel : type === 'audio' ? audioChannel : screenChannel;
        channel.webstrate.on('signalStream', function (clientId, meta, accept) {
            let conn = accept((stream) => {
                console.log('Got stream...', stream, type);
                addStream(stream, clientId, type);
                const video = document.querySelector('video[data-stream="' + clientId + '"][data-stream-type="' + type + '"]');
                if (video) {
                    addStreamToVideo(video, clientId, type);
                }
            });
            console.log(conn);
        });
    }, 0);
};

Object.defineProperty(HTMLMediaElement.prototype, 'playing', {
    get: function () {
        return !!(this.currentTime > 0 && !this.paused && !this.ended && this.readyState > 2);
    }
});

const closeStream = (clientId, type) => {
    if (type === 'camera') {
        window.cameraStreams[clientId].getTracks().forEach(track => track.stop());
        delete window.cameraStreams[clientId];
    } else if (type === 'audio') {
        window.audioStreams[clientId].getTracks().forEach(track => track.stop());
        delete window.audioStreams[clientId];
    } else {
        window.screenStreams[clientId].getTracks().forEach(track => track.stop());
        delete window.screenStreams[clientId];
    }
};



/**** Element Live Query ****/

cQuery(document).liveQuery('video[data-stream]', {
    added: (video) => {
        cQuery(video).liveAttribute('data-stream', (video) => {
            handleChangedVideoElement(video);
        });
        handleChangedVideoElement(video);

        const type = video.getAttribute('data-stream-type');
        if (type === 'audio') {
            cQuery(video).liveAttribute('data-muted', (video) => {
                handleMutedChanged(video);
            });
            cQuery(video).liveAttribute('data-volume', (video) => {
                handleVolumeChanged(video);
            });
            cQuery(video).liveAttribute('data-filter', (video) => {
                handleFilterChanged(video);
            });
            handleMutedChanged(video);
            handleVolumeChanged(video);
            handleFilterChanged(video);
        }
    }
});

const handleChangedVideoElement = (video) => {
    if (video.src && video.src !== '' && video.src !== 'undefined') {
        console.log('Skipping!');
        return;
    };
    let type = video.getAttribute('data-stream-type');
    let streamId = video.getAttribute('data-stream');
    if (streamId === '{stream}' || !streamId) return;
    addStreamToVideo(video, streamId, type);
};

const addStreamToVideo = (video, streamId, type) => {
    // If it is an audio then we do not want the videoNode to play any audio
    if (type === 'audio') {
        const audioStream = window.audioStreams[streamId];

        video.crossOrigin = 'anonymous';
        video.srcObject = audioStream;

        // Setup audioSettings if not yet available and store on the stream
        if (clicked) {
            setTimeout(() => {
                setupAudioSettings(audioStream, streamId);
            }, 200);
        } else {
            document.addEventListener('click', () => {
                if (!video.playing) {
                    setupAudioSettings(audioStream, streamId);
                }
            });
        }
    } else {
        video.crossOrigin = 'anonymous';
        video.srcObject = type === 'camera' ? window.cameraStreams[streamId] : window.screenStreams[streamId];

        if (clicked) {
            setTimeout(() => {
                video.play();
            }, 200);
        } else {
            document.addEventListener('click', () => {
                if (!video.playing) {
                    video.play();
                }
            });
        }
    }
};



/**** Audio Setup and Handling ****/

const setupAudioSettings = (audioStream, streamId) => {
    if (audioStream == null) {
        return; // Stream not ready or existing
    }

    let audioSettings = audioStream.audioSettings;

    if (audioSettings == null) {
        const audioCtx = new AudioContext();
        const tuna = new Tuna(audioCtx);
        const source = audioCtx.createMediaStreamSource(audioStream);

        const volumeNode = audioCtx.createGain();
        const muteNode = audioCtx.createGain();
        const analyserNode = audioCtx.createAnalyser();
        analyserNode.smoothingTimeConstant = 0.1;
        analyserNode.fftSize = 1024;

        const biquadFilter = audioCtx.createBiquadFilter();
        const delay = audioCtx.createDelay(10.0);
        const overdrive = new tuna.Overdrive({
            outputGain: -9.154,           // -42 to 0 in dB
            drive: 0.197,                 // 0 to 1
            curveAmount: 0.979,           // 0 to 1
            algorithmIndex: 0,            // 0 to 5, selects one of the drive algorithms
            bypass: 0
        });

        source.connect(volumeNode);
        volumeNode.connect(muteNode);
        muteNode.connect(analyserNode);

        // Mute my own client but have the analyser work in the background
        if (streamId != webstrate.clientId) {
            analyserNode.connect(audioCtx.destination);
        }

        audioSettings = {
            audioCtx: audioCtx,
            source: source,
            volumeNode: volumeNode,
            muteNode: muteNode,
            analyserNode: analyserNode,
            biquadFilter: biquadFilter,
            delay: delay,
            overdrive: overdrive
        };
        audioStream.audioSettings = audioSettings;
    }
};

const handleMutedChanged = (video) => {
    const mutedString = video.getAttribute('data-muted');
    const muted = mutedString === 'true' ? true : false;

    const audioStream = video.srcObject;
    if (audioStream == null || audioStream.audioSettings == null) {
        return; // Stream not ready or existing
    }

    const muteNode = audioStream.audioSettings.muteNode;

    muteNode.gain.value = muted ? 0 : 1;
};

const handleVolumeChanged = (video) => {
    const volumeString = video.getAttribute('data-volume');
    const volume = Number(volumeString);

    if (isNaN(volume)) {
        return; // Invalid volume
    }

    const audioStream = video.srcObject;
    if (audioStream == null || audioStream.audioSettings == null) {
        return; // Stream not ready or existing
    }

    const volumeNode = audioStream.audioSettings.volumeNode;

    volumeNode.gain.value = Math.max(Math.min(volume, 1), 0);
};

const handleFilterChanged = async (video) => {
    const filterString = video.getAttribute('data-filter');

    const audioStream = video.srcObject;
    if (audioStream == null || audioStream.audioSettings == null) {
        return; // Stream not ready or existing
    }

    try {
        const audioSettings = audioStream.audioSettings;

        const source = audioSettings.source;
        const biquadFilter = audioSettings.biquadFilter;
        const delay = audioSettings.delay;
        const overdrive = audioSettings.overdrive;

        const volumeNode = audioSettings.volumeNode;

        // Disconnect existing connections
        source.disconnect();
        biquadFilter.disconnect();
        delay.disconnect();
        overdrive.disconnect();

        switch (filterString) {
            case 'muffled':
                biquadFilter.type = 'lowpass';
                biquadFilter.frequency.value = 400;

                source.connect(biquadFilter);
                biquadFilter.connect(volumeNode);

                break;
            case 'overdrive':
                source.connect(overdrive);
                overdrive.connect(volumeNode);

                break;
            default:
                source.connect(volumeNode);
        }
    } catch (e) {
        console.log('handleFilterChanged error');
        console.log(e);
    }
};



/**** Init ****/

requestWebRTC('camera');
requestWebRTC('audio');
requestWebRTC('screen');



/**** Window Variables ****/

window.requestWebRTC = requestWebRTC;

window.requestCameraStream = requestCameraStream;
window.requestAudioStream = requestAudioStream;
window.requestScreenStream = requestScreenStream;

window.closeStream = closeStream;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Get Stream Action" auto>class GetCameraStreamAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        try {
            await requestCameraStream();
        } catch (e) {
            console.error('GetCameraStreamAction', e);
        }

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            Action.setVariable(context, Action.defaultVariableName(self), webstrate.clientId);

            return context;
        });
    }
}

Action.registerPrimitiveAction('getCameraStream', GetCameraStreamAction);
window.GetCameraStreamAction = GetCameraStreamAction;



class GetAudioStreamAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        try {
            await requestAudioStream();
        } catch (e) {
            console.error('GetAudioStreamAction', e);
        }

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            Action.setVariable(context, Action.defaultVariableName(self), webstrate.clientId);

            return context;
        });
    }
}

Action.registerPrimitiveAction('getAudioStream', GetAudioStreamAction);
window.GetAudioStreamAction = GetCameraStreamAction;



class GetScreenStreamAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        try {
            await requestScreenStream();
        } catch (e) {
            console.error('GetScreenStreamAction', e);
        }

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            Action.setVariable(context, Action.defaultVariableName(self), webstrate.clientId);

            return context;
        });
    }
}

Action.registerPrimitiveAction('getScreenStream', GetScreenStreamAction);
window.GetScreenStreamAction = GetScreenStreamAction;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Close Stream Action" auto>class CloseStreamAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            closeStream(options.stream, options.type);

            return context;
        });
    }
}

Action.registerPrimitiveAction('closeStream', CloseStreamAction);
window.CloseStreamAction = CloseStreamAction;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Is Local Stream Action" auto>class IsStreamLocalAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            let result = false;

            if (options.stream) {
                result = options.stream == webstrate.clientId;
            }

            Action.setVariable(context, Action.defaultVariableName(self), result);

            return context;
        });
    }
}

Action.registerPrimitiveAction('isStreamLocal', IsStreamLocalAction);
window.IsStreamLocalAction = IsStreamLocalAction;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Volume Action" auto>class VolumeAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            let volume = 0;

            try {
                const video = document.querySelector(`.audioStreams video[data-stream="${options.stream}"][data-stream-type="audio"]`);
                const audioStream = video.srcObject;
                const analyserNode = audioStream.audioSettings.analyserNode;

                const bufferLength = analyserNode.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyserNode.getByteFrequencyData(dataArray);

                let sum = 0;
                for (const amplitude of dataArray) {
                    sum += amplitude * amplitude
                }

                volume = Math.sqrt(sum / dataArray.length);
            } catch (e) {
                // Do nothing
            }

            let resultName = Action.defaultVariableName(self);
            if (options.as != null) {
                resultName = options.as;
            }

            Action.setVariable(context, resultName, volume);

            return context;
        });
    }
}

Action.registerPrimitiveAction('volume', VolumeAction);
window.VolumeAction = VolumeAction;
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="RecordingTools" name="RecordingTools"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Varv extension that handles recording of camera feeds or the whole room using Videostrates.",
    "dependencies": [
        "#StreamTools"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Recording Handling" auto>// Adapted from: https://raw.githubusercontent.com/webrtc/samples/gh-pages/src/content/getusermedia/record/js/main.js

let mediaRecorder;
let recordedBlobs;
let recordingSource;



const handleDataAvailable = (event) => {
    console.log('handleDataAvailable', event);
    if (event.data && event.data.size > 0) {
        recordedBlobs.push(event.data);
    }
};

const getStreamFromId = (streamId) => {
    return window.cameraStreams[streamId];
};



const startRecording = (streamId, source) => {
    recordedBlobs = [];
    recordingSource = source;
    const mimeType = 'video/webm;codecs=vp9,opus';
    const options = { mimeType };
    const stream = getStreamFromId(streamId);
    // TODO: This only records video so far. This might be a solution for this: https://stackoverflow.com/a/36101484. But it conflicts with the audio routing.

    try {
        mediaRecorder = new MediaRecorder(stream, options);
    } catch (e) {
        console.error('Exception while creating MediaRecorder:', e);
        return;
    }

    console.log('Created MediaRecorder', mediaRecorder, 'with options', options);
    mediaRecorder.onstop = (event) => {
        console.log('Recorder stopped: ', event);
        console.log('Recorded Blobs: ', recordedBlobs);
    };
    mediaRecorder.ondataavailable = handleDataAvailable;
    mediaRecorder.start();
    console.log('MediaRecorder started', mediaRecorder);
};



const stopRecording = (streamId) => {
    mediaRecorder.stop();
    setTimeout(() => {
        // Either upload the recording or offer a download for the user
        uploadRecordingAsAsset();
        // downloadRecording();
    }, 100);
};

const uploadRecordingAsAsset = () => {
    const blob = new Blob(recordedBlobs, { type: 'video/webm' });
    const assetName = crypto.randomUUID() + '.webm';

    const formData = new FormData();
    formData.append('file', blob, assetName);

    const request = new XMLHttpRequest();
    request.open('POST', window.location.pathname);
    request.send(formData);
    request.addEventListener('load', (e) => {
        const asset = JSON.parse(request.responseText);
        console.log(asset);
        NewRecordingTrigger.trigger(asset.fileName, recordingSource);
    });
};

const downloadRecording = () => {
    const blob = new Blob(recordedBlobs, { type: 'video/webm' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    a.download = 'test.webm';
    document.body.appendChild(a);
    a.click();

    setTimeout(() => {
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
    }, 100);
};



window.startRecording = startRecording;
window.stopRecording = stopRecording;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Recording Actions" auto>class StartRecordingAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {

            if (options.streamId) {
                const source = options.source || false;

                startRecording(options.streamId, source);
            } else {
                console.warn('streamId is required to start a recording!')
            }

            return context;
        });
    }
}

Action.registerPrimitiveAction('startRecording', StartRecordingAction);
window.StartRecordingAction = StartRecordingAction;



class StopRecordingAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            stopRecording();
            return context;
        });
    }
}

Action.registerPrimitiveAction('stopRecording', StopRecordingAction);
window.StopRecordingAction = StopRecordingAction;



class StartRoomRecordingAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {

            if (options.fullscreenRoom) {
                // startRoomRecording(options.fullscreenRoom);
                console.warn('Room recordings are not available on the GitHub release of Mirrorverse.');
            } else {
                console.warn('fullscreenRoom is required to start a recording!')
            }

            return context;
        });
    }
}

Action.registerPrimitiveAction('startRoomRecording', StartRoomRecordingAction);
window.StartRoomRecordingAction = StartRoomRecordingAction;



class StopRoomRecordingAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            // stopRoomRecording();
            console.warn('Room recordings are not available on the GitHub release of Mirrorverse.');
            return context;
        });
    }
}

Action.registerPrimitiveAction('stopRoomRecording', StopRoomRecordingAction);
window.StopRoomRecordingAction = StopRoomRecordingAction;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="New Recording Trigger" auto>class NewRecordingTrigger extends Trigger {
    constructor(name, options, concept, type) {
        super(name, options, concept);
        this.type = type;
    }

    enable() {
        const self = this;

        this.deleteTrigger = Trigger.registerTriggerEvent('newRecording', async (contexts) => {
            await Trigger.trigger(self.name, contexts);
        });
    }

    disable() {
        if (this.deleteTrigger != null) {
            this.deleteTrigger.delete();
        }
    }

    static trigger(recordingUrl, source) {
        const sourceSafe = source || '';
        let context = {
            variables: {
                recordingUrl: recordingUrl,
                source: sourceSafe
            },
            target: null,
            properties: null,
        }
        Trigger.trigger('newRecording', context);
    }
}

Trigger.registerTrigger('newRecording', NewRecordingTrigger);
window.NewRecordingTrigger = NewRecordingTrigger;
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="FindAction" id="FindAction"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Varv extension that adds a 'Find' action that can find concepts with filtering and stores them in a variable.",
    "dependencies": [],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Find Action" auto>// Adapts the 'select' action of Varv
// https://github.com/Webstrates/Varv/blob/0bb1236308bb4f3c3d409d69c4f278b730a738ce/actions/ContextActions.js#L125

class FindAction extends Action {
    static options() {
        return {
            '$selectType': 'enumValue[concept,property,variable]',
            'where': 'filter',
            'as': '@string'
        };
    }

    constructor(name, options, concept) {
        //Handle shorthand
        if (typeof options === 'string') {
            if (options.trim().startsWith('$')) {
                options = {
                    target: options
                }
            } else {
                options = {
                    concept: options
                }
            }
        }

        const defaultOptions = {};

        options = Object.assign({}, defaultOptions, options);

        let wherePart = options.where;
        delete options.where;

        super(name, options, concept);

        this.wherePart = wherePart;
    }

    async apply(contexts, actionArguments) {
        const self = this;

        const DEBUG_SELECT = false;

        const globalConceptUUIDs = [];

        async function doSelect(context, options, originalOptions) {
            let mark = VarvPerformance.start();

            if (DEBUG_SELECT) {
                console.group('doSelect');
                console.log('Context:', context);
                console.log('Options:', options);
                console.log('Where:', self.wherePart);
            }

            let conceptUUIDs = [];
            let doFilter = true;

            if (options.concept != null) {
                // Select concept from type
                if (DEBUG_SELECT) {
                    console.log('Concept selection...');
                }

                doFilter = false;

                let filter = null;

                if (self.wherePart) {
                    let clonedVariables = Object.assign({}, context.variables);

                    let filterContext = { target: null, lastTarget: context.target, variables: clonedVariables };

                    let lookupWhereWithArguments = await Action.lookupArguments(self.wherePart, actionArguments);

                    let lookupWhereOptions = await Action.lookupVariables(lookupWhereWithArguments, filterContext);

                    filter = await FilterAction.constructFilter(lookupWhereOptions);
                }

                let limit = 0;

                if (options.limit != null) {
                    limit = options.limit;
                }

                conceptUUIDs = await VarvEngine.lookupInstances(VarvEngine.getAllImplementingConceptNames(options.concept), filter, context, limit, self.concept);

            } else if (options.target != null) {
                // Select concept from target
                if (Array.isArray(options.target)) {
                    conceptUUIDs.push(...options.target);
                } else {
                    conceptUUIDs.push(options.target);
                }
            } else if (options.property != null) {
                // Select concept from property of type concept or concept[]
                let lookup = await VarvEngine.lookupProperty(context.target, self.concept, options.property);

                if (lookup == null) {
                    if (DEBUG_SELECT) {
                        console.groupEnd();
                    }
                    throw new Error('No property [' + options.property + '] found!');
                }

                if (lookup.property.isConceptType()) {
                    let value = await lookup.property.getValue(lookup.target)
                    conceptUUIDs.push(value);
                } else if (lookup.property.isConceptArrayType()) {
                    let value = await lookup.property.getValue(lookup.target)
                    conceptUUIDs.push(...value);
                } else {
                    if (DEBUG_SELECT) {
                        console.groupEnd();
                    }
                    throw new Error('Only able to select properties that are of concept or concept array type: [' + options.property + ':' + lookup.property.type + ']');
                }
            } else {
                if (DEBUG_SELECT) {
                    console.groupEnd();
                }
                throw new Error('Missing option "concept" or "target" on select action');
            }

            // Filtering already done?

            if (doFilter) {
                let filterMark = VarvPerformance.start();
                let filteredUUIDs = [];

                for (let uuid of conceptUUIDs) {
                    if (self.wherePart != null) {
                        let clonedVariables = Object.assign({}, context.variables);

                        let filterContext = { target: uuid, lastTarget: context.target, variables: clonedVariables };

                        let lookupWhereWithArguments = await Action.lookupArguments(self.wherePart, actionArguments);

                        let lookupWhereOptions = await Action.lookupVariables(lookupWhereWithArguments, filterContext);

                        let filter = await FilterAction.constructFilter(lookupWhereOptions);

                        if (await filter.filter(filterContext, self.concept)) {
                            filteredUUIDs.push(uuid);
                        }
                    } else {
                        filteredUUIDs.push(uuid);
                    }
                }
                VarvPerformance.stop('FindAction.doSelect.filtering', filterMark, { filter: self.wherePart, numConcepts: conceptUUIDs.length });

                conceptUUIDs = filteredUUIDs;
            }

            globalConceptUUIDs.push(...conceptUUIDs);

            VarvPerformance.stop('FindAction.doSelect', mark);

            if (DEBUG_SELECT) {
                console.groupEnd();
            }

            return context;
        }

        let result = [];

        let optionsWithArguments = await Action.lookupArguments(this.options, actionArguments);

        // Run the 'doSelect' method on each context to find the UUIDs and store them in the 'globalConceptUUIDs' variable
        result = await this.forEachContext(contexts, actionArguments, async (context, options) => {
            return await doSelect(context, options, optionsWithArguments);
        });

        // Add the global variable to all contexts
        result = await this.forEachContext(contexts, actionArguments, async (context, options) => {
            let resultName = Action.defaultVariableName(self);

            if (options.as != null) {
                resultName = options.as;
            }

            const uniqueGlobalConceptUUIDs = [...new Set(globalConceptUUIDs)]

            Action.setVariable(context, resultName, uniqueGlobalConceptUUIDs);

            return context;
        });

        return result;
    }
}

Action.registerPrimitiveAction('find', FindAction);
window.FindAction = FindAction;
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="WindowTools" id="WindowTools"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Varv extension that adds actions and triggers related to the window and viewport sizes.",
    "dependencies": [],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Window Resize Trigger">class WindowResizeTrigger extends Trigger {
    constructor(name, options, concept, type) {
        super(name, options, concept);
        this.type = type;
    }

    enable() {
        const self = this;

        this.deleteTrigger = Trigger.registerTriggerEvent('windowResized', async (contexts) => {
            await Trigger.trigger(self.name, contexts);
        });
    }

    disable() {
        if (this.deleteTrigger != null) {
            this.deleteTrigger.delete();
        }
    }

    static trigger(width, height) {
        let context = {
            variables: {
                windowWidth: width,
                windowHeight: height
            },
            target: null,
            properties: null
        }
        Trigger.trigger('windowResized', context);
    }
}

Trigger.registerTrigger('windowResized', WindowResizeTrigger);
window.WindowResizeTrigger = WindowResizeTrigger;



window.addEventListener('resize', (event) => {
    WindowResizeTrigger.trigger(event.target.innerWidth, event.target.innerHeight);
});
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Element Size Action" auto>class ElementRectAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            let element = document.body;

            if (options.element) {
                const customElement = document.querySelector(options.element);

                if (customElement) {
                    element = customElement;
                } else {
                    console.warn(`Could not find the element "${options.element}", using "document.body".`);
                }
            }

            const rect = element.getBoundingClientRect();

            Action.setVariable(context, 'elementLeft', rect.x);
            Action.setVariable(context, 'elementTop', rect.y);
            Action.setVariable(context, 'elementWidth', rect.width);
            Action.setVariable(context, 'elementHeight', rect.height);

            return context;
        });
    }
}

Action.registerPrimitiveAction('elementRect', ElementRectAction);
window.ElementRectAction = ElementRectAction;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Cursor Position Action" auto>let x, y;

class CursorPositionAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {

            Action.setVariable(context, 'x', x);
            Action.setVariable(context, 'y', y);

            return context;
        });
    }
}

Action.registerPrimitiveAction('cursorPosition', CursorPositionAction);
window.CursorPositionAction = CursorPositionAction;



document.addEventListener('mousemove', (event) => {
    x = event.clientX;
    y = event.clientY;
});
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" auto name="Modifier Keys Action">let ctrl = false;
let alt = false;
let shift = false;



class ModifierKeysAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {

            Action.setVariable(context, 'ctrl', ctrl);
            Action.setVariable(context, 'alt', alt);
            Action.setVariable(context, 'shift', shift);

            return context;
        });
    }
}

Action.registerPrimitiveAction('modifierKeys', ModifierKeysAction);
window.ModifierKeysAction = ModifierKeysAction;



class ModifierKeysChangeTrigger extends Trigger {
    constructor(name, options, concept, type) {
        super(name, options, concept);
        this.type = type;
    }

    enable() {
        const self = this;

        this.deleteTrigger = Trigger.registerTriggerEvent('modifierKeysChange', async (contexts) => {
            await Trigger.trigger(self.name, contexts);
        });
    }

    disable() {
        if (this.deleteTrigger != null) {
            this.deleteTrigger.delete();
        }
    }

    static trigger(ctrl, alt, shift) {
        let context = {
            variables: {
                ctrl: ctrl,
                alt: alt,
                shift: shift
            },
            target: null,
            properties: null
        }
        Trigger.trigger('modifierKeysChange', context);
    }
}

Trigger.registerTrigger('modifierKeysChange', ModifierKeysChangeTrigger);
window.ModifierKeysChangeTrigger = ModifierKeysChangeTrigger;



document.addEventListener('keydown', (event) => {
    updateModifierKey(event);
});
document.addEventListener('keyup', (event) => {
    updateModifierKey(event);
});

const updateModifierKey = (event) => {
    const oldCtrl = ctrl;
    const oldAlt = alt;
    const oldShift = shift;

    ctrl = event.ctrlKey || event.metaKey;
    alt = event.altKey;
    shift = event.shiftKey;

    if ((oldCtrl != ctrl) || (oldAlt != alt) || (oldShift != shift)) {
        ModifierKeysChangeTrigger.trigger(ctrl, alt, shift);
    }
};
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="TimeTools" id="TimeTools"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Varv extension that adds two time-related actions.",
    "dependencies": [],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Time Epoch Action" auto>class TimeEpochAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            const epoch = Date.now();

            let resultName = Action.defaultVariableName(self);
            if (options.as != null) {
                resultName = options.as;
            }

            Action.setVariable(context, resultName, epoch);

            return context;
        });
    }
}

Action.registerPrimitiveAction('timeEpoch', TimeEpochAction);
window.TimeEpochAction = TimeEpochAction;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" auto name="Epoch To Human Readable Action">class EpochToTimeAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            let epoch = Date.now();
            if (options.epoch != null) {
                epoch = new Date(options.epoch);
            }

            const timeString = epoch.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });

            let resultName = Action.defaultVariableName(self);
            if (options.as != null) {
                resultName = options.as;
            }

            Action.setVariable(context, resultName, timeString);

            return context;
        });
    }
}

Action.registerPrimitiveAction('epochToTime', EpochToTimeAction);
window.EpochToTimeAction = EpochToTimeAction;



class EpochToDateAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            let epoch = Date.now();
            if (options.epoch != null) {
                epoch = new Date(options.epoch);
            }

            const dateString = epoch.toLocaleDateString('de-DE', { month: '2-digit', day: '2-digit', year: 'numeric' });

            let resultName = Action.defaultVariableName(self);
            if (options.as != null) {
                resultName = options.as;
            }

            Action.setVariable(context, resultName, dateString);

            return context;
        });
    }
}

Action.registerPrimitiveAction('epochToDate', EpochToDateAction);
window.EpochToDateAction = EpochToDateAction;
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="RandomColorAction" name="RandomColorAction"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Varv extension that adds an action that creates random colors for avatars.",
    "dependencies": [],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Random Color Action" auto>// Adapted from: https://helderesteves.com/generating-random-colors-in-js-dark-light-colors/

const generateDarkColorHex = () => {
    let color = '#';
    for (let i = 0; i &lt; 3; i++) {
        color += ('0' + Math.floor(Math.random() * Math.pow(16, 2) / 2).toString(16)).slice(-2);
    }
    return color;
};

class RandomColorAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }

    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            const color = generateDarkColorHex();

            let resultName = Action.defaultVariableName(self);
            if (options.as != null) {
                resultName = options.as;
            }

            Action.setVariable(context, resultName, color);

            return context;
        });
    }
}

Action.registerPrimitiveAction('randomColor', RandomColorAction);
window.RandomColorAction = RandomColorAction;
</CODE-FRAGMENT></WPM-PACKAGE></DIV><DIV name="Mirrorverse"><WPM-PACKAGE id="Meeting" name="Meeting"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The main meeting concept.",
    "dependencies": [
        "#WindowTools"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Meeting Concepts" auto>{
    "dataStores": {
        "location": {
            "type":"location"
        }
    },
    "concepts": {
        "meeting": {
            "schema": {
                "rootRoom": "roomElement",
                "fullscreenRoom": "roomElement",
                "inRoot": { "boolean": {
                    "derive": {
                        "properties": [ "rootRoom", "fullscreenRoom" ],
                        "transform": [
                            { "get": "rootRoom" },
                            { "eval": {
                                "property": "fullscreenRoom",
                                "equals": "$get"
                            }}
                        ]
                    }
                }},
                "contentType": { "string": { "default": "cameraContent" }},
                "toolType": { "string": { "default": "gridTool" }},
                "modifierCtrl": "boolean",
                "modifierAlt": "boolean",
                "modifierShift": "boolean",
                "layoutMode": { "boolean": {
                    "derive": {
                        "properties": [ "modifierShift" ],
                        "transform": [
                            { "eval": {
                                "property": "modifierShift",
                                "equals": true
                            }}
                        ]
                    }
                }},
                "selectedElement": "element"
            },
            "mappings": {
                "fullscreenRoom": [ "localStorage", "cauldron" ],
                "contentType": [ "localStorage", "cauldron" ],
                "toolType": [ "localStorage", "cauldron" ],
                "modifierCtrl": [ "memory", "cauldron" ],
                "modifierAlt": [ "memory", "cauldron" ],
                "modifierShift": [ "memory", "cauldron" ],
                "layoutMode": [ "memory", "cauldron" ],
                "selectedElement": [ "memory", "cauldron" ]
            },
            "actions": {
                "checkIsfullscreenRoom": [
                    { "get": {
                        "property": "meeting.fullscreenRoom",
                        "as": "fullscreenRoom"
                    }},
                    { "where": {
                        "variable": "target",
                        "equals": "$fullscreenRoom",
                        "stopIfEmpty": true
                    }}
                ],
                "checkInfullscreenRoom": [
                    { "get": {
                        "property": "meeting.fullscreenRoom",
                        "as": "fullscreenRoom"
                    }},
                    { "where": {
                        "property": "parentRoom",
                        "equals": "$fullscreenRoom",
                        "stopIfEmpty": true
                    }}
                ],
                "selectfullscreenRoom": [
                    { "get": "meeting.fullscreenRoom" },
                    { "select": {
                        "target": "$get",
                        "stopIfEmpty": true
                    }}
                ],
                "addRoom": {
                    "when": { "click": { "view": "addRoomButton" }},
                    "then": [
                        { "set": { "variable": "type", "value": "regularRoom"}},
                        "addElement"
                    ]
                },
                "addContent": {
                    "when": { "click": { "view": "addContentButton" }},
                    "then": [
                        { "get": { "property": "meeting.contentType", "as": "type" }},
                        "addElement"
                    ]
                },
                "addTool": {
                    "when": { "click": { "view": "addToolButton" }},
                    "then": [
                        { "get": { "property": "meeting.toolType", "as": "type" }},
                        "addElement"
                    ]
                },
                "addElement": [
                    { "run": "deselectElements" },
                    { "get": { "property": "meeting.fullscreenRoom", "as": "parent" }},
                    { "new": {
                        "concept": "$type",
                        "with": {
                            "parentRoom": "$parent"
                        }
                    }}
                ],
                "enterBreadCrumb": {
                    "when": { "click": { "view": "enterBreadcrumbButton" }},
                    "then": [
                        { "set": { "meeting.fullscreenRoom": "$target" }},
                        { "run": "deselectElements" }
                    ]
                },
                "enterRoom": {
                    "when": { "click": { "view": "enterRoomButton" }},
                    "then": [
                        { "select": {
                            "concept": "roomElement",
                            "where": {
                                "property": "selected",
                                "equals": true
                            },
                            "stopIfEmpty": true
                        }},
                        { "limit": 1 },
                        { "set": { "meeting.fullscreenRoom": "$target" }},
                        { "run": "deselectElements" }
                    ]
                },
                "exitRoom": {
                    "when": [
                        { "click": { "view": "exitRoomButton" }}
                    ],
                    "then": [
                        "selectfullscreenRoom",
                        "selectparentRoom",
                        { "set": { "meeting.fullscreenRoom": "$target" }},
                        { "run": "deselectElements" }
                    ]
                },
                "gotoHomeRoom": {
                    "when": [
                        { "click": { "view": "homeButton" }}
                    ],
                    "then": [
                        { "get": "meeting.rootRoom" },
                        { "set": { "meeting.fullscreenRoom": "$get" }},
                        { "run": "deselectElements" }
                    ]
                },
                "checkCtrl": [
                    "modifierKeys",
                    { "where": {
                        "variable": "ctrl",
                        "equals": true,
                        "stopIfEmpty": true
                    }}
                ],
                "checkAlt": [
                    "modifierKeys",
                    { "where": {
                        "variable": "alt",
                        "equals": true,
                        "stopIfEmpty": true
                    }}
                ],
                "checkShift": [
                    "modifierKeys",
                    { "where": {
                        "variable": "shift",
                        "equals": true,
                        "stopIfEmpty": true
                    }}
                ],
                "checkNotCtrl": [
                    "modifierKeys",
                    { "where": {
                        "variable": "ctrl",
                        "equals": false,
                        "stopIfEmpty": true
                    }}
                ],
                "checkNotAlt": [
                    "modifierKeys",
                    { "where": {
                        "variable": "alt",
                        "equals": false,
                        "stopIfEmpty": true
                    }}
                ],
                "checkNotShift": [
                    "modifierKeys",
                    { "where": {
                        "variable": "shift",
                        "equals": false,
                        "stopIfEmpty": true
                    }}
                ],
                "checkInLayoutMode": [
                    { "get": "meeting.layoutMode" },
                    { "where": {
                        "variable": "get",
                        "equals": true,
                        "stopIfEmpty": true
                    }}
                ],
                "checkNotInLayoutMode": [
                    { "get": "meeting.layoutMode" },
                    { "where": {
                        "variable": "get",
                        "equals": false,
                        "stopIfEmpty": true
                    }}
                ],
                "updateModifierProperties": {
                    "when": [ "modifierKeysChange" ],
                    "then": [
                        { "set": { "meeting.modifierCtrl": "$ctrl" }},
                        { "set": { "meeting.modifierAlt": "$alt" }},
                        { "set": { "meeting.modifierShift": "$shift" }}
                    ]
                },
                "correctCursorPosition": [
                    { "elementRect": { "element": "varv-view > .meeting > .content" }},
                    { "set": {
                        "variable": "x",
                        "value": { "calculate": "$x$ - $elementLeft$" }
                    }},
                    { "set": {
                        "variable": "y",
                        "value": { "calculate": "$y$ - $elementTop$" }
                    }}
                ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="Meeting Template" auto>&lt;dom-view-template>
    &lt;div class="meeting" concept="meeting" data-modifier-ctrl="{modifierCtrl}" data-modifier-alt="{modifierAlt}" data-modifier-shift="{modifierShift}" data-layout-mode="{layoutMode}" data-videostrates="{videostrates}">
        &lt;div class="header">
            &lt;div class="header-content" if="fullscreenRoom">
                &lt;h1 class="mirrorverse">MIRRORVERSE&lt;/h1>
                &lt;div class="flex-spacer">&lt;/div>
                &lt;button view="addRoomButton">Add Room&lt;/button>
                &lt;div class="spacer">&lt;/div>
                &lt;label>
                    Content:
                    &lt;select value="{contentType}">
                        &lt;option value="cameraContent">Camera&lt;/option>
                        &lt;option value="screenContent">Screen Capture&lt;/option>
                        &lt;option value="videoContent">Video&lt;/option>
                        &lt;option value="imageContent">Image&lt;/option>
                        &lt;option value="noteContent">Note&lt;/option>
                        &lt;option value="sketchContent">Sketch&lt;/option>
                        &lt;option value="chatContent">Chat&lt;/option>
                        &lt;option value="avatarContent">Avatar&lt;/option>
                    &lt;/select>
                &lt;/label>
                &lt;button view="addContentButton">Add Content&lt;/button>
                &lt;div class="spacer">&lt;/div>
                &lt;label>
                    Tool:
                    &lt;select value="{toolType}">
                        &lt;option value="gridTool">Grid Layout&lt;/option>
                        &lt;option value="speakerViewTool">Speaker View Layout&lt;/option>
                        &lt;option value="layoutTemplateTool">Layout Template&lt;/option>
                        &lt;option value="highlightTool">Highlight&lt;/option>
                        &lt;option value="cameraShakerTool">Camera Shaker&lt;/option>
                        &lt;option value="recordingTool">Recording&lt;/option>
                        &lt;option value="roomRecordingTool">Room Recording&lt;/option>
                        &lt;option value="doorwayTool">Doorway&lt;/option>
                        &lt;option value="proximityBasedAudioTool">Proximity-based Audio&lt;/option>
                        &lt;option value="podiumTool">Podium&lt;/option>
                        &lt;option value="whisperTool">Whisper&lt;/option>
                        &lt;option value="broadcastTool">Broadcast&lt;/option>
                        &lt;option value="templateStoreTool">Template Store&lt;/option>
                    &lt;/select>
                &lt;/label>
                &lt;button view="addToolButton">Add Tool&lt;/button>
                &lt;div class="flex-spacer">&lt;/div>
                &lt;!-- &lt;label concept="audioManager" class="audio-routing-toggle">
                    Pause Audio Routing:
                    &lt;input value="{pauseAudioRouting}" type="checkbox">
                &lt;/label> -->
                &lt;div class="edit-button-spacer">&lt;/div>
            &lt;/div>
        &lt;/div>
        &lt;div class="panel-group">
            &lt;div class="panel tool-panel">
                &lt;div class="headline">Tool Panel&lt;/div>
                &lt;div property="fullscreenRoom" class="panel-inner">
                    &lt;template-ref template-name="element" property="childElements" if="inToolPanel">&lt;/template-ref>
                &lt;/div>
            &lt;/div>
        &lt;/div>
        &lt;div class="content" property="fullscreenRoom">
            &lt;div class="fullscreen-background" view="fullscreen-background">&lt;/div>
            &lt;template-ref template-name="element" property="childElements" if="!inToolPanel">&lt;/template-ref>
            &lt;div class="room-title">
                &lt;span class="breadcrumb-parent" property="parentRoom" view="enterBreadcrumbButton">
                    &lt;span class="breadcrumb-parent" property="parentRoom" view="enterBreadcrumbButton">
                        &lt;span class="breadcrumb-parent" property="parentRoom" view="enterBreadcrumbButton">
                            ... ›
                        &lt;/span>
                        {name} ›
                    &lt;/span>
                    {name} ›
                &lt;/span>
                {name}
            &lt;/div>
            &lt;div class="client-overview" title="Clients in this Room" if="clients">
                &lt;div class="client-thumbnail" property="clients" style="background: {color}">
                    &lt;span property="user" title="{user.name}: {client.name}">{name}&lt;/span>: {name}
                &lt;/div>
            &lt;/div>
        &lt;/div>
        &lt;div class="content" if="!fullscreenRoom">
            &lt;button class="welcome-button green" view="homeButton">Enter the Main Room&lt;/button>
        &lt;/div>
        &lt;div class="panel-group">
            &lt;div class="panel navigation-panel" if="fullscreenRoom">
                &lt;div class="headline">Navigation&lt;/div>
                &lt;div class="panel-inner" if="!inRoot">
                    &lt;button view="homeButton">Home&lt;/button>
                    &lt;button view="exitRoomButton">Exit Room&lt;/button>
                &lt;/div>
                &lt;div class="panel-inner" property="selectedElement">
                    &lt;div class="spacer" if="!inRoot" style="margin-top: -2px;">&lt;/div>
                    &lt;button view="enterRoomButton" if="isRoom">Enter Room&lt;/button>
                    &lt;button view="moveElementOutButton" if="!inRoot">Move Element Out of Room&lt;/button>
                &lt;/div>
            &lt;/div>
            &lt;div class="panel room-options-panel">
                &lt;div class="headline">Room Inspector&lt;/div>
                &lt;div class="panel-inner">
                    &lt;label property="fullscreenRoom">
                        Name:
                        &lt;input value="{name}">
                    &lt;/label>
                    &lt;label property="fullscreenRoom">
                        Audio Filter:
                        &lt;input value="{audioFilter}">
                    &lt;/label>
                &lt;/div>
            &lt;/div>
            &lt;div class="panel object-options-panel">
                &lt;div class="headline">Element Inspector&lt;/div>
                &lt;div class="panel-inner" property="selectedElement">
                    &lt;template-ref template-name="{elementType}Options">&lt;/template-ref>
                &lt;/div>
            &lt;/div>
        &lt;/div>
        &lt;div class="sidebar">
            &lt;div class="sidebar-content" if="fullscreenRoom">
                &lt;template-ref template-name="clientPanel" concept="userManager">&lt;/template-ref>
            &lt;/div>
        &lt;/div>
        &lt;template-ref template-name="audioStreams">&lt;/template-ref>
    &lt;/div>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/css" name="Roboto Font" auto>@import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,500;0,700;0,900;1,400;1,500;1,700;1,900&display=swap');

body,
body button,
body input,
body select,
body textarea {
    font-family: Roboto, Arial, sans-serif;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Meeting Style" auto>@mixin heading-font {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}



.m-ico {
    font-family: "Material Icons";
    font-weight: normal;
    font-style: normal;
    line-height: 1;
    letter-spacing: normal;
    text-transform: none;
    display: inline-block;
    white-space: nowrap;
    word-wrap: normal;
    direction: ltr;
    vertical-align: middle;
}



body {
    margin: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #313131;

    button {
        @include heading-font;

        user-select: none;
        border-radius: 4px;
        padding: 0 8px;
        background: #636363;
        color: #fff;
        vertical-align: middle;
        text-align: center;
        cursor: pointer;
        border: none;

        &:hover {
            background: #848484;
        }

        &.red {
            background: #d32f2f !important;

            &:hover {
                background: #ff6659 !important;
            }

            &:active {
                background: #9a0007 !important;
            }
        }

        &.green {
            background: #2e7d32 !important;

            &:hover {
                background: #60ad5e !important;
            }

            &:active {
                background: #005005 !important;
            }
        }
    }

    label {
        @include heading-font;

        user-select: none;
        white-space: nowrap;

        background: #eeeeee;
        color: #000000;

        border-radius: 4px;
        padding-left: 8px;
        padding-right: 8px;
        padding-right: 0;

        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        align-items: center;
        gap: 4px;

        input[type="checkbox"] {
            width: 24px;
        }

        input:not([type="checkbox"]),
        select {
            border-top-left-radius: 16px;
            border-bottom-left-radius: 16px;
            height: 100%;
        }
    }

    input:not([type="checkbox"]),
    select,
    textarea {
        border-radius: 4px;
        border: none;
        padding: 0 8px;
        text-overflow: ellipsis;
        outline: none;
        color: #000;
        width: 100%;
    }
}

.meeting {
    position: absolute;
    top: 64px;
    left: 16px;
    right: 96px;
    bottom: 0;
    overflow: auto;
    background: #313131;

    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    align-items: center;
    justify-content: center;
    gap: 16px;

    &[data-layout-mode="true"] {
        user-select: none;
    }

    &::-webkit-scrollbar {
        width: 8px;
        height: 8px;
    }

    /* Track */
    &::-webkit-scrollbar-track,
    &::-webkit-scrollbar-corner {
        background: none;
    }

    /* Handle */
    &::-webkit-scrollbar-thumb {
        background: #636363;
        border-radius: 4px;
    }

    /* Handle on hover */
    &::-webkit-scrollbar-thumb:hover {
        background: #848484;
    }
}

// Fix for problem of cut-off elements when leaving it centered
@media screen and (max-width: 1675px) {
    .meeting {
        justify-content: flex-start;
    }
}

@media screen and (max-height: 1096px) {
    .meeting {
        align-items: flex-start;
    }
}

// Absolute Content
.content {
    position: relative;
    flex: 0 0 auto;
    background: #424242;
    box-shadow: inset 0px 0px 8px 0px #333333;
    width: 1280px;
    height: 960px;
    overflow: hidden;
    border-radius: 20px;

    .welcome-button {
        position: absolute;
        width: 256px;
        height: 48px;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
    }

    >.room-title {
        @include heading-font;

        position: absolute;
        top: 0px;
        left: 0px;
        height: 32px;

        background: #313131;
        box-shadow: 0px 0px 8px 0px #333333;
        color: #CCCCCC;

        border-bottom-right-radius: 12px;
        border-top-left-radius: 8px;

        line-height: 32px;
        font-size: 14px;
        letter-spacing: 1px;
        padding: 3px 8px;
        user-select: none;
        z-index: 1000;

        &:empty {
            display: none;
        }

        .breadcrumb-parent {
            opacity: 0.66;
            cursor: pointer;
        }
    }

    >.client-overview {
        position: absolute;
        background: #313131;
        box-shadow: 0px 0px 8px 0px #333333;
        border-bottom-left-radius: 12px;
        border-top-right-radius: 8px;
        top: 0px;
        right: 0px;
        height: 30px;
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 4px;
        padding: 4px 6px;
        min-width: 30px;
        user-select: none;
        z-index: 1000;

        .client-thumbnail {
            color: #fff;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            overflow: hidden;
            user-select: none;
            font-size: 8px;
            line-height: 20px;
            padding: 4px;
            text-align: center;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
    }
}

.panel-group {
    position: relative;
    flex: 0 0 auto;

    width: 256px;
    height: 960px;

    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
    gap: 16px;
}

.navigation-panel {
    flex: 0 0 auto;
}

.room-options-panel {
    flex: 0 0 auto;
}

.object-options-panel {
    flex: 1 0 auto;
}

.tool-panel {
    flex: 1 0 auto;

    .element {
        position: relative;
        top: initial !important;
        left: initial !important;
        width: initial !important;
        height: initial !important;

        .move-handle,
        .resize-handle {
            display: none;
        }
    }
}

.panel {
    position: relative;
    max-height: calc(100% - 32px);

    background: #424242;
    box-shadow: inset 0px 0px 8px 0px #333333;

    padding: 16px;
    border-radius: 20px;
    color: #fff;

    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
    align-items: stretch;
    gap: 14px;

    .headline {
        @include heading-font;
        text-align: center;
        display: block;
        width: 100%;
        font-size: 14px;
        letter-spacing: 1px;
        color: #CCCCCC;
        height: 24px;
        line-height: 24px;
    }

    .panel-inner {
        display: flex;
        flex: 1 1 auto;
        max-height: 100%;
        overflow: auto;
        padding: 2px;

        flex-direction: column;
        flex-wrap: nowrap;
        align-items: stretch;
        gap: 8px;

        label,
        input,
        select,
        button {
            height: 32px;
        }

        .spacer {
            margin: 4px 0;
            height: 2px;
            border-radius: 2px;
            background: #848484;
        }
    }
}

.header {
    position: fixed;
    background: #212121;
    box-shadow: 0px 0px 4px 0px #212121;
    color: #FFF;
    height: 48px;
    left: 0;
    right: 0;
    z-index: 1000;
}

.header {
    top: 0;
}

.sidebar {
    position: fixed;
    background: hsl(0, 0%, 13%);
    box-shadow: 0px 0px 4px 0px #212121;
    color: #ffffff;
    width: 80px;
    right: 0;
    top: 64px;
    bottom: 16px;
    z-index: 1000;
    border-radius: 20px 0 0 20px;
}

.sidebar-content {
    width: calc(100% - 16px);
    height: calc(100% - 16px);
    margin: 8px;
    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
    gap: 8px;
    align-items: center;
}

.header-content {
    width: calc(100% - 16px);
    height: calc(100% - 16px);
    margin: 8px;
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    gap: 8px;
    align-items: stretch;

    .spacer {
        flex: 0 0 2px;
        border-radius: 2px;
        background-color: #848484;
        margin: 0 16px;
    }

    .flex-spacer {
        flex: 1 1 auto;
    }

    .edit-button-spacer {
        flex: 0 0 48px;
    }
}

.fullscreen-background {
    width: 100%;
    height: 100%;
}

.audio-routing-toggle {
    opacity: 0;
    transition: 250ms ease-in-out opacity;
    transition-delay: 1000ms;

    &:hover {
        opacity: 1;
        transition-delay: 0ms;
    }
}



button#cauldron-edit-button {
    top: 8px !important;
    right: 8px !important;
    height: 32px;
    width: 48px;

    opacity: 0;
    transition: 250ms ease-in-out opacity;
    transition-delay: 1000ms;

    z-index: 10000;

    &:hover {
        opacity: 1;
        transition-delay: 0ms;
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Mirrorverse Title" auto>// Adapted from: https://codepen.io/boldfacedesign/pen/DpXjzY

h1.mirrorverse,
h1.mirrorverse:hover:before {
    letter-spacing: 0.3px;
    font-weight: 900;
    padding: 0 16px;
    font-style: italic;
    font-size: 25px;
    white-space: nowrap;
    -webkit-background-clip: text;
    background-clip: text;
    user-select: none;
}

h1.mirrorverse {
    position: relative;
    background-image: -webkit-linear-gradient(#378DBC 0%, #B6E8F1 46%, #ffffff 50%, #32120E 54%, #FFC488 58%, #582C11 90%, #EC9B4E 100%);
    -webkit-text-fill-color: transparent;
    -webkit-text-stroke: 0.4px #f5f5f5;
    margin: 0;
    line-height: 32px;

    &:hover:before {
        position: absolute;
        content: 'MIRRORVERSE';
        left: 0;
        top: 0;
        z-index: 10;
        background-image: -webkit-linear-gradient(-40deg, transparent 0%, transparent 40%, #fff 50%, transparent 60%, transparent 100%);
        background-position: -150px 0;
        -webkit-text-stroke: 0;
        padding-right: 37.5px;
        -webkit-animation-name: chrome_effect;
        -webkit-animation-duration: 2.5s;
        -webkit-animation-timing-function: linear;
        -webkit-animation-iteration-count: infinite;
        animation-name: chrome_effect;
        animation-duration: 2.5s;
        animation-timing-function: linear;
        animation-iteration-count: infinite;
    }
}

@keyframes chrome_effect {
    0% {
        background-position: -100px 0;
    }

    20% {
        background-position: 100px 0;
    }

    100% {
        background-position: 100px 0;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Users" name="Users"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "User, client, and userManager concepts.",
    "dependencies": [
        "#FindAction",
        "#TimeTools",
        "#RandomColorAction"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Users Concepts" auto>{
    "concepts": {
        "userManager": {
            "schema": {
                "placeholder": "string",
                "loggedIn": "boolean",
                "localUser": { "user": { "default": "conceptd5e030d471d39150d148" }},
                "localRole": { "string":{
                    "derive": {
                        "properties": [ "localUser", "user.role" ],
                        "transform": [
                            { "select": { "property": "localUser" }},
                            { "get": "role" }
                        ]
                    }
                }},
                "localClient": "client",
                "audibleClients": { "array": "client" }
            },
            "mappings": {
                "loggedIn": [ "memory", "cauldron" ],
                "localUser": [ "localStorage", "cauldron" ],
                "localRole": [ "memory", "cauldron" ],
                "localClient": [ "localStorage", "cauldron" ],
                "audibleClients": [ "memory", "cauldron" ]
            },
            "actions": {
                "updateAudibleClients": {
                    "comment": "Optimzation: Run this as an action because the derived property would run once for each audioStream.",
                    "then": [
                        { "select": {
                            "concept": "audioStream",
                            "where": { "and": [
                                { "property": "muted", "equals": false },
                                { "property": "volume", "unequals": 0 }
                            ]}
                        }},
                        { "find": {
                            "concept": "client",
                            "where": {
                                "and": [
                                    { "property": "audioStream", "equals": "$lastTarget" },
                                    { "property": "local", "equals": false }
                                ]
                            }
                        }},
                        { "set": { "userManager.audibleClients": "$find" }}
                    ]
                },
                "addUser": {
                    "when": { "click": { "view": "addUserButton" }},
                    "then": [
                        "random",
                        { "new": {
                            "concept": "user",
                            "with": {
                                "name": "User $random$"
                            }
                        }},
                        { "set": { "userManager.localUser": "$target" }}
                    ]
                },
                "deleteUser": {
                    "when": { "click": { "view": "deleteUserButton" }},
                    "then": [
                        { "get": "userManager.localUser" },
                        { "select": "$get" },
                        "remove"
                    ]
                },
                "login": {
                    "when": { "click": { "view": "loginbutton" }},
                    "then": [
                        { "run": "reconnectClient" },
                        { "run": "newClient" },
                        "updateLocation"
                    ]
                },
                "reconnectClient": [
                    { "select": {
                        "concept": "client",
                        "where": {
                            "property": "local",
                            "equals": true
                        },
                        "as": "localClient",
                        "stopIfEmpty": true
                    }},
                    { "get": "audioStream" },
                    { "select": "$get" },
                    "updateAudioStream",
                    { "select": "$localClient" },
                    { "get": "cameraStream" },
                    { "select": "$get" },
                    "updateCameraStream",
                    { "set": { "userManager.loggedIn": true }}
                ],
                "newClient": [
                    { "exists": {
                        "concept": "client",
                        "where": {
                            "property": "local",
                            "equals": true
                        }
                    }},
                    { "where": {
                        "variable": "exists",
                        "equals": false,
                        "stopIfEmpty": true
                    }},
                    "newAudioStream",
                    "newCameraStream",
                    "randomColor",
                    { "get": "userManager.localUser" },
                    { "new": {
                        "concept": "client",
                        "with": {
                            "audioStream": "$newAudioStream",
                            "cameraStream": "$newCameraStream",
                            "color": "$randomColor",
                            "user": "$get"
                        },
                        "as": "newClient"
                    }},
                    { "select": "$newAudioStream" },
                    { "set": { "client": "$newClient" }},
                    { "select": "$newCameraStream" },
                    { "set": { "client": "$newClient" }},
                    { "set": { "userManager.loggedIn": true }},
                    { "set": { "userManager.localClient": "$newClient" }}
                ]
            }
        },
        "user": {
            "schema": {
                "name": "string",
                "role": { "string": { "default": "User" }},
                "local": { "boolean": {
                    "derive": {
                        "properties": [ "userManager.localUser" ],
                        "transform": [
                            { "eval": {
                                "property": "userManager.localUser",
                                "equals": "$target"
                            }}
                        ]
                    }
                }}
            },
            "mappings": {
                "local": [ "memory", "cauldron" ]
            }
        },
        "client": {
            "schema": {
                "name": { "string": { "default": "Client" }},
                "user": "user",
                "color": "string",
                "local": { "boolean": {
                    "derive": {
                        "properties": [ "userManager.localClient" ],
                        "transform": [
                            { "eval": {
                                "property": "userManager.localClient",
                                "equals": "$target"
                            }}
                        ]
                    }
                }},
                "location": "roomElement",
                "cameraStream": "cameraStream",
                "audioStream": "audioStream",
                "muted": "boolean",
                "logicalVolume": "number",
                "logicalDistance": "number",
                "distance": { "number": { "default": 10000 }},
                "lastSeen": "number",
                "timeout": "number",
                "clientTimedOut": { "boolean": {
                    "derive": {
                        "properties": [ "timeout" ],
                        "transform": [
                            { "eval": {
                                "and": [
                                    { "property": "timeout", "greaterThan": 60000 },
                                    { "property": "mockupClient", "equals": false }
                                ]
                            }}
                        ]
                    }
                }},
                "mockupClient": "boolean",
                "analyserVolume": "number",
                "analyserVolumeString": { "string": {
                    "derive": {
                        "properties": [ "analyserVolume" ],
                        "transform": [
                            { "switch": [
                                {
                                    "where": {
                                        "property": "analyserVolume",
                                        "equals": 0
                                    },
                                    "then": [
                                        { "set": {
                                            "variable": "result",
                                            "value": "silent"
                                        }}
                                    ]
                                },
                                {
                                    "where": {
                                        "property": "analyserVolume",
                                        "greaterThan": 50
                                    },
                                    "then": [
                                        { "set": {
                                            "variable": "result",
                                            "value": "loud"
                                        }}
                                    ]
                                },
                                {
                                    "where": {
                                        "property": "analyserVolume",
                                        "greaterThan": 25
                                    },
                                    "then": [
                                        { "set": {
                                            "variable": "result",
                                            "value": "medium"
                                        }}
                                    ]
                                },
                                {
                                    "then": [
                                        { "set": {
                                            "variable": "result",
                                            "value": "quiet"
                                        }}
                                    ]
                                }
                            ]},
                            { "concat": [ "$result" ]}
                        ]
                    }
                }}
            },
            "mappings": {
                "local": [ "memory", "cauldron" ],
                "logicalDistance": [ "memory", "cauldron" ],
                "distance": [ "memory", "cauldron" ],
                "timeout": [ "memory", "cauldron" ],
                "clientTimedOut": [ "memory", "cauldron" ],
                "analyserVolume": [ "memory", "cauldron" ],
                "analyserVolumeString": [ "memory", "cauldron" ]
            },
            "actions": {
                "selectLocalClient": [
                    { "select": {
                        "concept": "client",
                        "where": {
                            "property": "local",
                            "equals": true
                        },
                        "stopIfEmpty": true
                    }}
                ],
                "updateClientUser": {
                    "when": { "stateChanged": {
                        "concept": "userManager",
                        "property": "localUser"
                    }},
                    "then": [
                        "selectLocalClient",
                        { "set": { "user": "$currentValue" }}
                    ]
                },
                "updateLocation": {
                    "when": { "stateChanged": {
                        "concept": "meeting",
                        "property": "fullscreenRoom"
                    }},
                    "then": [
                        "selectLocalClient",
                        { "get": "meeting.fullscreenRoom" },
                        { "set": { "location": "$get" }}
                    ]
                },
                "updateLogicalDistance": {
                    "when": [
                        { "stateChanged": {
                            "concept": "client",
                            "property": "location"
                        }},
                        { "stateChanged": {
                            "concept": "userManager",
                            "property": "loggedIn"
                        }}
                    ],
                    "then": [
                        { "run": "resetTraversed" },
                        { "set": {
                            "variable": "distance",
                            "value": 0
                        }},
                        "selectfullscreenRoom",
                        "nextRecursionStep"
                    ]
                },
                "resetTraversed": [
                    { "select": "roomElement" },
                    { "set": { "traversed": false }}
                ],
                "nextRecursionStep": [
                    { "set": { "traversed": true }},
                    { "run": "setDistanceToClients" },
                    { "run": "recurseLogicalDistanceParent" },
                    { "run": "recurseLogicalDistanceChildren" }
                ],
                "setDistanceToClients": [
                    { "select": {
                        "concept": "client",
                        "where": {
                            "property": "location",
                            "equals": "$lastTarget"
                        },
                        "forEach": true,
                        "stopIfEmpty": true
                    }},
                    { "set": { "logicalDistance": "$distance" }}
                ],
                "recurseLogicalDistanceParent": [
                    { "select": {
                        "concept": "roomElement",
                        "where": {
                            "and": [
                                { "property": "childElements", "includes": "$lastTarget" },
                                { "property": "traversed", "equals": false }
                            ]
                        },
                        "forEach": true,
                        "stopIfEmpty": true
                    }},
                    { "increment": { "variable": "distance" }},
                    "nextRecursionStep"
                ],
                "recurseLogicalDistanceChildren": [
                    { "select": {
                        "concept": "roomElement",
                        "where": {
                            "and": [
                                { "property": "parentRoom", "equals": "$lastTarget" },
                                { "property": "traversed", "equals": false }
                            ]
                        },
                        "forEach": true,
                        "stopIfEmpty": true
                    }},
                    { "increment": { "variable": "distance" }},
                    "nextRecursionStep"
                ],
                "updateLastSeenAndTimeout": {
                    "when": { "interval": 60000 },
                    "then": [
                        { "run": "updateClientLastSeen" },
                        { "run": "updateClientTimeout" }
                    ]
                },
                "updateClientLastSeen": [
                    "selectLocalClient",
                    "timeEpoch",
                    { "set": { "lastSeen": "$timeEpoch" }}
                ],
                "updateClientTimeout": [
                    { "select": "client" },
                    { "get": "lastSeen" },
                    "timeEpoch",
                    { "calculate": "$timeEpoch$ - $get$" },
                    { "set": { "timeout": "$calculate" }}
                ],
                "removeClient": {
                    "when": { "click": "removeClientButton" },
                    "then": [
                        { "get": {
                            "property": "cameraStream",
                            "as": "cameraStream"
                        }},
                        { "get": {
                            "property": "audioStream",
                            "as": "audioStream"
                        }},
                        "remove",
                        { "select": "$cameraStream" },
                        "remove",
                        { "select": "$audioStream" },
                        "remove"
                    ]
                },
                "gotoClient": {
                    "when": { "click": { "view": "gotoOverlayButton" }},
                    "then": [
                        { "set": { "meeting.fullscreenRoom": "$target" }}
                    ]
                }
            }
        },
        "roomElement": {
            "schema": {
                "traversed": "boolean"
            },
            "mappings": {
                "traversed": [ "memory" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="Users Template" auto>&lt;dom-view-template>
    &lt;varv-template name="clientPanel">
        &lt;button class="login-button green" view="loginbutton" if="!loggedIn">Login&lt;/button>

        &lt;div class="sidebar-bubble" if="loggedIn">
            &lt;div class="sidebar-bubble-title">User&lt;/div>
            &lt;select value="{localUser}" title="Select a User">
                &lt;option concept="user" value="{concept::uuid}">{name}&lt;/option>
            &lt;/select>
            &lt;input property="localUser" value="{name}" title="Rename User">
            &lt;input property="localUser" value="{role}" title="Change Role">
            &lt;button view="addUserButton" class="sidebar-bubble-button" title="Add User">
                &lt;span class="m-ico">person_add&lt;/span>
            &lt;/button>
            &lt;button view="deleteUserButton" class="sidebar-bubble-button red" title="Delete User">
                &lt;span class="m-ico">person_remove&lt;/span>
            &lt;/button>
        &lt;/div>

        &lt;div class="sidebar-bubble" property="localClient" if="loggedIn">
            &lt;div class="sidebar-bubble-title" title="Your Current Client">Client&lt;/div>
            &lt;input value="{name}" title="Rename Client">
            &lt;label class="mute-button sidebar-bubble-button" title="Mute/Unmute Client">
                &lt;input type="checkbox" value="{muted}">
                &lt;span class="m-ico" if="muted">volume_off&lt;/span>
                &lt;span class="m-ico" if="!muted">volume_up&lt;/span>
            &lt;/label>
            &lt;template-ref template-name="clientChip">&lt;/template-ref>
        &lt;/div>

        &lt;div class="sidebar-bubble" if="loggedIn">
            &lt;div class="sidebar-bubble-title" title="Clients that You Can Hear">Audible&lt;/div>
            &lt;template-ref template-name="clientChip" property="audibleClients">&lt;/template-ref>
        &lt;/div>

        &lt;div class="sidebar-bubble" if="loggedIn">
            &lt;div class="sidebar-bubble-title" title="All Clients">All&lt;/div>
            &lt;template-ref template-name="clientChipLocation" concept="client" if="!local">&lt;/template-ref>
        &lt;/div>
    &lt;/varv-template>

    &lt;varv-template name="clientChip">
        &lt;div class="client" data-client-timed-out="{clientTimedOut}" style="background: {color}" data-client-analyser-volume="{analyserVolumeString}">
            &lt;div class="name" title="Client: {name}">&lt;span class="userName" property="user" title="User: {name}">{name}&lt;/span>: {name}&lt;/div>
            &lt;div class="audio-overlay m-ico" if="!muted">volume_up&lt;/div>
            &lt;div class="audio-overlay m-ico" if="muted">volume_off&lt;/div>
            &lt;button class="remove-overlay m-ico red" view="removeClientButton" if="clientTimedOut" title="Remove Client">delete&lt;/button>
        &lt;/div>
    &lt;/varv-template>

    &lt;varv-template name="clientChipLocation">
        &lt;div class="client" data-client-timed-out="{clientTimedOut}" style="background: {color}" if="!mockupClient">
            &lt;div class="name" title="Client: {name}">&lt;span class="userName" property="user" title="User: {name}">{name}&lt;/span>: {name}&lt;/div>
            &lt;div class="goto-overlay" property="location" view="gotoOverlayButton" title="Go to room “{name}”">{name}&lt;/div>
        &lt;/div>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Users Styles" auto>@mixin heading-font {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}



button.login-button {
    width: 100%;
    border-radius: 12px;
    padding: 12px 8px;
    font-size: 12px;
    letter-spacing: 1px;
}

.sidebar-bubble {
    width: calc(100% - 16px);
    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
    gap: 8px;
    align-items: center;
    background: #424242;
    border-radius: 12px;
    padding: 8px;
    overflow-x: hidden;
    overflow-y: scroll;

    &::-webkit-scrollbar {
        display: none;
    }

    .sidebar-bubble-title {
        @include heading-font;

        padding-top: 4px;
        padding-bottom: 4px;
        user-select: none;
        text-align: center;
    }

    .sidebar-bubble-button {
        font-size: 15px;
        user-select: none;
        width: 100%;
        height: 24px;
        padding: 0 8px;
        line-height: 24px;
        background: #636363;
        color: #fff;
        border-radius: 6px;
        text-align: center;
        cursor: pointer;
        border: none;
        display: block;

        &:hover {
            background: #848484;
        }
    }

    .mute-button {
        width: calc(100% - 16px);
        padding: 0 8px;

        >input {
            display: none;
        }
    }

    >input,
    select {
        width: 100%;
        padding: 4px 0;
        font-size: 10px;
        border-radius: 6px;
    }

    >input:not([type="checkbox"]) {
        width: calc(100% - 8px);
        padding: 4px;
    }

    .client {
        position: relative;
        width: 40px;
        height: 40px;
        background: #607d8b;
        border-radius: 6px;
        font-size: 10px;
        text-align: center;
        line-height: 40px;
        vertical-align: middle;
        user-select: none;
        text-overflow: ellipsis;
        padding: 4px;

        >.name {
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
            height: calc(100% - 4px);
            padding-top: 4px;
            line-height: 16px;

            >.userName {
                white-space: nowrap;
            }
        }

        &[data-client-timed-out="true"] {
            background: #cfd8dc !important;
        }

        .audio-overlay {
            display: block;
            position: absolute;
            background: #263238;
            border-radius: 50%;
            right: -4px;
            bottom: -4px;
            font-size: 10px;
            line-height: 20px;
            text-align: center;
            width: 20px;
            height: 20px;
            z-index: 1000;
            white-space: nowrap;
        }

        .remove-overlay {
            display: block;
            position: absolute;
            background: #ef9a9a;
            border-radius: 50%;
            right: -4px;
            bottom: -4px;
            font-size: 10px;
            line-height: 20px;
            text-align: center;
            width: 20px;
            height: 20px;
            z-index: 1000;
            padding: 0;
            white-space: nowrap;
            cursor: pointer;
        }

        .goto-overlay {
            display: block;
            position: absolute;
            background: #263238;
            border-radius: 10px;
            right: -4px;
            bottom: -4px;
            font-size: 10px;
            line-height: 20px;
            height: 20px;
            z-index: 1000;
            white-space: nowrap;
            padding: 0 6px;
            max-width: calc(100% - 4px);
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }

        &[data-client-analyser-volume="quiet"] {
            outline: solid 2px green;
        }

        &[data-client-analyser-volume="medium"] {
            outline: solid 3px orange;
        }

        &[data-client-analyser-volume="loud"] {
            outline: solid 4px red;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="Streams" id="Streams"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Audio, video, and screen streaming.",
    "dependencies": [
        "#StreamTools"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Streaming Concepts" auto>{
    "concepts": {
        "audioStream": {
            "schema": {
                "id": "string",
                "client": "client",
                "muted": "boolean",
                "volume": { "number": { "default": 1.0 }},
                "audioFilter": { "string": { "default": "none" }}
            },
            "mappings": {
                "muted": [ "memory", "cauldron" ],
                "volume": [ "memory", "cauldron" ],
                "audioFilter": [ "memory", "cauldron" ]
            },
            "actions": {
                "newAudioStream": [
                    "getAudioStream",
                    { "new": {
                        "concept": "audioStream",
                        "with": { "id": "$getAudioStream" },
                        "select": false,
                        "as": "newAudioStream"
                    }}
                ],
                "updateAudioStream": [
                    "getAudioStream",
                    { "set": { "id": "$getAudioStream" }}
                ]
            }
        },
        "cameraStream": {
            "schema": {
                "id": "string",
                "client": "client"
            },
            "actions": {
                "newCameraStream": [
                    "getCameraStream",
                    { "new": {
                        "concept": "cameraStream",
                        "with": { "id": "$getCameraStream" },
                        "select": false,
                        "as": "newCameraStream"
                    }}
                ],
                "updateCameraStream": [
                    "getCameraStream",
                    { "set": { "id": "$getCameraStream" }}
                ]
            }
        },
        "audioManager": {
            "schema": {
                "placeholder": "string",
                "pauseAudioRouting": "boolean"
            },
            "mappings": {
                "pauseAudioRouting": [ "memory", "cauldron" ]
            },
            "actions": {
                "updateAnalyserVolume": {
                    "when": { "interval": 1000 },
                    "then": [
                        { "select": "audioStream" },
                        { "get": {
                            "property": "id",
                            "as": "streamId"
                        }},
                        { "select": {
                            "concept": "client",
                            "where": { "and": [
                                { "property": "audioStream", "equals": "$lastTarget" },
                                { "property": "mockupClient", "equals": false }
                            ]},
                            "forEach": true
                        }},
                        { "volume": { "stream": "$streamId" }},
                        { "set": { "analyserVolume": "$volume" }}
                    ]
                },
                "selectOriginalAudioStream": [
                    { "select": {
                        "target": "$originalAudioStream",
                        "forEach": true
                    }}
                ],
                "selectClient": [
                    { "select": {
                        "target": "$client",
                        "forEach": true
                    }}
                ],
                "selectCurrentRoom": [
                    { "select": {
                        "target": "$currentRoom",
                        "forEach": true
                    }}
                ],
                "selectToolManager": [
                    { "select": {
                        "target": "$toolManager",
                        "forEach": true
                    }}
                ],
                "updateAudio": {
                    "when": { "interval": 1000 },
                    "then": [
                        { "where": {
                            "property": "audioManager.pauseAudioRouting",
                            "equals": false,
                            "stopIfEmpty": true
                        }},
                        { "select": {
                            "concept": "audioStream",
                            "stopIfEmpty": true
                        }},
                        { "set": { "variable": "originalAudioStream", "value": "$target" }},
                        { "get": { "property": "client", "as": "client" }},
                        { "get": { "property": "meeting.fullscreenRoom", "as": "currentRoom" }},
                        { "get": { "property": "meeting.toolManager", "as": "toolManager" }},
                        { "run": "mutedRootConnectionOptimized" },
                        { "run": "volumeRootConnectionOptimized" },
                        { "run": "audioFilterRootConnectionOptimized" },
                        { "run": "updateAudibleClients" }
                    ]
                },
                "mutedRootConnectionOptimized": [
                    { "run": "mutedRootConnection" }
                ],
                "volumeRootConnectionOptimized": [
                    { "where": {
                        "property": "muted",
                        "equals": false,
                        "stopIfEmpty": true
                    }},
                    { "run": "volumeRootConnection" }
                ],
                "audioFilterRootConnectionOptimized": [
                    { "where": {
                        "property": "muted",
                        "equals": false,
                        "stopIfEmpty": true
                    }},
                    { "where": {
                        "property": "volume",
                        "unequals": 0,
                        "stopIfEmpty": true
                    }},
                    "selectClient",
                    { "where": {
                        "property": "mockupClient",
                        "equals": false,
                        "stopIfEmpty": true
                    }},
                    "selectOriginalAudioStream",
                    { "run": "audioFilterRootConnection" }
                ]
            }
        },
        "toolManager": {
            "schema": {
                "placeholder": "string"
            }
        },
        "meeting": {
            "schema": {
                "toolManager": "toolManager"
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="Streaming Template" auto>&lt;dom-view-template>
    &lt;varv-template name="audioStreams">
        &lt;div class="audioStreams" style="display: none;">
            &lt;video concept="audioStream" data-stream="{id}" data-stream-type="audio" data-muted="{muted}" data-volume="{volume}" data-filter="{audioFilter}">&lt;/video>
        &lt;/div>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="Streaming Muted Routing" auto>{
  "rootConnections": {
    "muted": {
      "position": {
        "x": 2791.7000579833984,
        "y": 2800.893732070923
      },
      "connection": "ZmEA2h52Xn"
    }
  },
  "nodes": {
    "cOws1LEgka": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2557.0999603271484,
        "y": 3312.106267929077
      },
      "type": "muted"
    },
    "Sw0B1x9Vm9": {
      "nodeType": "ValueNode",
      "value": false,
      "position": {
        "x": 2760.7000579833984,
        "y": 3315.893732070923
      },
      "type": "muted"
    },
    "rYSeeaKep4": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientInDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 2,
          "connection": "cOws1LEgka"
        },
        {
          "comparator": "lessThan",
          "value": 2,
          "connection": "Sw0B1x9Vm9"
        }
      ],
      "position": {
        "x": 2584.7000579833984,
        "y": 3099.7061824798584
      }
    },
    "4GpHRhnuOX": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2857.9000396728516,
        "y": 3104.7062435150146
      },
      "type": "muted"
    },
    "ZmEA2h52Xn": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientMuted",
      "concept": "client",
      "property": "muted",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "rYSeeaKep4"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "4GpHRhnuOX"
        }
      ],
      "position": {
        "x": 2704.7000579833984,
        "y": 2895.893732070923
      }
    }
  },
  "unused": []
}</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="Streaming Volume Routing" auto>{
  "rootConnections": {
    "volume": {
      "position": {
        "x": 2787.25,
        "y": 2925.5
      },
      "connection": "LgEjFUx25k"
    }
  },
  "nodes": {
    "NJze4UOYlA": {
      "nodeType": "ValueNode",
      "value": 0,
      "position": {
        "x": 2637.25,
        "y": 3279.5
      },
      "type": "volume"
    },
    "S9gcODgW3g": {
      "nodeType": "ValueNode",
      "value": 0.5,
      "position": {
        "x": 2785.25,
        "y": 3278.5
      },
      "type": "volume"
    },
    "2bTYSJ6bNB": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 2931.25,
        "y": 3279.5
      },
      "type": "volume"
    },
    "LgEjFUx25k": {
      "nodeType": "DecisionNode",
      "name": "volumeClientLogicalDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 3,
      "decisions": [
        {
          "comparator": "greaterThan",
          "value": 1,
          "connection": "NJze4UOYlA"
        },
        {
          "comparator": "equals",
          "value": 1,
          "connection": "S9gcODgW3g"
        },
        {
          "comparator": "equals",
          "value": 0,
          "connection": "2bTYSJ6bNB"
        }
      ],
      "position": {
        "x": 2646.25,
        "y": 3042.5
      }
    }
  },
  "unused": []
}</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="Streaming Filter Routing" auto>{
  "rootConnections": {
    "audioFilter": {
      "position": {
        "x": 2680.25,
        "y": 2811.5
      },
      "connection": "1kWhmMpUFO"
    }
  },
  "nodes": {
    "JlMvMkXExA": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2598.25,
        "y": 3164.5
      },
      "type": "audioFilter"
    },
    "FUf0416U07": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2776.25,
        "y": 3402.5
      },
      "type": "audioFilter"
    },
    "rScKXNSFIH": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2948.25,
        "y": 3401.5
      },
      "type": "audioFilter"
    },
    "C5E6P2PNS1": {
      "nodeType": "DecisionNode",
      "name": "filterLocationHasFilter",
      "concept": "currentRoom",
      "property": "audioFilter",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": "",
          "connection": "FUf0416U07"
        },
        {
          "comparator": "unequals",
          "value": "",
          "connection": "rScKXNSFIH"
        }
      ],
      "position": {
        "x": 2763.25,
        "y": 3164.5
      }
    },
    "1kWhmMpUFO": {
      "nodeType": "DecisionNode",
      "name": "filterClientLogicalDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 1,
          "connection": "JlMvMkXExA"
        },
        {
          "comparator": "equals",
          "value": 0,
          "connection": "C5E6P2PNS1"
        }
      ],
      "position": {
        "x": 2596.25,
        "y": 2928.5
      }
    }
  },
  "unused": []
}</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Chat" name="Chat"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Chat funtionality.",
    "dependencies": [
        "#TimeTools"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Chat Concepts" auto>{
    "concepts": {
        "chatManager": {
            "schema": {
                "placeholder": "string"
            },
            "actions": {
                "newChat": [
                    { "new": {
                        "concept": "chat",
                        "select": false,
                        "forEach": true,
                        "as": "newChat"
                    }}
                ],
                "deleteChat": [
                    { "run": "cleanupMessages" },
                    "remove"
                ],
                "cleanupMessages": [
                    { "items": "messages" },
                    { "select": "$items" },
                    "remove"
                ]
            }
        },
        "chat": {
            "schema": {
                "name": { "string": { "default": "New Chat" }},
                "messages": { "array": "message" },
                "newMessageText": "string"
            },
            "mappings": {
                "newMessageText": [ "memory", "cauldron" ]
            },
            "actions": {
                "sendMessage": {
                    "when": [
                        { "click": { "view": "send-message-button" }},
                        { "key": { "key": "Enter", "focus": { "view": "messageInput" }}}
                    ],
                    "then": [
                        { "get": {
                            "property": "userManager.localUser",
                            "as": "localUser"
                        }},
                        { "get": {
                            "property": "newMessageText",
                            "as": "content"
                        }},
                        "timeEpoch",
                        { "new": {
                            "concept": "message",
                            "with": {
                                "user": "$localUser",
                                "time": "$timeEpoch",
                                "content": "$content"
                            },
                            "forEach": true,
                            "select": false
                        }},
                        { "prepend": {
                            "to": { "property": "messages" },
                            "item": "$new"
                        }},
                        { "set": { "newMessageText": "" }}
                    ]
                }
            }
        },
        "message": {
            "schema": {
                "user": "user",
                "local": { "boolean": {
                    "derive": {
                        "properties": [ "user", "userManager.localUser" ],
                        "transform": [
                            { "get": "userManager.localUser" },
                            { "eval": {
                                "property": "user",
                                "equals": "$get"
                            }}
                        ]
                    }
                }},
                "time": "number",
                "timeString": { "string": {
                    "derive": {
                        "properties": [ "time" ],
                        "transform": [
                            { "get": "time" },
                            { "epochToTime": { "epoch": "$get" }}
                        ]
                    }
                }},
                "dateString": { "string": {
                    "derive": {
                        "properties": [ "time" ],
                        "transform": [
                            { "get": "time" },
                            { "epochToDate": { "epoch": "$get" }}
                        ]
                    }
                }},
                "content": "string"
            },
            "mappings": {
                "local": [ "memory", "cauldron" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="Chat Template" auto>&lt;dom-view-template>
    &lt;varv-template name="chat">
        &lt;div class="chat">
            &lt;div class="messages">
                &lt;template-ref template-name="message" property="messages">&lt;/template-ref>
            &lt;/div>
            &lt;div class="new-message">
                &lt;input value="{newMessageText}" view="messageInput">
                &lt;button view="send-message-button">SEND&lt;/button>
            &lt;/div>
        &lt;/div>
    &lt;/varv-template>

    &lt;varv-template name="message">
        &lt;div class="message" data-local="{local}">
            &lt;div class="user" property="user">{name}&lt;/div>
            &lt;div class="message-content">
                {content}
                &lt;div class="time" title="{dateString}">{timeString}&lt;/div>
            &lt;/div>
        &lt;/div>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Chat Style" auto>@mixin heading-font {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}



.chat {
    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
    background: #333333;

    .messages {
        flex: 1 1 auto;
        display: flex;
        flex-direction: column-reverse;
        flex-wrap: nowrap;
        align-items: flex-start;
        gap: 10px;
        padding: 16px;
        overflow-x: hidden;

        .message {
            flex: 0 0 auto;
            position: relative;
            max-width: 80%;
            margin-bottom: 10px;

            .message-content {
                background: #F2F2F2;
                border-radius: 16px 16px 16px 2px;
                padding: 8px 12px;
            }

            .user {
                @include heading-font;
                font-size: 9px;
                position: absolute;
                bottom: -13px;
                left: 4px;
                color: #AAAAAA;
                white-space: nowrap;
            }

            .time {
                @include heading-font;
                font-size: 9px;
                color: #848484;
                margin-left: 4px;
                text-align: end;
                display: inline;
            }

            &[data-local="true"] {
                align-self: flex-end;

                .message-content {
                    border-radius: 16px 16px 2px 16px;
                }

                .user {
                    left: inherit;
                    right: 4px;
                }
            }
        }
    }

    .new-message {
        flex: 0 0 32px;
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 8px;
        padding: 8px;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Element" name="Element"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The abstract element concept.",
    "dependencies": [],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Element Concepts" auto>{
    "concepts": {
        "element": {
            "schema": {
                "parentRoom": "roomElement",
                "top": { "number": { "default": 100 }},
                "left": { "number": { "default": 100 }},
                "width": { "number": { "default": 200 }},
                "height": { "number": { "default": 150 }},
                "opacity": { "number": { "default": 1 }},
                "zIndex": "number",
                "elementType": { "string": {
                    "derive": { "transform": [ "getType" ] }
                }},
                "selected": "boolean",
                "inToolPanel": "boolean"
            },
            "mappings": {
                "selected": [ "memory", "cauldron" ]
            },
            "actions": {
                "elementDrop": [
                    "getType",
                    { "concat": [ "$getType", "Drop" ]},
                    { "run": "$concat" }
                ],
                "elementCleanup": [
                    "getType",
                    { "concat": [ "$getType", "Cleanup" ]},
                    { "switch": [
                        {
                            "where": { "variable": "getType", "equals": "cameraContent" },
                            "then": { "run": "cameraContentCleanup" }
                        },
                        {
                            "where": { "variable": "getType", "equals": "screenContent" },
                            "then": { "run": "screenContentCleanup" }
                        },
                        {
                            "where": { "variable": "getType", "equals": "regularRoom" },
                            "then": { "run": "regularRoomCleanup" }
                        },
                        {
                            "where": { "variable": "getType", "equals": "layoutTemplateTool" },
                            "then": { "run": "layoutTemplateToolCleanup" }
                        }
                    ]},
                    "remove"
                ],
                "selectElement": [
                    { "where": {
                        "property": "selected",
                        "equals": false,
                        "stopIfEmpty": true
                    }},
                    { "run": "deselectElements" },
                    "checkInfullscreenRoom",
                    { "set": { "selected": true }},
                    { "set": { "meeting.selectedElement": "$target" }}
                ],
                "deselectElements": [
                    { "select": "element" },
                    { "set": { "selected": false }},
                    { "set": { "meeting.selectedElement": "" }}
                ],
                "selectparentRoom": [
                    { "get": "parentRoom" },
                    { "select": {
                        "target": "$get",
                        "stopIfEmpty": true
                    }}
                ],
                "selectselectedElement": [
                    { "select": {
                        "concept": "element",
                        "where": {
                            "property": "selected",
                            "equals": true
                        },
                        "stopIfEmpty": true
                    }}
                ],
                "deleteElement": {
                    "when": { "click": {
                        "view": "deleteElementButton",
                        "exactConceptMatch": true
                    }},
                    "then": [
                        "checkInfullscreenRoom",
                        "elementCleanup"
                    ]
                }
            }
        },
        "meeting": {
            "actions": {
                "selectElementOnClick": {
                    "comment": "Do this in the meeting concept as it otherwise gets executed multiple times for each injected element type.",
                    "when": { "click": { "concept": "element" }},
                    "then": [ "selectElement" ]
                }
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="Element Template" auto>&lt;dom-view-template>
    &lt;varv-template name="element">
        &lt;div class="element {elementType}" style="left: {left}px; top: {top}px; width: {width}px; height: {height}px; opacity: {opacity}; z-index: {zIndex}" tabindex=0 data-selected="{selected}" data-is-being-moved="{isBeingMoved}" data-is-resizing="{isResizing}" data-is-drop-target="{isDropTarget}" data-is-content="{isContent}" data-is-room="{isRoom}" data-is-tool="{isTool}">
            &lt;div class="element-body">
                &lt;template-ref template-name="{elementType}Body">&lt;/template-ref>
            &lt;/div>
            &lt;div class="move-handle" view="moveHandle" if="concept movableMixin">&lt;/div>
            &lt;div class="resize-handle" view="resizeHandle" if="concept resizableMixin">&lt;/div>
        &lt;/div>
    &lt;/varv-template>

    &lt;varv-template name="elementBody">&lt;/varv-template>

    &lt;varv-template name="elementOptions">
        &lt;button class="red" view="deleteElementButton">Delete Element&lt;/button>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Element Style" auto>@mixin heading-font {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}



.element {
    position: absolute;
    background: #636363;
    border: 1px solid #848484;
    border-radius: 12px;
    transition: box-shadow 250ms ease-in-out;
    box-sizing: border-box;

    .move-handle {
        position: absolute;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
        cursor: move;
    }

    .resize-handle {
        position: absolute;
        background: #848484;
        border-top-left-radius: 6px;
        border-bottom-right-radius: 8px;
        bottom: 0;
        right: 0;
        width: 16px;
        height: 16px;
        cursor: nwse-resize;

        &:hover {
            background: #CCCCCC;
        }
    }

    .element-title {
        @include heading-font;

        position: absolute;
        top: 0;
        left: 0;
        height: 16px;

        background: #848484;
        color: #fff;

        border-bottom-right-radius: 6px;
        border-top-left-radius: 8px;

        line-height: 16px;
        padding: 2px 8px;
        user-select: none;

        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;

        max-width: calc(100% - 16px);

        z-index: 10;

        &:empty {
            display: none;
        }
    }

    .element-body {
        width: 100%;
        height: 100%;
        user-select: none;
        position: relative;
        overflow: hidden;
        border-radius: 11px;
    }
}

.element:hover {
    outline: 1px solid rgba(220, 220, 220, 0.5);
}

.element[data-selected="true"] {
    outline: 2px solid #dcdcdc;
    z-index: 100 !important;
}

.element[data-is-being-moved="true"] {
    z-index: 100 !important;
}

.element[data-is-resizing="true"] {
    z-index: 100 !important;
}

@keyframes wiggle {
    0% {
        transform: rotate(0deg);
    }

    25% {
        transform: rotate(0.3deg);
    }

    50% {
        transform: rotate(0deg);
    }

    75% {
        transform: rotate(-0.3deg);
    }

    100% {
        transform: rotate(0deg);
    }
}

.meeting[data-layout-mode="true"] {
    .content>.element {
        animation: wiggle 300ms infinite;
        box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.45);

        &:hover {
            box-shadow: 0 0 24px 0 rgba(0, 0, 0, 0.45);
        }
    }
}

.meeting[data-layout-mode="false"] {
    .move-handle,
    .resize-handle {
        display: none;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="RoomElement" id="RoomElement"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The abstract room concept.",
    "dependencies": [
        "#FindAction",
        "#Element",
        "#MovableMixin",
        "#ResizableMixin",
        "#DroppableMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="RoomElement Concepts" auto>{
    "concepts": {
        "roomElement": {
            "schema": {
                "isRoom": { "boolean": { "default": true }},
                "isContent": { "boolean": { "default": false }},
                "isTool": { "boolean": { "default": false }},
                "name": { "string": { "default": "New Room" }},
                "childElements": { "array": {
                    "items": "element",
                    "derive": {
                        "concepts": [
                            "regularRoom",

                            "cameraContent",
                            "screenContent",
                            "imageContent",
                            "noteContent",
                            "videoContent",
                            "sketchContent",
                            "chatContent",
                            "avatarContent",

                            "gridTool",
                            "speakerViewTool",
                            "layoutTemplateTool",
                            "highlightTool",
                            "cameraShakerTool",
                            "recordingTool",
                            "roomRecordingTool",
                            "doorwayTool",
                            "proximityBasedAudioTool",
                            "podiumTool",
                            "whisperTool",
                            "broadcastTool",
                            "templateStoreTool"
                        ],
                        "properties": [
                            "regularRoom.parentRoom",

                            "cameraContent.parentRoom",
                            "screenContent.parentRoom",
                            "imageContent.parentRoom",
                            "noteContent.parentRoom",
                            "videoContent.parentRoom",
                            "sketchContent.parentRoom",
                            "chatContent.parentRoom",
                            "avatarContent.parentRoom",

                            "gridTool.parentRoom",
                            "speakerViewTool.parentRoom",
                            "layoutTemplateTool.parentRoom",
                            "highlightTool.parentRoom",
                            "cameraShakerTool.parentRoom",
                            "recordingTool.parentRoom",
                            "roomRecordingTool.parentRoom",
                            "doorwayTool.parentRoom",
                            "proximityBasedAudioTool.parentRoom",
                            "podiumTool.parentRoom",
                            "whisperTool.parentRoom",
                            "broadcastTool.parentRoom",
                            "templateStoreTool.parentRoom"
                        ],
                        "transform": [
                            { "find": {
                                "concept": "element",
                                "where": {
                                    "property": "parentRoom",
                                    "equals": "$lastTarget"
                                }
                            }}
                        ]
                    }
                }},
                "clients": { "array": {
                    "items": "client",
                    "derive": {
                        "concepts": [ "client" ],
                        "properties": [ "client.location" ],
                        "transform": [
                            { "find": {
                                "concept": "client",
                                "where": {
                                    "property": "location",
                                    "equals": "$lastTarget"
                                }
                            }}
                        ]
                    }
                }},
                "hasClients": { "boolean": {
                    "derive": {
                        "properties": [ "clients" ],
                        "transform": [
                            { "length": "clients" },
                            { "eval": {
                                "variable": "length",
                                "unequals": 0
                            }}
                        ]
                    }
                }},
                "isInFullscreenRoom": { "boolean": {
                    "derive": {
                        "properties": [ "parentRoom", "meeting.fullscreenRoom" ],
                        "transform": [
                            { "get": "meeting.fullscreenRoom" },
                            { "eval": {
                                "property": "parentRoom",
                                "equals": "$get"
                            }}
                        ]
                    }
                }},
                "audioFilter": "string"
            },
            "actions": {
                "roomElementDrop": [
                    "moveElementInRoom"
                ],
                "roomElementCleanup": [
                    { "items": "childElements" },
                    { "select": "$items" },
                    "elementCleanup"
                ],
                "moveElementInRoom": [
                    { "select": "$movedElement" },
                    { "set": {
                        "property": "parentRoom",
                        "value": "$targetElement"
                    }}
                ],
                "moveElementOutOfRoom": [
                    { "select": "$movedElement" },
                    { "get": {
                        "property": "parentRoom",
                        "as": "oldParent"
                    }},
                    { "select": "$oldParent" },
                    { "get": {
                        "property": "parentRoom",
                        "as": "newParent"
                    }},
                    { "select": "$movedElement" },
                    { "set": {
                        "property": "parentRoom",
                        "value": "$newParent"
                    }},
                    { "run": "deselectElements" }
                ],
                "moveElementOutOfRoomReaction": [
                    "selectselectedElement",
                    { "get": {
                        "property": "meeting.rootRoom",
                        "as": "rootRoom"
                    }},
                    { "where": {
                        "property": "parentRoom",
                        "unequals": "$rootRoom",
                        "stopIfEmpty": true
                    }},
                    { "set": {
                        "variable": "movedElement",
                        "value": "$target"
                    }},
                    "moveElementOutOfRoom"
                ]
            },
            "extensions": { "inject": [ "element" ] }
        },
        "meeting": {
            "actions": {
                "moveElementOutOfRoomReaction": {
                    "comment": "Moved to the meeting as otherwise injection causes the action to be run multiple times.",
                    "when": { "click": { "view": "moveElementOutButton" }},
                    "then": "roomElement.moveElementOutOfRoomReaction"
                }
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="RoomElement Template" auto>&lt;dom-view-template>
    &lt;varv-template name="roomElementBody">&lt;/varv-template>

    &lt;varv-template name="roomElementOptions">
        &lt;label>
            Name:
            &lt;input value="{name}">
        &lt;/label>
        &lt;label>
            Audio Filter:
            &lt;input value="{audioFilter}">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="stackableMixinOptions">&lt;/template-ref>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="elementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="RoomElement Style" auto>.element[data-is-room="true"] .element-preview>* {
    pointer-events: none;
}

.element[data-is-room="true"] {
    border: 4px solid #848484;

    >.element-body {
        box-shadow: inset 0px 0px 8px 0px #333333;
        background: #535353;
        outline: 2px solid #848484;
        border-radius: 8px;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ContentElement" name="ContentElement"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The abstract content element concept.",
    "dependencies": [
        "#Element",
        "#MovableMixin",
        "#ResizableMixin",
        "#DroppableMixin",
        "#OpacityMixin",
        "#StackableMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ContentElement Concepts" auto>{
    "concepts": {
        "contentElement": {
            "schema": {
                "isRoom": { "boolean": { "default": false }},
                "isContent": { "boolean": { "default": true }},
                "isTool": { "boolean": { "default": false }}
            },
            "extensions": { "inject": [ "element" ] }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="ContentElement Template" auto>&lt;dom-view-template>
    &lt;varv-template name="contentElementBody">&lt;/varv-template>

    &lt;varv-template name="contentElementOptions">
        &lt;template-ref template-name="opacityMixinOptions">&lt;/template-ref>
        &lt;template-ref template-name="stackableMixinOptions">&lt;/template-ref>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="elementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="ContentElement Style" auto>.element[data-is-content="true"] .placeholder-icon {
    position: absolute;
    width: 32px;
    height: 32px;
    left: calc(50% - 16px);
    top: calc(50% - 16px);
    font-size: 32px;
    z-index: -1;
    color: #aaa;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="ToolElement" id="ToolElement"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The abstract tool concept.",
    "dependencies": [
        "#Element",
        "#MovableMixin",
        "#ResizableMixin",
        "#DroppableMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ToolElement Concepts" auto>{
    "concepts": {
        "toolElement": {
            "schema": {
                "isRoom": { "boolean": { "default": false }},
                "isContent": { "boolean": { "default": false }},
                "isTool": { "boolean": { "default": true }},
                "inToolPanel": { "boolean": { "default": true }}
            },
            "extensions": { "inject": [ "element" ] }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="ToolElement Template" auto>&lt;dom-view-template>
    &lt;varv-template name="toolElementBody">&lt;/varv-template>

    &lt;varv-template name="toolElementOptions">
        &lt;label>
            Move to Tool Panel:
            &lt;input value="{inToolPanel}" type="checkbox">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="elementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="ToolElement Style" auto>@mixin heading-font {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}



.element[data-is-tool="true"]>.element-body {
    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
    overflow-y: auto;
    width: calc(100% - 16px);
    height: calc(100% - 16px);
    padding: 8px;
    gap: 8px;
    background: #212121;

    &::-webkit-scrollbar {
        display: none;
    }

    >input,
    >button,
    >label {
        display: flex;
        flex: 1 0 24px;
        min-height: 32px;
        white-space: initial;
        text-align: center;
        justify-content: center;
        align-items: center;
    }

    .tool-title {
        @include heading-font;
        text-align: center;
        display: block;
        width: 100%;
        font-size: 14px;
        letter-spacing: 1px;
        color: #CCCCCC;
        height: 24px;
        line-height: 24px;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><DIV name="Mixins"><WPM-PACKAGE name="MovableMixin" id="MovableMixin"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Mixin for making elements movable.",
    "dependencies": [
        "#Element"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="MovableMixin Concept" auto>{
    "concepts": {
        "meeting": {
            "actions": {
                "move": {
                    "when": { "mousemove": {
                        "property": "fullscreenRoom"
                    }},
                    "then": [
                        { "select": {
                            "concept": "movableMixin",
                            "where": {
                                "property": "isBeingMoved",
                                "equals": true
                            },
                            "stopIfEmpty": true
                        }},
                        { "get": "movingOffsetLeft" },
                        { "calculate": { "expression": "$x$ - $get$", "as": "x" }},
                        { "get": "movingOffsetTop" },
                        { "calculate": { "expression": "$y$ - $get$", "as": "y" }},
                        { "set": { "left": "$x"}},
                        { "set": { "top": "$y"}}
                    ]
                }
            }
        },
        "movableMixin": {
            "schema": {
                "isBeingMoved": "boolean",
                "movingOffsetLeft": "number",
                "movingOffsetTop": "number"
            },
            "mappings": {
                "isBeingMoved": [ "memory", "cauldron" ],
                "movingOffsetLeft": [ "memory", "cauldron" ],
                "movingOffsetTop": [ "memory", "cauldron" ]
            },
            "actions": {
                "beginMove": {
                    "when": { "mousedown": {
                        "view": "moveHandle",
                        "exactConceptMatch": true
                    }},
                    "then": [
                        "checkInfullscreenRoom",
                        { "set": { "isBeingMoved": true }},
                        { "get": "left" },
                        { "calculate": "$x$ - $get$" },
                        { "set": { "movingOffsetLeft": "$calculate" }},
                        { "get": "top" },
                        { "calculate": "$y$ - $get$" },
                        { "set": { "movingOffsetTop": "$calculate" }}
                    ]
                },
                "endMove": {
                    "when": { "mouseup": {
                        "exactConceptMatch": true
                    }},
                    "then": [
                        "checkInfullscreenRoom",
                        { "run": "moveEndDrop" },
                        { "select": {
                            "concept": "movableMixin",
                            "stopIfEmpty": true
                        }},
                        { "set": { "isBeingMoved": false }}
                    ]
                }
            }
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ResizableMixin" name="ResizableMixin"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Mixins for making elements resizable.",
    "dependencies": [
        "#Element"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ResizableMixin Concept" auto>{
    "concepts": {
        "meeting": {
            "actions": {
                "resize": {
                    "when": { "mousemove": {
                        "property": "fullscreenRoom"
                    }},
                    "then": [
                        { "select": {
                            "concept": "resizableMixin",
                            "where": { "property": "isResizing", "equals": true },
                            "stopIfEmpty": true
                        }},
                        { "get": { "property": "resizeInitialX", "as": "initialX" }},
                        { "get": { "property": "resizeInitialWidth", "as": "width" }},
                        { "calculate": { "expression": "$width$ + ( $x$ - $initialX$ )", "as": "w" }},
                        { "get": { "property": "resizeInitialY", "as": "initialY" }},
                        { "get": { "property": "resizeInitialHeight", "as": "height" }},
                        { "calculate": { "expression": "$height$ + ( $y$ - $initialY$ )", "as": "h" }},
                        { "set": { "width": "$w"}},
                        { "set": { "height": "$h"}}
                    ]
                }
            }
        },
        "resizableMixin": {
            "schema": {
                "isResizing": "boolean",
                "resizeInitialX": "number",
                "resizeInitialY": "number",
                "resizeInitialWidth": "number",
                "resizeInitialHeight": "number"
            },
            "mappings": {
                "isResizing": [ "memory", "cauldron" ],
                "resizeInitialX": [ "memory", "cauldron" ],
                "resizeInitialY": [ "memory", "cauldron" ],
                "resizeInitialWidth": [ "memory", "cauldron" ],
                "resizeInitialHeight": [ "memory", "cauldron" ]
            },
            "actions": {
                "beginResize": {
                    "when": { "mousedown": {
                        "view": "resizeHandle",
                        "exactConceptMatch": true
                    }},
                    "then": [
                        "checkInfullscreenRoom",
                        { "set": { "isResizing": true }},
                        { "set": { "resizeInitialX": "$x" }},
                        { "set": { "resizeInitialY": "$y" }},
                        { "get": "width" },
                        { "set": { "resizeInitialWidth": "$get" }},
                        { "get": "height" },
                        { "set": { "resizeInitialHeight": "$get" }}
                    ]
                },
                "endResize": {
                    "when": { "mouseup": {
                        "exactConceptMatch": true
                    }},
                    "then": [
                        { "select": {
                            "concept": "resizableMixin",
                            "stopIfEmpty": true
                        }},
                        { "set": { "isResizing": false }}
                    ]
                }
            }
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="DroppableMixin" name="DroppableMixin"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Mixin for making elements droppable into each other.",
    "dependencies": [
        "#WindowTools",
        "#Element",
        "#MovableMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="DroppableMixin Concept" auto>{
    "concepts": {
        "droppableMixin": {
            "schema": {
                "isDropTarget": "boolean"
            },
            "mappings": {
                "isDropTarget": [ "memory", "cauldron" ]
            },
            "actions": {
                "moveEndDrop": {
                    "then": [
                        "checkCtrl",
                        "checkInfullscreenRoom",
                        { "limit": 1 },
                        { "run": "drop" },
                        "resetHovered"
                    ]
                },
                "moveDrop": {
                    "comment": "Optimization: Use interval here for better performance as mouse move is too fast.",
                    "when": { "interval": 500 },
                    "then": [
                        { "select": {
                            "concept": "droppableMixin",
                            "where": {
                                "property": "isBeingMoved",
                                "equals": true
                            },
                            "stopIfEmpty": true
                        }},
                        { "run": "resetHovered" },
                        "checkCtrl",
                        "checkHovered"
                    ]
                },
                "resetHovered": [
                    { "select": {
                        "concept": "droppableMixin",
                        "stopIfEmpty": true
                    }},
                    { "set": { "isDropTarget": false }}
                ],
                "checkHovered": [
                    { "select": {
                        "concept": "droppableMixin",
                        "where": {
                            "property": "isBeingMoved",
                            "equals": false
                        },
                        "stopIfEmpty": true
                    }},
                    "checkInfullscreenRoom",
                    "cursorPosition",
                    "correctCursorPosition",
                    { "where": {
                        "and": [
                            { "variable": "x", "greaterThan": "$target.left" },
                            { "variable": "x", "lessThan": { "calculate": "$target.left$+$target.width$" } },
                            { "variable": "y", "greaterThan": { "calculate": "$target.top$" }},
                            { "variable": "y", "lessThan": { "calculate": "$target.top$+$target.height$" }},
                            { "property": "inToolPanel", "equals": false }
                        ],
                        "stopIfEmpty": true
                    }},
                    { "set": { "isDropTarget": true }}
                ],
                "drop": [
                    { "select": {
                        "concept": "movableMixin",
                        "where": {
                            "property": "isBeingMoved",
                            "equals": true
                        },
                        "stopIfEmpty": true,
                        "as": "movedElements"
                    }},
                    { "removeFirst": {
                        "of": { "variable": "movedElements" },
                        "as": "movedElement"
                    }},
                    { "select": {
                        "concept": "droppableMixin",
                        "where": {
                            "property": "isDropTarget",
                            "equals": true
                        },
                        "stopIfEmpty": true,
                        "as": "targetElements"
                    }},
                    { "removeFirst": {
                        "of": { "variable": "targetElements" },
                        "as": "targetElement"
                    }},
                    { "select": "$targetElement" },
                    { "run": "elementDrop" },
                    { "run": "deselectElements" }
                ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="DroppableMixin Style" auto>.element[data-is-drop-target="true"] {
    outline: 2px solid salmon;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="OpacityMixin" id="OpacityMixin"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Mixin for being able to change element's opacity.",
    "dependencies": [
        "#Element"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="OpacityMixin Concept" auto>{
    "concepts": {
        "opacityMixin": {
            "schema": {
                "opacity": { "number": {
                    "default": 1,
                    "min": 0.1,
                    "max": 1
                }}
            },
            "actions": {
                "wheelToChangeOpacity": {
                    "when": { "wheel": {
                        "exactConceptMatch": true
                    }},
                    "then": [
                        "checkInLayoutMode",
                        { "get": "opacity" },
                        { "calculate": "max(0.1, min(1, $get$ + $wheelDelta$ / 1000))" },
                        { "set": { "opacity": "$calculate" }}
                    ]
                }
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="OpacityMixin Template" auto>&lt;dom-view-template>
    &lt;varv-template name="opacityMixinOptions">
        &lt;label title="Change with mousewheel">
            Opacity:
            &lt;input value="{opacity}" type="number" min="0.1" max="1" step="0.1">
        &lt;/label>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="StackableMixin" id="StackableMixin"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Mixin for making elements stackable.",
    "dependencies": [
        "#Element"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="StackableMixin Concept" auto>{
    "concepts": {
        "stackableMixin": {
            "schema": {
                "zIndex": "number"
            },
            "actions": {
                "moveStackUp": {
                    "when": { "key": {
                        "key": "u"
                    }},
                    "then": [
                        "checkInLayoutMode",
                        { "select": {
                            "concept": "stackableMixin",
                            "where": {
                                "property": "selected",
                                "equals": true
                            },
                            "stopIfEmpty": true
                        }},
                        { "increment": "zIndex" }
                    ]
                },
                "moveStackDown": {
                    "when": { "key": {
                        "key": "d"
                    }},
                    "then": [
                        "checkInLayoutMode",
                        { "select": {
                            "concept": "stackableMixin",
                            "where": {
                                "property": "selected",
                                "equals": true
                            },
                            "stopIfEmpty": true
                        }},
                        { "get": "zIndex" },
                        { "calculate": "max(0, $get$ - 1)" },
                        { "set": { "zIndex": "$calculate" }}
                    ]
                }
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="StackableMixin Template" auto>&lt;dom-view-template>
    &lt;varv-template name="stackableMixinOptions">
        &lt;label title="Change by pressing 'u' or 'd'">
            Z-Index:
            &lt;input value="{zIndex}" type="number" min="0">
        &lt;/label>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ToolFunctionMixin" name="ToolFunctionMixin"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Mixin for tools that can be activated and deactivated.",
    "dependencies": [
        "#ToolElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ToolFunctionMixin Concepts" auto>{
    "concepts": {
        "toolFunctionMixin": {
            "schema": {
                "disabled": "boolean",
                "role": "string",
                "isActive": { "boolean": {
                    "derive": {
                        "properties": [
                            "disabled",
                            "role",
                            "parentRoom",
                            "meeting.fullscreenRoom",
                            "userManager.localRole"
                        ],
                        "transform": [
                            { "get": {
                                "property": "meeting.fullscreenRoom",
                                "as": "fullscreenRoom"
                            }},
                            { "get": {
                                "property": "userManager.localRole",
                                "as": "localRole"
                            }},
                            { "eval": {
                                "and": [
                                    { "property": "parentRoom", "equals": "$fullscreenRoom" },
                                    { "property": "disabled", "equals": false },
                                    { "or": [
                                        { "property": "role", "equals": "$localRole" },
                                        { "property": "role", "equals": "" }
                                    ]}
                                ]
                            }}
                        ]
                    }
                }}
            },
            "mappings": {
                "isActive": [ "memory", "cauldron" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="ToolFunctionMixin Template" auto>&lt;dom-view-template>
    &lt;varv-template name="toolFunctionMixinBody">
        &lt;label if="isActive" class="toolFunctionStatus status-active">Tool active&lt;/label>
        &lt;label if="!isActive" class="toolFunctionStatus status-not-active">Tool not active&lt;/label>
    &lt;/varv-template>

    &lt;varv-template name="toolFunctionMixinOptions">
        &lt;label>
            Disabled:
            &lt;input value="{disabled}" type="checkbox">
        &lt;/label>
        &lt;label>
            Role:
            &lt;input value="{role}" title="Role">
        &lt;/label>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="ToolFunctionMixin Style" auto>.element {
    .toolFunctionStatus {
        color: #fff;
        font-size: 14px;
    }

    .status-active {
        background: #2e7d32;
    }

    .status-not-active {
        background: #d32f2f;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ToolLayoutMixin" name="ToolLayoutMixin"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Mixin for tools that change the layout of a room.",
    "dependencies": [
        "#FindAction",
        "#ToolElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ToolLayoutMixin Concepts" auto>{
    "concepts": {
        "toolLayoutMixin": {
            "schema": {
                "active": "boolean",
                "elements": { "array": {
                    "items": "element",
                    "derive": {
                        "properties": [
                            "parentRoom",

                            "regularRoom.childElements",

                            "gridTool.inToolPanel",
                            "speakerViewTool.inToolPanel",
                            "layoutTemplateTool.inToolPanel",
                            "highlightTool.inToolPanel",
                            "cameraShakerTool.inToolPanel",
                            "recordingTool.inToolPanel",
                            "roomRecordingTool.inToolPanel",
                            "doorwayTool.inToolPanel",
                            "proximityBasedAudioTool.inToolPanel",
                            "podiumTool.inToolPanel",
                            "whisperTool.inToolPanel",
                            "broadcastTool.inToolPanel",
                            "templateStoreTool.inToolPanel"
                        ],
                        "transform": [
                            { "get": "parentRoom" },
                            { "find": {
                                "concept": "element",
                                "where": { "and": [
                                    { "property": "parentRoom", "equals": "$get" },
                                    { "property": "inToolPanel", "equals": false }
                                ]}
                            }}
                        ]
                    }
                }},
                "elementCount": { "number": {
                    "derive": {
                        "properties": [ "elements" ],
                        "transform": [
                            { "length": "elements" }
                        ]
                    }
                }}
            }
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE></DIV><DIV name="Room Types"><WPM-PACKAGE id="RegularRoom" name="RegularRoom"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A regular room concept.",
    "dependencies": [
        "#RoomElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="RegularRoom Concepts" auto>{
    "concepts": {
        "regularRoom": {
            "actions": {
                "regularRoomDrop": [
                    "roomElementDrop"
                ],
                "regularRoomCleanup": [
                    "roomElementCleanup"
                ]
            },
            "extensions": { "inject": [
                "element",
                "roomElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="RegularRoom Template" auto>&lt;dom-view-template>
    &lt;varv-template name="regularRoomBody">
        &lt;div class="element-title" title="Room Name">{name}&lt;/div>
        &lt;div class="client-overview" title="Clients in this Room" if="hasClients">
            &lt;div class="client-thumbnail" property="clients" style="background: {color}" title="{name}">{name}&lt;/div>
        &lt;/div>
        &lt;div class="element-preview" if="isInFullscreenRoom">
            &lt;template-ref template-name="element" property="childElements" if="!inToolPanel">&lt;/template-ref>
        &lt;/div>
        &lt;button view="enterRoomButton" class="enter-room-button" if="isInFullscreenRoom">Enter Room&lt;/button>
    &lt;/varv-template>

    &lt;varv-template name="regularRoomOptions">
        &lt;template-ref template-name="roomElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="RegularRoom Style" auto>.regularRoom {
    .client-overview {
        position: absolute;
        background: #848484;
        border-bottom-left-radius: 6px;
        border-top-right-radius: 8px;
        top: 0;
        right: 0;
        height: 16px;
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 4px;
        padding: 2px;
        min-width: 16px;
        user-select: none;
        z-index: 10;

        .client-thumbnail {
            color: #fff;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            overflow: hidden;
            user-select: none;
            font-size: 8px;
            line-height: 12px;
            padding: 2px;
        }
    }

    .element-preview {
        width: 300%;
        height: 300%;
        transform: scale(0.333);
        transform-origin: top left;
    }

    button.enter-room-button {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50%;
        height: 50%;
        max-width: 192px;
        max-height: 48px;
        box-shadow: 0px 0px 4px 0px #424242;
    }

    &[data-selected="true"] {
        background: #424242;

        .element-preview {
            opacity: 20%;
        }

        button.enter-room-button {
            display: block;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE></DIV><DIV name="Content Types"><WPM-PACKAGE name="CameraContent" id="CameraContent"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The camera content concept.",
    "dependencies": [
        "#ContentElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="CameraContent Concepts" auto>{
    "concepts": {
        "cameraContent": {
            "schema": {
                "cameraStream": "cameraStream",
                "fit": { "string": {
                    "enum": [ "cover", "contain" ],
                    "default": "cover"
                }},
                "fitOptions": { "array": {
                    "items": "string",
                    "derive": {
                        "transform": [
                            { "enums": "fit" }
                        ]
                    }
                }},
                "scale": { "number": {
                    "min": 100,
                    "max": 200,
                    "default": 100
                }},
                "cropOffsetLeft": { "number": {
                    "min": 0,
                    "max": 100,
                    "default": 50
                }},
                "cropOffsetTop": { "number": {
                    "min": 0,
                    "max": 100,
                    "default": 50
                }},
                "aspectRatioWide": { "boolean": {
                    "derive": {
                        "properties": [ "width", "height" ],
                        "transform": [
                            { "get": { "property": "width", "as": "width" }},
                            { "get": { "property": "height", "as": "height" }},
                            { "calculate": "$width$ / $height$" },
                            { "eval": {
                                "variable": "calculate",
                                "greaterThan": 1.33
                            }}
                        ]
                    }
                }},
                "videoWidth": { "number": {
                    "derive": {
                        "properties": [ "aspectRatioWide", "width", "height", "scale" ],
                        "transform": [
                            { "get": { "property": "width", "as": "width" }},
                            { "get": { "property": "height", "as": "height" }},
                            { "get": { "property": "scale", "as": "scale" }},
                            { "get": { "property": "aspectRatioWide", "as": "aspectRatioWide" }},
                            { "switch": [
                                {
                                    "where": { "variable": "aspectRatioWide", "equals": true },
                                    "then": [
                                        { "set": { "variable": "videoWidth", "value": "$width" }}
                                    ]
                                },
                                {
                                    "where": { "variable": "aspectRatioWide", "equals": false },
                                    "then": [
                                        { "calculate": "floor($height$ * 1.33)"},
                                        { "set": { "variable": "videoWidth", "value": "$calculate" }}
                                    ]
                                }
                            ]},
                            { "calculate": "$videoWidth$ * ($scale$ / 100)" }
                        ]
                    }
                }},
                "videoHeight": { "number": {
                    "derive": {
                        "properties": [ "aspectRatioWide", "width", "height", "scale" ],
                        "transform": [
                            { "get": { "property": "width", "as": "width" }},
                            { "get": { "property": "height", "as": "height" }},
                            { "get": { "property": "scale", "as": "scale" }},
                            { "get": { "property": "aspectRatioWide", "as": "aspectRatioWide" }},
                            { "switch": [
                                {
                                    "where": { "variable": "aspectRatioWide", "equals": true },
                                    "then": [
                                        { "calculate": "floor($width$ / 1.33)"},
                                        { "set": { "variable": "videoHeight", "value": "$calculate" }}
                                    ]
                                },
                                {
                                    "where": { "variable": "aspectRatioWide", "equals": false },
                                    "then": [
                                        { "set": { "variable": "videoHeight", "value": "$height" }}
                                    ]
                                }
                            ]},
                            { "calculate": "$videoHeight$ * ($scale$ / 100)" }
                        ]
                    }
                }},
                "cropOffsetLeftCorrected": { "number": {
                    "derive": {
                        "properties": [ "videoWidth", "cropOffsetLeft" ],
                        "transform": [
                            { "get": { "property": "width", "as": "width" }},
                            { "get": { "property": "videoWidth", "as": "videoWidth" }},
                            { "calculate": "($videoWidth$ / $width$) - 1" },
                            { "get": "cropOffsetLeft" },
                            { "calculate": "$get$ * $calculate$" }
                        ]
                    }
                }},
                "cropOffsetTopCorrected": { "number": {
                    "derive": {
                        "properties": [ "videoHeight", "cropOffsetTop" ],
                        "transform": [
                            { "get": { "property": "height", "as": "height" }},
                            { "get": { "property": "videoHeight", "as": "videoHeight" }},
                            { "calculate": "($videoHeight$ / $height$) - 1" },
                            { "get": "cropOffsetTop" },
                            { "calculate": "$get$ * $calculate$" }
                        ]
                    }
                }},
                "clientInRoom": { "boolean": {
                    "derive": {
                        "properties": [ "cameraStream", "client.location" ],
                        "transform": [
                            { "get": { "property": "cameraStream", "as": "cameraStream" }},
                            { "get": { "property": "parentRoom", "as": "parentRoom" }},
                            { "select": {
                                "target": "$cameraStream",
                                "forEach": true,
                                "stopIfEmpty": true
                            }},
                            { "get": "client" },
                            { "select": {
                                "target": "$get",
                                "forEach": true,
                                "stopIfEmpty": true
                            }},
                            { "eval": { "and": [
                                {
                                    "variable": "cameraStream",
                                    "unequals": "null"
                                },
                                {
                                    "variable": "cameraStream",
                                    "unequals": ""
                                },
                                {
                                    "property": "location",
                                    "equals": "$parentRoom"
                                }
                            ]}}
                        ]
                    }
                }}
            },
            "actions": {
                "cameraContentCleanup": [
                    { "where": {
                        "property": "stream",
                        "unequals": "",
                        "stopIfEmpty": true
                    }},
                    "stopCamera"
                ],
                "startCamera": {
                    "when": { "click": { "view": "startCameraButton" }},
                    "then": [
                        { "set": {
                            "variable": "element",
                            "value": "$target"
                        }},
                        { "select": {
                            "concept": "client",
                            "where": {
                                "property": "local",
                                "equals": true
                            },
                            "stopIfEmpty": true
                        }},
                        { "get": "cameraStream" },
                        { "select": "$element" },
                        { "set": { "cameraStream": "$get" }}
                    ]
                },
                "stopCamera": {
                    "when": { "click": { "view": "stopCameraButton" }},
                    "then": [
                        { "set": { "cameraStream": "" }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "contentElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "opacityMixin",
                "stackableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="CameraContent Template" auto>&lt;dom-view-template>
    &lt;varv-template name="cameraContentBody">
        &lt;div class="element-title" property="cameraStream">
            &lt;span property="client">
                &lt;span property="user">{name}: &lt;/span>{name}
            &lt;/span>
        &lt;/div>
        &lt;div class="placeholder-icon m-ico">photo_camera&lt;/div>
        &lt;video property="cameraStream" data-stream="{id}" data-stream-type="camera" style="object-fit: {fit}; width: {videoWidth}px; height: {videoHeight}px; left: -{cropOffsetLeftCorrected}%; top: -{cropOffsetTopCorrected}%;" data-client-in-room="{clientInRoom}">&lt;/video>
    &lt;/varv-template>

    &lt;varv-template name="cameraContentOptions">
        &lt;button view="startCameraButton">Start Camera&lt;/button>
        &lt;button view="stopCameraButton">Stop Camera&lt;/button>
        &lt;div class="spacer">&lt;/div>
        &lt;label>
            Fit:
            &lt;select value="{fit}">
                &lt;option property="fitOptions">{fitOptions.value}&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;label>
            Scale:
            &lt;input value="{scale}" type="range" min="100" max="200" step="1">
        &lt;/label>
        &lt;label>
            Crop Left:
            &lt;input value="{cropOffsetLeft}" type="range" min="0" max="100" step="1">
        &lt;/label>
        &lt;label>
            Crop Top:
            &lt;input value="{cropOffsetTop}" type="range" min="0" max="100" step="1">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="contentElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="CameraContent Style" auto>.cameraContent video {
    width: 100%;
    height: 100%;
    transform: scaleX(-1);
    position: absolute;
    transition: filter 500ms ease-in-out;

    &[data-client-in-room="false"] {
        filter: blur(12px) grayscale(50%);
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ScreenContent" name="ScreenContent"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The screen content concept.",
    "dependencies": [
        "#StreamTools",
        "#ContentElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ScreenContent Concepts" auto>{
    "concepts": {
        "screenContent": {
            "schema": {
                "stream": "string",
                "local": { "boolean": {
                    "derive": {
                        "properties": [ "stream" ],
                        "transform": [
                            { "get": "stream" },
                            { "isStreamLocal": { "stream": "$get" }}
                        ]
                    }
                }},
                "fit": { "string": {
                    "enum": [ "cover", "contain" ],
                    "default": "contain"
                }},
                "fitOptions": { "array": {
                    "items": "string",
                    "derive": {
                        "transform": [
                            { "enums": "fit" }
                        ]
                    }
                }}
            },
            "mappings": {
                "local": [ "memory", "cauldron" ]
            },
            "actions": {
                "screenContentCleanup": [
                    { "where": {
                        "property": "stream",
                        "unequals": "",
                        "stopIfEmpty": true
                    }},
                    "stopScreen"
                ],
                "startScreen": {
                    "when": { "click": { "view": "startScreenButton" }},
                    "then": [
                        "getScreenStream",
                        { "set": { "stream": "$getScreenStream" }}
                    ]
                },
                "stopScreen": {
                    "when": { "click": { "view": "stopScreenButton" }},
                    "then": [
                        { "get": "stream" },
                        { "closeStream": {
                            "stream": "$get",
                            "type": "screen"
                        }},
                        { "set": { "stream": "" }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "contentElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "opacityMixin",
                "stackableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="ScreenContent Template" auto>&lt;dom-view-template>
    &lt;varv-template name="screenContentBody">
        &lt;div class="placeholder-icon m-ico">cast&lt;/div>
        &lt;video data-stream="{stream}" data-stream-type="screen" style="object-fit: {fit};">&lt;/video>
    &lt;/varv-template>

    &lt;varv-template name="screenContentOptions">
        &lt;button view="startScreenButton">Start Screen&lt;/button>
        &lt;button view="stopScreenButton" if="local">Stop Screen&lt;/button>
        &lt;div class="spacer">&lt;/div>
        &lt;label>
            Fit:
            &lt;select value="{fit}">
                &lt;option property="fitOptions">{fitOptions.value}&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="contentElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="ScreenContent Style" auto>.screenContent video {
    width: 100%;
    height: 100%;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="VideoContent" id="VideoContent"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The video content element.",
    "dependencies": [
        "#ContentElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="VideoContent Concepts" auto>{
    "concepts": {
        "videoContent": {
            "schema": {
                "title": "string",
                "videoUrl": "string",
                "videoUrlEmpty": { "boolean": {
                    "derive": {
                        "properties": [ "videoUrl" ],
                        "transform": [
                            { "eval": {
                                "property": "videoUrl",
                                "equals": ""
                            }}
                        ]
                    }
                }},
                "fit": { "string": {
                    "enum": [ "cover", "contain" ],
                    "default": "cover"
                }},
                "fitOptions": { "array": {
                    "items": "string",
                    "derive": {
                        "transform": [
                            { "enums": "fit" }
                        ]
                    }
                }}
            },
            "extensions": { "inject": [
                "element",
                "contentElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "opacityMixin",
                "stackableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="VideoContent Template" auto>&lt;dom-view-template>
    &lt;varv-template name="videoContentBody">
        &lt;div class="element-title">{title}&lt;/div>
        &lt;div class="placeholder-icon m-ico">theaters&lt;/div>
        &lt;video if="!videoUrlEmpty" src="{videoUrl}" class="video-element-video" draggable="false" style="object-fit: {fit};" loop controls>&lt;/video>
    &lt;/varv-template>

    &lt;varv-template name="videoContentOptions">
        &lt;label>
            Title:
            &lt;input value="{title}">
        &lt;/label>
        &lt;label>
            Video URL:
            &lt;input value="{videoUrl}">
        &lt;/label>
        &lt;label>
            Fit:
            &lt;select value="{fit}">
                &lt;option property="fitOptions">{fitOptions.value}&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="contentElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="VideoContent Style" auto>.video-element-video {
    width: 100%;
    height: 100%;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="ImageContent" id="ImageContent"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The image content concept.",
    "dependencies": [
        "#ContentElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ImageContent Concepts" auto>{
    "concepts": {
        "imageContent": {
            "schema": {
                "imageUrl": "string",
                "imageUrlEmpty": { "boolean": {
                    "derive": {
                        "properties": [ "imageUrl" ],
                        "transform": [
                            { "eval": {
                                "property": "imageUrl",
                                "equals": ""
                            }}
                        ]
                    }
                }},
                "fit": { "string": {
                    "enum": [ "cover", "contain" ],
                    "default": "cover"
                }},
                "fitOptions": { "array": {
                    "items": "string",
                    "derive": {
                        "transform": [
                            { "enums": "fit" }
                        ]
                    }
                }}
            },
            "extensions": { "inject": [
                "element",
                "contentElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "opacityMixin",
                "stackableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="ImageContent Template" auto>&lt;dom-view-template>
    &lt;varv-template name="imageContentBody">
        &lt;div class="placeholder-icon m-ico">image&lt;/div>
        &lt;img src="{imageUrl}" class="image-element-image" draggable="false" style="object-fit: {fit};" if="!imageUrlEmpty">
    &lt;/varv-template>

    &lt;varv-template name="imageContentOptions">
        &lt;label>
            Image URL:
            &lt;input value="{imageUrl}">
        &lt;/label>
        &lt;label>
            Fit:
            &lt;select value="{fit}">
                &lt;option property="fitOptions">{fitOptions.value}&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="contentElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="ImageContent Style" auto>.imageContent .image-element-image {
    width: 100%;
    height: 100%;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="NoteContent" id="NoteContent"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The note content concept.",
    "dependencies": [
        "#ContentElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="NoteContent Concepts" auto>{
    "concepts": {
        "noteContent": {
            "schema": {
                "content": "string",
                "color": { "string": {
                    "default": "Yellow",
                    "enum": [
                        "Yellow",
                        "Red",
                        "Blue",
                        "Green"
                    ]
                }},
                "colors": { "array": {
                    "items": "string",
                    "derive": {
                        "transform": [
                            { "enums": "color" }
                        ]
                    }
                }}
            },
            "extensions": { "inject": [
                "element",
                "contentElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "opacityMixin",
                "stackableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="NoteContent Template" auto>&lt;dom-view-template>
    &lt;varv-template name="noteContentBody">
        &lt;textarea value="{content}" data-color="{color}">&lt;/textarea>
    &lt;/varv-template>

    &lt;varv-template name="noteContentOptions">
        &lt;label>
            Color:
            &lt;select value="{color}">
                &lt;option property="colors">{colors.value}&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="contentElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="NoteContent Style" auto>.noteContent>.element-body {
    display: flex;
}

.noteContent {
    textarea {
        flex: 1 1 auto;
        resize: none;
        padding: 16px;
        font-size: 14px;
        background: #fff475;
    }

    textarea[data-color="Yellow"] {
        background: #fff475;
    }

    textarea[data-color="Red"] {
        background: #f28b82;
    }

    textarea[data-color="Blue"] {
        background: #cbf0f8;
    }

    textarea[data-color="Green"] {
        background: #ccff90;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="SketchContent" id="SketchContent"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The sketch content concept.",
    "dependencies": [
        "#ContentElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="SketchContent Concepts" auto>{
    "concepts": {
        "sketchContent": {
            "schema": {
                "baseURL": { "string": { "default": "https://beta.tldraw.com/r" }},
                "sessionId": "string"
            },
            "extensions": { "inject": [
                "element",
                "contentElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "opacityMixin",
                "stackableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="SketchContent Template" auto>&lt;dom-view-template>
    &lt;varv-template name="sketchContentBody">
        &lt;iframe src="{baseURL}/{sessionId}">&lt;/iframe>
    &lt;/varv-template>
    &lt;varv-template name="sketchContentOptions">
        &lt;label>
            Session:
            &lt;input value="{sessionId}">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="contentElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="SketchContent Style" auto>.sketchContent iframe {
    width: 100%;
    height: 100%;
    border: none;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ChatContent" name="ChatContent"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The chat content concept.",
    "dependencies": [
        "#Chat",
        "#ContentElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ChatContent Concepts" auto>{
    "concepts": {
        "chatContent": {
            "schema": {
                "chat": "chat"
            },
            "actions": {
                "createChatInElement": {
                    "when": { "click": { "view": "createChat" }},
                    "then": [
                        "newChat",
                        { "set": { "chat": "$newChat" }}
                    ]
                },
                "deleteChatInElement": {
                    "when": { "click": { "view": "deleteChat" }},
                    "then": [
                        { "get": "chat" },
                        { "set": { "chat": "" }},
                        { "select": "$get" },
                        "deleteChat"
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "contentElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "opacityMixin",
                "stackableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="ChatContent Template" auto>&lt;dom-view-template>
    &lt;varv-template name="chatContentBody">
        &lt;template-ref template-name="chat" property="chat">&lt;/template-ref>
    &lt;/varv-template>

    &lt;varv-template name="chatContentOptions">
        &lt;button view="createChat">Create New Chat&lt;/button>
        &lt;label>
            Chat:
            &lt;select value="{chat}">
                &lt;option concept="chat" value="{concept::uuid}">{name}&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;label property="chat">
            Name:
            &lt;input value="{name}">
        &lt;/label>
        &lt;button class="red" view="deleteChat" if="chat">Delete Chat&lt;/button>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="contentElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="ChatContent Style" auto>.chatContent .chat {
    width: 100%;
    height: 100%;

    .messages {
        &::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        /* Track */
        &::-webkit-scrollbar-track,
        &::-webkit-scrollbar-corner {
            background: none;
        }

        /* Handle */
        &::-webkit-scrollbar-thumb {
            background: #636363;
            border-radius: 4px;
        }

        /* Handle on hover */
        &::-webkit-scrollbar-thumb:hover {
            background: #848484;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="AvatarContent" name="AvatarContent"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The avatar content concept. Works together with proximity-based audio.",
    "dependencies": [
        "#ContentElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" auto name="AvatarContent Concepts">{
    "concepts": {
        "avatarContent": {
            "schema": {
                "user": "user",
                "avatarUrl": { "string": {
                    "default": "your-avatar-url.png"
                }},
                "distance": { "number": { "default": 10000 }},
                "inDistance": { "boolean": {
                    "derive": {
                        "properties": [ "distance" ],
                        "transform": [
                            { "eval": {
                                "property": "distance",
                                "lessThan": 150
                            }}
                        ]
                    }
                }}
            },
            "mappings": {
                "distance": [ "memory", "cauldron" ],
                "inDistance": [ "memory", "cauldron" ]
            },
            "actions": {
                "moveOwnRight": {
                    "when": { "key": { "key": "d" }},
                    "then": [
                        "selectOwnAvatarInRoom",
                        { "increment": { "property": "left", "by": 32 }}
                    ]
                },
                "moveOwnLeft": {
                    "when": { "key": { "key": "a" }},
                    "then": [
                        "selectOwnAvatarInRoom",
                        { "decrement": { "property": "left", "by": 32 }}
                    ]
                },
                "moveOwnDown": {
                    "when": { "key": { "key": "s" }},
                    "then": [
                        "selectOwnAvatarInRoom",
                        { "increment": { "property": "top", "by": 32 }}
                    ]
                },
                "moveOwnUp": {
                    "when": { "key": { "key": "w" }},
                    "then": [
                        "selectOwnAvatarInRoom",
                        { "decrement": { "property": "top", "by": 32 }}
                    ]
                },
                "selectOwnAvatarInRoom": [
                    { "select": "avatarContent" },
                    "checkInfullscreenRoom",
                    { "get": "userManager.localUser" },
                    { "where": {
                        "property": "user",
                        "equals": "$get"
                    }}
                ],
                "selectOtherAvatarsInRoom": [
                    { "select": "avatarContent" },
                    "checkInfullscreenRoom",
                    { "get": "userManager.localUser" },
                    { "where": {
                        "property": "user",
                        "unequals": "$get"
                    }}
                ],
                "updateDistance": {
                    "when": [
                        { "stateChanged": {
                            "concept": "avatarContent",
                            "property": "left"
                        }},
                        { "stateChanged": {
                            "concept": "avatarContent",
                            "property": "top"
                        }},
                        { "stateChanged": {
                            "concept": "client",
                            "property": "location"
                        }}
                    ],
                    "then": [
                        { "where": {
                            "property": "toolManager.proximityBasedAudioActive",
                            "equals": true,
                            "stopIfEmpty": true
                        }},
                        "selectOwnAvatarInRoom",
                        { "get": { "property": "left", "as": "ownLeft" }},
                        { "get": { "property": "top", "as": "ownTop" }},
                        { "select": "avatarContent" },
                        "checkInfullscreenRoom",
                        { "get": { "property": "left", "as": "otherLeft" }},
                        { "get": { "property": "top", "as": "otherTop" }},
                        { "calculate": {
                            "expression": "floor(sqrt(square($ownLeft$ - $otherLeft$) + square($ownTop$ - $otherTop$)))",
                            "as": "distance"
                        }},
                        { "set": { "distance": "$distance" }},
                        { "select": {
                            "property": "user",
                            "forEach": true
                        }},
                        { "select": {
                            "concept": "client",
                            "where": {
                                "property": "user",
                                "equals": "$lastTarget"
                            },
                            "forEach": true
                        }},
                        { "set": { "distance": "$distance" }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "contentElement",
                "movableMixin",
                "droppableMixin",
                "opacityMixin",
                "stackableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" auto name="AvatarContent Template">&lt;dom-view-template>
    &lt;varv-template name="avatarContentBody">
        &lt;img src="{avatarUrl}" class="avatar-image no-user" draggable="false" tabindex=0 if="!user" title="Missing User">
        &lt;img src="{avatarUrl}" class="avatar-image" data-in-distance="{inDistance}" draggable="false" tabindex=0 property="user" title="{name}">
    &lt;/varv-template>

    &lt;varv-template name="avatarContentOptions">
        &lt;label>
            User:
            &lt;select value="{user}">
                &lt;option value="">None&lt;/option>
                &lt;option concept="user" value="{concept::uuid}">{name}&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;label>
            Avatar URL:
            &lt;input value="{avatarUrl}">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="contentElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" auto name="AvatarContent Style">.avatarContent {
    background: none;
    border: none;
    width: 48px !important;
    height: 96px !important;
    padding: 4px;
    box-shadow: none !important;
    transition: left 100ms linear,
        top 100ms linear;

    .element-body {
        overflow: visible;

        .avatar-image {
            object-fit: scale-down;
            width: 100%;
            height: 100%;
            outline: none;
            transition: filter 350ms ease-in-out;

            &[data-in-distance="true"] {
                filter: drop-shadow(0 0 2px orange) drop-shadow(0 0 3px orange) drop-shadow(0 0 8px #cccccc);
            }

            &.no-user {
                filter: grayscale(100%) brightness(0.2);
            }
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE></DIV><DIV name="Tool Types"><WPM-PACKAGE id="GridTool" name="GridTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Changes the layout to a grid.",
    "dependencies": [
        "#WindowTools",
        "#ToolElement",
        "#ToolLayoutMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="GridTool Concepts" auto>{
    "concepts": {
        "gridTool": {
            "schema": {
                "gap": { "number": { "default": 8 }},
                "columnCount": { "number": {
                    "derive": {
                        "properties": [ "elementCount" ],
                        "transform": [
                            { "get": "elementCount" },
                            { "calculate": "ceil(sqrt($get$))" }
                        ]
                    }
                }},
                "rowCount": { "number": {
                    "derive": {
                        "properties": [ "elementCount" ],
                        "transform": [
                            { "get": "elementCount" },
                            { "calculate": "round(sqrt($get$))" }
                        ]
                    }
                }}
            },
            "actions": {
                "autoupdateElementSizes": {
                    "when": { "stateChanged": { "property": "elements" }},
                    "then": [
                        { "select": {
                            "concept": "gridTool",
                            "where": {
                                "property": "active",
                                "equals": true
                            },
                            "stopIfEmpty": true
                        }},
                        "checkInfullscreenRoom",
                        { "limit": 1 },
                        "updateElementSizes"
                    ]
                },
                "updateElementSizes": {
                    "when": { "click": { "view": "activateGridButton" }},
                    "then": [
                        { "elementRect": { "element": "varv-view > .meeting > .content" }},
                        { "get": {
                            "property": "columnCount",
                            "as": "columnCount"
                        }},
                        { "get": {
                            "property": "rowCount",
                            "as": "rowCount"
                        }},
                        { "get": {
                            "property": "gap",
                            "as": "gap"
                        }},
                        { "calculate": {
                            "expression": "$elementWidth$-(($columnCount$+1)*$gap$)",
                            "as": "elementSpaceWidth"
                        }},
                        { "calculate": {
                            "expression": "$elementHeight$-(($rowCount$+1)*$gap$)",
                            "as": "elementSpaceHeight"
                        }},
                        { "calculate": {
                            "expression": "floor($elementSpaceWidth$/$columnCount$)",
                            "as": "elementWidth"
                        }},
                        { "calculate": {
                            "expression": "floor($elementSpaceHeight$/$rowCount$)",
                            "as": "elementHeight"
                        }},
                        { "items": "elements" },
                        { "select": "$items" },
                        { "index": {
                            "of": { "variable": "items" },
                            "item": "$target",
                            "as": "gridIndex"
                        }},
                        { "calculate": {
                            "expression": "mod($gridIndex$, $columnCount$)",
                            "as": "columnIndex"
                        }},
                        { "calculate": {
                            "expression": "floor($gridIndex$/$columnCount$)",
                            "as": "rowIndex"
                        }},
                        { "set": { "top": { "calculate": "($rowIndex$ * $elementHeight$) + (($rowIndex$) * $gap$) + $gap$" }}},
                        { "set": { "left": { "calculate": "($columnIndex$ * $elementWidth$) + (($columnIndex$) * $gap$) + $gap$" }}},
                        { "set": { "width": "$elementWidth" }},
                        { "set": { "height": "$elementHeight" }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "toolLayoutMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="GridTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="gridToolBody">
        &lt;div class="tool-title">Grid Tool&lt;/div>
        &lt;button view="activateGridButton">Change to Grid&lt;/button>
    &lt;/varv-template>

    &lt;varv-template name="gridToolOptions">
        &lt;label>
            Continuous Active:
            &lt;input value="{active}" type="checkbox">
        &lt;/label>
        &lt;label>
            Gap:
            &lt;input value="{gap}" type="number">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="SpeakerViewTool" id="SpeakerViewTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Changes the layout to one big speaker and a film strip for other elements.",
    "dependencies": [
        "#WindowTools",
        "#ToolElement",
        "#ToolLayoutMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="SpeakerViewTool Concepts" auto>{
    "concepts": {
        "speakerViewTool": {
            "schema": {
                "speaker": "element"
            },
            "actions": {
                "speakerViewToolDrop": [
                    { "set": { "speaker": "$movedElement" }},
                    "updateElementSizes"
                ],
                "setSpeaker": {
                    "when": { "mousedown": { "view": "setSpeakerButton" }},
                    "then": [
                        { "get": "meeting.selectedElement"},
                        { "set": { "speaker": "$get" }},
                        "updateElementSizes"
                    ]
                },
                "autoupdateElementSizes": {
                    "then": [
                        { "select": {
                            "concept": "speakerViewTool",
                            "where": {
                                "property": "active",
                                "equals": true
                            },
                            "stopIfEmpty": true
                        }},
                        "checkInfullscreenRoom",
                        { "limit": 1 },
                        "updateElementSizes"
                    ]
                },
                "updateElementSizes": {
                    "when": { "click": { "view": "activateSpeakerViewButton" }},
                    "then": [
                        { "elementRect": { "element": "varv-view > .meeting > .content" }},
                        { "select": "speakerViewTool" },
                        "checkInfullscreenRoom",
                        { "limit": 1 },
                        { "get": {
                            "property": "speaker",
                            "as": "speaker"
                        }},
                        { "calculate": {
                            "expression": "$elementHeight$ * 0.75",
                            "as": "speakerHeight"
                        }},
                        { "calculate": {
                            "expression": "$elementHeight$ * 0.25",
                            "as": "audienceHeight"
                        }},
                        { "run": "updateSpeaker" },
                        { "run": "updateAudience" }
                    ]
                },
                "updateSpeaker": [
                    { "select": "$speaker" },
                    "checkInfullscreenRoom",
                    { "set": { "left": 8 }},
                    { "set": { "top": { "calculate": "$audienceHeight$ + 8" }}},
                    { "set": { "width": { "calculate": "$elementWidth$ - 16" }}},
                    { "set": { "height": { "calculate": "$speakerHeight$ - 16" }}}
                ],
                "updateAudience": [
                    { "get": {
                        "property": "elementCount",
                        "as": "elementCount"
                    }},
                    { "calculate": {
                        "expression": "($elementWidth$ - ($elementCount$ * 8)) / ($elementCount$ - 1)",
                        "as": "audienceWidth"
                    }},
                    { "get": "elements" },
                    { "index": {
                        "of": { "variable": "get" },
                        "item": "$speaker"
                    }},
                    { "removeItem": {
                        "of": { "variable": "get" },
                        "index": "$index"
                    }},
                    { "select": "$get" },
                    { "index": {
                        "of": { "variable": "get" },
                        "item": "$target",
                        "as": "columnIndex"
                    }},
                    { "set": { "left": { "calculate": "($columnIndex$ * ($audienceWidth$ + 8)) + 8" }}},
                    { "set": { "top": 8 }},
                    { "set": { "width": "$audienceWidth" }},
                    { "set": { "height": { "calculate": "$audienceHeight$ - 8" }}}
                ]
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "toolLayoutMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="SpeakerViewTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="speakerViewToolBody">
        &lt;div class="tool-title">Speaker View Tool&lt;/div>
        &lt;button view="activateSpeakerViewButton">Change to Speaker View&lt;/button>
        &lt;button view="setSpeakerButton">Set Element as Speaker&lt;/button>
    &lt;/varv-template>

    &lt;varv-template name="speakerViewToolOptions">
        &lt;label>
            Continuous Active:
            &lt;input value="{active}" type="checkbox">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="LayoutTemplateTool" id="LayoutTemplateTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Stores the current layout in a template.",
    "dependencies": [
        "#ToolElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="LayoutTemplateTool Concepts" auto>{
    "concepts": {
        "elementLayoutTemplate": {
            "schema": {
                "element": "element",
                "top": "number",
                "left": "number",
                "width": "number",
                "height": "number",
                "opacity": "number",
                "zIndex": "number"
            }
        },
        "layoutTemplateTool": {
            "schema": {
                "templateName": "string",
                "elementLayoutTemplates": { "array": "elementLayoutTemplate" }
            },
            "actions": {
                "layoutTemplateToolCleanup": [
                    { "items": "elementLayoutTemplates" },
                    { "select": "$items" },
                    "remove"
                ],
                "storeTemplate": {
                    "when": { "click": { "view": "storeTemplateButton" }},
                    "then": [
                        { "run": "cleanupTemplates" },
                        { "set": {
                            "variable": "originaltemplateTool",
                            "value": "$target"
                        }},
                        { "get": "parentRoom" },
                        { "select": {
                            "concept": "element",
                            "where": {
                                "property": "parentRoom",
                                "equals": "$get"
                            },
                            "stopIfEmpty": true
                        }},
                        { "new": {
                            "concept": "elementLayoutTemplate",
                            "with": {
                                "element": "$target",
                                "top": "$target.top",
                                "left": "$target.left",
                                "width": "$target.width",
                                "height": "$target.height",
                                "opacity": "$target.opacity",
                                "zIndex": "$target.zIndex"
                            },
                            "forEach": true,
                            "select": "false"
                        }},
                        { "select": {
                            "target": "$originaltemplateTool",
                            "forEach": true
                        }},
                        { "append": {
                            "property": "elementLayoutTemplates",
                            "item": "$new"
                        }}
                    ]
                },
                "restoreTemplate": {
                    "when": { "click": { "view": "restoreTemplateButton" }},
                    "then": [
                        { "get": "meeting.fullscreenRoom" },
                        { "set": { "$fullscreenRoom": "$get" }},
                        { "items": {
                            "property": "elementLayoutTemplates",
                            "as": "elementLayoutTemplates"
                        }},
                        { "select": {
                            "target": "$elementLayoutTemplates",
                            "stopIfEmpty": true
                        }},
                        { "restoreProperty": { "propertyName": "top" }},
                        { "restoreProperty": { "propertyName": "left" }},
                        { "restoreProperty": { "propertyName": "width" }},
                        { "restoreProperty": { "propertyName": "height" }},
                        { "restoreProperty": { "propertyName": "opacity" }},
                        { "restoreProperty": { "propertyName": "zIndex" }}
                    ]
                },
                "cleanupTemplates": [
                    { "items": "elementLayoutTemplates" },
                    { "select": {
                        "target": "$items",
                        "stopIfEmpty": true
                    }},
                    "remove"
                ],
                "restoreProperty": [
                    { "get": "@propertyName" },
                    { "select": {
                        "property": "element",
                        "forEach": true
                    }},
                    { "where": {
                        "property": "parentRoom",
                        "equals": "$fullscreenRoom",
                        "stopIfEmpty": true
                    }},
                    { "set": { "@propertyName": "$get" }},
                    { "select": "$elementLayoutTemplates" }
                ]
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="LayoutTemplateTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="layoutTemplateToolBody">
        &lt;div class="tool-title">Layout Template Tool&lt;/div>
        &lt;button view="storeTemplateButton">Store Template&lt;/button>
        &lt;button view="restoreTemplateButton">Restore Template&lt;/button>
    &lt;/varv-template>

    &lt;varv-template name="layoutTemplateToolOptions">
        &lt;label>
            Template Name:
            &lt;input value="{templateName}">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="HighlightTool" id="HighlightTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Allows to globally highlight elements.",
    "dependencies": [
        "#ToolElement",
        "#ToolFunctionMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="HighlightTool Concepts" auto>{
    "concepts": {
        "highlightTool": {
            "schema": {
                "placeholder": "string"
            },
            "actions": {
                "checkHighlightActive": [
                    { "exists": {
                        "concept": "highlightTool",
                        "where": {
                            "property": "isActive",
                            "equals": true
                        }
                    }},
                    { "where": {
                        "variable": "exists",
                        "equals": true,
                        "stopIfEmpty": true
                    }}
                ]
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "toolFunctionMixin"
            ]}
        },
        "element": {
            "schema": {
                "globalHighlighted": "boolean"
            }
        },
        "meeting": {
            "actions": {
                "resetGlobalHighlightOnFullscreenClick": {
                    "when": { "click": { "concept": "element" }},
                    "then": [
                        "checkHighlightActive",
                        "checkIsfullscreenRoom",
                        "resetGlobalHighlight"
                    ]
                },
                "resetGlobalHighlight": [
                    { "select": "element" },
                    "checkInfullscreenRoom",
                    { "set": { "globalHighlighted": false }}
                ],
                "setGlobalHighlight": {
                    "when": { "mousedown": { "concept": "contentElement" }},
                    "then": [
                        "checkHighlightActive",
                        "checkInfullscreenRoom",
                        { "where": {
                            "property": "selected",
                            "equals": true,
                            "stopIfEmpty": true
                        }},
                        { "run": "resetGlobalHighlight" },
                        { "set": { "globalHighlighted": true }}
                    ]
                }
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="HighlightTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="highlightToolBody">
        &lt;div class="tool-title">Highlight Tool&lt;/div>
        &lt;template-ref template-name="toolFunctionMixinBody">&lt;/template-ref>
    &lt;/varv-template>

    &lt;varv-template name="highlightToolOptions">
        &lt;template-ref template-name="toolFunctionMixinOptions">&lt;/template-ref>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>

    &lt;varv-template name="element">
        &lt;div class="element {elementType}" style="left: {left}px; top: {top}px; width: {width}px; height: {height}px; opacity: {opacity}; z-index: {zIndex}" tabindex=0 data-selected="{selected}" data-is-being-moved="{isBeingMoved}" data-is-resizing="{isResizing}" data-is-drop-target="{isDropTarget}" data-is-content="{isContent}" data-is-room="{isRoom}" data-is-tool="{isTool}" data-is-global-highlighted="{globalHighlighted}">
            &lt;div class="element-body">
                &lt;template-ref template-name="{elementType}Body">&lt;/template-ref>
            &lt;/div>
            &lt;div class="move-handle" view="moveHandle" if="concept movableMixin">&lt;/div>
            &lt;div class="resize-handle" view="resizeHandle" if="concept resizableMixin" title="{elementType}">&lt;/div>
        &lt;/div>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="HighlightTool Style" auto>.element[data-is-global-highlighted="true"] {
    outline: 4px solid #EEFF41;
    box-shadow: 0 0 16px #EEFF41;
    z-index: 900 !important;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="CameraShakerTool" id="CameraShakerTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Shakes the camera content of users that speak loudly.",
    "dependencies": [
        "#ToolElement",
        "#ToolFunctionMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="CameraShakerTool Concepts" auto>{
    "concepts": {
        "cameraShakerTool": {
            "schema": {
                "placeholder": "string"
            },
            "actions": {
                "checkcameraShakerActive": [
                    { "exists": {
                        "concept": "cameraShakerTool",
                        "where": {
                            "property": "isActive",
                            "equals": true
                        }
                    }},
                    { "where": {
                        "variable": "exists",
                        "equals": true,
                        "stopIfEmpty": true
                    }}
                ],
                "updateShakingState": {
                    "when": { "stateChanged": {
                        "concept": "client",
                        "property": "analyserVolumeString"
                    }},
                    "then": [
                        { "get": "cameraStream" },
                        { "select": {
                            "concept": "cameraContent",
                            "where": {
                                "property": "cameraStream",
                                "equals": "$get"
                            },
                            "stopIfEmpty": true
                        }},
                        "checkInfullscreenRoom",
                        { "set": { "shaking": false }},
                        "checkcameraShakerActive",
                        { "where": {
                            "variable": "currentValue",
                            "equals": "loud",
                            "stopIfEmpty": true
                        }},
                        { "set": { "shaking": true }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "toolFunctionMixin"
            ]}
        },
        "cameraContent": {
            "schema": {
                "shaking": "boolean"
            },
            "mappings": {
                "shaking": [ "memory", "cauldron" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="CameraShakerTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="cameraShakerToolBody">
        &lt;div class="tool-title">Camera Shaker Tool&lt;/div>
        &lt;template-ref template-name="toolFunctionMixinBody">&lt;/template-ref>
    &lt;/varv-template>

    &lt;varv-template name="cameraShakerToolOptions">
        &lt;template-ref template-name="toolFunctionMixinOptions">&lt;/template-ref>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>

    &lt;varv-template name="cameraContentBody">
        &lt;div class="element-title" property="cameraStream">
            &lt;span property="client">
                &lt;span property="user">{name}: &lt;/span>{name}
            &lt;/span>
        &lt;/div>
        &lt;div class="placeholder-icon m-ico">photo_camera&lt;/div>
        &lt;video property="cameraStream" data-stream="{id}" data-stream-type="camera" style="object-fit: {fit}; width: {videoWidth}px; height: {videoHeight}px; left: -{cropOffsetLeftCorrected}%; top: -{cropOffsetTopCorrected}%;" data-client-in-room="{clientInRoom}" data-shaking="{shaking}">&lt;/video>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="CameraShakerTool Style" auto>.cameraContent video[data-stream-type="camera"][data-shaking="true"] {
    animation: shake 0.5s;
    animation-iteration-count: infinite;
    filter: contrast(200%);
}

// https://www.w3schools.com/howto/howto_css_shake_image.asp
@keyframes shake {
    0% { transform: scaleX(-1) scale(1.1) translate(1px, 1px) rotate(0deg); }
    10% { transform: scaleX(-1) scale(1.1) translate(-1px, -2px) rotate(-1deg); }
    20% { transform: scaleX(-1) scale(1.1) translate(-3px, 0px) rotate(1deg); }
    30% { transform: scaleX(-1) scale(1.1) translate(3px, 2px) rotate(0deg); }
    40% { transform: scaleX(-1) scale(1.1) translate(1px, -1px) rotate(1deg); }
    50% { transform: scaleX(-1) scale(1.1) translate(-1px, 2px) rotate(-1deg); }
    60% { transform: scaleX(-1) scale(1.1) translate(-3px, 1px) rotate(0deg); }
    70% { transform: scaleX(-1) scale(1.1) translate(3px, 1px) rotate(-1deg); }
    80% { transform: scaleX(-1) scale(1.1) translate(-1px, -1px) rotate(1deg); }
    90% { transform: scaleX(-1) scale(1.1) translate(1px, 2px) rotate(0deg); }
    100% { transform: scaleX(-1) scale(1.1) translate(1px, -2px) rotate(-1deg); }
  }
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="RecordingTool" id="RecordingTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Records a single camera feed.",
    "dependencies": [
        "#RecordingTools",
        "#ToolElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="RecordingTool Concepts" auto>{
    "concepts": {
        "recordingTool": {
            "schema": {
                "isRecording": "boolean",
                "showRecordingEmbedded": "boolean",
                "lastRecordingUrl": "string"
            },
            "mappings": {
                "isRecording": [ "memory", "cauldron" ]
            },
            "actions": {
                "recordingToolDrop": [
                    { "select": "$movedElement" },
                    "getType",
                    { "where": {
                        "variable": "getType",
                        "equals": "cameraContent"
                    }},
                    { "get": "cameraStream" },
                    { "select": "$get" },
                    { "get": "id" },
                    { "startRecording": {
                        "streamId": "$get",
                        "source": "$targetElement"
                    }},
                    { "select": "$targetElement" },
                    { "set": { "isRecording": true }}
                ],
                "stopRecording": {
                    "when": { "click": { "view": "stopRecordingButton" }},
                    "then": [
                        "stopRecording",
                        { "set": { "isRecording": false }}
                    ]
                },
                "handleNewRecording": {
                    "then": [
                        "debugContext",
                        { "select": "meeting" },
                        { "get": { "property": "fullscreenRoom", "as": "parent" }},
                        { "new": {
                            "concept": "videoContent",
                            "with": {
                                "videoUrl": "$recordingUrl",
                                "parentRoom": "$parent"
                            }
                        }},
                        { "select": {
                            "target": "$source",
                            "stopIfEmpty": true
                        }},
                        { "set": { "lastRecordingUrl": "$recordingUrl" }}
                    ]
                },
                "handleNewRecordingEmbedded": {
                    "when": "newRecording",
                    "then": [
                        { "select": {
                            "target": "$source",
                            "stopIfEmpty": true
                        }},
                        { "set": { "lastRecordingUrl": "$recordingUrl" }},
                        { "where": {
                            "property": "showRecordingEmbedded",
                            "equals": false,
                            "stopIfEmpty": true
                        }},
                        { "get": { "property": "fullscreenRoom", "as": "parent" }},
                        { "new": {
                            "concept": "videoContent",
                            "with": {
                                "videoUrl": "$recordingUrl",
                                "parentRoom": "$parent"
                            }
                        }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="RecordingTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="recordingToolBody">
        &lt;div class="tool-title">Recording Tool&lt;/div>
        &lt;video if="showRecordingEmbedded" src="{lastRecordingUrl}" class="recording-video" draggable="false" controls>&lt;/video>
        &lt;label if="!showRecordingEmbedded">Drop Video to Start Recording&lt;/label>
        &lt;label if="isRecording">Recording video ...&lt;/label>
        &lt;button view="stopRecordingButton" if="isRecording">Stop Recording&lt;/button>
    &lt;/varv-template>

    &lt;varv-template name="recordingToolOptions">
        &lt;label>
            Show recording embedded:
            &lt;input value="{showRecordingEmbedded}" type="checkbox">
        &lt;/label>
        &lt;label if="showRecordingEmbedded">
            Last recording URL:
            &lt;input value="{lastRecordingUrl}">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="RecordingTool Style" auto>.recordingTool .recording-video {
    width: 100%;
    border-radius: 4px;
    flex: 1 0 auto;
    object-fit: cover;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="RoomRecordingTool" id="RoomRecordingTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Records the whole workspace of a room (not working on GitHub release of Mirrorverse).",
    "dependencies": [
        "#RecordingTools",
        "#ToolElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="RoomRecordingTool Concepts" auto>{
    "concepts": {
        "roomRecordingTool": {
            "schema": {
                "placeholder": "string",
                "isRecording": "boolean"
            },
            "mappings": {
                "isRecording": [ "memory", "cauldron" ]
            },
            "actions": {
                "startRecording": {
                    "when": { "click": { "view": "startRoomRecordingButton" }},
                    "then": [
                        { "get": "meeting.fullscreenRoom" },
                        { "startRoomRecording": { "fullscreenRoom": "$get" }},
                        { "set": { "isRecording": true }}
                    ]
                },
                "stopRecording": {
                    "when": { "click": { "view": "stopRoomRecordingButton" }},
                    "then": [
                        "stopRoomRecording",
                        { "set": { "isRecording": false }}
                    ]
                },
                "handleNewRoomRecording": {
                    "when": "newRoomRecording",
                    "then": [
                        { "select": "meeting" },
                        { "get": { "property": "fullscreenRoom", "as": "parent" }},
                        { "new": {
                            "concept": "videoContent",
                            "with": {
                                "videoUrl": "$recordingUrl",
                                "parentRoom": "$parent"
                            }
                        }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin"
            ]}
        },
        "meeting": {
            "schema": {
                "videostrates": "boolean",
                "videostratesFullscreenRoom": "roomElement"
            },
            "mappings": {
                "videostrates": [ "location", "cauldron" ],
                "videostratesFullscreenRoom": [ "location", "cauldron" ]
            },
            "actions": {
                "videostrates": {
                    "when": { "interval": 5000 },
                    "then": [
                        { "where": {
                            "property": "meeting.videostrates",
                            "equals": true,
                            "stopIfEmpty": true
                        }},
                        { "get": "meeting.videostratesFullscreenRoom" },
                        { "where": {
                            "property": "meeting.fullscreenRoom",
                            "unequals": "$get",
                            "stopIfEmpty": true
                        }},
                        { "set": { "meeting.fullscreenRoom": "$get" }}
                    ]
                }
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="RoomRecordingTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="roomRecordingToolBody">
        &lt;div class="tool-title">Room Recording Tool&lt;/div>
        &lt;button view="startRoomRecordingButton" if="!isRecording">Start Room Recording&lt;/button>
        &lt;button view="stopRoomRecordingButton" if="isRecording">Stop Room Recording&lt;/button>
    &lt;/varv-template>

    &lt;varv-template name="roomRecordingToolOptions">
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Videostrates Recording Style" auto>.meeting[data-videostrates="true"] {
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    align-items: flex-start;
    justify-content: flex-start;

    .header,
    .panel-group,
    .sidebar {
        display: none;
    }

    .content {
        border-radius: 0;

        .element-title,
        .client-overview {
            display: none;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="DoorwayTool" id="DoorwayTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Allows listening into rooms.",
    "dependencies": [
        "#WindowTools",
        "#ToolElement",
        "#ToolFunctionMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="DoorwayTool Concepts" auto>{
    "concepts": {
        "doorwayTool": {
            "schema": {
                "placholder": "string"
            },
            "actions": {
                "updateIsHoveredForListeningIn": {
                    "when": { "interval": 1000 },
                    "then": [
                        { "where": {
                            "property": "toolManager.doorwayActive",
                            "equals": true,
                            "stopIfEmpty": true
                        }},
                        { "select": "roomElement" },
                        "checkInfullscreenRoom",
                        { "run": "resetIsHoveredForListeningIn" },
                        "cursorPosition",
                        "correctCursorPosition",
                        { "where": {
                            "and": [
                                { "variable": "x", "greaterThan": "$target.left" },
                                { "variable": "x", "lessThan": { "calculate": "$target.left$+$target.width$" } },
                                { "variable": "y", "greaterThan": { "calculate": "$target.top$" }},
                                { "variable": "y", "lessThan": { "calculate": "$target.top$+$target.height$" }}
                            ],
                            "stopIfEmpty": true
                        }},
                        { "set": { "isHoveredForListeningIn": true }},
                        { "select": { "property": "clients", "forEach": true }},
                        { "set": { "inHoveredRoom": true }}
                    ]
                },
                "resetIsHoveredForListeningIn": [
                    { "set": { "isHoveredForListeningIn": false }},
                    { "select": { "property": "clients", "forEach": true }},
                    { "set": { "inHoveredRoom": false }}
                ]
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "toolFunctionMixin"
            ]}
        },
        "roomElement": {
            "schema": {
                "isHoveredForListeningIn": "boolean"
            },
            "mappings": {
                "isHoveredForListeningIn": [ "memory", "cauldron" ]
            }
        },
        "toolManager": {
            "schema": {
                "doorwayActive": { "boolean": {
                    "derive": {
                        "properties": [ "doorwayTool.isActive" ],
                        "transform": [
                            { "exists": {
                                "concept": "doorwayTool",
                                "where": {
                                    "property": "isActive",
                                    "equals": true
                                }
                            }}
                        ]
                    }
                }},
                "doorwayHoveredExists": { "boolean": {
                    "derive": {
                        "properties": [ "regularRoom.isHoveredForListeningIn" ],
                        "transform": [
                            { "exists": {
                                "concept": "roomElement",
                                "where": {
                                    "property": "isHoveredForListeningIn",
                                    "equals": true
                                }
                            }}
                        ]
                    }
                }}
            },
            "mappings": {
                "doorwayActive": [ "memory", "cauldron" ],
                "doorwayHoveredExists": [ "memory", "cauldron" ]
            }
        },
        "client": {
            "schema": {
                "inHoveredRoom": "boolean"
            },
            "mappings": {
                "inHoveredRoom": [ "memory", "cauldron" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="DoorwayMirror Template" auto>&lt;dom-view-template>
    &lt;varv-template name="doorwayToolBody">
        &lt;div class="tool-title">Doorway Tool&lt;/div>
        &lt;template-ref template-name="toolFunctionMixinBody">&lt;/template-ref>
    &lt;/varv-template>

    &lt;varv-template name="doorwayToolOptions">
        &lt;template-ref template-name="toolFunctionMixinOptions">&lt;/template-ref>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="DoorwayTool Volume Routing" auto>{
  "rootConnections": {
    "volume": {
      "position": {
        "x": 2745.75,
        "y": 2616
      },
      "connection": "19raEkariU"
    }
  },
  "nodes": {
    "NJze4UOYlA": {
      "nodeType": "ValueNode",
      "value": 0,
      "position": {
        "x": 2643.75,
        "y": 3575
      },
      "type": "volume"
    },
    "S9gcODgW3g": {
      "nodeType": "ValueNode",
      "value": 0.5,
      "position": {
        "x": 2799.75,
        "y": 3572
      },
      "type": "volume"
    },
    "2bTYSJ6bNB": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 2946.75,
        "y": 3575
      },
      "type": "volume"
    },
    "LgEjFUx25k": {
      "nodeType": "DecisionNode",
      "name": "volumeClientLogicalDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 3,
      "decisions": [
        {
          "comparator": "greaterThan",
          "value": 1,
          "connection": "NJze4UOYlA"
        },
        {
          "comparator": "equals",
          "value": 1,
          "connection": "S9gcODgW3g"
        },
        {
          "comparator": "equals",
          "value": 0,
          "connection": "2bTYSJ6bNB"
        }
      ],
      "position": {
        "x": 2658.75,
        "y": 3359
      }
    },
    "RLbhSiMhtj": {
      "nodeType": "ValueNode",
      "value": 0,
      "position": {
        "x": 2895.75,
        "y": 3295
      },
      "type": "volume"
    },
    "umLpbpAwFh": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 3038.75,
        "y": 3292
      },
      "type": "volume"
    },
    "ke15KV1cSe": {
      "nodeType": "DecisionNode",
      "name": "volumeClientInHovered",
      "concept": "client",
      "property": "inHoveredRoom",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "RLbhSiMhtj"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "umLpbpAwFh"
        }
      ],
      "position": {
        "x": 2898.75,
        "y": 3105
      }
    },
    "73Ca7JJHAw": {
      "nodeType": "DecisionNode",
      "name": "volumeExistsHovered",
      "concept": "toolManager",
      "property": "doorwayHoveredExists",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "LgEjFUx25k"
        },
        {
          "comparator": "equals",
          "value": false,
          "connection": "ke15KV1cSe"
        }
      ],
      "position": {
        "x": 2770.75,
        "y": 2914
      }
    },
    "19raEkariU": {
      "nodeType": "DecisionNode",
      "name": "volumedoorwayActive",
      "concept": "toolManager",
      "property": "doorwayActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "LgEjFUx25k"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "73Ca7JJHAw"
        }
      ],
      "position": {
        "x": 2657.75,
        "y": 2720
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="DoorwayTool Filter Routing" auto>{
  "rootConnections": {
    "audioFilter": {
      "position": {
        "x": 2647.25,
        "y": 2560
      },
      "connection": "3qEccHXEYd"
    }
  },
  "nodes": {
    "K3uZTNW6VQ": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2563.25,
        "y": 3271
      },
      "type": "audioFilter"
    },
    "FUf0416U07": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2714.25,
        "y": 3635
      },
      "type": "audioFilter"
    },
    "rScKXNSFIH": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2893.25,
        "y": 3634
      },
      "type": "audioFilter"
    },
    "C5E6P2PNS1": {
      "nodeType": "DecisionNode",
      "name": "filterLocationHasFilter",
      "concept": "currentRoom",
      "property": "audioFilter",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": "",
          "connection": "FUf0416U07"
        },
        {
          "comparator": "unequals",
          "value": "",
          "connection": "rScKXNSFIH"
        }
      ],
      "position": {
        "x": 2705.25,
        "y": 3433
      }
    },
    "1kWhmMpUFO": {
      "nodeType": "DecisionNode",
      "name": "filterClientLogicalDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 1,
          "connection": "K3uZTNW6VQ"
        },
        {
          "comparator": "equals",
          "value": 0,
          "connection": "C5E6P2PNS1"
        }
      ],
      "position": {
        "x": 2565.25,
        "y": 3032
      }
    },
    "g2JEiwDI38": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2845.25,
        "y": 3283
      },
      "type": "audioFilter"
    },
    "UrFfooDXhs": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 3004.25,
        "y": 3282
      },
      "type": "audioFilter"
    },
    "fOt7eLofpb": {
      "nodeType": "DecisionNode",
      "name": "filterClientInHovered",
      "concept": "client",
      "property": "inHoveredRoom",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "g2JEiwDI38"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "UrFfooDXhs"
        }
      ],
      "position": {
        "x": 2858.25,
        "y": 3061
      }
    },
    "bm9IK40lob": {
      "nodeType": "DecisionNode",
      "name": "filterExistsHovered",
      "concept": "toolManager",
      "property": "doorwayHoveredExists",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "1kWhmMpUFO"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "fOt7eLofpb"
        }
      ],
      "position": {
        "x": 2846.25,
        "y": 2837
      }
    },
    "3qEccHXEYd": {
      "nodeType": "DecisionNode",
      "name": "filterDoorwayActive",
      "concept": "toolManager",
      "property": "doorwayActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "1kWhmMpUFO"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "bm9IK40lob"
        }
      ],
      "position": {
        "x": 2561.25,
        "y": 2667
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="ProximityBasedAudioTool" id="ProximityBasedAudioTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Proximity-based audio in a room. Uses the avatar content elements.",
    "dependencies": [
        "#FindAction",
        "#ToolElement",
        "#ToolFunctionMixin",
        "#AvatarContent"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="ProximityBasedAudioTool Concepts" auto>{
    "concepts": {
        "proximityBasedAudioTool": {
            "schema": {
                "placeholder": "string",
                "proximityUsersWithoutPodium": { "array": {
                    "items": "user",
                    "derive": {
                        "properties": [
                            "avatarContent.distance",
                            "meeting.fullscreenRoom"
                        ],
                        "transform": [
                            { "get": { "property": "meeting.fullscreenRoom", "as": "fullscreen" }},
                            { "select": {
                                "concept": "avatarContent",
                                "where": { "and": [
                                    { "property": "parentRoom", "equals": "$fullscreen" },
                                    { "property": "distance", "lessThan": 150 }
                                ]}
                            }},
                            { "find": { "property": "user" }}
                        ]
                    }
                }}
            },
            "mappings": {
                "proximityUsers": [ "memory", "cauldron" ]
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "toolFunctionMixin"
            ]}
        },
        "user": {
            "schema": {
                "proximityClients": { "array": {
                    "items": "client",
                    "derive": {
                        "properties": [
                            "client.location",
                            "client.user",
                            "meeting.fullscreenRoom"
                        ],
                        "transform": [
                            { "get": { "property": "meeting.fullscreenRoom", "as": "fullscreen" }},
                            { "find": {
                                "concept": "client",
                                "where": { "and": [
                                    { "property": "location", "equals": "$fullscreen" },
                                    { "property": "user", "equals": "$lastTarget" }
                                ]}
                            }}
                        ]
                    }
                }}
            },
            "mappings": {
                "proximityClients": [ "memory", "cauldron" ]
            }
        },
        "toolManager": {
            "schema": {
                "proximityBasedAudioActive": { "boolean": {
                    "derive": {
                        "properties": [ "proximityBasedAudioTool.isActive" ],
                        "transform": [
                            { "exists": {
                                "concept": "proximityBasedAudioTool",
                                "where": {
                                    "property": "isActive",
                                    "equals": true
                                }
                            }}
                        ]
                    }
                }}
            },
            "mappings": {
                "proximityBasedAudioActive": [ "memory", "cauldron" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="ProximityBasedAudioTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="proximityBasedAudioToolBody">
        &lt;div class="tool-title">Proximity-based Audio Tool&lt;/div>
        &lt;div property="proximityUsers" class="proximity-users">
            &lt;div class="user-title">{name}&lt;/div>
            &lt;div property="proximityClients" class="proximity-clients" title="Client {name}">
                &lt;div class="video-title">{name}&lt;/div>
                &lt;video property="cameraStream" data-stream="{id}" data-stream-type="camera">
                &lt;/video>
            &lt;/div>
        &lt;/div>
    &lt;/varv-template>

    &lt;varv-template name="proximityBasedAudioToolOptions">
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="ProximityBasedAudioTool Style" auto>@mixin heading-font {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}



.proximityBasedAudioTool>.element-body {
    flex-wrap: nowrap !important;
    flex-direction: column !important;

    .proximity-users {
        flex: 1 1 auto;

        @include heading-font;
        text-align: center;

        display: flex;
        flex-wrap: nowrap;
        flex-direction: column;
        gap: 4px;

        background: #424242;
        border-radius: 8px;
        padding: 4px;

        .user-title {
            padding: 2px 0;
        }

        .proximity-clients {
            flex: 1 1 144px;
            background: #333333;
            border: 1px solid #848484;
            border-radius: 8px;
            overflow: hidden;
            position: relative;

            .video-title {
                @include heading-font;

                position: absolute;
                top: 0px;
                left: 0px;
                height: 16px;

                background: #848484;
                color: #fff;

                border-bottom-right-radius: 6px;
                border-top-left-radius: 4px;

                line-height: 16px;
                padding: 2px 8px;
                user-select: none;

                &:empty {
                    display: none;
                }
            }

            video {
                width: 100% !important;
                height: 100% !important;
                object-fit: cover;
                transform: scaleX(-1);
                border-radius: 8px;
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="ProximityBasedAudioTool Muted Routing" auto>{
  "rootConnections": {
    "muted": {
      "position": {
        "x": 2765.800048828125,
        "y": 2603.5
      },
      "connection": "ZmEA2h52Xn"
    }
  },
  "nodes": {
    "cOws1LEgka": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2606.199951171875,
        "y": 3221.7125358581543
      },
      "type": "muted"
    },
    "Sw0B1x9Vm9": {
      "nodeType": "ValueNode",
      "value": false,
      "position": {
        "x": 2685.800048828125,
        "y": 3393.5
      },
      "type": "muted"
    },
    "0AuPuPxxYm": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2806.800048828125,
        "y": 3598.5
      },
      "type": "muted"
    },
    "0t8RSi0qGv": {
      "nodeType": "ValueNode",
      "value": false,
      "position": {
        "x": 2951.800048828125,
        "y": 3600.5
      },
      "type": "muted"
    },
    "L9CueKVYRa": {
      "nodeType": "DecisionNode",
      "name": "mutedInProximityDistance",
      "concept": "client",
      "property": "distance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 150,
          "connection": "0AuPuPxxYm"
        },
        {
          "comparator": "lessThan",
          "value": 150,
          "connection": "0t8RSi0qGv"
        }
      ],
      "position": {
        "x": 2833.800048828125,
        "y": 3386.5
      }
    },
    "pWndXjd86V": {
      "nodeType": "DecisionNode",
      "name": "mutedproximityBasedAudioActive",
      "concept": "toolManager",
      "property": "proximityBasedAudioActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "Sw0B1x9Vm9"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "L9CueKVYRa"
        }
      ],
      "position": {
        "x": 2746.800048828125,
        "y": 3185.5
      }
    },
    "rYSeeaKep4": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientInDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 2,
          "connection": "cOws1LEgka"
        },
        {
          "comparator": "lessThan",
          "value": 2,
          "connection": "pWndXjd86V"
        }
      ],
      "position": {
        "x": 2611.800048828125,
        "y": 2987.3124504089355
      }
    },
    "4GpHRhnuOX": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2763.000030517578,
        "y": 2906.312511444092
      },
      "type": "muted"
    },
    "ZmEA2h52Xn": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientMuted",
      "concept": "client",
      "property": "muted",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "rYSeeaKep4"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "4GpHRhnuOX"
        }
      ],
      "position": {
        "x": 2678.800048828125,
        "y": 2713.5
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="PodiumTool" name="PodiumTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A podium to talk to all avatars when using proximity-based audio.",
    "dependencies": [
        "#FindAction",
        "#ToolElement",
        "#ProximityBasedAudioTool"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" auto name="PodiumTool Concepts">{
    "concepts": {
        "podiumTool": {
            "schema": {
                "inToolPanel": { "boolean": { "default": false }}
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin"
            ]}
        },
        "client": {
            "schema": {
                "onPedestal": "boolean"
            }
        },
        "avatarContent": {
            "schema": {
                "onPedestal": "boolean"
            },
            "actions": {
                "updatePedestal": {
                    "when": [
                        { "stateChanged": {
                            "concept": "avatarContent",
                            "property": "left"
                        }},
                        { "stateChanged": {
                            "concept": "avatarContent",
                            "property": "top"
                        }},
                        { "stateChanged": {
                            "concept": "podiumTool",
                            "property": "left"
                        }},
                        { "stateChanged": {
                            "concept": "podiumTool",
                            "property": "top"
                        }},
                        { "stateChanged": {
                            "concept": "client",
                            "property": "location"
                        }}
                    ],
                    "then": [
                        { "where": {
                            "property": "toolManager.proximityBasedAudioActive",
                            "equals": true,
                            "stopIfEmpty": true
                        }},
                        "selectOwnAvatarInRoom",
                        { "set": { "onPedestal": false }},
                        { "set": { "variable": "myAvatar", "value": "$target" }},
                        { "get": { "property": "left", "as": "ownLeft" }},
                        { "get": { "property": "top", "as": "ownTop" }},
                        { "select": "podiumTool" },
                        "checkInfullscreenRoom",
                        { "limit": 1 },
                        { "get": { "property": "left", "as": "otherLeft" }},
                        { "get": { "property": "top", "as": "otherTop" }},
                        { "calculate": {
                            "expression": "floor(sqrt(square($ownLeft$ - $otherLeft$) + square($ownTop$ - $otherTop$)))",
                            "as": "distance"
                        }},
                        { "eval": {
                            "variable": "distance",
                            "lessThan": 150
                        }},
                        { "select": "$myAvatar" },
                        { "set": { "onPedestal": "$eval" }},
                        { "select": {
                            "property": "user",
                            "forEach": true
                        }},
                        { "select": {
                            "concept": "client",
                            "where": {
                                "property": "user",
                                "equals": "$lastTarget"
                            },
                            "forEach": true
                        }},
                        { "set": { "onPedestal": "$eval" }}
                    ]
                }
            }
        },
        "proximityBasedAudioTool": {
            "schema": {
                "proximityUsers": { "array": {
                    "items": "user",
                    "derive": {
                        "properties": [
                            "avatarContent.distance",
                            "avatarContent.onPedestal",
                            "meeting.fullscreenRoom"
                        ],
                        "transform": [
                            { "get": { "property": "meeting.fullscreenRoom", "as": "fullscreen" }},
                            { "select": {
                                "concept": "avatarContent",
                                "where": { "and": [
                                    { "property": "parentRoom", "equals": "$fullscreen" },
                                    { "or": [
                                        { "property": "distance", "lessThan": 150 },
                                        { "property": "onPedestal", "equals": true }
                                    ]}
                                ]}
                            }},
                            { "find": { "property": "user" }}
                        ]
                    }
                }}
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" auto name="PodiumTool Template">&lt;dom-view-template>
    &lt;varv-template name="podiumToolBody">
        &lt;div class="tool-title">Podium Tool&lt;/div>
    &lt;/varv-template>

    &lt;varv-template name="podiumToolOptions">
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>

    &lt;varv-template name="avatarContentBody">
        &lt;img src="{avatarUrl}" class="avatar-image no-user" draggable="false" tabindex=0 if="!user" title="Missing User">
        &lt;img src="{avatarUrl}" class="avatar-image" data-in-distance="{inDistance}" data-on-pedestal="{onPedestal}" draggable="false" tabindex=0 property="user" title="{name}">
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" auto name="PodiumTool Style">.avatarContent>.element-body .avatar-image[data-on-pedestal="true"] {
    filter: drop-shadow(0 0 2px red) drop-shadow(0 0 3px red) drop-shadow(0 0 8px #cccccc);
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="PodiumTool Muted Routing" auto>{
  "rootConnections": {
    "muted": {
      "position": {
        "x": 2664.300048828125,
        "y": 2538.5
      },
      "connection": "ZmEA2h52Xn"
    }
  },
  "nodes": {
    "cOws1LEgka": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2579.699951171875,
        "y": 3148.7125358581543
      },
      "type": "muted"
    },
    "Sw0B1x9Vm9": {
      "nodeType": "ValueNode",
      "value": false,
      "position": {
        "x": 2659.300048828125,
        "y": 3320.5
      },
      "type": "muted"
    },
    "0AuPuPxxYm": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2578.300048828125,
        "y": 3718.5
      },
      "type": "muted"
    },
    "0t8RSi0qGv": {
      "nodeType": "ValueNode",
      "value": false,
      "position": {
        "x": 2860.300048828125,
        "y": 3729.5
      },
      "type": "muted"
    },
    "L9CueKVYRa": {
      "nodeType": "DecisionNode",
      "name": "mutedInProximityDistance",
      "concept": "client",
      "property": "distance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 150,
          "connection": "0AuPuPxxYm"
        },
        {
          "comparator": "lessThan",
          "value": 150,
          "connection": "0t8RSi0qGv"
        }
      ],
      "position": {
        "x": 2636.300048828125,
        "y": 3509.5
      }
    },
    "Q7C3YKmRd8": {
      "nodeType": "DecisionNode",
      "name": "mutedOnPedestal",
      "concept": "client",
      "property": "onPedestal",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "L9CueKVYRa"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "0t8RSi0qGv"
        }
      ],
      "position": {
        "x": 2850.300048828125,
        "y": 3317.5
      }
    },
    "pWndXjd86V": {
      "nodeType": "DecisionNode",
      "name": "mutedproximityBasedAudioActive",
      "concept": "toolManager",
      "property": "proximityBasedAudioActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "Sw0B1x9Vm9"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "Q7C3YKmRd8"
        }
      ],
      "position": {
        "x": 2720.300048828125,
        "y": 3112.5
      }
    },
    "rYSeeaKep4": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientInDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 2,
          "connection": "cOws1LEgka"
        },
        {
          "comparator": "lessThan",
          "value": 2,
          "connection": "pWndXjd86V"
        }
      ],
      "position": {
        "x": 2585.300048828125,
        "y": 2914.3124504089355
      }
    },
    "4GpHRhnuOX": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2736.500030517578,
        "y": 2833.312511444092
      },
      "type": "muted"
    },
    "ZmEA2h52Xn": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientMuted",
      "concept": "client",
      "property": "muted",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "rYSeeaKep4"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "4GpHRhnuOX"
        }
      ],
      "position": {
        "x": 2583.300048828125,
        "y": 2636.5
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="WhisperTool" id="WhisperTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Allows whispering directly to other clients.",
    "dependencies": [
        "#FindAction",
        "#WindowTools",
        "#ToolElement",
        "#ToolFunctionMixin"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="WhisperTool Concepts" auto>{
    "concepts": {
        "whisperTool": {
            "schema": {
                "placholder": "string"
            },
            "actions": {
                "updateWhisperTarget": {
                    "when": { "interval": 1000 },
                    "then": [
                        { "where": {
                            "property": "toolManager.whisperActive",
                            "equals": true,
                            "stopIfEmpty": true
                        }},
                        "selectLocalClient",
                        { "set": { "whisperTarget": "" }},
                        { "select": "cameraContent" },
                        "checkInfullscreenRoom",
                        "cursorPosition",
                        "correctCursorPosition",
                        { "where": {
                            "and": [
                                { "variable": "x", "greaterThan": "$target.left" },
                                { "variable": "x", "lessThan": { "calculate": "$target.left$+$target.width$" } },
                                { "variable": "y", "greaterThan": { "calculate": "$target.top$" }},
                                { "variable": "y", "lessThan": { "calculate": "$target.top$+$target.height$" }}
                            ],
                            "stopIfEmpty": true
                        }},
                        { "limit": 1 },
                        { "select": {
                            "property": "cameraStream",
                            "forEach": true,
                            "stopIfEmpty": true
                        }},
                        { "select": {
                            "property": "client",
                            "forEach": true,
                            "stopIfEmpty": true
                        }},
                        { "set": { "variable": "whisperTarget", "value": "$target" }},
                        { "select": {
                            "concept": "client",
                            "where": {
                                "property": "local",
                                "equals": true
                            },
                            "forEach": true,
                            "stopIfEmpty": true
                        }},
                        { "set": { "whisperTarget": "$whisperTarget" }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin",
                "toolFunctionMixin"
            ]}
        },
        "client": {
            "schema": {
                "whisperTarget": "client"
            }
        },
        "toolManager": {
            "schema": {
                "whisperActive": { "boolean": {
                    "derive": {
                        "properties": [ "whisperTool.isActive" ],
                        "transform": [
                            { "exists": {
                                "concept": "whisperTool",
                                "where": {
                                    "property": "isActive",
                                    "equals": true
                                }
                            }}
                        ]
                    }
                }},
                "whisperTargeted": { "boolean": {
                    "derive": {
                        "properties": [ "client.whisperTarget" ],
                        "transform": [
                            { "get": "userManager.localClient" },
                            { "exists": {
                                "concept": "client",
                                "where": {
                                    "property": "whisperTarget",
                                    "equals": "$get"
                                }
                            }}
                        ]
                    }
                }},
                "whisperTargetedBy": { "array": {
                    "items": "client",
                    "derive": {
                        "properties": [ "client.whisperTarget" ],
                        "transform": [
                            { "get": "userManager.localClient" },
                            { "find": {
                                "concept": "client",
                                "where": {
                                    "property": "whisperTarget",
                                    "equals": "$get"
                                }
                            }}
                        ]
                    }
                }}
            },
            "mappings": {
                "whisperActive": [ "memory", "cauldron" ],
                "whisperTargeted": [ "memory", "cauldron" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="WhisperTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="whisperToolBody">
        &lt;div class="tool-title">Whisper Tool&lt;/div>
        &lt;template-ref template-name="toolFunctionMixinBody">&lt;/template-ref>
        &lt;div class="whisper-section" concept="userManager" property="localClient">
            &lt;div class="whisper-section-title">Whispering to:&lt;/div>
            &lt;div class="whisper-client" property="whisperTarget">
                &lt;span property="user">{name}: &lt;/span>{name}
            &lt;/div>
        &lt;/div>
        &lt;div class="whisper-section" concept="toolManager">
            &lt;div class="whisper-section-title">Being whispered to by:&lt;/div>
            &lt;div class="whisper-client" property="whisperTargetedBy">
                &lt;span property="user">{name}: &lt;/span> {name}
            &lt;/div>
        &lt;/div>
    &lt;/varv-template>

    &lt;varv-template name="whisperToolOptions">
        &lt;template-ref template-name="toolFunctionMixinOptions">&lt;/template-ref>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="WhisperTool Style" auto>@mixin heading-font {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}



.whisperTool>.element-body {
    flex-wrap: nowrap !important;
    flex-direction: column !important;

    .whisper-section {
        flex: 1 1 auto;

        @include heading-font;
        text-align: center;

        display: flex;
        flex-wrap: nowrap;
        flex-direction: column;
        gap: 4px;

        background: #424242;
        border-radius: 8px;
        padding: 4px;

        .whisper-section-title {
            padding: 2px 0;
        }

        .whisper-client {
            flex: 1 0 32px;
            background: #333333;
            border: 1px solid #848484;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="WhisperTool Volume Routing" auto>{
  "rootConnections": {
    "volume": {
      "position": {
        "x": 2558.4500274658203,
        "y": 2447.200023651123
      },
      "connection": "7nfLkWCxEa"
    }
  },
  "nodes": {
    "NoVla0FWWm": {
      "nodeType": "ValueNode",
      "value": 0,
      "position": {
        "x": 2451.449935913086,
        "y": 2978.800037384033
      },
      "type": "volume"
    },
    "CAIcGVCsm0": {
      "nodeType": "ValueNode",
      "value": 0.5,
      "position": {
        "x": 2617.0499725341797,
        "y": 2977.399890899658
      },
      "type": "volume"
    },
    "OIc3npFR9a": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 2505.049819946289,
        "y": 3741.4001960754395
      },
      "type": "volume"
    },
    "tpy4gmRP9g": {
      "nodeType": "ValueNode",
      "value": 0.3,
      "position": {
        "x": 2830.6499786376953,
        "y": 3748.799976348877
      },
      "type": "volume"
    },
    "xmzFZT3Tpu": {
      "nodeType": "DecisionNode",
      "name": "volumeAnyoneWhispersToMe",
      "concept": "toolManager",
      "property": "whisperTargeted",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "OIc3npFR9a"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "tpy4gmRP9g"
        }
      ],
      "position": {
        "x": 2664.449905395508,
        "y": 3491.799976348877
      }
    },
    "vgXQprbLv0": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 3108.0499725341797,
        "y": 3744.9875259399414
      },
      "type": "volume"
    },
    "IsSVGugff8": {
      "nodeType": "DecisionNode",
      "name": "volumeWhispersToMe",
      "concept": "toolManager",
      "property": "whisperTargetedBy",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "includes",
          "value": "$client",
          "connection": "tpy4gmRP9g"
        },
        {
          "comparator": "includes",
          "value": "$client",
          "connection": "vgXQprbLv0"
        }
      ],
      "position": {
        "x": 2936.249954223633,
        "y": 3494.400074005127
      }
    },
    "KVFodKj9zO": {
      "nodeType": "DecisionNode",
      "name": "volumeIsWhispering",
      "concept": "client",
      "property": "whisperTarget",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": "",
          "connection": "xmzFZT3Tpu"
        },
        {
          "comparator": "unequals",
          "value": "",
          "connection": "IsSVGugff8"
        }
      ],
      "position": {
        "x": 2845.850051879883,
        "y": 3269.7999153137207
      }
    },
    "0aHAiVw4QT": {
      "nodeType": "DecisionNode",
      "name": "volumeWhisperActive",
      "concept": "toolManager",
      "property": "whisperActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "OIc3npFR9a"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "KVFodKj9zO"
        }
      ],
      "position": {
        "x": 2672.649917602539,
        "y": 3059.8000984191895
      }
    },
    "tlE8U4K1WI": {
      "nodeType": "DecisionNode",
      "name": "volumeClientLogicalDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 3,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 1,
          "connection": "NoVla0FWWm"
        },
        {
          "comparator": "equals",
          "value": 1,
          "connection": "CAIcGVCsm0"
        },
        {
          "comparator": "equals",
          "value": 0,
          "connection": "0aHAiVw4QT"
        }
      ],
      "position": {
        "x": 2459.4500274658203,
        "y": 2772.6001777648926
      }
    },
    "hH1J0Lq5ax": {
      "nodeType": "ValueNode",
      "value": 0,
      "position": {
        "x": 2952.2498931884766,
        "y": 3008.800037384033
      },
      "type": "volume"
    },
    "EwpAvM8psA": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 3098.249954223633,
        "y": 3008.2000617980957
      },
      "type": "volume"
    },
    "94TJMgUpTV": {
      "nodeType": "DecisionNode",
      "name": "volumeClientInHovered",
      "concept": "client",
      "property": "inHoveredRoom",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "hH1J0Lq5ax"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "EwpAvM8psA"
        }
      ],
      "position": {
        "x": 2972.0498809814453,
        "y": 2815.800006866455
      }
    },
    "e9x6WwtBbb": {
      "nodeType": "DecisionNode",
      "name": "volumeExistsHovered",
      "concept": "toolManager",
      "property": "doorwayHoveredExists",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "tlE8U4K1WI"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "94TJMgUpTV"
        }
      ],
      "position": {
        "x": 2911.0499420166016,
        "y": 2590.4000282287598
      }
    },
    "7nfLkWCxEa": {
      "nodeType": "DecisionNode",
      "name": "volumedoorwayActive",
      "concept": "toolManager",
      "property": "doorwayActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "tlE8U4K1WI"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "e9x6WwtBbb"
        }
      ],
      "position": {
        "x": 2471.0499725341797,
        "y": 2559.600025177002
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="WhisperTool Filter Routing" auto>{
  "rootConnections": {
    "audioFilter": {
      "position": {
        "x": 2509.75,
        "y": 2273.5
      },
      "connection": "3qEccHXEYd"
    }
  },
  "nodes": {
    "mmR7pI87cW": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2420.75,
        "y": 2959.5
      },
      "type": "audioFilter"
    },
    "FUf0416U07": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2446.75,
        "y": 3928.5
      },
      "type": "audioFilter"
    },
    "rScKXNSFIH": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2618.75,
        "y": 3930.5
      },
      "type": "audioFilter"
    },
    "C5E6P2PNS1": {
      "nodeType": "DecisionNode",
      "name": "filterLocationHasFilter",
      "concept": "currentRoom",
      "property": "audioFilter",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": "",
          "connection": "FUf0416U07"
        },
        {
          "comparator": "unequals",
          "value": "",
          "connection": "rScKXNSFIH"
        }
      ],
      "position": {
        "x": 2428.75,
        "y": 3718.5
      }
    },
    "MfMGQHme7X": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2792.75,
        "y": 3702.5
      },
      "type": "audioFilter"
    },
    "wjx55vVir8": {
      "nodeType": "DecisionNode",
      "name": "filterAnyoneWhispersToMe",
      "concept": "toolManager",
      "property": "whisperTargeted",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "C5E6P2PNS1"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "MfMGQHme7X"
        }
      ],
      "position": {
        "x": 2644.75,
        "y": 3460.5
      }
    },
    "jQ2IkTyaGV": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2976.75,
        "y": 3706.5
      },
      "type": "audioFilter"
    },
    "hIw3Kw5Hb2": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 3145.75,
        "y": 3705.5
      },
      "type": "audioFilter"
    },
    "pS4ziWX0BD": {
      "nodeType": "DecisionNode",
      "name": "filterWhispersToMe",
      "concept": "toolManager",
      "property": "whisperTargetedBy",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "includes",
          "value": "$client",
          "connection": "jQ2IkTyaGV"
        },
        {
          "comparator": "includes",
          "value": "$client",
          "connection": "hIw3Kw5Hb2"
        }
      ],
      "position": {
        "x": 2998.75,
        "y": 3477.5
      }
    },
    "d2EkOYpR8O": {
      "nodeType": "DecisionNode",
      "name": "filterIsWhispering",
      "concept": "client",
      "property": "whisperTarget",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": "",
          "connection": "wjx55vVir8"
        },
        {
          "comparator": "unequals",
          "value": "",
          "connection": "pS4ziWX0BD"
        }
      ],
      "position": {
        "x": 2811.75,
        "y": 3257.5
      }
    },
    "xq0UNVtXei": {
      "nodeType": "DecisionNode",
      "name": "filterWhisperActive",
      "concept": "toolManager",
      "property": "whisperActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "C5E6P2PNS1"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "d2EkOYpR8O"
        }
      ],
      "position": {
        "x": 2509.75,
        "y": 3072.5
      }
    },
    "1kWhmMpUFO": {
      "nodeType": "DecisionNode",
      "name": "filterClientLogicalDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 1,
          "connection": "mmR7pI87cW"
        },
        {
          "comparator": "equals",
          "value": 0,
          "connection": "xq0UNVtXei"
        }
      ],
      "position": {
        "x": 2423.75,
        "y": 2736.5
      }
    },
    "g2JEiwDI38": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2703.75,
        "y": 2987.5
      },
      "type": "audioFilter"
    },
    "UrFfooDXhs": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2862.75,
        "y": 2986.5
      },
      "type": "audioFilter"
    },
    "fOt7eLofpb": {
      "nodeType": "DecisionNode",
      "name": "filterClientInHovered",
      "concept": "client",
      "property": "inHoveredRoom",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "g2JEiwDI38"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "UrFfooDXhs"
        }
      ],
      "position": {
        "x": 2716.75,
        "y": 2765.5
      }
    },
    "bm9IK40lob": {
      "nodeType": "DecisionNode",
      "name": "filterExistsHovered",
      "concept": "toolManager",
      "property": "doorwayHoveredExists",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "1kWhmMpUFO"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "fOt7eLofpb"
        }
      ],
      "position": {
        "x": 2704.75,
        "y": 2541.5
      }
    },
    "3qEccHXEYd": {
      "nodeType": "DecisionNode",
      "name": "filterDoorwayActive",
      "concept": "toolManager",
      "property": "doorwayActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "1kWhmMpUFO"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "bm9IK40lob"
        }
      ],
      "position": {
        "x": 2419.75,
        "y": 2371.5
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="BroadcastTool" name="BroadcastTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Allows broadcasting your voice to users in other rooms.",
    "dependencies": [
        "#ToolElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="BroadcastTool Concepts" auto>{
    "concepts": {
        "broadcastTool": {
            "schema": {
                "broadcasting": "boolean"
            },
            "mappings": {
                "broadcasting": [ "memory", "cauldron" ]
            },
            "actions": {
                "startBroadCasting": {
                    "when": { "mousedown": { "view": "broadcastButton" }},
                    "then": [
                        { "set": { "broadcasting": true }},
                        "selectLocalClient",
                        { "set": { "broadcasting": true }}
                    ]
                },
                "stopBroadCasting": {
                    "when": "mouseup",
                    "then": [
                        { "select": "broadcastTool" },
                        { "set": { "broadcasting": false }},
                        "selectLocalClient",
                        { "set": { "broadcasting": false }}
                    ]
                }
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin"
            ]}
        },
        "client": {
            "schema": {
                "broadcasting": "boolean"
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="BroadcastTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="broadcastToolBody">
        &lt;div class="tool-title">Broadcast Tool&lt;/div>
        &lt;button view="broadcastButton" class="broadcast-button" data-broadcasting="{broadcasting}">Broadcast&lt;/button>
    &lt;/varv-template>

    &lt;varv-template name="broadcastToolOptions">
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="BroadcastTool Style" auto>.broadcastTool .broadcast-button[data-broadcasting="true"] {
    background: #2e7d32;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="BroadcastTool Routing Muted" auto>{
  "rootConnections": {
    "muted": {
      "position": {
        "x": 2657.9000244140625,
        "y": 2378.5
      },
      "connection": "ZmEA2h52Xn"
    }
  },
  "nodes": {
    "cOws1LEgka": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2579.699951171875,
        "y": 3148.7125358581543
      },
      "type": "muted"
    },
    "Sw0B1x9Vm9": {
      "nodeType": "ValueNode",
      "value": false,
      "position": {
        "x": 2659.300048828125,
        "y": 3320.5
      },
      "type": "muted"
    },
    "0AuPuPxxYm": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2578.300048828125,
        "y": 3718.5
      },
      "type": "muted"
    },
    "0t8RSi0qGv": {
      "nodeType": "ValueNode",
      "value": false,
      "position": {
        "x": 2860.300048828125,
        "y": 3729.5
      },
      "type": "muted"
    },
    "L9CueKVYRa": {
      "nodeType": "DecisionNode",
      "name": "mutedInProximityDistance",
      "concept": "client",
      "property": "distance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 150,
          "connection": "0AuPuPxxYm"
        },
        {
          "comparator": "lessThan",
          "value": 150,
          "connection": "0t8RSi0qGv"
        }
      ],
      "position": {
        "x": 2636.300048828125,
        "y": 3509.5
      }
    },
    "Q7C3YKmRd8": {
      "nodeType": "DecisionNode",
      "name": "mutedOnPedestal",
      "concept": "client",
      "property": "onPedestal",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "L9CueKVYRa"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "0t8RSi0qGv"
        }
      ],
      "position": {
        "x": 2850.300048828125,
        "y": 3317.5
      }
    },
    "pWndXjd86V": {
      "nodeType": "DecisionNode",
      "name": "mutedproximityBasedAudioActive",
      "concept": "toolManager",
      "property": "proximityBasedAudioActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "Sw0B1x9Vm9"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "Q7C3YKmRd8"
        }
      ],
      "position": {
        "x": 2720.300048828125,
        "y": 3112.5
      }
    },
    "rYSeeaKep4": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientInDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 2,
          "connection": "cOws1LEgka"
        },
        {
          "comparator": "lessThan",
          "value": 2,
          "connection": "pWndXjd86V"
        }
      ],
      "position": {
        "x": 2585.300048828125,
        "y": 2914.3124504089355
      }
    },
    "coKNOWx7Gg": {
      "nodeType": "ValueNode",
      "value": false,
      "position": {
        "x": 2858.1875,
        "y": 2899.1500244140625
      },
      "type": "muted"
    },
    "glgxeBTrE9": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientBroadcasting",
      "concept": "client",
      "property": "broadcasting",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "rYSeeaKep4"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "coKNOWx7Gg"
        }
      ],
      "position": {
        "x": 2595,
        "y": 2701.1499633789062
      }
    },
    "4GpHRhnuOX": {
      "nodeType": "ValueNode",
      "value": true,
      "position": {
        "x": 2851.7001037597656,
        "y": 2690.9125175476074
      },
      "type": "muted"
    },
    "ZmEA2h52Xn": {
      "nodeType": "DecisionNode",
      "name": "mutedIsClientMuted",
      "concept": "client",
      "property": "muted",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "glgxeBTrE9"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "4GpHRhnuOX"
        }
      ],
      "position": {
        "x": 2580.9000244140625,
        "y": 2480.4999389648438
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="BroadcastTool Routing Volume" auto>{
  "rootConnections": {
    "volume": {
      "position": {
        "x": 2631.2500762939453,
        "y": 1973.6000328063965
      },
      "connection": "cWXvbLUMwS"
    }
  },
  "nodes": {
    "NoVla0FWWm": {
      "nodeType": "ValueNode",
      "value": 0,
      "position": {
        "x": 2451.449935913086,
        "y": 2978.800037384033
      },
      "type": "volume"
    },
    "CAIcGVCsm0": {
      "nodeType": "ValueNode",
      "value": 0.5,
      "position": {
        "x": 2617.0499725341797,
        "y": 2977.399890899658
      },
      "type": "volume"
    },
    "OIc3npFR9a": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 2505.049819946289,
        "y": 3741.4001960754395
      },
      "type": "volume"
    },
    "tpy4gmRP9g": {
      "nodeType": "ValueNode",
      "value": 0.3,
      "position": {
        "x": 2830.6499786376953,
        "y": 3748.799976348877
      },
      "type": "volume"
    },
    "xmzFZT3Tpu": {
      "nodeType": "DecisionNode",
      "name": "volumeAnyoneWhispersToMe",
      "concept": "toolManager",
      "property": "whisperTargeted",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "OIc3npFR9a"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "tpy4gmRP9g"
        }
      ],
      "position": {
        "x": 2664.449905395508,
        "y": 3491.799976348877
      }
    },
    "vgXQprbLv0": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 3108.0499725341797,
        "y": 3744.9875259399414
      },
      "type": "volume"
    },
    "IsSVGugff8": {
      "nodeType": "DecisionNode",
      "name": "volumeWhispersToMe",
      "concept": "toolManager",
      "property": "whisperTargetedBy",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "includes",
          "value": "$client",
          "connection": "tpy4gmRP9g"
        },
        {
          "comparator": "includes",
          "value": "$client",
          "connection": "vgXQprbLv0"
        }
      ],
      "position": {
        "x": 2936.249954223633,
        "y": 3494.400074005127
      }
    },
    "KVFodKj9zO": {
      "nodeType": "DecisionNode",
      "name": "volumeIsWhispering",
      "concept": "client",
      "property": "whisperTarget",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": "",
          "connection": "xmzFZT3Tpu"
        },
        {
          "comparator": "unequals",
          "value": "",
          "connection": "IsSVGugff8"
        }
      ],
      "position": {
        "x": 2845.850051879883,
        "y": 3269.7999153137207
      }
    },
    "0aHAiVw4QT": {
      "nodeType": "DecisionNode",
      "name": "volumeWhisperActive",
      "concept": "toolManager",
      "property": "whisperActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "OIc3npFR9a"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "KVFodKj9zO"
        }
      ],
      "position": {
        "x": 2672.649917602539,
        "y": 3059.8000984191895
      }
    },
    "tlE8U4K1WI": {
      "nodeType": "DecisionNode",
      "name": "volumeClientLogicalDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 3,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 1,
          "connection": "NoVla0FWWm"
        },
        {
          "comparator": "equals",
          "value": 1,
          "connection": "CAIcGVCsm0"
        },
        {
          "comparator": "equals",
          "value": 0,
          "connection": "0aHAiVw4QT"
        }
      ],
      "position": {
        "x": 2459.4500274658203,
        "y": 2772.6001777648926
      }
    },
    "hH1J0Lq5ax": {
      "nodeType": "ValueNode",
      "value": 0,
      "position": {
        "x": 2952.2498931884766,
        "y": 3008.800037384033
      },
      "type": "volume"
    },
    "EwpAvM8psA": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 3098.249954223633,
        "y": 3008.2000617980957
      },
      "type": "volume"
    },
    "94TJMgUpTV": {
      "nodeType": "DecisionNode",
      "name": "volumeClientInHovered",
      "concept": "client",
      "property": "inHoveredRoom",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "hH1J0Lq5ax"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "EwpAvM8psA"
        }
      ],
      "position": {
        "x": 2972.0498809814453,
        "y": 2815.800006866455
      }
    },
    "e9x6WwtBbb": {
      "nodeType": "DecisionNode",
      "name": "volumeExistsHovered",
      "concept": "toolManager",
      "property": "doorwayHoveredExists",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "tlE8U4K1WI"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "94TJMgUpTV"
        }
      ],
      "position": {
        "x": 2832.649917602539,
        "y": 2584.8000526428223
      }
    },
    "7nfLkWCxEa": {
      "nodeType": "DecisionNode",
      "name": "volumedoorwayActive",
      "concept": "toolManager",
      "property": "doorwayActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "tlE8U4K1WI"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "e9x6WwtBbb"
        }
      ],
      "position": {
        "x": 2529.449996948242,
        "y": 2370.0000801086426
      }
    },
    "geuhhE9asE": {
      "nodeType": "ValueNode",
      "value": 1,
      "position": {
        "x": 2666.0125732421875,
        "y": 2280.5501098632812
      },
      "type": "volume"
    },
    "cWXvbLUMwS": {
      "nodeType": "DecisionNode",
      "name": "volumeIsClientBroadcasting",
      "concept": "client",
      "property": "broadcasting",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "7nfLkWCxEa"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "geuhhE9asE"
        }
      ],
      "position": {
        "x": 2549.8126220703125,
        "y": 2076.550079345703
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/mirrorverse-audio-router" name="BroadcastTool Routing Filter" auto>{
  "rootConnections": {
    "audioFilter": {
      "position": {
        "x": 2518.550048828125,
        "y": 2028.6999969482422
      },
      "connection": "O5u4OJq7BL"
    }
  },
  "nodes": {
    "mmR7pI87cW": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2420.75,
        "y": 2959.5
      },
      "type": "audioFilter"
    },
    "FUf0416U07": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2446.75,
        "y": 3928.5
      },
      "type": "audioFilter"
    },
    "rScKXNSFIH": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2618.75,
        "y": 3930.5
      },
      "type": "audioFilter"
    },
    "C5E6P2PNS1": {
      "nodeType": "DecisionNode",
      "name": "filterLocationHasFilter",
      "concept": "currentRoom",
      "property": "audioFilter",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": "",
          "connection": "FUf0416U07"
        },
        {
          "comparator": "unequals",
          "value": "",
          "connection": "rScKXNSFIH"
        }
      ],
      "position": {
        "x": 2428.75,
        "y": 3718.5
      }
    },
    "MfMGQHme7X": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2792.75,
        "y": 3702.5
      },
      "type": "audioFilter"
    },
    "wjx55vVir8": {
      "nodeType": "DecisionNode",
      "name": "filterAnyoneWhispersToMe",
      "concept": "toolManager",
      "property": "whisperTargeted",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "C5E6P2PNS1"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "MfMGQHme7X"
        }
      ],
      "position": {
        "x": 2644.75,
        "y": 3460.5
      }
    },
    "jQ2IkTyaGV": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2976.75,
        "y": 3706.5
      },
      "type": "audioFilter"
    },
    "hIw3Kw5Hb2": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 3145.75,
        "y": 3705.5
      },
      "type": "audioFilter"
    },
    "pS4ziWX0BD": {
      "nodeType": "DecisionNode",
      "name": "filterWhispersToMe",
      "concept": "toolManager",
      "property": "whisperTargetedBy",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "includes",
          "value": "$client",
          "connection": "jQ2IkTyaGV"
        },
        {
          "comparator": "includes",
          "value": "$client",
          "connection": "hIw3Kw5Hb2"
        }
      ],
      "position": {
        "x": 2998.75,
        "y": 3477.5
      }
    },
    "d2EkOYpR8O": {
      "nodeType": "DecisionNode",
      "name": "filterIsWhispering",
      "concept": "client",
      "property": "whisperTarget",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": "",
          "connection": "wjx55vVir8"
        },
        {
          "comparator": "unequals",
          "value": "",
          "connection": "pS4ziWX0BD"
        }
      ],
      "position": {
        "x": 2811.75,
        "y": 3257.5
      }
    },
    "xq0UNVtXei": {
      "nodeType": "DecisionNode",
      "name": "filterWhisperActive",
      "concept": "toolManager",
      "property": "whisperActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "C5E6P2PNS1"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "d2EkOYpR8O"
        }
      ],
      "position": {
        "x": 2509.75,
        "y": 3072.5
      }
    },
    "1kWhmMpUFO": {
      "nodeType": "DecisionNode",
      "name": "filterClientLogicalDistance",
      "concept": "client",
      "property": "logicalDistance",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "greaterOrEquals",
          "value": 1,
          "connection": "mmR7pI87cW"
        },
        {
          "comparator": "equals",
          "value": 0,
          "connection": "xq0UNVtXei"
        }
      ],
      "position": {
        "x": 2423.75,
        "y": 2736.5
      }
    },
    "g2JEiwDI38": {
      "nodeType": "ValueNode",
      "value": "muffled",
      "position": {
        "x": 2703.75,
        "y": 2987.5
      },
      "type": "audioFilter"
    },
    "UrFfooDXhs": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2862.75,
        "y": 2986.5
      },
      "type": "audioFilter"
    },
    "fOt7eLofpb": {
      "nodeType": "DecisionNode",
      "name": "filterClientInHovered",
      "concept": "client",
      "property": "inHoveredRoom",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "g2JEiwDI38"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "UrFfooDXhs"
        }
      ],
      "position": {
        "x": 2716.75,
        "y": 2765.5
      }
    },
    "bm9IK40lob": {
      "nodeType": "DecisionNode",
      "name": "filterExistsHovered",
      "concept": "toolManager",
      "property": "doorwayHoveredExists",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "1kWhmMpUFO"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "fOt7eLofpb"
        }
      ],
      "position": {
        "x": 2704.75,
        "y": 2541.5
      }
    },
    "3qEccHXEYd": {
      "nodeType": "DecisionNode",
      "name": "filterDoorwayActive",
      "concept": "toolManager",
      "property": "doorwayActive",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "1kWhmMpUFO"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "bm9IK40lob"
        }
      ],
      "position": {
        "x": 2419.75,
        "y": 2371.5
      }
    },
    "aZXrp19rNQ": {
      "nodeType": "ValueNode",
      "value": "none",
      "position": {
        "x": 2724.800048828125,
        "y": 2366.1500244140625
      },
      "type": "audioFilter"
    },
    "O5u4OJq7BL": {
      "nodeType": "DecisionNode",
      "name": "filterIsClientBroadcasting",
      "concept": "client",
      "property": "broadcasting",
      "decisionCount": 2,
      "decisions": [
        {
          "comparator": "equals",
          "value": false,
          "connection": "3qEccHXEYd"
        },
        {
          "comparator": "equals",
          "value": true,
          "connection": "aZXrp19rNQ"
        }
      ],
      "position": {
        "x": 2445.8001708984375,
        "y": 2139.350067138672
      }
    }
  },
  "unused": []
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="TemplateStoreTool" id="TemplateStoreTool"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Stores templates of room layout for reuse.",
    "dependencies": [
        "#ToolElement"
    ],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="TemplateStoreTool Concepts" auto>{
    "concepts": {
        "templateStoreTemplate": {
            "schema": {
                "name": "string",
                "blueprints": { "array": "templateStoreToolBlueprint" }
            }
        },
        "templateStoreToolBlueprint": {
            "schema": {
                "elementType": "string",
                "top": "number",
                "left": "number",
                "width": "number",
                "height": "number",
                "opacity": "number",
                "zIndex": "number",
                "inToolPanel": "boolean"
            }
        },
        "templateStoreTool": {
            "schema": {
                "overwriteExistingElements": { "boolean": { "default": true }},
                "templateName": "string",
                "selectedTemplate": "templateStoreTemplate",
                "previewScaleFactor": { "number": {
                    "derive": {
                        "properties": [ "width" ],
                        "transform": [
                            { "get": "width" },
                            { "calculate": "($get$ - 16) / 1280"}
                        ]
                    }
                }}
            },
            "actions": {
                "storeStoreTemplate": {
                    "when": { "click": { "view": "storeStoreTemplateButton" }},
                    "then": [
                        { "get": {
                            "property": "templateName",
                            "as": "templateName"
                        }},
                        { "new": {
                            "concept": "templateStoreTemplate",
                            "with": {
                                "name": "$templateName"
                            },
                            "forEach": true,
                            "select": false,
                            "as": "newTemplateStoreTemplate"
                        }},
                        { "get": "parentRoom" },
                        { "select": {
                            "concept": "element",
                            "where": { "and": [
                                {
                                    "property": "parentRoom",
                                    "equals": "$get"
                                },
                                {
                                    "property": "elementType",
                                    "unequals": "templateStoreTool"
                                }
                            ]},
                            "stopIfEmpty": true
                        }},
                        { "new": {
                            "concept": "templateStoreToolBlueprint",
                            "with": {
                                "elementType": "$target.elementType",
                                "top": "$target.top",
                                "left": "$target.left",
                                "width": "$target.width",
                                "height": "$target.height",
                                "opacity": "$target.opacity",
                                "zIndex": "$target.zIndex",
                                "inToolPanel": "$target.inToolPanel"
                            },
                            "forEach": true
                        }},
                        { "set": {
                            "variable": "blueprint",
                            "value": "$target"
                        }},
                        { "select": {
                            "target": "$newTemplateStoreTemplate",
                            "forEach": true
                        }},
                        { "append": {
                            "property": "blueprints",
                            "item": "$blueprint"
                        }}
                    ]
                },
                "restoreStoreTemplate": {
                    "when": { "click": { "view": "restoreStoreTemplateButton" }},
                    "then": [
                        { "run": "cleanupElements" },
                        { "select": {
                            "property": "selectedTemplate",
                            "forEach": true,
                            "stopIfEmpty": true
                        }},
                        { "select": {
                            "property": "blueprints",
                            "forEach": true,
                            "stopIfEmpty": true
                        }},
                        { "get": { "property": "meeting.fullscreenRoom", "as": "parent" }},
                        { "new": {
                            "concept": "$target.elementType",
                            "with": {
                                "parentRoom": "$parent",
                                "top": "$target.top",
                                "left": "$target.left",
                                "width": "$target.width",
                                "height": "$target.height",
                                "opacity": "$target.opacity",
                                "zIndex": "$target.zIndex",
                                "inToolPanel": "$target.inToolPanel"
                            },
                            "forEach": true
                        }}
                    ]
                },
                "cleanupElements": [
                    { "where": {
                        "property": "overwriteExistingElements",
                        "equals": true,
                        "stopIfEmpty": true
                    }},
                    { "get": "parentRoom" },
                    { "select": {
                        "concept": "element",
                        "where": { "and": [
                            {
                                "property": "parentRoom",
                                "equals": "$get"
                            },
                            {
                                "property": "elementType",
                                "unequals": "templateStoreTool"
                            }
                        ]},
                        "stopIfEmpty": true
                    }},
                    "elementCleanup"
                ],
                "deleteStoreTemplate": {
                    "when": { "click": { "view": "deleteStoreTemplateButton" }},
                    "then": [
                        { "get": "selectedTemplate" },
                        { "set": { "selectedTemplate": "" }},
                        { "select": {
                            "target": "$get",
                            "stopIfEmpty": true
                        }},
                        { "items": "blueprints" },
                        { "run": "deleteStoreTemplateBlueprints" },
                        "remove"
                    ]
                },
                "deleteStoreTemplateBlueprints": [
                    { "select": "$items" },
                    "remove"
                ]
            },
            "extensions": { "inject": [
                "element",
                "toolElement",
                "movableMixin",
                "resizableMixin",
                "droppableMixin"
            ]}
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/html" name="TemplateStoreTool Template" auto>&lt;dom-view-template>
    &lt;varv-template name="templateStoreToolBody">
        &lt;div class="tool-title">Template Store Tool&lt;/div>
        &lt;div class="template-preview-container">
            &lt;div class="template-preview" property="selectedTemplate" style="transform: scale({previewScaleFactor})">
                &lt;div class="blueprint-preview {elementType}" property="blueprints" if="!inToolPanel" style="top: {top}px; left: {left}px; width: {width}px; height: {height}px;">&lt;/div>
            &lt;/div>
        &lt;/div>
        &lt;label>
            Template:
            &lt;select value="{selectedTemplate}">
                &lt;option concept="templateStoreTemplate" value="{concept::uuid}">{name}&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;label property="selectedTemplate">
            Rename:
            &lt;input value="{name}">
        &lt;/label>
        &lt;button view="deleteStoreTemplateButton" if="selectedTemplate" class="red">Delete Template&lt;/button>
        &lt;button view="restoreStoreTemplateButton">Restore Template&lt;/button>
        &lt;div class="tool-title">—&lt;/div>
        &lt;label>
            Template Name:
            &lt;input value="{templateName}">
        &lt;/label>
        &lt;button view="storeStoreTemplateButton">Store Template&lt;/button>
    &lt;/varv-template>

    &lt;varv-template name="templateStoreToolOptions">
        &lt;label>
            Overwrite Existing Elements:
            &lt;input value="{overwriteExistingElements}" type="checkbox">
        &lt;/label>
        &lt;div class="spacer">&lt;/div>
        &lt;template-ref template-name="toolElementOptions">&lt;/template-ref>
    &lt;/varv-template>
&lt;/dom-view-template>
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="TemplateStoreTool Style" auto>.templateStoreTool {
    .template-preview-container {
        aspect-ratio: 4 / 3;
        width: 100%;
        overflow: hidden;
        border-radius: 4px;
        background: #313131;
        flex: 0 0 auto;
    }

    .template-preview {
        position: relative;
        width: 1280px;
        height: 960px;
        transform-origin: 0 0;

        .blueprint-preview {
            position: absolute;
            background: #636363;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;

            &:before {
                color: #b2b2b2;
                font-family: "Material Icons";
                font-weight: normal;
                font-style: normal;
                font-size: 80px;
                line-height: 1;
                letter-spacing: normal;
                text-transform: none;
                display: inline-block;
                white-space: nowrap;
                word-wrap: normal;
                direction: ltr;
                content: "build";
            }

            &.cameraContent:before {
                content: "photo_camera";
            }

            &.screenContent:before {
                content: "cast";
            }

            &.videoContent:before {
                content: "theaters";
            }

            &.imageContent:before {
                content: "image";
            }

            &.noteContent:before {
                content: "description";
            }

            &.sketchContent:before {
                content: "brush";
            }

            &.chatContent:before {
                content: "chat";
            }

            &.avatarContent:before {
                content: "account_circle";
            }

            &.regularRoom:before {
                content: "meeting_room";
            }
        }
    }
}

// Use fixed scale in the tool panel
.tool-panel {
    .templateStoreTool {
        .template-preview {
            transform: scale(0.1578125) !important;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE></DIV><WPM-PACKAGE id="AudioRoutingFixes" name="AudioRoutingFixes"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Fixes minor shortcomings of the audio routing GUI and updates property list and style.",
    "dependencies": [],
    "assets": [],
    "version": "1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Audio Routing Fixes" auto>{
    "concepts": {
        "audioManager": {
            "actions": {
                "filterLocationHasFilterNodeConnection2": [
                    { "get": "audioFilter" },
                    "selectOriginalAudioStream",
                    { "set": { "audioFilter": "$get" }}
                ],
                "volumeWhispersToMeNodeDecision1": [
                    { "where": { "not": {
                        "property": "whisperTargetedBy",
                        "stopIfEmpty": true,
                        "includes": "$client"
                    }}},
                    "volumeWhispersToMeNodeConnection1"
                ],
                "filterWhispersToMeNodeDecision1": [
                    { "where": { "not": {
                        "property": "whisperTargetedBy",
                        "stopIfEmpty": true,
                        "includes": "$client"
                    }}},
                    "filterWhispersToMe1NodeConnection1"
                ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Audio Routing Property List" auto>MirrorVerseAudioRouter.conceptPropertyList = {
    "client": [
        "name",
        "local",
        "muted",
        "logicalDistance",
        "logicalVolume",
        "analyserVolume",
        "inHoveredRoom",
        "distance",
        "onPedestal",
        "whisperTarget",
        "broadcasting"
    ],
    "currentRoom": [
        "name",
        "audioFilter"
    ],
    "toolManager": [
        "doorwayActive",
        "doorwayHoveredExists",
        "proximityBasedAudioActive",
        "whisperActive",
        "whisperTargeted",
        "whisperTargetedBy"
    ]
};
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Audio Routing GUI Style" auto>@mixin heading-font {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}



.codestrates-editor-core.component {
    overflow: hidden;
}

div.mirrorverse-audio-router-maximized {
    background-image: radial-gradient(#ccc 1px, transparent 0);
    background-size: 24px 24px;
    background-position: -11px -11px;
    cursor: grab;
    user-select: none;

    &:active {
        cursor: grabbing;
    }
}

.mirrorverse-audio-router {
    font-family: Roboto, sans-serif;

    .mirrorverse-audio-routing-connection {
        stroke: #005005;
    }

    .connectionOut {
        cursor: default;
        background: #2e7d32 !important;
        border-radius: 2px;
        margin: 4px;

        &:hover {
            background: #60ad5e;
        }

        &:active {
            background: #005005;
        }
    }

    .mirrorVerseAudioRouterNode {
        background-color: #eee;
        border: 1px solid #ccc;
        border-radius: 8px;
        align-items: stretch;
        gap: 4px;
        cursor: move;
        // z-index: 1000;

        &:hover {
            background: #f2f2f2;
        }

        &:active {
            background: #eaeaea;
        }

        >div:not(.decisions) {
            font-weight: 700;
            height: 22px;
        }

        .addDecision,
        .removeDecision {
            user-select: none;
            border-radius: 4px;
            background: #fff;
            color: #000;
            vertical-align: middle;
            text-align: center;
            cursor: pointer;
            border: 1px solid #ccc;
            font-weight: 500;
        }

        .removeDecision {
            margin-left: 3px;
        }

        .decisions {
            gap: 8px;
            flex-wrap: wrap;
            position: relative;

            .decision {
                background-color: #ccc;
                border: none;
                padding: 4px;
                border-radius: 4px;

                &:not([data-type='boolean']) .select {
                    display: flex;
                    gap: 4px;
                }
            }

            >div:not(.decision) {
                background: #2e7d32 !important;
                border-radius: 2px;
                cursor: default;
            }
        }

    }

    .mirrorVerseAudioRouterRootNode {
        width: 48px;
        height: 48px;
        align-items: center;

        .title {
            @include heading-font;
            color: #000;
        }

        .connectionOut {
            width: 18px;
            height: 18px;
            position: initial;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE></DIV></body></html>
